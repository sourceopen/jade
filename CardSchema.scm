jadeVersionNumber "22.0.03";
schemaDefinition
CardSchema subschemaOf RootSchema completeDefinition, formsManagement = 2;
	documentationText
`                  			JADECare Start
							==============
                   	    (CardSchema Class Library)
                         -------------------------
__________________________________________________________________________________

					P R O P R I E T A R Y   N O T I C E

This software, in whole and in every part, is proprietary to Jade Software
Corporation Limited at Christchurch, New Zealand and is not to be
reproduced, used or disclosed except upon prior written permission of Jade
Software Corporation Limited.

Jade Software Corporation Limited cannot accept any financial or other responsibilities that
may be the result of your use of this information or software material, including direct, indirect,
special or consequential damages or loss of profits. There are no warranties extended or granted
by this document or software material.

You should be very careful to ensure that the use of this software material and/or information
complies with the laws, rules, and regulations of the jurisdictions with respect to which it is used.
No part of this document may be reproduced or transmitted in any form or by any means, electronic or
mechanical, for any purpose, without the express written permission of Jade Software Corporation Limited.

The information contained herein is subject to change without notice. Revisions may be issued to advise
of such changes and/or additions.

JADE is a trademark of Jade Software Corporation Limited. All trade names referenced are the service
mark, trademark, or registered trademark of the respective manufacturer.


   COPYRIGHT (c) JADE SOFTWARE CORPORATION LIMITED 2006 - ALL RIGHTS RESERVED
__________________________________________________________________________________

  For version identification and schema history, please refer to class constant	
  CardSchema_Version in class CnCntrl.
__________________________________________________________________________________`
constantDefinitions
	categoryDefinition CnExceptions
		Cn_Connection_Exception:       Integer = 999997;
		Cn_Edit_Error:                 Integer = 100001;
		Cn_Exception_Base:             Integer = 100000;
		Cn_Field_Overflow:             Integer = 100002;
		Cn_File_Error:                 Integer = 100006;
		Cn_General_Error:              Integer = 100007;
		Cn_PerformanceLock_Error:      Integer = 100015;
		Cn_Raise_Alert:                Boolean = true;
		Cn_SDS_Exception:              Integer = 100199;
		Cn_Tcp_Header_Error:           Integer = 100101;
		Cn_Transaction_Error:          Integer = 100010;
		Cn_Windows_Error:              Integer = 1;
	categoryDefinition Cn_Alert_Strings
		Cn_ExtendedLockAlarm:          String = "Extended lock alarm";
		Cn_PossibleSDSConnectionIssue: String = "Possible SDS connection issue";
		Cn_SDSConnectionAlert:         String = "SDS connection alert";
		Cn_SDSDelayedReplay:           String = "SDS delayed replay";
		Cn_SDSSecondaryLagsPrimary:    String = "SDS secondary lags primary database";
		Cn_SDSSecondaryNotSynchronised:String = "SDS secondary is not synchronised with primary database";
		Cn_SDSSecondaryUsingConn:      String = "SDS Secondary using connection name";
		Cn_SDSTrackingAlert:           String = "SDS tracking alert";
		Cn_SDSTrackingAlert_NotTracking:String = "not tracking";
	categoryDefinition Cn_Application_Names
		CN_CARDSCHEMA:                 String = "CardSchema";
		CN_JADEMONITORBACKGROUND:      String = "JadeMonitorBackground";
		CN_JADEMONITORSCHEMA:          String = "JadeMonitorSchema";
		CN_JADERECOMPILEALLMETHODS:    String = "JadeRecompileAllMethods";
		CN_JADEREORGAPP:               String = "JadeReorgApp";
		CN_JADERPSDATAPUMP:            String = "JadeRpsDataPump";
		CN_JADESCHEMALOADER:           String = "JadeSchemaLoader";
		CN_JADE_EXE:                   String = "(jade.exe)";
		CN_JOSS:                       String = "Joss";
		CN_JOSSBATCHQUAL:              String = "JossBatchQual";
		CN_JOSSCOMMSMGR:               String = "JossCommsMgr";
		CN_JOSSCONTROL:                String = "JossControl";
		CN_JOSSSTATSCOLLECTOR:         String = "JossStatsCollector";
		CN_KARMA:                      String = "Karma";
		CN_KARMABATCHINTERFACE:        String = "KarmaBatchInterface";
		CN_KARMACOMMSMGR:              String = "KarmaCommsMgr";
		CN_KCBATCH:                    String = "KCBatch";
		CN_KCCMGR:                     String = "KCCMgr";
		CN_KCDATABASEBACKUP:           String = "KCDatabaseBackup";
		CN_KCDATABASEBACKUPMULTI:      String = "KCDatabaseBackupMulti";
		CN_KCDBBACKUPWORKER:           String = "KCDbBackupWorker";
		CN_KCDUMMY:                    String = "KCDummy";
		CN_KCLOCKCHECK:                String = "KCLockCheck";
		CN_KCNODECONTROL:              String = "KCNodeControl";
		CN_KCONLINEBACKUP:             String = "KCOnLineBackup";
		CN_KCONLINEBACKUPWORKER:       String = "KCOnLineBackupWorker";
		CN_KCONLINECOMPACT:            String = "KCOnLineCompact";
		CN_KCONLINECOMPACTWORKER:      String = "KCOnLineCompactWorker";
		CN_KCONLINEPARTITIONWORKER:    String = "KCOnLinePartitionWorker";
		CN_KCSCHEMACOPY:               String = "KCSchemaCopy";
		CN_KCSDSCHECKS:                String = "KCSDSChecks";
		CN_KCSTATSCOLLECTOR:           String = "KCStatsCollector";
		CN_KCVALIDATEMETHODS:          String = "KCValidateMethods";
		CN_KCVERIFYJOURNAL:            String = "KCVerifyJournal";
		CN_PORTABLE_GUI:               String = "(portable GUI)";
		CN_ROOTSCHEMA:                 String = "RootSchema";
		CN_SCMCONTROL:                 String = "ScmControl";
		CN_SCMSCHEMA:                  String = "ScmSchema";
	categoryDefinition Cn_Backup_Phases
		Phase_MapFile_BackingUp:       Character = "B";
		Phase_MapFile_Completed:       Character = "C";
		Phase_MapFile_New:             Character = "S";
		Phase_MapFile_Starting:        Character = "S";
		Phase_MapFile_Verify:          Character = "V";
		Phase_Worker_Terminated:       Character = "T";
	categoryDefinition Cn_Boolean_Values
		Cn_Case_Insensitive:           Boolean = false;
		Cn_Case_Sensitive:             Boolean = true;
	categoryDefinition Cn_Character_Constants
		CN_AMPERSAND:                  Character = "&";
		CN_ASTERISK:                   Character = "*";
		CN_AT_SIGN:                    Character = "@";
		CN_BACK_SLASH:                 Character = "\";
		CN_CARET:                      Character = "^";
		CN_COLON:                      Character = ":";
		CN_DOLLAR:                     Character = "$";
		CN_DOUBLE_QUOTE:               Character = '"';
		CN_FF_DELIMITER:               Character = #"FF";
		CN_HASH:                       Character = "#";
		CN_HYPHEN:                     Character = "-";
		CN_LEFT_BRACE:                 Character = "{";
		CN_LEFT_BRACKET:               Character = "[";
		CN_LEFT_PARENTHESES:           Character = "(";
		CN_NULL:                       Character = null;
		CN_PERCENT:                    Character = "%";
		CN_PERIOD:                     Character = ".";
		CN_PIPE:                       Character = "|";
		CN_PLUS:                       Character = "+";
		CN_QUESTIONMARK:               Character = "?";
		CN_QUOTE:                      Character = "'";
		CN_RIGHT_BRACE:                Character = "}";
		CN_RIGHT_BRACKET:              Character = "]";
		CN_RIGHT_PARENTHESES:          Character = ")";
		CN_SEMICOLON:                  Character = ";";
		CN_SLASH:                      Character = "/";
		CN_SPACE:                      Character = " ";
		CN_SQL_COLUMN_CHARACTER:       Character = 179.Character;
		documentationText
		`Used in SQL Query response to delimit columns.`
		CN_TILDE:                      Character = "~";
		CN_UNDERSCORE:                 Character = "_";
	categoryDefinition Cn_Colors
		Cn_DarkYellow:                 Integer = 3523274;
		Cn_LightGray:                  Integer = 14671839;
		Cn_MediumGray:                 Integer = 9408399;
		Cn_OliveDrab:                  Integer = 2330219;
		documentationText
		`RGB(107, 142, 35)
`
		Cn_Orange:                     Integer = 33023;
		Cn_PaleBlue:                   Integer = 16444894;
		documentationText
		`Red 222, Green 237, Blue 250`
		Cn_PaleGray:                   Integer = 16119285;
		documentationText
		`RGB(245, 245, 245)`
		Cn_PaleGreen:                  Integer = 13171902;
		documentationText
		`Red 190, Green 252, Blue 200`
		Cn_PaleOrange:                 Integer = 7846911;
		Cn_PalePurple:                 Integer = 16561888;
		documentationText
		`R 224, G 182, B 252`
		Cn_PaleYellow:                 Integer = 12122362;
		documentationText
		`Red 250, Green 248, Blue 184`
		Cn_Pink:                       Integer = 14136575;
		documentationText
		`Red 255, Green 180, Blue 215`
		Cn_WedgeWoodBlue:              Integer = 16764831;
		documentationText
		`Red 159, Green 207, Blue 255`
	categoryDefinition Cn_Debug_Items
		Cn_Debug_NodeProcessMonitoring:Boolean = false;
	categoryDefinition Cn_EventTags
		CN_A_EventTags_NextAvailable:  Integer = 55000145;
		CN_BACKUP_ABORT_REQUESTED:     Integer = 55000102;
		CN_CHECK_SDSCHECKSREQUIRED:    Integer = 55000134;
		CN_COMPACTION_ABORT_REQUESTED: Integer = 55000104;
		CN_COMPACTION_STOP_REQUESTED:  Integer = 55000144;
		CN_COMPACT_TRANSIENT_FILE:     Integer = 55000138;
		CN_DEVELOPMENT_ACTIVITY:       Integer = 55000109;
		CN_HEARTBEAT:                  Integer = 55000105;
		CN_LOCK_CHECKS_EVENT_DISABLE:  Integer = 55000110;
		CN_LOCK_CHECKS_EVENT_ENABLE:   Integer = 55000112;
		CN_LOCK_CHECK_TIMER:           Integer = 55000124;
		CN_NODE_MONITOR_TIMER:         Integer = 55000106;
		CN_PROCESSREGISTRATION_TIMEINT:Integer = 60 * 1000;
		CN_PROCESSREGISTRATION_TIMER:  Integer = 55000107;
		CN_QUAL_APPSERVERMONITOR_SUSPEND:Integer = 55000133;
		CN_REGISTER_MAXLOCALPROCESSES: Integer = 55000108;
		CN_REPORT_LOCKEXCEPTION:       Integer = 55000123;
		CN_RPS_APPLICATION_EVENT:      Integer = 55000139;
		CN_SEND_TRANSACTIONSTATISTICS: Integer = 55000135;
		documentationText
		`Add in 3.8.09 - PAR 977`
		CN_TRAN_STATS_DISCARD_ALL:     Integer = 55000264;
		CN_WAIT_TAKEOVER_ROLECHANGE:   Integer = 55000143;
		CN_WRITE_SERVER_LOG:           Integer = 55000103;
		Cn_Analyze_Transients:         Integer = 55000121;
		Cn_Backup_Complete:            Integer = 55000118;
		Cn_Backup_Failed:              Integer = 55000119;
		Cn_Backup_Inclusions:          Integer = 55000120;
		Cn_Backup_Journal_Start:       Integer = 55000116;
		Cn_Backup_NonDbFile_Start:     Integer = 55000115;
		Cn_Backup_Process_Deleted:     Integer = 55000222;
		Cn_Backup_Progress_Update:     Integer = 55000113;
		Cn_Backup_Status_Change:       Integer = 55000114;
		Cn_Backup_Workers_Complete:    Integer = 55000117;
		Cn_Cache_Stats_Request:        Integer = 55000208;
		Cn_Cache_Stats_Submission:     Integer = 55000209;
		Cn_Compact_Process_Deleted:    Integer = 55000223;
		Cn_Deadlock_Retry_Event:       Integer = 55000292;
		Cn_ForceCreateOfProcess:       Integer = 55000137;
		Cn_ForceDeleteOfProcess:       Integer = 55000136;
		Cn_JDB_Admin_Tag:              Integer = 55000220;
		Cn_JDB_Log_Transfer_Event:     Integer = 55000263;
		documentationText
		`Constant for JadeDatabaseAdmin.LogTransferEvent`
		Cn_JDB_Managed_Tag:            Integer = 55000221;
		Cn_JadeCareInstaller_Loader_Terminate:Integer = 55000141;
		Cn_JadeCareInstaller_ReorgApp_Terminate:Integer = 55000140;
		Cn_JadeCareInstaller_Response: Integer = 55000141;
		Cn_JadeCareInstaller_Terminate:Integer = 55000140;
		Cn_Joss_Emergency_Alert:       Integer = 55000101;
		Cn_KCCMgr_JournalTransferEvent:Integer = 55000131;
		Cn_Launch_Application_Node:    Integer = 55000205;
		documentationText
`KCCMgr subscribes to this eventType on the Node class.
It gets the PID number and tries to identify if any processes
from this node have registered.

If so, then the first registered process in the node will be sent
a notification Cn_Launch_Application_Process along with the
schema and application name`
		Cn_Launch_Application_Process: Integer = 55000204;
		documentationText
`All registered processes subscribe to this eventType.
When used, only the first registered process in the node will incur this notification sent from KCCMgr.`
		Cn_Launch_Application_Reply:   Integer = 55000207;
		Cn_Launch_Application_Timeout: Integer = 55000210;
		Cn_Message_From_Client:        Integer = 55000201;
		Cn_Message_To_Client:          Integer = 55000202;
		Cn_Node_Class:                 Integer = 55000151;
		Cn_Node_Sampling_Status_Chg:   Integer = 55000206;
		Cn_Param_Class:                Integer = 55000270;
		Cn_Partition_Process_Deleted:  Integer = 55000132;
		Cn_Process_Class:              Integer = 55000150;
		Cn_Process_Shutdown_Command:   Integer = 55000121;
		Cn_SDSStructureState_Class:    Integer = 55000126;
		Cn_SDSStructure_Sync_Request:  Integer = 55000130;
		Cn_SDS_PreTakeOver_Request:    Integer = 55000127;
		Cn_SDS_PreTakeOver_Response:   Integer = 55000128;
		Cn_SDS_PreTakeOver_Timeout:    Integer = 55000129;
		Cn_SDS_Structure_State_Delete: Integer = 55000125;
		Cn_SOA_UserPatches_Alert:      Integer = 55000265;
		Cn_SendDbDetails_TimeDaily:    Integer = 24 * 60 * 60 * 1000;
		documentationText
		`24 hours`
		Cn_SendDbDetails_TimeReorg:    Integer = 15 * 1000;
		documentationText
		`15 second interval`
		Cn_SendDbDetails_Timer:        Integer = 55000122;
		Cn_Session_Open_Advice_Request:Integer = 55000203;
		Cn_Tran_Stats_Request:         Integer = 55000260;
		Cn_Tran_Stats_Submission:      Integer = 55000261;
		Cn_Tran_Stats_Timer_Change:    Integer = 55000262;
		Cn_Transfer_Complete:          Integer = 55000291;
		Cn_Transfer_Progress:          Integer = 55000290;
		Cn_Unhandled_Exception:        Integer = 55000299;
	categoryDefinition Cn_ExternalMethods
		Cn_CreateProcess:              String = "emCreateProcess";
		Cn_CreateProcessReturnResults: String = "emCreateProcessReturnResults";
	categoryDefinition Cn_File_Path_Constants
		CN_ALTOS:                      String = "altos";
		CN_CLIENT:                     String = "client";
		CN_C_BIN:                      String = "c_bin";
		CN_C_BIN_DOWNLOAD:             String = "c_bin/download";
		CN_C_LIB:                      String = "c_lib";
		documentationText
		`Unix only`
		CN_C_MISC:                     String = "c_misc";
		CN_C_MISC_C_MISC:              String = "c_misc/c_misc";
		CN_C_SCHEMA:                   String = "c_schema";
		CN_C_SYSTEM:                   String = "c_system";
		CN_DBFILES_BACKUP:             String = "Cn_DbFiles_Backup.txt";
		CN_DOWNLOAD:                   String = "download";
		CN_DOWNLOAD_C_BIN:             String = "download/c_bin";
		CN_DOWNLOAD_C_LIB:             String = "download/c_lib";
		CN_DOWNLOAD_C_MISC:            String = "download/c_misc";
		CN_LOGS:                       String = "logs";
		CN_N_BIN:                      String = "n_bin";
		CN_N_LIB:                      String = "n_lib";
		documentationText
		`Unix only`
		CN_N_MISC:                     String = "n_misc";
		CN_N_SCHEMA:                   String = "n_schema";
		CN_N_SYSTEM:                   String = "n_system";
		CN_O_BIN:                      String = "o_bin";
		CN_O_LIB:                      String = "o_lib";
		documentationText
		`Unix only`
		CN_O_MISC:                     String = "o_misc";
		CN_O_SCHEMA:                   String = "o_schema";
		CN_O_SYSTEM:                   String = "o_system";
		CN_ROOT:                       String = "ROOT";
		CN_RUNTIME:                    String = "runtime";
		CN_SERVER:                     String = "server";
		CN_THINCLIENT:                 String = "client/thinclient";
	categoryDefinition Cn_IniFileStuff
		CN_ALLOWMULTILEVELBACKUPDIR:   String = "AllowMultiLevelBackupDirectory";
		CN_ALLOWOVERWRITE:             String = "AllowOverWrite";
		CN_ALLOWOVERWRITEFILES:        String = "AllowOverwriteFiles";
		CN_APPENVIRONMENT:             String = "AppEnvironment";
		CN_APPEXCEPTIONS:              String = "AppExceptions";
		CN_APPSERVER:                  String = "AppServer";
		CN_APPSERVERGROUPNAME:         String = "AppServerGroupName";
		CN_BACKUPDIRECTORY:            String = "BackupDirectory";
		CN_BACKUPWORKERS:              String = "BackupWorkers";
		CN_BASEDIRECTORY:              String = "BaseDirectory";
		CN_CARDLOG:                    String = "CardLog";
		CN_CHECKSHARELOCKS:            String = "CheckShareLocks";
		CN_CHECKSHARELOCKS_SECONDARY:  String = "CheckShareLocksSecondary";
		CN_COMMITCOHERENTBACKUP_MAX_TRIES:String = "commitCoherentBackupMaxTries";
		CN_COMMITCOHERENTBACKUP_RETRY_INTERVAL:String = "commitCoherentBackupRetryInterval";
		CN_COMPRESSFILES:              String = "CompressFiles";
		CN_COMPRESSLOGS:               String = "CompressLogs";
		CN_CURRENTCONFIGURATION:       String = "CurrentConfiguration";
		CN_DATABASEROLE:               String = "DatabaseRole";
		CN_DATABASESUBROLE:            String = "DatabaseSubrole";
		CN_DATAPUMPAPPLICATION:        String = "DataPumpApplication";
		CN_DEFAULTDATAPUMPAPPLICATION: String = "CnDefaultDataPumpApplication";
		CN_DISABLEBACKUPNOTIFICATIONS: String = "DisableBackupNotifications";
		CN_DISTRIBUTION:               String = "Distribution";
		CN_DOUBLEDEADLOCKEXCEPTION:    String = "DoubleDeadlockException";
		CN_DOWNLOAD_DIRECTORY:         String = "DownloadDirectory";
		CN_DOWNLOAD_VERSION:           String = "DownloadVersion";
		CN_ENABLEARCHIVALRECOVERY:     String = "EnableArchivalRecovery";
		CN_ENABLE_AUTO_UPDATE:         String = "EnableAutoUpdate";
		CN_ENVIRONMENTID:              String = "EnvironmentId";
		CN_FAULTHANDLING:              String = "FaultHandling";
		CN_FULLJADEINSTALLDIRECTORY:   String = "FullJadeInstallDirectory";
		CN_IGNORENABLEARCHIVALRECOVERY:String = "IgnoreEnableArchivalRecovery";
		CN_IGNORE_KARMACONTROL_CHECK:  String = "IgnoreKarmaControlCheck";
		CN_INITIALIZATION_HANDLER_LIB: String = "InitializationHandlerLibrary";
		CN_JADEAPPSERVER:              String = "JadeAppServer";
		CN_JADEAUTOUPDATE:             String = "JadeAutoUpdate";
		CN_JADECLIENT:                 String = "JadeClient";
		CN_JADEENVIRONMENT:            String = "JadeEnvironment";
		documentationText
`Refer to PAR 35026.

There is a new set of undocumented INI file key values defined, that enable unbuffered output in some Jade console/batch applications.

[JadeEnvironment]
XYZZYStdoutUnbuffered=true
XYZZYStderrUnbuffered=true

Where XYZZY can be one of jadclient, jadloadb, jadregb, jdbutilb, jddlutlb

i.e.
[JadeEnvironment]
jdbutilbStdoutUnbuffered=true

The INI file values are not automatically created and default to false`
		CN_JADEEXECUTEFLAGS:           String = "JadeExecuteFlags";
		CN_JADEREORG:                  String = "JadeReorg";
		CN_JADERPS:                    String = "JadeRps";
		CN_JADESERVER:                 String = "JadeServer";
		CN_JADETHINCLIENT:             String = "JadeThinClient";
		CN_JADE_LOG:                   String = "JadeLog";
		CN_JOURNALCLOSEACTION:         String = "JournalCloseAction";
		CN_JOURNALROOTDIRECTORY:       String = "JournalRootDirectory";
		CN_JSMDATABASEBACKUP:          String = "JSMDatabaseBackup";
		CN_JSMSTATS:                   String = "JSMStats";
		CN_KARMACONTROL:               String = "KarmaControl";
		CN_LOCKCHECKINTERVAL:          String = "LockCheckInterval";
		CN_LOCKCHECKINTERVAL_SECONDARY:String = "LockCheckIntervalSecondary";
		CN_LOGCOMMSBUFFERS:            String = "LogCommsBuffers";
		CN_LOGCOMMSCOMPUTER:           String = "LogCommsComputer";
		CN_LOGCOMMSCONNECTIONS:        String = "LogCommsConnections";
		CN_LOGDIAGNOSTICS:             String = "LogDiagnostics";
		CN_LOGFILEMAXSIZE:             String = "LogFileMaxSize";
		CN_LOGFILENAME:                String = "LogFileName";
		CN_LOGGING:                    String = "Logging";
		CN_LOGIMMEDIATECOMMIT:         String = "LogImmediateCommit";
		CN_LOGMESSAGING:               String = "LogMessaging";
		CN_LOGNAMESUSEIPADDRESS:       String = "LogNamesUseIPAddress";
		CN_LOGPATH:                    String = "LogPath";
		CN_LOGTOSCREEN:                String = "LogToScreen";
		CN_MASTER_ENVIRONMENT_ID:      String = "MasterEnvironmentId";
		CN_MAXLOCKSREQUESTED:          String = "MaxLocksRequested";
		CN_MAXLOCKSREQUESTED_SECONDARY:String = "MaxLocksRequestedSecondary";
		CN_MAXLOCKTIMEBEFOREALARM:     String = "MaxLockTimeBeforeAlarm";
		CN_MAXLOCKTIMEBEFOREALARM_SECONDARY:String = "MaxLockTimeBeforeAlarmSecondary";
		CN_MYNAME:                     String = "myName";
		CN_NETWORKSPECIFICATION:       String = "NetworkSpecification";
		CN_OPENALLFILESONDBOPEN:       String = "OpenAllFilesOnDbOpen";
		CN_PERSISTENTDB:               String = "PersistentDb";
		CN_POSTINSTALLEXE:             String = "PostInstallExe";
		CN_PRIMARYSERVERNAME:          String = "PrimaryServerName";
		CN_QUIESCE:                    String = "Quiesce";
		CN_REMAININGPROCESSALERTTHRESHOLD:String = "RemainingProcessAlertThreshold";
		CN_REMAININGPROCESSALERTTHRESHOLD_SECONDARY:String = "RemainingProcessAlertThresholdSecondary";
		CN_RPCENCRYPTIONENABLED:       String = "RPCEncryptionEnabled";
		CN_RPCENCRYPTIONHOOKDLL:       String = "RPCEncrytionHookDLL";
		CN_SDS_CHECK_INTERVAL:         String = "SDSCheckInterval";
		CN_SDS_ENVIRONMENT_ID:         String = "SDSEnvironmentId";
		CN_SDS_MAX_LAG_TIME:           String = "SDSMaxLagTime";
		CN_SDS_REPLAY_STRUCT_STATE:    String = "SDSReplayStructureState";
		CN_SDS_UPDATE_STRUCT_STATE_FRQ:String = "SDSUpdateStructureStateFrequency";
		CN_SECTION_KARMA:              String = "Karma";
		CN_SERVERNODESPECIFICATIONS:   String = "ServerNodeSpecifications";
		CN_SMTPCLIENT:                 String = "SMTPClient";
		CN_SMTPCLIENT_LOGGING:         String = "Logging";
		CN_SMTPCLIENT_LOGGINGRESPONSE: String = "LoggingResponse";
		CN_SSL_CERTIFICATEAUTHFILE:    String = "SSLCertificateAuthorityFile";
		CN_SSL_CERTIFICATEAUTHPATHS:   String = "SSLCertificateAuthorityPaths";
		CN_SSL_CERTIFICATEFILE:        String = "SSLCertificateFile";
		CN_SSL_CIPHERNAMES:            String = "SSLCipherNames";
		CN_SSL_METHODNAME:             String = "SSLMethodName";
		CN_SSL_SECURE_PORT:            String = "SSLSecurePort";
		CN_STATEOVERFLOWDIRECTORY:     String = "StateOverflowDirectory";
		CN_SUPPRESSALERTS:             String = "SuppressAlerts";
		CN_SUPPRESS_EMBEDDEDSPACE_ALERT:String = "SuppressEmbeddedSpaceAlert";
		CN_SYNCDBSERVICE:              String = "SyncDbService";
		CN_TESTMODE:                   String = "TestMode";
		CN_TESTMODE_EMAILADDRESS:      String = "TestModeEmailAddress";
		CN_TRANSTATS_INTERVAL:         String = "TranStatsInterval";
		CN_UNITTEST_DEBUG:             String = "UnitTestDebug";
		CN_USECOMPRESSION:             String = "UseCompression";
	categoryDefinition Cn_JadeCare_Limits
		Cn_Max_EnvironmentName_Length: Integer = 20;
		documentationText
`This restriction is due to the limit of 20 bytes allowed by Windows
when setting up account names (user).`
	categoryDefinition Cn_JadeDynamicObjectProperties
		CN_OSDETAIL_ADDRESSWIDTH:      String = "addressWidth";
		CN_OSDETAIL_ARCHITECTURE:      String = "architecture";
		CN_OSDETAIL_BUILDARCHITECTURE: String = "buildArchitecture";
		CN_OSDETAIL_CHARACTERSIZE:     String = "characterSize";
		CN_OSDETAIL_FULLBUILDARCHLIST: String = "fullBuildArchitectureList";
		CN_OSDETAIL_ISBIGENDIAN:       String = "isBigEndian";
		CN_OSDETAIL_OSADDRESSWIDTH:    String = "osAddressWidth";
		CN_OSDETAIL_OSVERSIONENUM:     String = "osVersionEnum";
		CN_OSDETAIL_OSVERSIONSTRING:   String = "osVersionString";
		CN_OSDETAIL_PLATFORMID:        String = "platformId";
		CN_OSDETAIL_VERSION:           String = "version";
	categoryDefinition Cn_JadeExecuteFlagCategory
		Cn_Debug_FileDetails:          Boolean = false;
		Cn_Debug_KarmaDllBad:          Boolean = false;
		Cn_Debug_SDSStructureState:    Boolean = false;
		Cn_Debug_SMTP:                 Boolean = false;
		Cn_Ignore_JadeAutoUpdate:      Boolean = false;
	categoryDefinition Cn_Jade_Exceptions
		Cn_AccessToObjectsSDSDisabled: Integer = 3123;
		Cn_ActiveXMetaDataMissing:     Integer = 14159;
		Cn_AddDuplToArrayWithInverse:  Integer = 1272;
		Cn_ArrayIndexOutOfBounds:      Integer = 1300;
		Cn_AttemptToRenameFileFailed:  Integer = 5015;
		Cn_AttemptedAccessViaNullRef:  Integer = 1090;
		Cn_BackupIsIncompleteOrBackupinfoCorrupted:Integer = 3124;
		Cn_CannotOverwriteExistingFile:Integer = 5008;
		Cn_CannotPerformInBackupState: Integer = 3156;
		Cn_ClassNeedsReorganization:   Integer = 1200;
		Cn_ClassOfObjectInvalidContext:Integer = 1086;
		Cn_CommandFileNotSuccessful:   Integer = 8514;
		Cn_ConnectionBindFailed:       Integer = 31005;
		Cn_ConnectionWasClosed:        Integer = 31017;
		Cn_ControlFileVerNotSupported: Integer = 3030;
		Cn_CouldNotChangeDeltaDbMode:  Integer = 1163;
		Cn_DatabaseAuditError:         Integer = 3029;
		Cn_DatabaseFileLockedForReorg: Integer = 3116;
		Cn_DatabaseFileReqdNotFound:   Integer = 3036;
		Cn_DatabaseLockedForReorganize:Integer = 3059;
		Cn_DatabaseReadPastEndOfFile:  Integer = 3060;
		Cn_Deadlock:                   Integer = 1081;
		Cn_DirSpecifiedNameNotCreated: Integer = 5023;
		Cn_Divide_By_Zero:             Integer = 4030;
		Cn_DynamicObjectPropertyNameConflict:Integer = 1433;
		Cn_EntryNotFoundInCollection:  Integer = 1301;
		Cn_ExceededProcessLicences:    Integer = 5504;
		Cn_FailedToCreateClass:        Integer = 14116;
		Cn_FailedToCreateDotNetObject: Integer = 14577;
		Cn_FileAccessNotPermitted:     Integer = 5002;
		Cn_FileDirectoryNotFound:      Integer = 5028;
		Cn_FileDirectoryNotValid:      Integer = 5027;
		Cn_FileInUseByAnotherProcess:  Integer = 5030;
		Cn_FileNameNotValidForFileSyst:Integer = 5029;
		Cn_FileWriteOutOfDiskCondition:Integer = 5031;
		Cn_IndexInSubStringOutOfBounds:Integer = 4031;
		Cn_IndexUsedInStringOperationIsOutOfBounds:Integer = 1413;
		Cn_InvalidAddress:             Integer = 8;
		Cn_InvalidApplication:         Integer = 1214;
		Cn_InvalidClassNumber:         Integer = 1046;
		Cn_InvalidNumRowsSetForTable:  Integer = 14049;
		Cn_InvalidParameterValue:      Integer = 1002;
		Cn_InvalidPropertyArrayIndex:  Integer = 14011;
		Cn_InvalidPropertyValue:       Integer = 14008;
		Cn_InvalidSchema:              Integer = 1213;
		Cn_InvalidTableRow:            Integer = 14051;
		Cn_KeyAlreadyUsed:             Integer = 1310;
		Cn_LibraryNotFound:            Integer = 1006;
		Cn_MaximumEntriesInListbox:    Integer = 14025;
		Cn_MethodAborted:              Integer = 1205;
		Cn_MethodsInErrorDetected:     Integer = 8510;
		Cn_MultimediaFunctionFailed:   Integer = 14092;
		Cn_NoMemoryForBuffers:         Integer = 1018;
		Cn_NotificationInfoTooBig:     Integer = 1267;
		Cn_NotificationNotSet:         Integer = 1066;
		Cn_NotifySubscriberNotFound:   Integer = 1227;
		Cn_NullRefInvArgToCollMethod:  Integer = 1311;
		Cn_ObjectAlreadyInCollection:  Integer = 1309;
		Cn_ObjectDeleted:              Integer = 1072;
		Cn_ObjectEditionOutOfDate:     Integer = 3049;
		Cn_ObjectLocked:               Integer = 1027;
		Cn_ObjectNotAvailable:         Integer = 1092;
		Cn_ObjectNotFound:             Integer = 4;
		Cn_OpenPinterFailed:           Integer = 15005;
		Cn_OutOfResourcesForOperation: Integer = 4024;
		Cn_PictureIsNotAnIcon:         Integer = 14013;
		Cn_Printing_Cancelled:         Integer = 15015;
		Cn_ReceiverAlreadyRegTimer:    Integer = 1400;
		Cn_RecordTruncatedMaxRecordSz: Integer = 5011;
		Cn_ReorgReqdPriorToDDBLoad:    Integer = 8525;
		Cn_ReorgWaitingForTransition:  Integer = 3413;
		Cn_ReorganisationIsRequired:   Integer = 8511;
		Cn_RequestedAccessNotPermitted:Integer = 5002;
		Cn_RequestedFileDirNotFound:   Integer = 5028;
		Cn_RequestedFileNotFound:      Integer = 5003;
		Cn_RequestedMethodNotDefined:  Integer = 1010;
		Cn_RequestedPropertyNotDefined:Integer = 1011;
		Cn_RequiredLogFileNotOpen:     Integer = 1436;
		Cn_ResultExpressionIntOverflow:Integer = 1406;
		Cn_SDSBackupTerminatedReorg:   Integer = 3213;
		Cn_SDSNotInitialized:          Integer = 3201;
		Cn_SDSReplayIncompleteJournal: Integer = 3200;
		Cn_SDSResponseTimeout:         Integer = 3212;
		Cn_SDSSecondaryNotAttached:    Integer = 3204;
		Cn_SchemaDatabaseObjSizeErr:   Integer = 3039;
		Cn_StringTooLong:              Integer = 1035;
		Cn_ThinClientTcpConnClosed:    Integer = 14143;
		Cn_Uncompiled_InError_Methods: Integer = 8711;
		Cn_Uncompiled_Or_InError_Methods_Remain:Integer = 1183;
		Cn_UnexpectedIOErrorAccessFile:Integer = 5033;
		Cn_UserSignOnCurrentlyDisabled:Integer = 1284;
		Cn_WindowCreateFailed:         Integer = 14063;
	categoryDefinition Cn_Jade_Limits
		Cn_Max_Table_Rows:             Integer = 32000;
	categoryDefinition Cn_Jade_Utilities
		Cn_Jadclient:                  String = "jadclient.exe";
		Cn_Jade:                       String = "jade.exe";
		Cn_Jadeadmin:                  String = "jadeadmin.exe";
		Cn_Jadloadb:                   String = "jadloadb.exe";
		Cn_Jadregb:                    String = "jadregb.exe";
		Cn_Jdbutilb:                   String = "jdbutilb.exe";
	categoryDefinition Cn_KarmaConstants
		Cn_CARDSCHEMA:                 String = "CardSchema";
		Cn_FTP:                        Integer = 2;
		Cn_Fat_Client:                 Integer = 0;
		Cn_HTTP:                       Integer = 3;
		Cn_HTTPS:                      Integer = 4;
		Cn_JADE_Thin_Client:           Integer = 2;
		Cn_JOSS:                       String = "Joss";
		Cn_Java_Thin_Client:           Integer = 1;
		Cn_Windows_Share:              Integer = 1;
	categoryDefinition Cn_Managed_System_Type
		CN_SYSTEMTYPE_JSA:             Integer = 1;
		CN_SYSTEMTYPE_JSM:             Integer = 2;
		CN_SYSTEMTYPE_USER:            Integer = 0;
	categoryDefinition Cn_Node_Cache_Statistics
		Cn_CleanSwappedBuffers:        String = "cleanSwappedBuffers";
		Cn_CreatedBuffers:             String = "createdBuffers";
		Cn_DirtySwappedBuffers:        String = "dirtySwappedBuffers";
		Cn_Hits:                       String = "hits";
		Cn_MaxBufferSize:              String = "maximumBufferSize";
		Cn_Misses:                     String = "misses";
		Cn_NodeCPUTime:                String = "nodeCPUTime";
		Cn_TotalBuffers:               String = "totalNumberOfBuffers";
	categoryDefinition Cn_Node_Types
		Cn_NodeType_AppServer:         Character = "A";
		Cn_NodeType_Jade:              Character = "J";
		Cn_NodeType_Server:            Character = "S";
	categoryDefinition Cn_Numbers
		CN_BYTES_PER_GIGABYTE:         Integer = 1073741824;
		CN_BYTES_PER_KILOBYTE:         Integer = 1024;
		CN_BYTES_PER_MEGABYTE:         Integer = 1048576;
		CN_BYTES_PER_TERABYTE:         Decimal = 1099511627776;
		CN_TRANSACTION_ID_MAXLENGTH:   Integer = 202;
	categoryDefinition Cn_Picture_Types
		Cn_Green_Frog:                 Integer = 1;
		Cn_Green_Frog_Photo:           Integer = 3;
		Cn_Original_Green_Frog:        Integer = 2;
		Cn_Rainbow_Frog:               Integer = 4;
		Cn_Road_Sign:                  Integer = 5;
	categoryDefinition Cn_Process_Local_Statistics
		Cn_Persistent_CauseEvents:     String = "persistentCauseEvents";
		Cn_Persistent_CreateObjects:   String = "persistentObjectCreates";
		Cn_Persistent_DeleteObjects:   String = "persistentObjectDeletes";
		Cn_Persistent_EndTransactions: String = "persistentEndTransactions";
		Cn_Persistent_GetObjects:      String = "persistentObjectGets";
		Cn_Persistent_LockObjects:     String = "persistentObjectLocks";
		Cn_Persistent_UnlockObjects:   String = "persistentObjectUnlocks";
		Cn_Persistent_UpdateObjects:   String = "persistentObjectPuts";
		Cn_Stats_Type_Local:           Integer = 1;
		Cn_Stats_Type_Remote:          Integer = 2;
		Cn_TC_BytesFromAppServer:      String = "thinClientBytesSentByAppServer";
		Cn_TC_BytesFromClient:         String = "thinClientBytesSentByClient";
		Cn_TC_LogicMsgWaitTime:        String = "thinClientLogicMsgWaitTime";
		documentationText
`This is the milliseconds that the logic had to wait for a reply sent by the app server to the presentation client.
It does not include time waiting for modal forms, message boxes or exception dialogs etc`
		Cn_TC_MsgsFromAppServer:       String = "thinClientMsgsSentByAppServer";
		Cn_TC_MsgsFromClient:          String = "thinClientMsgsSentByClient";
	categoryDefinition Cn_Process_Priority
		CN_PRIORITY_ABOVE_NORMAL:      String = "THREAD_PRIORITY_ABOVE_NORMAL";
		CN_PRIORITY_BELOW_NORMAL:      String = "THREAD_PRIORITY_BELOW_NORMAL";
		CN_PRIORITY_HIGHEST:           String = "THREAD_PRIORITY_HIGHEST";
		CN_PRIORITY_IDLE:              String = "THREAD_PRIORITY_IDLE";
		CN_PRIORITY_LOWEST:            String = "THREAD_PRIORITY_LOWEST";
		CN_PRIORITY_NORMAL:            String = "THREAD_PRIORITY_NORMAL";
		CN_PRIORITY_TIME_CRITICAL:     String = "THREAD_PRIORITY_TIME_CRITICAL";
	categoryDefinition Cn_Process_Rpc_Statistics
		Cn_ProcessCPUTime:             String = "processCPUTime";
		Cn_RpcCauseEvents:             String = "rpcCauseEvents";
		Cn_RpcCreateObjects:           String = "rpcCreateObjects";
		Cn_RpcDeleteObjects:           String = "rpcDeleteObjects";
		Cn_RpcEndTransactions:         String = "rpcEndTransactions";
		Cn_RpcLockQueueWaitsTime:      String = "rpcLockQueueWaitsTime";
		Cn_RpcNewBufferGetObjects:     String = "rpcNewBufferGetObjects";
		Cn_RpcNewBufferLockObjects:    String = "rpcNewBufferLockObjects";
		Cn_RpcNonUpdatedBufferGetObjs: String = "rpcNonUpdatedBufferGetObjects";
		Cn_RpcNonUpdatedBufferLockObjs:String = "rpcNonUpdatedBufferLockObjects";
		Cn_RpcServerExecutions:        String = "rpcServerExecutions";
		Cn_RpcServerExecutionsTime:    String = "rpcServerExecutionsTime";
		Cn_RpcTemporaryBufferGetObjs:  String = "rpcTemporaryBufferGetObjects";
		Cn_RpcTemporaryBufferLockObjs: String = "rpcTemporaryBufferLockObjects";
		Cn_RpcUnlockObjects:           String = "rpcUnlockObjects";
		Cn_RpcUpdateObjects:           String = "rpcUpdateObjects";
		Cn_RpcUpdatedBufferGetObjects: String = "rpcUpdatedBufferGetObjects";
		Cn_RpcUpdatedBufferLockObjects:String = "rpcUpdatedBufferLockObjects";
	categoryDefinition Cn_SDS_Constants
		Cn_Cmd_Disconnect:             String = "DISCONNECT";
		Cn_Cmd_Reconnect:              String = "RECONNECT";
		Cn_Cmd_Report_SDS_Status:      String = "SDS_REPORT";
		Cn_Cmd_ResumeTracking:         String = "RESUME_TRACKING";
		Cn_Cmd_StopTracking:           String = "STOP_TRACKING";
		Cn_Cmd_Stop_KCCMgr:            String = "STOP_KCCMGR";
		SDS_ReasonDeploymentEnd:       Integer = 109;
		SDS_ReasonDeploymentStart:     Integer = 100;
		SDS_ReasonEndJadeUpgrade:      Integer = 101;
		SDS_ReasonEndUserSchemaLoad:   Integer = 102;
	categoryDefinition Cn_SNMP_Traps
		Cn_Application_Alert:          Integer = 10;
		Cn_Backup_Link_Active:         Integer = 3;
		Cn_Backup_Link_Still_Active:   Integer = 2;
		Cn_Custom_Trap:                Integer = 9;
		Cn_Emergency_Alert:            Integer = 15;
		Cn_Enterprise:                 String = "1.3.6.1.4.1.2553";
		Cn_Interface_Unstable:         Integer = 1;
		Cn_JadeEnv_Down:               Integer = 13;
		Cn_JadeEnv_Up:                 Integer = 14;
		Cn_JossDirect_Alert:           Integer = 17;
		Cn_Joss_Interface_RangeEnd:    Integer = 899;
		Cn_Joss_Interface_RangeStart:  Integer = 800;
		Cn_Joss_Interface_Trap_JoobWebAlive:Integer = 800;
		Cn_Joss_Trap:                  Integer = 12;
		Cn_Karma_Alert:                Integer = 11;
		Cn_Performance_Trap:           Integer = 8;
		Cn_Test_Alert:                 Integer = 16;
		Cn_Tracker_Interface_RangeEnd: Integer = 999;
		Cn_Tracker_Interface_RangeStart:Integer = 900;
		Cn_Tracker_Interface_Trap_CustomerSBS_ICS_Critical:Integer = 950;
		documentationText
`Refer to PAR #7782.

Added to JSM 4.0.03 but implemented in JADECare 24 production in 4.0.02.`
		Cn_Tracker_Interface_Trap_CustomerSBS_ICS_Warning:Integer = 951;
		documentationText
`Refer to PAR #7782.

Added to JSM 4.0.03 but implemented in JADECare 24 production in 4.0.02.`
		Cn_Tracker_Interface_Trap_JadeEnv:Integer = 901;
		Cn_Tracker_Interface_Trap_ODBCEnv:Integer = 902;
		Cn_Tracker_Interface_Trap_Server:Integer = 900;
		documentationText
`Used in conjunction with
- Enterprise = Cardinal (1.3.6.1.4.1.2553)
- Generic 	 = 6

If Tracker is instantiated this will create / update a Tracker call with relevant details provided as trap arguments`
	categoryDefinition Cn_Special_Characters
		Cn_BackSpace:                  String = #"08";
	categoryDefinition Cn_Strings
		CN_ABORT:                      String = "ABORT";
		CN_BINARY:                     String = "Binary";
		CN_COMMA:                      Character = ",";
		CN_DISTRIBUTION_ANSI:          String = "-ansi";
		CN_DISTRIBUTION_UNICODE:       String = "-unicode";
		CN_EQUAL:                      String = "=";
		CN_FILETYPE_BINARY:            Character = "B";
		CN_FILETYPE_LIBRARY:           Character = "L";
		CN_HEXVALS:                    String = "0123456789abcdef";
		CN_LOCALHOST_IPADDRESS:        String = "127.0.0.1";
		CN_NO:                         String = "No";
		CN_NOT_OK:                     String = "NOT OK";
		CN_OK:                         String = "OK";
		CN_STRING:                     String = "String";
		CN_STRINGUTF8:                 String = "StringUtf8";
		CN_TIME:                       String = "Time";
		CN_TIMESTAMP:                  String = "TimeStamp";
		CN_TIMESTAMPINTERVAL:          String = "TimeStampInterval";
		CN_YES:                        String = "Yes";
		OK:                            String = "OK";
	categoryDefinition Cn_System_Constants
		CN_NETWORK_BYTE_ORDER:         Integer = 1;
		documentationText
`See Node class constants.  This constant is currently set to 1 because JADE 6.0.16 doesn't support conversions to 
network byte order for anything except Integer.  Once this is fixed, this constant should be updated to a value of 
zero (0) in order to activate byte re-ordering in CardSchema and Joss when different hardware platforms are in use.

RWM 12 June 2003`
	categoryDefinition Cn_TCP_Ports
		APP_TO_JSA_PORT:               Integer = 12095;
		JSA_TO_JSM_PORT:               Integer = 12097;
		KCDEPLOY_TO_JSA_PORT:          Integer = 12098;
	categoryDefinition Cn_Version_Control
		Cn_Current_Stats_Version:      Integer = 7;
		documentationText
`Statistics log / message version
--------------------------------
Version 7	: Changed for 3.7.05 to add Database Cache Statistics as part of 
			  KCCMgr stats.																MFJ 06/01/15

Version 6	: Changed for 3.3 to add Queued Locks in transaction statistics

Version 5   : Changed for 3.0 to allow handling of endian issues, addition of
			  node statistics to transaction stats, and change in scaling of 
			  systemn network stats.													RWM 15/8/03

Version 4 	: Changed for 2.9 to accommodate disk partition size in EnvStatsLog			RWM 8/10/02`
localeDefinitions
	1025 "Arabic (Saudi Arabia)";
	1033 "English (United States)";
	1036 "French (France)";
	1053 "Swedish (Sweden)";
	1054 "Thai (Thailand)";
	1057 "Indonesian (Indonesia)";
	1066 "Vietnamese (Vietnam)";
	1115 "Sinhala (Sri Lanka)";
	2052 "Chinese (Simplified) (China)";
	2057 "English (United Kingdom)";
	2074 "Serbian (Latin) (Serbia and Montenegro (Former))";
	3081 "English (Australia)";
	5129 "English (New Zealand)" schemaDefaultLocale;
	9226 "Spanish (Colombia)";
	10249 "English (Belize)" _cloneOf 5129;
	11273 "English (Trinidad & Tobago)" _cloneOf 5129;
	12297 "English (Zimbabwe)" _cloneOf 5129;
	13321 "English (Philippines)" _cloneOf 5129;
	4105 "English (Canada)" _cloneOf 5129;
	6153 "English (Ireland)" _cloneOf 5129;
	7177 "English (South Africa)" _cloneOf 5129;
	8201 "English (Jamaica)" _cloneOf 5129;
	9225 "English (Caribbean)" _cloneOf 5129;
localeFormatDefinitions
	CnCCYYMMDD: DateFormat(true, true, true, "/", true, 2);
	CnCCYYMMDD_ns: DateFormat(true, true, true, "", true, 2);
	CnDDMMCCYY: DateFormat(true, false, true, "/", true, 1);
	CnDDMMCCYY_lz: DateFormat(true, true, true, "/", true, 1);
	CnDDMMYY: DateFormat(true, true, true, "/", false, 1);
	CnDD_MMMMM_CCYY: DateFormat(false, false, 3, 1, 1, " ", " ", " ", true);
	CnDD_MMM_YY: DateFormat(false, true, 3, 2, 1, " ", " ", " ", false);
	CnDW_DD_MMM_CCYY: DateFormat(false, false, 2, 1, 1, ", ", " ", " ", true);
	CnDW_MMM_DD_CCYY: DateFormat(false, false, 2, 1, 0, ", ", " ", " ", true);
	CnHHMM: TimeFormat("", true, false, "p.m.", ":", true, false);
	CnHHMMSS: TimeFormat("", true, false, "p.m.", ":", true, true);
	CnHHMMSS_ns: TimeFormat("", true, false, "PM", "", true, true);
	CnMMDDYY: DateFormat(true, false, false, "/", false, 0);
	CnMMMMM_DD_CCYY: DateFormat(false, false, 3, 1, 0, " ", " ", " ", true);
	CnMMM_DD_YY: DateFormat(false, false, 3, 2, 0, " ", " ", " ", false);
	CnOneDecimalPlace: NumberFormat(1, ".", ",", 1, true, "3;0");
	CnWholeNumbers: NumberFormat(0, ".", ",", 1, true, "3;0");
	CnWholeNumbers_ns: NumberFormat(0, " ", "", 1, false, "3;0");
	CnYYMMDD_ns: DateFormat(true, true, true, "", false, 2);
libraryDefinitions
	"cnldap";
	"josssnmp";
	"karma";
	"kernel32";
	"version";
externalFunctionDefinitions
	cnCopyToClipboard(s: String): Integer is "cnCopyToClipboard" in "karma" presentationClientExecution;
	cnFileVersionInfo(
		fileName: String; 
		infoType: String; 
		infoBuff: String [50] output; 
		maxLength: Integer; 
		errText: String [200] output): Integer is "cnFileVersionInfo" in "karma" presentationClientExecution;
	cnGetCommandLine(
		value: String [1024] output; 
		maxLength: Integer io): Integer is "cnGetCommandLine" in "karma" presentationClientExecution;
	cnGetCurrentProcessId(): Integer is "GetCurrentProcessId" in "kernel32" presentationClientExecution;
	cnGetCurrentThreadId(): Integer is "GetCurrentThreadId" in "kernel32" presentationClientExecution;
	cnGetDriveInfo(
		driveName: String; 
		volumeName: String [32] output; 
		pcName: String [128] output): Integer is "cnGetDriveInfo" in "karma" presentationClientExecution;
	cnGetDriveInfoEx(
		driveName: String; 
		volumeName: String [260] output; 
		pcName: String [260] output; 
		iType: Integer output): Integer is "cnGetDriveInfoEx" in "karma" presentationClientExecution;
	cnGetDriveMapping(
		driveName: String; 
		mapName: String [260] output; 
		maxLength: Integer): Integer is "cnGetDriveMapping" in "karma" presentationClientExecution;
	cnGetEnvironmentVariable(
		variable: String; 
		value: String [256] output; 
		maxLength: Integer): Integer is "cnGetEnvironmentVariable" in "karma" presentationClientExecution;
	cnGetLogicalDrives(drives: String [30] output): Integer is "cnGetLogicalDrives" in "karma" presentationClientExecution;
	cnGetSubDirectories(
		parentDirectory: String; 
		subDirList: String [8192] output; 
		maxListLength: Integer): Integer is "cnGetSubDirectories" in "karma" presentationClientExecution;
	cnHasSubDirectories(dirName: String): Boolean is "cnHasSubDirectories" in "karma" presentationClientExecution;
	cnIsProcessRunning(pProcessName: String): Boolean is "cnIsProcessRunning" in "karma" presentationClientExecution;
	cnSetModifyTime(
		fileName: String; 
		newDate: Integer; 
		newTime: Integer): Integer is "cnSetModifyTime" in "karma" presentationClientExecution;
	getFileVersionInfoANSI(
		pPath: String; 
		pParam1: String; 
		pLength: String; 
		pInfoblock: Binary [3000] output): Boolean is "GetFileVersionInfoA" in "version" presentationClientExecution;
	getFileVersionInfoUnicode(
		pPath: String; 
		pParam1: String; 
		pLength: String; 
		pInfoblock: Binary [3000] output): Boolean is "GetFileVersionInfoW" in "version" presentationClientExecution;
	verQueryValueANSI(
		pInfoblock: Binary; 
		pSubblock: String; 
		pTxtMemAddr: MemoryAddress output; 
		pTxtLen: Integer output): Boolean is "VerQueryValueA" in "version" applicationServerExecution;
	verQueryValueUnicode(
		pInfoblock: Binary; 
		pSubblock: String; 
		pTxtMemAddr: MemoryAddress output; 
		pTxtLen: Integer output): Boolean is "VerQueryValueW" in "version" applicationServerExecution;
typeHeaders
	A_VersionClass subclassOf Object abstract, transient, subclassTransientAllowed, number = 2533;
	CardSchema subclassOf RootSchemaApp transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, highestSubId = 1, highestOrdinal = 54, number = 2048;
	CnAdmin subclassOf Object abstract, transient, number = 2369;
	CnApplicationLauncher subclassOf CnAdmin transient, final, transientAllowed, highestOrdinal = 4, number = 2802;
	CnDatabaseAdmin subclassOf CnAdmin transient, final, sharedTransientAllowed, transientAllowed, highestSubId = 22, highestOrdinal = 78, number = 2370;
	CnJadeSkinsLoader subclassOf CnAdmin transient, final, transientAllowed, number = 2601;
	CnNodeControl subclassOf CnAdmin transient, sharedTransientAllowed, subclassSharedTransientAllowed, highestSubId = 1, highestOrdinal = 15, number = 2958;
	CnNodeControlCnCntrl subclassOf CnAdmin transient, subschemaHidden, final, sharedTransientAllowed, transientAllowed, number = 7230;
	CnParam subclassOf CnAdmin transient, subschemaHidden, final, sharedTransientAllowed, transientAllowed, highestOrdinal = 2, number = 2959;
	CnSchemaAnalyser subclassOf CnAdmin transient, final, transientAllowed, highestOrdinal = 15, number = 2649;
	CnServerStatistics subclassOf CnAdmin transient, subschemaHidden, final, transientAllowed, highestOrdinal = 30, number = 2516;
	CnTransactionData subclassOf CnAdmin transient, transientAllowed, subclassTransientAllowed, highestSubId = 42, highestOrdinal = 42, number = 2616;
	CnTransactionStack subclassOf CnAdmin transient, final, transientAllowed, highestSubId = 7, highestOrdinal = 9, number = 2528;
	CnTransactionStatistics subclassOf CnAdmin transient, final, highestOrdinal = 2, number = 4386;
	CnUtility subclassOf CnAdmin transient, transientAllowed, subclassTransientAllowed, number = 5025;
	CnApp subclassOf Object transient, highestSubId = 1, highestOrdinal = 10, number = 2049;
	CnClusterInfo subclassOf Object transient, final, transientAllowed, highestSubId = 1, highestOrdinal = 8, number = 2796;
	CnCntrl subclassOf Object transient, final, transientAllowed, highestSubId = 4, highestOrdinal = 98, number = 2050;
	CnDeadlockHandler subclassOf Object transient, subschemaHidden, final, transientAllowed, highestOrdinal = 4, number = 2545;
	CnInternet subclassOf Object abstract, transient, highestOrdinal = 16, number = 2132;
	CnFtp subclassOf CnInternet protected, transient, highestOrdinal = 5, number = 2051;
	CnHttp subclassOf CnInternet transient, highestOrdinal = 2, number = 2147;
	CnInternet64 subclassOf Object abstract, transient, highestOrdinal = 16, number = 3411;
	CnFtp64 subclassOf CnInternet64 protected, transient, highestOrdinal = 5, number = 4346;
	CnHttp64 subclassOf CnInternet64 transient, highestOrdinal = 2, number = 3948;
	CnKarmaCntrl subclassOf Object transient, transientAllowed, subclassTransientAllowed, highestSubId = 25, highestOrdinal = 50, number = 2052;
	CnLdap subclassOf Object abstract, transient, number = 2451;
	CnLdapAttribute subclassOf CnLdap transient, highestSubId = 2, highestOrdinal = 11, number = 2452;
	CnLdapBinary subclassOf CnLdap transient, highestOrdinal = 3, number = 2454;
	CnLdapConnection subclassOf CnLdap transient, highestSubId = 7, highestOrdinal = 24, number = 2455;
	CnLdapConstraints subclassOf CnLdap transient, highestOrdinal = 6, number = 2456;
	CnLdapEntry subclassOf CnLdap transient, highestSubId = 1, highestOrdinal = 5, number = 2457;
	CnLdapSearch subclassOf CnLdap transient, highestSubId = 1, highestOrdinal = 9, number = 2458;
	CnLdapSyntax subclassOf CnLdap transient, highestSubId = 2, highestOrdinal = 2, number = 2459;
	CnLdapURL subclassOf CnLdap transient, highestOrdinal = 10, number = 2460;
	CnMIME subclassOf Object abstract, transient, highestOrdinal = 13, number = 2542;
	CnAttachment subclassOf CnMIME transient, highestOrdinal = 1, number = 2359;
	CnSmtpInline subclassOf CnMIME transient, highestOrdinal = 2, number = 2540;
	CnMachine subclassOf Object transient, highestSubId = 2, highestOrdinal = 12, number = 2053;
	CnMessage subclassOf Object transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 32, number = 2054;
	CnAdvice subclassOf CnMessage transient, transientAllowed, subclassTransientAllowed, number = 2055;
	CnBackupAdvice subclassOf CnAdvice transient, transientAllowed, subclassTransientAllowed, highestSubId = 5, highestOrdinal = 17, number = 2523;
	CnCompactAdvice subclassOf CnAdvice transient, transientAllowed, subclassTransientAllowed, highestSubId = 3, highestOrdinal = 17, number = 6696;
	CnControlAdvice subclassOf CnAdvice transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 4, number = 2562;
	CnExceptionAdvice subclassOf CnAdvice transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 15, number = 2960;
	CnExecuteAdvice subclassOf CnAdvice transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 5, number = 2219;
	CnFileDetailsAdvice subclassOf CnAdvice transient, transientAllowed, subclassTransientAllowed, highestSubId = 14, highestOrdinal = 15, number = 7233;
	CnNodeStatsAdvice subclassOf CnAdvice transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 6, number = 2977;
	CnPingReplyAdvice subclassOf CnAdvice transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 31, number = 2057;
	CnSDSAdvice subclassOf CnAdvice transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 19, number = 5026;
	CnSSLAdvice subclassOf CnAdvice transient, transientAllowed, subclassTransientAllowed, highestSubId = 1, highestOrdinal = 13, number = 2827;
	CnSessionAdvice subclassOf CnAdvice abstract, transient, subclassTransientAllowed, highestOrdinal = 24, number = 2058;
	CnSchemaCopyCompleteAdvice subclassOf CnSessionAdvice transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 3, number = 2059;
	CnSessionCloseAdvice subclassOf CnSessionAdvice transient, transientAllowed, subclassTransientAllowed, number = 2060;
	CnSessionOpenAdvice subclassOf CnSessionAdvice transient, transientAllowed, subclassTransientAllowed, highestSubId = 8, highestOrdinal = 73, number = 2061;
	CnStatisticsAdvice subclassOf CnAdvice transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 4, number = 2375;
	CnThreadAdvice subclassOf CnAdvice transient, transientAllowed, subclassTransientAllowed, highestSubId = 4, highestOrdinal = 10, number = 2298;
	CnTrapAdvice subclassOf CnAdvice transient, transientAllowed, subclassTransientAllowed, highestSubId = 4, highestOrdinal = 9, number = 2431;
	CnWatchAdvice subclassOf CnAdvice transient, transientAllowed, subclassTransientAllowed, highestSubId = 5, highestOrdinal = 9, number = 2299;
	CnCommand subclassOf CnMessage transient, transientAllowed, subclassTransientAllowed, number = 2062;
	CnBackupCmd subclassOf CnCommand transient, transientAllowed, subclassTransientAllowed, highestSubId = 3, highestOrdinal = 11, number = 2527;
	CnCompactCmd subclassOf CnCommand transient, transientAllowed, subclassTransientAllowed, highestSubId = 2, highestOrdinal = 7, number = 6697;
	CnControlCmd subclassOf CnCommand transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 11, number = 2228;
	CnExecuteCmd subclassOf CnCommand transient, transientAllowed, subclassTransientAllowed, highestSubId = 1, highestOrdinal = 5, number = 4225;
	CnPingCmd subclassOf CnCommand transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 2, number = 2063;
	CnProcCmd subclassOf CnCommand transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 2, number = 2303;
	CnSDSCmd subclassOf CnCommand transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 3, number = 5027;
	CnSchemaCopyCmd subclassOf CnCommand transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 12, number = 2064;
	CnThreadCmd subclassOf CnCommand transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 2, number = 2304;
	CnPersistentDb subclassOf Object abstract, number = 2482;
	CnLockTarget subclassOf CnPersistentDb highestOrdinal = 4, number = 2563;
	CnRoot subclassOf CnPersistentDb highestSubId = 3, highestOrdinal = 12, number = 2483;
	CnSDSStructureState subclassOf CnPersistentDb highestOrdinal = 5, number = 3216;
	CnProcess subclassOf Object transient, highestSubId = 3, highestOrdinal = 17, number = 2066;
	CnSmtpState subclassOf Object abstract, transient, number = 2275;
	CnSmtpStateAUTH subclassOf CnSmtpState transient, number = 4626;
	CnSmtpStateDATA subclassOf CnSmtpState transient, number = 2276;
	CnSmtpStateDATASent subclassOf CnSmtpState transient, number = 2277;
	CnSmtpStateHELO subclassOf CnSmtpState transient, number = 2278;
	CnSmtpStateMAIL subclassOf CnSmtpState transient, number = 2279;
	CnSmtpStateNOOP subclassOf CnSmtpState transient, number = 2280;
	CnSmtpStateQUIT subclassOf CnSmtpState transient, number = 2281;
	CnSmtpStateRCPT subclassOf CnSmtpState transient, number = 2282;
	CnSmtpStateRSET subclassOf CnSmtpState transient, number = 2283;
	CnSmtpStateTCPConnected subclassOf CnSmtpState transient, number = 2284;
	CnSmtpStateTCPDisconnected subclassOf CnSmtpState transient, number = 2339;
	CnStackDump subclassOf Object transient, highestSubId = 2, highestOrdinal = 8, number = 2292;
	CnTransientDb subclassOf Object abstract, transient, number = 4898;
	CnAgents subclassOf CnTransientDb abstract, transient, number = 7234;
	CnFunctionAgent subclassOf CnAgents transient, final, transientAllowed, number = 7235;
	CnIniFileAgent subclassOf CnAgents transient, highestOrdinal = 1, number = 20499;
	CnProfilingAgent subclassOf CnAgents transient, final, transientAllowed, number = 7236;
	CnTransactionAgent subclassOf CnAgents number = 2113;
	CnValidateMethodAgent subclassOf CnAgents transient, highestSubId = 1, highestOrdinal = 4, number = 2251;
	CnBackup subclassOf CnTransientDb transient, highestSubId = 6, highestOrdinal = 19, number = 2894;
	CnDatabaseStructure subclassOf CnTransientDb transient, sharedTransientAllowed, transientAllowed, subclassTransientAllowed, highestOrdinal = 9, number = 7237;
	CnExternalMethods subclassOf CnTransientDb transient, final, transientAllowed, number = 2507;
	CnIpAddress subclassOf CnTransientDb transient, highestOrdinal = 1, number = 2114;
	CnJadeSystemClasses subclassOf CnTransientDb abstract, transient, highestOrdinal = 1, number = 6701;
	CnJadeApplication subclassOf CnJadeSystemClasses transient, final, transientAllowed, highestSubId = 1, highestOrdinal = 6, number = 6704;
	CnJadeNode subclassOf CnJadeSystemClasses transient, highestSubId = 1, highestOrdinal = 10, number = 6707;
	CnJadeProcess subclassOf CnJadeSystemClasses transient, highestOrdinal = 16, number = 6708;
	CnJadeTestCaseListenerIf subclassOf CnTransientDb transient, transientAllowed, subclassTransientAllowed, highestSubId = 5, highestOrdinal = 13, number = 8520;
	CnLockCheck subclassOf CnTransientDb transient, highestSubId = 1, highestOrdinal = 7, number = 8521;
	CnLocks subclassOf CnTransientDb abstract, transient, number = 7238;
	CnKCLockCheck subclassOf CnLocks transient, number = 8522;
	CnKCNodeControl subclassOf CnLocks transient, sharedTransientAllowed, subclassSharedTransientAllowed, number = 7239;
	CnKCSDSChecks subclassOf CnLocks transient, sharedTransientAllowed, subclassSharedTransientAllowed, number = 5762;
	CnKCStatsCollector subclassOf CnLocks transient, number = 4387;
	CnKCVerifyJournal subclassOf CnLocks transient, number = 4101;
	CnThinClientConnBalancing subclassOf CnLocks transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, number = 8523;
	CnManagerClass subclassOf CnTransientDb abstract, transient, number = 6845;
	CnBatchMgr subclassOf CnManagerClass transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, highestSubId = 2, highestOrdinal = 7, number = 7240;
	CnJadeCareExecutor subclassOf CnManagerClass transient, highestOrdinal = 4, number = 4228;
	CnSecurityManager subclassOf CnManagerClass transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, number = 2912;
	CnStartManager subclassOf CnManagerClass transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, number = 6847;
	CnNameSizeInfo subclassOf CnTransientDb transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, highestOrdinal = 6, number = 2913;
	CnQueuedLockDepth subclassOf CnTransientDb transient, subschemaHidden, final, transientAllowed, highestOrdinal = 2, number = 5267;
	CnSchemaElement subclassOf CnTransientDb transient, final, transientAllowed, highestOrdinal = 9, number = 7241;
	CnVariant subclassOf Object transient, highestOrdinal = 3, number = 2125;
	CnNamedPipe subclassOf NamedPipe transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, highestOrdinal = 6, number = 2762;
	CnDeployMgrTcpConnection subclassOf TcpIpConnection transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, highestOrdinal = 5, number = 5028;
	CnTcpConnection subclassOf TcpIpConnection transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, highestOrdinal = 15, number = 2067;
	CnKarmaTcpConnection subclassOf CnTcpConnection transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, highestOrdinal = 3, number = 2068;
	CnSmtpConnection subclassOf CnTcpConnection transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, highestSubId = 11, highestOrdinal = 68, number = 2344;
	CnLdapException subclassOf NormalException transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, number = 2461;
	CnSmtpConnectionException subclassOf NormalException transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, highestOrdinal = 1, number = 2358;
	CnFile subclassOf File transient, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, highestOrdinal = 1, number = 3225;
	GCardSchema subclassOf RootSchemaGlobal transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, highestSubId = 1, number = 2069;
	CnJadeDatabaseAdmin subclassOf JadeDatabaseAdmin transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, highestSubId = 1, highestOrdinal = 6, number = 2072;
	CnJadeDatabaseAdminExternal subclassOf JadeDatabaseAdmin transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, number = 5029;
	CnSDSDatabaseAdmin subclassOf JadeDatabaseAdmin transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, highestSubId = 4, highestOrdinal = 34, number = 5030;
	CnJadeDynamicObject subclassOf JadeDynamicObject transient, number = 4213;
	CnSchemaSession subclassOf RootSchemaSession transient, number = 2150;
	CnToolBarPicture subclassOf Picture transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, highestOrdinal = 1, number = 2151;
	CnConnectionForm subclassOf Form transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 11, number = 8524;
	CnDumpForm subclassOf Form transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 12, number = 2119;
	CnExceptionForm subclassOf Form transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 17, number = 2100;
	CnForm subclassOf Form transient, transientAllowed, subclassTransientAllowed, number = 2070;
	CnKCGui subclassOf CnForm transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 2, number = 2115;
	CnKCGuiTimer subclassOf CnForm transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 2, number = 4066;
	CnTransferProgress subclassOf CnForm transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 12, number = 2148;
	KCMLoading subclassOf CnForm transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 7, number = 2071;
	CnLogOptions subclassOf Form transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 19, number = 2074;
	CnMsgForm subclassOf Form transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 9, number = 2229;
	CnPrinterForm subclassOf Form transient, transientAllowed, subclassTransientAllowed, number = 2794;
	CnSchemaAnalysisOutputForm subclassOf CnPrinterForm transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 10, number = 2795;
	CnProgressDialog subclassOf Form transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 6, number = 2924;
	CnWebAppError subclassOf Form transient, transientAllowed, subclassTransientAllowed, highestOrdinal = 11, number = 2158;
	CnAppDict subclassOf MemberKeyDictionary maxLogicalBlockSize = 58, loadFactor = 66, transient, number = 2075;
	CnDatabaseStructureByNameDict subclassOf MemberKeyDictionary loadFactor = 66, transient, transientAllowed, subclassTransientAllowed, objectVolatility="stable", number = 7244;
	CnDatabaseStructureBySizeDict subclassOf MemberKeyDictionary loadFactor = 66, transient, subclassTransientAllowed, objectVolatility="stable", number = 7245;
	CnJadeApplicationDict subclassOf MemberKeyDictionary loadFactor = 66, transient, final, transientAllowed, number = 6709;
	CnJadeNodeDict subclassOf MemberKeyDictionary loadFactor = 66, transient, final, transientAllowed, number = 6710;
	CnJadeProcessDict subclassOf MemberKeyDictionary loadFactor = 66, transient, final, transientAllowed, number = 6711;
	CnLdapAttributeDict subclassOf MemberKeyDictionary duplicatesAllowed, maxLogicalBlockSize = 32, transient, number = 2462;
	CnLockTargetDict subclassOf MemberKeyDictionary maxLogicalBlockSize = 33, number = 2565;
	CnMachineDict subclassOf MemberKeyDictionary maxLogicalBlockSize = 32, loadFactor = 66, transient, number = 2076;
	CnNameSizeInfoByNameDict subclassOf MemberKeyDictionary loadFactor = 66, transient, number = 4103;
	CnNameSizeInfoBySizeDict subclassOf MemberKeyDictionary duplicatesAllowed, loadFactor = 66, number = 3119;
	CnProcessDict subclassOf MemberKeyDictionary maxLogicalBlockSize = 171, loadFactor = 66, transient, number = 2077;
	CnSDSStructureStateDict subclassOf MemberKeyDictionary loadFactor = 66, number = 3272;
	CnSchemaElementDict subclassOf MemberKeyDictionary duplicatesAllowed, loadFactor = 66, number = 7246;
	CnTcpClientDict subclassOf MemberKeyDictionary maxLogicalBlockSize = 16, transient, number = 2078;
	CnTcpConnectionDict subclassOf MemberKeyDictionary maxLogicalBlockSize = 133, transient, number = 2079;
	CnProcessSet subclassOf Set transient, number = 2766;
	CnBinaryArray subclassOf BinaryArray loadFactor = 66, transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, number = 2994;
	CnStatisticsSampleBinaryArray subclassOf BinaryArray maxLogicalBlockSize = 128, blockSize = 20, loadFactor = 66, transient, sharedTransientAllowed, transientAllowed, subclassSharedTransientAllowed, subclassTransientAllowed, number = 4679;
	CnStatsBinaryArray subclassOf BinaryArray loadFactor = 66, transient, number = 4745;
	CnHugeStringArray2D subclassOf Array loadFactor = 66, number = 2191;
	CnLdapBinaryArray subclassOf Array transient, number = 2463;
	CnLdapEntryArray subclassOf Array transient, number = 2464;
	CnSmallStringArray2D subclassOf Array loadFactor = 66, transient, number = 4067;
	CnStringArray2D subclassOf Array loadFactor = 66, number = 2193;
	CnDecimalArray subclassOf DecimalArray transient, number = 2526;
	CnAttachmentArray subclassOf ObjectArray transient, number = 2541;
	CnBooleanArrayArray subclassOf ObjectArray transient, number = 2603;
	CnClassArray subclassOf ObjectArray loadFactor = 66, number = 7247;
	CnDatabaseStructureArray subclassOf ObjectArray loadFactor = 66, transient, number = 7248;
	CnJadeDynamicObjectArray subclassOf ObjectArray loadFactor = 66, transient, number = 4513;
	CnNameSizeInfoArray subclassOf ObjectArray loadFactor = 66, number = 3873;
	CnNodeControlCnCntrlArray subclassOf ObjectArray loadFactor = 66, number = 7249;
	CnSmtpInlineArray subclassOf ObjectArray transient, number = 2543;
	CnStringArrayArray subclassOf ObjectArray transient, number = 2602;
	CnVariantArray subclassOf ObjectArray transient, number = 2172;
	CnLargeStringArray subclassOf StringArray loadFactor = 66, transient, number = 4724;
	CnSmallStringArray subclassOf StringArray maxLogicalBlockSize = 66, transient, number = 2525;
	CnStringArray subclassOf StringArray maxLogicalBlockSize = 7, transient, number = 2175;
	CnTransactionIdArray subclassOf StringArray loadFactor = 66, transient, number = 4746;
membershipDefinitions
	CnAppDict of CnApp;
	CnDatabaseStructureByNameDict of CnDatabaseStructure;
	CnDatabaseStructureBySizeDict of CnDatabaseStructure;
	CnJadeApplicationDict of CnJadeApplication;
	CnJadeNodeDict of CnJadeNode;
	CnJadeProcessDict of CnJadeProcess;
	CnLdapAttributeDict of CnLdapAttribute;
	CnLockTargetDict of CnLockTarget;
	CnMachineDict of CnMachine;
	CnNameSizeInfoByNameDict of CnNameSizeInfo;
	CnNameSizeInfoBySizeDict of CnNameSizeInfo;
	CnProcessDict of CnProcess;
	CnSDSStructureStateDict of CnSDSStructureState;
	CnSchemaElementDict of CnSchemaElement;
	CnTcpClientDict of CnTcpConnection;
	CnTcpConnectionDict of CnTcpConnection;
	CnProcessSet of Process;
	CnBinaryArray of Binary [256];
	CnStatisticsSampleBinaryArray of Binary [588];
	CnStatsBinaryArray of Binary [450];
	CnHugeStringArray2D of HugeStringArray;
	CnLdapBinaryArray of CnLdapBinary;
	CnLdapEntryArray of CnLdapEntry;
	CnSmallStringArray2D of CnSmallStringArray;
	CnStringArray2D of CnStringArray;
	CnDecimalArray of Decimal [19];
	CnAttachmentArray of CnAttachment;
	CnBooleanArrayArray of BooleanArray;
	CnClassArray of Class;
	CnDatabaseStructureArray of CnDatabaseStructure;
	CnJadeDynamicObjectArray of CnJadeDynamicObject;
	CnNameSizeInfoArray of CnNameSizeInfo;
	CnNodeControlCnCntrlArray of CnNodeControlCnCntrl;
	CnSmtpInlineArray of CnSmtpInline;
	CnStringArrayArray of CnStringArray;
	CnVariantArray of CnVariant;
	CnLargeStringArray of String [1001];
	CnSmallStringArray of String [31];
	CnStringArray of String [261];
	CnTransactionIdArray of String [203];
typeDefinitions
	JadeDotNetType completeDefinition
	(
	)
	Object completeDefinition
	(
	constantDefinitions
		TranStats_Debug:               Boolean = false number = 1001;
	jadeMethodDefinitions
		cnAnsiBinary(str: String): Binary number = 1005;
		cnCheckEdition() number = 1001;
		cnCheckTransactionStack(
			inTag: Integer; 
			callingMethodName: String; 
			checkLast: Boolean): Integer protected, number = 1013;
		cnDiscardTransaction(tag: Integer) number = 1014;
		cnEndTransaction() number = 1002;
		cnEndTransactionEx(inTag: Integer) number = 1010;
		cnGetInstanceId(obj: Object): Integer number = 1003;
		cnGetInstanceId64(pObject: Object): Integer64 number = 1029;
		cnGetIntegerConstantName(
			category: String; 
			value: Integer; 
			isEventType: Boolean): String number = 1007;
		cnResumeTransaction() clientExecution, number = 1015;
		cnSetTransactionError(currentTransactionOnly: Boolean) number = 1006;
		cnStartTransaction(id: String): Integer number = 1004;
		cnSuspendTransaction() clientExecution, number = 1012;
		zCnDeimplementationWarning(
			pMethod: Method; 
			pRelease: String) protected, number = 1068;
		zCnDumpTransactionStack() protected, number = 1090;
		zCnLogTransactionEntry(
			pMethod: Method; 
			pTran: String; 
			pMsg: String) protected, number = 1091;
		zCnReimplementationRequired(pMethod: Method) protected, number = 1009;
		zCnToBeCoded(pMethod: Method) protected, number = 1031;
	externalMethodDefinitions
		emUnicodeToAnsi(str: String): Binary is "emUnicodeToAnsi" in "karma" number = 1008;
	)
	A_VersionClass completeDefinition
	(
	constantDefinitions
		CardSchema_Version:            String = "4.1.02.007" number = 1001;
		documentationText
`
-----------------------------------  Reserved Event Numbers ------------------------------------
|																							   | 
|	Note that JADECare Start (CardSchema) reserves the use of event numbers in the range 	   |
|	from 55000101 thru 55000299 for notifications on JADE environmental classes such as  	   | 
|	System, Node, Process etc. 																   |
|																							   |
|	The use of this event number range should be avoided by developers of applications that    |
|   use this schema.  Refer to the JADECare Start User Guide for further information.          |
|																							   |
------------------------------------------------------------------------------------------------

											HISTORY
											=======
Version				Comments																							By / Date
-------				--------																							---------
4.1.02		Sources forked.																								03Jul21

			Cut UAT and qualification candidate 4.1.02.000																05May22
			
			Cut UAT and qualification candidate 4.1.02.001																05May22
			
			PAR 1108. Transient info and Transient Analysis fail with UE 1090.
			
			Cut 4.1.02.002 containing PAR 1108.																			07Jul22
			
			PAR 1109. Start of RPS backup took over 20 minutes to respond back to JSM
			
			J PAR 8347. CheckForUpdates can prematurely attempt to install and reboot host while WUA is busy.
			
			Cut 4.1.02.003 containings PARs 1109, J 8347.																09Aug22
			
			PAR 1110. When journal verify fails, the alert generated recommends an OFFLINE backup, should be escalated.
			
			PAR 1111. When KCVerifyJournal detects an error in a journal then add the scan file text to alert
			
			Cut 4.1.02.004 containing PARs 1110, 1111.																	16Aug22
			
			JSM PAR 8373. Provide a way to exclude Windows update categories from automatic installation.
			
			JSM PAR 8376. Add a new notification to cnwIUpdateInstaller.dll for INSTALLATION_DOWNLOAD_COMPLETE
			
			Cut 4.1.02.005 containing JSM PAR 8373, JSM PAR 8376.														06Sep22
			
			Tracker PAR 1097. UE 1413 in app ScmSchema::ScmGUI ScmFormCallTableUser::tblCalls_mouseHover (880)
			
			HF 4.1.02.006 containing Tracker PAR 1097.																	21Sep22
			
			JSM PAR 8428. Display a 'Interrupted' state for both the Activity Log and WU Advice Summary form.
			
			Cut 4.1.02.007 containing JSM PAR 8428																		19Oct22			

4.1.01		Sources forked.																								22Dec20

			Cut UAT/Qual candidate 4.1.01.000.																			05May21
			
			PAR 1092. Exception incurred executing "action=suspend_appservermonitor" in KCBatch
			
			Production candidate 4.1.01.001																				19May21
			
			JSM PAR 8090. Migration file copies need to allow for retry rather than immediate fail
			
			HF 4.1.01.002 containing JSM PAR 8090, PAR 1093 (see 4.0.01 below) and 1077 (refer to 4.0.02 below).		05Jul21
			
			JSM PAR 8184. Develop a Webhook Endpoint for JSM monitoring using REST services.
			
			HF 4.1.01.003 containing JSM PAR 8184, PAR 1098 (see 4.0.01 below)											12Oct21
			
			PAR 1103. PARs 1087 and 1089 patches not rolled forward from 3.9.03 (see below).
			
			PAR 1104. UE 1011 around period of SDS takeover
			
			PAR 1102. UE 3201 (SDS not initialized) in application KCCMgr on SDS takeover
			
			HF 4.1.01.004 containing PAR 1103, 1104 and 1102.															29Nov21
			
			PAR 1100. 4031 Exception in CardSchema::CnMessage::getField (236) may prevent backup completion
			
			HF 4.1.01.005 containing PAR 1100.																			09Dec21	
			
			HF 4.1.01.006 containing PAR 1106 (see 4.0.03 below)														25Jan21

=================================================================================================================================
4.0.03		Sources forked.																								20Mar20

			PAR 1081. Add logging to record when extended lock exists but process has registered as disable lock check
			
			PAR 1083. JADE 2020 is to deprecate some application types, review application types
			
			Production candidate 4.0.03.001																				10Dec20
			
			PAR 1091. Extended lock check MaxLocksRequested value of zero anomaly
			
			HF 4.0.03.002 containing PAR 1091.																			24Mar21
			
			HF 4.0.03.003 containing PAR 1089 (refer to 3.9.03 below).													15Apr21
			
			HF 4.0.03.003 containing PAR 1093 (see 4.0.01 below) and 1077 (refer to 4.0.02 below).						05Jul21
			
			HF 4.0.03.004 containing PAR 1093 (see 4.0.01 below) and 1077 (refer to 4.0.02 below).						05Jul21
			
			PAR 1104. UE 1011 around period of SDS takeover
			
			PAR 1102. UE 3201 (SDS not initialized) in application KCCMgr on SDS takeover
			
			HF 4.0.03.005 containing PARs 1102, 1104																	26Nov21
			
			PAR 1106. KCCheckConnection UE 1006 when clicking Copy button
			
			HF 4.0.03.006 containing PAR 1106																			25Jan22
			
4.0.02		Sources forked.																								17Jun19

			JSM PAR 7586. Increase JADE Environment name length for JADECare Managed environments
			
			PAR 1043. Provide ability to determine if the server or workstation is executing a specific Windows process
			
			PAR 1044. Provide ini file option to log the SMTP server responses even when [SMTPClient] Logging=false
			
			PAR 1045. KCCMgr ping request during takeover results in spurious alert 'SDS has not initialized'
			
			PAR 1048. Provide the ability to 'resetUserAppliedPatches' via KCBatch command line
			
			JSM PAR 7671. Provide ability for JSM to open listening socket to JSA on a specific interface
			
			Cut UAT/Qual candidate																						14Feb20
			
			HF 4.0.02.001 containing PAR 1059 (refer to 3.9.03 below)													24Feb20
			
			PAR 1060. jadclient running singleUser causes KCCMgr to start up preventing jadclient from terminating
			
			HF 4.0.02.002 containing PAR 1060.																			28Feb20
			
			Production candidate 4.0.02.002																				28Feb20
			
			PAR 448. Stack dump methods dumpObjVars and dumpArray don't dump oids of collections
			
			Production candidate 4.0.02.003																				17Mar20
			
			PAR 1063. Add thin-client AppServer and AppServerPort details to KCCheckConnection form
			
			HF 4.0.02.004 containing PARs 1063 and 1065 (refer to 3.9.03 below).										17Apr20
			
			HF 4.0.02.005 containing PAR 1066 (refer to 3.9.03 below).													28Apr20
			
			HF 4.0.02.006 containing PAR 1072 (refer to 3.8.03 below).													28May20
			
			HF 4.0.02.007 containing PAR 1075 (refer to 3.9.03 below).													20Jul20
			
			JSM PAR 7858. Changes to deployment/restore methodology to ignore appsettings.json file
			add Method String::cnIsBoolean
			
			JSM PAR 7815. Alert History form 'copy selected' still copies entire content of listbox
			
			PAR 1078. Deadlock exception method return Ex_Pass_Back if receiver is WebSessionManager orJadeWebAppExtension
						
			HF 4.0.02.008 containing JSM PARs 7858, 7815 and PAR 1078.													19Aug20
			
			HF 4.0.02.009 containing PAR 1079 (see 3.8.10 below)														14Sep20
			
			HF 4.0.02.010 containing PAR 1080 (see 3.8.03 below).														28Sep20
			
			HF 4.0.02.012 containing PAR 1087 (see 3.9.03 below).														08Dec20

4.0.01		Sources forked.																								06Dec18

			PAR 1016. KCOnlineBackup left running after unhandled exception, interferes with subsequent backups
			
			PAR 1019. Backfitted to 3.9.03 (see below).
			
			PAR 1021. Provide facility to generate RPS creation scripts
			
			PAR 1022. Provide facility to extract data from RPS node for loading into SQL database
			
			PAR 1030. Method Any cnGetType does not handle some primitive types
			
			PAR 1031. Error in TCP header alert does not identify the server concerned.
			
			PAR 1032. Sometimes cn_jade_development_activity.csv file details do not align with columns headings
			
			PAR 1034. It would be useful if the app.appVersion details could be included on the CnExceptionForm caption
			
			Cut UAT candidate 4.0.01.000																				31May19
			
			PAR 1038. Message from KCDatabaseBackupMulti causes KCCMgr exception 4031 CnMessage::getField (236)
			
			PAR 1036. UE 3124 in KCOnlineBackup, leaves KCOnlineBackup running
			
			Cut UAT candidate 4.0.01.001																				06Jun19
			
			Cut UAR candidate 4.0.01.002																				23Jun19
			
			Cut Production Candidate 4.0.01.003																			28Jun19
			
			Cut Production candidate 4.0.01.004																			30Jul19
			
			HF 4.0.01.005 containing PAR 1046 (see 3.9.03 below)														22Oct19
			
			HF 4.0.01.006 containing PAR 1050 (see 3.9.03 below)														09Dec19
			
			HF 4.0.01.007 containing PAR 1052 (see 3.9.03 below)														10Dec19
			
			HF 4.0.01.008 containing PAR 1053 (refer to 3.7.05 below)													18Dec19
			
			HF 4.0.01.009 containing PAR 1059 (refer to 3.9.03 below)													24Feb20
			
			HF 4.0.01.010 containing PAR 1062 (refer to 3.8.03 below).													10Mar20
			
			HF 4.0.01.011 containing PAR 1065 (refer to 3.9.03 below).													17Apr20
			
			HF 4.0.01.012 containing PAR 1066 (refer to 3.9.03 below).													28Apr20
			
			HF 4.0.01.013 containing PAR 1089 (refer to 3.9.03 below).													15Apr21
			
			PAR 1093. 'relationDatabaseName' parameter for KCBatch action generateRpsTableCreationScript is "unknown"
			
			HF 4.0.01.014 containing PAR 1093.																			05Jul21
			
			PAR 1098. RPS mapped extent database backup fails
			
			HF 4.0.01.015 containing PAR 1098.																			12Oct21
			
3.9.03		Sources forked.																								21Sep18

			JSM PAR 7040. Convert extended lock alerts to Tracker calls rather than alert
			
			PAR 1012. action=analyzeTransients invokes Process.analyzeTransientFileUsage, s/be sendTransientFileAnalysis
			
			PAR 1013. Add diagnostics to intrumented transactions to identify possible JadeDynamicObject leak
			
			PAR 1014. Provide ability to compact a given process transient file
			
			PAR 1003. Enhance Extended Lock Checks to cater for SDS Secondary and other and suppress while takeover
			occurs
			
			JSM PAR 7050. Obtain the encryption status of map files where the database has encryption specified
			
			UAT candidate 3.9.03.000																					22Nov18
			
			Production candidate 3.9.03.001.																			06Dec18
			
			HF 3.9.03.002 containing PAR 1025 (see 3.9.01 below).														15Mar19
			
			PAR 1035. Exception 1163 unable to deactivate delta mode as KCSDSCheck holding persistent lock
			
			HF 3.9.03.003 containing PAR 1035.																			29May19

			PAR 1019. UE 3162 when KCCMgr starts up when accessing DbFile _rpstrans
			
			HF 3.9.03.004 containing PAR 1019.																			30May19
			
			PAR 1046. KCSDSChecks is repeatedly being started and then terminating
			
			HF 3.9.03.005 containing PAR 1046.																			22Oct19
			
			PAR 1050. KCCMgr not always updating master environment id for application SESSOPEN
			
			HF 3.9.03.006 containing PAR 1050.																			09Dec19
			
			PAR 1052. UE 1090 occurs after actual online compaction has completed
			
			HF 3.9.03.007 containing PAR 1052.																			10Dec19
			
			HF 3.9.03.008 containing PAR 1053 (refer to 3.7.05 below)													18Dec19
			
			PAR 1059. SDS checks alerts not being cleared until check interval passed
			
			HF 3.9.03.009 containing PAR 1059																			24Feb20
			
			HF 3.9.03.010 containing PAR 1062 (refer to 3.8.03 below).													10Mar20
			
			PAR 1065. UE 1163 - uanble to change delta database mode because not all processes are idle (KCSDSChecks)
			
			HF 3.9.03.011 containing PAR 1065.																			17Apr20
			
			PAR 1066. KCVerifyJournal being started on each journal switch after deploy of HF 3.9.03.011
			
			HF 3.9.03.012 containing PAR 1066.																			28Apr20
			
			HF 3.9.03.013 containing PAR 1072 (refer to 3.8.03 below).													28May20
			
			PAR 1075. Some database structures that are encrypted do not show as such in extract file and JSM
			
			HF 3.9.03.014 containing PAR 1075.																			20Jul20
			
			HF 3.9.03.015 containing PAR 1079 (see 3.8.10 below).														14Sep20
			
			HF 3.9.03.016 containing PAR 1090 (see 3.8.03 below).														28Sep20
			
			PAR 1087. When only one backup worker fails to start, no alert is issued
			
			HF 3.9.03.017 containing PAR 1087.																			08Dec20
			
3.9.02		Sources forked.																								21May18

			PAR 1007. UE 3059 during initiation of KCSDSChecks on SDS Secondary
			
			PAR 996. Provide batch facility to create RPS database from SDS Primary
			
			Cut UAT candidate release 3.9.02.000																		22Aug18
			
			JSM PAR 7180. Delete of Machine entity issues incorrect warning message
			
			Cut production candidate release 3.9.02.001																	03Oct18
			
			PAR 1014. Provide ability to compact a given process transient file
			
			HF 3.9.02.002 containing PAR 1014.																			17Oct18
			
			PAR 1015. Provide method on Integer to convert to formatted version m.r.cc.ppp
			
			HF 3.9.02.003 containing PAR 1015.																			07Nov18
			
			HF 3.9.02.004 containing PAR 1025 (see 3.9.01 below).														15Mar19

3.9.01		Sources forked.																								18Apr18

			Cut production candidate release 3.9.01.001 to support JADE 2016 SP 1 (16.0.02)								18Apr18
			
			PAR 1001. Stack dump exception form does not allow Esc key to close form
			
			Cut production candidate release 3.9.01.002 to support JSM/JSA 3.9.01.										16May18
			
			HF 3.9.01.002 containing PAR 1001, 1004 (see 3.7.04 below).													15Jun18
			
			PAR 1025. BACKUP FAILED : #1 Backup is invalid, post-backup-commit check has identified structure ~
			
			HF 3.9.01.003 containing PAR 1025.																			15Mar19

3.8.10		Sources forked.																								04Dec17

			PAR 883. Refer to release 3.8.03 below.
			
			PAR 988. Refer to release 3.8.03 below.
			
			Cut production release candidate 3.8.10.000																	23Jan18
			
			PAR 992. Process license stats showing negative with DR takeover
			
			Cut production release candidate 3.8.10.002																	21Feb18
			
			JSM PAR 6830. backup/deploy to detect database in reorg state.
			
			Cut production release candidate 3.8.10.003																	11Apr18
			
			PAR 1014. Provide ability to compact a given process transient file
			
			HF 3.8.10.004 containing PAR 1014.																			17Oct18
			
			HF 3.8.10.005 containing PAR 1053 (refer to 3.7.05 below)													18Dec19
			
			HF 3.8.10.006 containing PAR 1062 (refer to 3.8.03 below).													10Mar20
			
			HF 3.8.10.007 containing PAR 1072 (refer to 3.8.03 below).													28May20
			
			PAR 1075. Some database structures that are encrypted do not show as such in extract file and JSM
			
			HF 3.8.10.008 containing PAR 1075.																			20Jul20
			
			PAR 1075. Some database structures that are encrypted do not show as such in extract file and JSM

			PAR 1079. Provide jadloadb executable method to return abort journal number
			
			HF 3.8.10.008 containing PAR 1075 and 1079.																	14Sep20
			
			HF 3.8.10.016 containing PAR 1080 (see 3.8.10 below).														28Sep20

3.8.09		Sources forked.																								06Oct17

			PAR 977. Move transaction stats handling and extended lock checks out of KCCMgr as queuing is occuring.
			
			PAR 981. Deadlock global exception handler retry should have randomised sleep time to avoid repeat deadlock
			
			PAR 982. Global Deadlock retry mechanism will get 1035 UE if the executing method name is longer than 30 char
			
			Cut UAT release candidate 3.8.09.000																		14Nov17
			
			PAR 983. Refer to release 3.8.03 below.
			
			PAR 923. KCDatabaseBackupMulti command line invocation could be more flexible about parameters passed
			
			Cut production release candidate 3.8.09.001																	04Dec17
			
			Cut production release candidate 3.8.09.002																	05Dec17
			
			Cut production release candidate 3.8.09.003	(containing PAR 986, refer 3.8.03 below)						09Jan18
			
			PAR 883. Refer 3.8.03 below.
			
			PAR 988. Refer 3.8.03 below.
			
			HF 3.8.09.004 containing PARs 883 and 988.																	23Jan18
						
3.8.08		Sources forked.																								21Aug17

			PAR 976. Transaction stats appear to cater for 202 bytes but cnStartTransaction gets exception if gtr 62
			
			PAR 877. CardSchema - Stack dump doesn't mention interface usage
			
			PAR 964. SDS Primary checks can cause 60 sec timeout, implement KCSDSChecks
			
			PAR 979. UE 1013 in method CardSchema::CardSchema::cnShowExceptionWebForm (708)
			
			PAR 980. Add recording of the server details of JADE node in CardSchema instrumented transactions
			
			Cut UAT release candidate 3.8.08.000																		06Oct17
			
			Cut production release candidate 3.8.08.001																	17Oct17
			
3.8.07		Sources forked.																								14Jun17

			PAR 969. Enhance CnExceptionForm to show exception call stack and source pos + copy&paste
			
			Cut UAT release candidate 3.8.07.000																		14Aug17
			
			Add property CnCntrl.testMode for use with AppServerMonitor (for use by Qual group)
			
			Cut production release candidate 3.8.07.002																	06Sep17

3.8.06		Sources forked.																								04Jan17

			Cut UAT release candidate 3.8.06.000																		30May17
			
			Cut production release candidate 3.8.06.001																	03Jul17
			
			PAR 973. Remove the 30byte size limit for Ftp and Http usercode/password
			
			PAR 959. cnGlobalLockExceptionHandler logs wrong Jade process id and application name for lock owner
			
			Cut production release candidate 3.8.06.002																	17Jul17
			
			HF 3.8.06.003 containing PAR 974, 975 (refer to 3.7.03 below)												09Aug17

3.8.05		Sources forked.																								09Dec16

			PAR 957. Incorrect method position logged in exception output to cn_log file
			
			PAR 958. SDS Alerting not advising that a secondary has disconnected.
			
			Cut final candidate 3.8.05.001																				14Feb17
			
			HF 3.8.05.002 containing PAR 963 (refer to 3.5.04 below).													02Jun17
			
			HF 3.8.05.003 containing PAR 970 (refer to 3.8.03 below).													14Jul17
			
			HF 3.8.05.004 containing PAR 974, 975 (refer to 3.7.03 below)												09Aug17
			
3.8.04		Sources forked.																								22Aug16

			JSM NFS 5970. Modify KCVerifyJournal to look for journal (compressed or not) in current and
			archive directories.
			
			UAT Candidate cut 3.8.04.000																				08Dec16

3.8.03		Sources forked.																								30Dec15

			NFS 919. Online deployment caused extended lock alerts on meta-schema items
			
			PAR 927. Exception 4013 (Result of expression overflows Integer precision) in CnHttp64::cnGetFileInfo
			
			PAR 928. CnHttp::cnGetFileInfo Exception 4013 (Result of expression overflows Integer precision)
			
			NFS 932. SMTP modified to cater for:
						- extra character sets UTF-8 and ISO-8859-1
						- encoding type of Quoted-Printable
						- subject encoded and encapsulated to cater for 2 bytes character sets
						
			Qualification cut 3.8.03.000.																				08Jul16
			
			PAR 938. online compaction duration error
			
			PAR 940. Refer to 3.6.01 below.
			
			Qualification cut 3.8.03.001.																				29Jul16
			
			PAR 942. SMTP states 530 and 534 not handled leaving connection open
			
			PAR 944. KCNodeControl is holding up jadclient.exe node
			
			UAT cut 3.8.03.002.																							15Aug16
			
			Final candidate cut 3.8.03.003.																				24Aug16
			
			PAR 948. App Server crash in Karma dll
			
			HF 3.8.03.005 containg PAR 948 (binaries)																	30Sep16
			
			PAR 954. thinclient karma.dll is being changed to karma.dll.bad as appserver looking for \download\c_bin
			
			HF 3.8.03.006 containing PAR 954.																			09Dec16
			
			HF 3.8.03.008 containing PAR 963 (refer to 3.5.04 below).													02Jun17
			
			PAR 970. FTP close connection does not close the session
			
			HF 3.8.03.009 containing PAR 970.																			14Jul17
			
			HF 3.8.03.010 containing PAR 974, 975 (refer to 3.7.03 below)												09Aug17
			
			PAR 983. Modify the FTP connect to use emFtpConnectEx2 and allow port number to be specified
			
			HF 3.8.03.011 containing PAR 983.																			15Nov17
			
			PAR 986. Background process terminated unexpectedly, process dump stack was karma.dll
			
			HF 3.8.03.012 containing PAR 986																			09Jan18
			
			PAR 883. Rename an application after activateKarmaControl to allow accurate application monitoring
			
			HF 3.8.03.013 containing PAR 883																			15Jan18
			
			PAR 988. KCCMgr incurring endless UE 4 after JSA message header corrupted.
			
			HF 3.8.03.014 containing PAR 988.																			23Jan18
			
			PAR 953. RemainingProcessAlertThreshold shouldn't be active on SDS secondary / RPS nodes.
			
			HF 3.8.03.015 containing PAR 953.																			08Mar18
			
			PAR 999. Converting IPv4 hex address drops address node if value is zero
			
			HF 3.8.03.016 containing PAR 999.																			11Apr18
			
			HF 3.8.03.017 containing PAR 1004 (see 3.7.04 below).														15Jun18
			
			PAR 1014. Provide ability to compact a given process transient file
			
			HF 3.8.03.018 containing PAR 1014.																			17Oct18
			
			HF 3.8.03.019 containing PAR 1053 (refer to 3.7.05 below)													18Dec19
			
			PAR 1062. String method cnTrimLeadingZeros incorrectly returns null string when passed a string of all zeros
			
			HF 3.8.03.020 containing PAR 1062.																			10Mar20
			
			PAR 1072. Invalid [CardLog] LogPath means expected logic is not executed in KCBatch

			HF 3.8.03.022 containing PAR 1072.																			28May20
			
			PAR 1080. CardSchema Global Exception Handler incurs UE 14180 in applicationtype Non_GUI_Web
			
			HF 3.8.03.023 containing PAR 1080.																			28Sep20

3.8.02		Sources forked.																								07Apr15

			Internal. Enhance KCDummy to update ini file on remote fat-clients with correct distribution in
			[JadeAutoUpdate] section.
			
			PAR 895. Method CardSchema::CnIpAddress::checkNumString incorrectly references RootSchema Object::version
			
			PAR 897. JSA alert TCP Header Error : Message from JADE environment where message size > 1,000,000 bytes
			
			PAR 898. Provide multi-thread feature for copying partition control and index files
			
			NFS 900. CardSchema forms have controls using MS Sans Serif, change required
			
			NFS 880. Cater for base64 encoded inline images longer than 76 characters (Abel Software) 
			
			First cut for qualification 3.8.02.000.																		09Nov15
			
			Beta cut 3.8.02.001 for JUO UAT testing.																	30Nov15
			
			PAR 909. 1035 string too long in CnCntrl::setupControlOptions on dbLogPath
			
			New Feature. Add facility to KCBatch application to analyze transient usage for specified process.
			
			Final candidate cut 3.8.02.002.																				15Jan16
			
			New final candidate cut 3.8.02.003.																			15Feb16
			
			HF 3.8.02.004 containing PAR 940 (refer to 3.6.01 below).													21Jul16
			
			PAR 947. Thin-client execute incorrectly changes workstation karma.dll to karma.dll.bad
			
			HF 3.8.02.005 containing PAR 947																			31Aug16
			
			HF 3.8.02.009 containing PAR 963 (refer to 3.5.04 below).													02Jun17
			
			HF 3.8.02.010 containing PAR 974, 975 (refer to 3.7.03 below)												09Aug17

3.8.01		Sources forked.																								21Jan15

			PAR 868. 'Check for Transients' routine incorrectly states 'Check for undeleted process transients found
			none...'
			
			PAR 871. UE 4031 Index used in substring is out of bounds in File::cnGetSuffix
			
			Cut qualification candidate 3.8.01.000																		27Mar15
			
			Cut production candidate 3.8.01.000																			02Apr15
			
			PAR 874. Some SMTP servers do not accept HELO when authenticating
			
			PAR 875. Refer to 3.7.04 below
			
			PAR 876. Refer to PAR 876 below in 3.5.04
			
			PAR 878. KCDatabaseBackupMulti fails if [PersistentDb]EnableArchivalRecovery not explicitly defined as true
			
			Cut production candidate 3.8.01.001																			10Jul15
			
			PAR 888. Database structures not being correctly updated with UDR file sizes etc
			
			HF 3.8.01.002 containing PAR 888.																			21Jul15
			
			HF 3.8.01.003 containing PAR 890 (see 3.7.05 below)															27Jul15
			
			PAR 891. refer to 3.7.04 below
			
			PAR 892. Under some circumstances a secondary backup cannot be recovered due to insufficient journals
			
			HF 3.8.01.004 containing PARs 891 and 892																	04Aug15
			
			Recut of base release 3.8.01.004.																			04Aug15

			HF 3.8.01.005 containing binaries for PAR 894																25Aug15
			
			HF 3.8.01.006 containing NFS 916 (refer to 3.7.04 below)													12Feb16
			
			HF 3.8.01.007 containing PAR 940 (refer to 3.6.01 below).													21Jul16
			
			HF 3.8.01.011 containing PAR 963 (refer to 3.5.04 below).													02Jun17
			
			HF 3.8.01.012 containing PAR 974, 975 (refer to 3.7.03 below)												09Aug17
			
3.7.05		Sources forked.																								17Oct14

			New feature. Make use of DbFile.getTotalFileLength(<selector) so that file length reported includes the 
			size of the _ndx.dat should the mapfile have been partitioned.
			
			JSM NFS 5572. Add cache statistics to current performance statistics being gathered
			
			JSM PAR 5600. Compaction log shows incorrect size after compaction
			
			JSM NFS 5626. Capture database encryption enabled and master key verified and display in JSM
			
			Cut production candidate 3.7.05.000																			30Jan15
			
			NFS 865. Application alert does not specifiy the JADE Environment name
			
			HF 3.7.05.001 containing NFS 865.
			
			PAR 875. Refer to 3.7.04 below
			
			HF 3.7.05.002 containing PAR 875																			21Apr15
			
			HF 3.7.05.003 containing PAR 876 (refer to 3.5.04 below)													22Apr15
			
			PAR 885. Modify CardSchema cnGetClassAndOid to avoid JADE assert failure
			
			HF 3.7.05.004 containing PAR 885.																			06Jul15
			
			HF 3.7.05.005 containing NFS 887 (refer to 3.5.04 below)													10Jul15
			
			PAR 890. Detour JADE #62913 - recode to avoid executing String type cast of object
			
			HF 3.7.05.006 containing PAR 890.																			27Jul15
			
			HF 3.7.05.007 binaries containing PAR 893																	03Aug15
			
			HF 3.7.05.008 binaries containing PAR 894																	25Aug15
			
			HF 3.7.05.009 containing PAR 891 and NFS 916 (refer to 3.7.04 for both below)								12Feb16
			
			HF 3.7.05.010 containing PAR 940 (refer to 3.6.01 below).													21Jul16
			
			HF 3.7.05.014 containing PAR 963 (refer to 3.5.04 below).													02Jun17
			
			HF 3.7.05.015 containing PAR 974, 975 (refer to 3.7.03 below)												09Aug17
			
			PAR 1053. Backup structure alerts with embedded space warning, unable to suppress

			HF 3.7.05.016 containing PAR 1053																			18Dec19
			
3.7.04.900	Sources forked.	3.7.04.900 release is to provide support for JADE 7.1 beta release							06Oct14

			Cut 3.7.04.900 for JADE 7.1 beta.																			17Oct14

3.7.04		Sources forked.																								07Feb14

			CnMessage constant Current_Protocol_Version incremented for Task Scheduling module changes to messaging.
			
			NFS 830. Provide ability for exception handlers to re-implement/sub-class the CnStackDump class
			
			PAR 833. Timing issue: KCCMgr has requested TCP connection and processes client message before TCP 
			callback openNotify had been processed.
			
			Internal. When reporting an exception to JSM, use the fully qualified method name (that includes the
			schema name).
			
			PAR 840. KCDatabaseBackup application type 'GUI, noForms' requiring jade.exe
			
			PAR 435. Provide SMTP authentication, Transport Layer Security, and port number via ini file.
			
			PAR 841. Handle 3060 exception (read past end-of-file) when backing up SDS Secondary's last journal
			
			PAR 845. Backup multi failing with UE 1035 'String too long' on partitioned database structure. 
					 Cater for 115 byte structure names as from JADE 7.1.
					 
			PAR 850. CnLdapConnection::certDbPath no longer required
			
			Cut 3.7.04.000 for JUO release																				10Sep14
			
			PAR 852. On exception dump file name is saved incorrectly in app.cnStackDumpFileName attribute.
			
			Cut 3.7.04.002 production candidate.																		06Oct14
			
			NFS 853. Wynyard ACA customer has node where Schema=<unknown> App=<unknown> shows in JSM's System View
			
			Cut 3.7.04.003 production candidate.																		15Oct14
			
			PAR 856. Reporting an exception from Unicode environment incurs UE 4031 in CnExceptionAdvice::loadMsg
			
			PAR 858. Statistics values are derived incorrectly when the value wraps around
			
			JSM PAR 5540. Alert definition maintenance taking long time to display existing definition
			
			JSM PAR 5560. UE 1090 on backup start for Managed Environments using CardSchema prior to 3.5.01
			
			HF 3.7.04.004 containing PARs 856, 858 and JSM PAR 5540 and JSM PAR 5560									10Nov14
			
			Cut 3.7.04.004 for general release.																			26Nov14
			
			PAR 864. CnFtp methods in 3.7.04 now protected when they weren't in 3.7.03
			
			HF 3.7.04.005 containing PAR 864																			04Feb15
			
			PAR 875. UE 1035 and UE 1300 exceptions in KCDatabaseBackupMulti interpreter
			
			HF 3.7.04.006 containing PAR 875																			21Apr15
			
			PAR 876. Refer 3.5.04 below
			
			HF 3.7.04.007 containing PAR 876																			22Apr15
			
			HF 3.7.04.008 containing NFS 887 (see 3.5.04 below).														10Jul15
			
			HF 3.7.04.009 (binaries) containing PAR 893 & JSM PAR #5776													03Aug15
			
			PAR 891. Alert not being generated from a managed environment UE because the device name is not defined
			
			HF 3.7.04.010 containing PAR 891.																			10Aug15
			
			NFS 916. Alerting for low licence process count
			
			HF 3.7.04.011 containing NFS 916																			12Feb16
			
			HF 3.7.04.013 containing PAR 940 (refer to 3.6.01 below).													21Jul16
			
			HF 3.7.04.017 containing PAR 963 (refer to 3.5.04 below).													02Jun17
			
			HF 3.7.04.018 containing PAR 974, 975 (refer to 3.7.03 below)												09Aug17
			
			PAR 1004. Provide ability to identify which structures are encrypted or not while environment is online
			
			HF 3.7.04.019 containing PAR 1004.																			15Jun18
---------------------------------------------------------------------------------------------------------------------------------
3.7.03		Sources forked.																								05Sep13

			JSM PAR 5288. UE 1027 lock exceptions incurred during JSM application startup
			
			PAR 823. Length of string returned by CardSchema::cnGetApplicationVersion truncating at 20 bytes.
			
			Cut production candidate for JADECare UAT.																	07Jan14
			
			JSM PAR 5358. No retry of file copy when populating server\c_bin32 directory from altos distribution
			
			Cut production candidate release 3.7.03.002																	05Feb14
			
			PAR 835. FTP file details seem to be cached between FTP sessions
			
			Cut production candidate release 3.7.03.003																	10Mar14
			
			HF 3.7.03.004 containing PAR 839 (see 3.7.02 below)															24Apr14
			
			HF 3.7.03.005 containing PAR 843 (see 3.5.04 below).														03Jun14
			
			PAR 849. AppServer crashing while accessing SSL details
			
			HF 3.7.03.006 containing PAR 849 (karma.dll 2.8.0.11)														26Aug14
			
			JSM PAR 5491. Global Parameter command notification exceeds 48KB userInfo limit
			
			PAR 854. Stackdump logStackDumpCensored option caused run-away memory.
			
			HF 3.7.03.007 containing JSM PAR 5491, PAR 854																24Oct14
			
			PAR 855. CardSchema Logical transaction info can cause never-ending growth of transients
			
			HF 3.7.03.008 containing PAR 855																			28Oct14
			
			HF 3.7.03.009 containing PAR 940 (refer to 3.6.01 below).													21Jul16
			
			PAR 974. Online deployment process 'JadeFileLoaderNonGui' caused extended lock alerts on meta-schema items
			
			PAR 975. Setting ini file'LockCheckInterval' to zero causes KCCMgr to terminate
			
			HF 3.7.03.011 containing PARs 974, 975.																		09Aug17

3.7.02		Sources forked.																								10Oct12

			NFS 793. Modify Extended Lock checking to verify the lock target is a valid object.
			
			PAR 797. JadeMethod::cnGetSourceLine does not report '<Position > source length>'
			
			Cut 3.7.02.001 release for Qualification and Pre-Release UAT.												27Feb13
			
			PAR 798. CnSmtpConnection::loggingRequired is unconditionally turned off, should default to ini setting.
			
			NFS 800. Refer to 3.6.02 below.
			
			PAR 799. Stackdump not always expanding objects due to 1035 exception
			
			HF 3.7.02.002 containing PARs 798 and 799 and NFS 800.														28Mar13
			
			PAR 803. Correct deficiencies in releasing WinInet file handles when using CnInternet class and
			sub-classes.
			
			Cut 3.7.02.003 extracted for general release.																15May13
			
			HF 3.7.02.004 containing PAR 805 (see 3.6.02 below)
			
			HF 3.7.02.005 containing PAR 812 (see 3.7.01 below)															17Jul13
			
			Cut new base release 3.7.02.005																				25Jul13
			
			PAR 816. File::cnGetFileInfo can return '<File <filename> not found>', should be null
			
			HF 3.7.02.006 containing PAR 816.																			07Aug13
			
			Internal. String::cnIsAlpha added for qualification.
			
			Internal. Expand errorcode returned from karma.dll routines into error text.
			
			PAR 819. KCDatabaseBackupMulti gets into loop trying to backup non existing journals
			
			HF 3.7.02.007 containing PAR 819 and two internal changes.													05Sep13
			
			PAR 820. Obscure readable strings in a stack dump that are client sensitive
			
			HF 3.7.02.008 containing PAR 820.																			01Oct13
			
			PAR 825. KCDatabaseBackupMulti is doing database backup and also Windows copy of database directory
			
			HF 3.7.02.010 containing PAR 825.																			29Nov13
			
			Withdrawn HF 3.7.02.010.
			HF 3.7.02.011 containing PAR 826.																			03Dec13
			
			PAR 839. KCDatabaseBackup fails in on-line backup as databaseDirectory attribute has not been initialized.
			
			HF 3.7.02.012 containing PAR 839.																			24Apr14
			
			HF 3.7.02.013 containing PAR 940 (refer to 3.6.01 below).													21Jul16

3.7.01		Sources forked.																								02Dec11

			Merged IPv6 patches from RCG 22Mar12 14:20
			
			NFS 763. Modify SMTP validation to allow max recipients to be specified in ini file (refer RFC 2821)
			
			PAR 760. Looping type error when write binary if email size limit exceeded, allow attachments
			to be written synchronously rather than asynch.
			
			PAR 771. UE 3116 when JSA attempts to get Map file sizes
			
			PAR 654. Multi worker backup does not work if archival recovery is not enabled.
			
			NFS 743. Implement max lag time checks by connection name when doing SDS Primary checks
			
			Released with JSM/JSA																						05Dec12
			
			HF 3.7.01.001 containing PAR 789 (see 3.6.02 below)															03Jan13
			
			JSM PAR 5083. KarmaCommsMgr duplicate process termination turning off system stats sampling
			- ensure duplicate process check for KarmaCommsMgr tests JossControl and Joss
			- if duplicate process detected, set flag to indicate duplicate process termination
			
			HF 3.7.01.002 containing JSM PAR 5083.																		17Jan13
			
			JSM PAR 5087. JSA does not always reconnect automatically with JSM after JSM has been cycled
			
			HF 3.7.01.003 containing JSM PAR 5087.																		21Jan13
			
			Cut base release for general distribution 3.7.01.003.														28Jan13
			
			PAR 795. Backup of SDS Secondary is failing 3060 as current journal is being read past end of file
			
			HF 3.7.01.004 containing PAR 795.																			07Feb13
			
			HF 3.7.01.005 containing NFS 800 (see 3.6.02 below)															22Mar13
			
			HF 3.7.01.006 containing PAR 805 (see 3.6.02 below).														24May13
			
			PAR 812. SDS Secondary journals not being replayed as tracking stopped but no alert when tracking halt
			is deployment related.
			
			HF 3.7.01.007 containing PAR 812.																			17Jul13
			
			PAR 824. UE 3049  (Object edition out of date) forcing process dumps no longer required
			
			HF 3.7.01.008 containing PAR 824.																			14Nov13
			
			HF 3.7.01.009 containing PAR 940 (refer to 3.6.01 below).													21Jul16

=========================================================================================================================================
3.6.02		PAR 781. Backup rendered invalid when mapfile is instantiated during backup window (see 3.3.03 below)

			Release cut 3.6.02.																							28Aug12
			
			PAR 782. See 3.5.04 below
			
			HF 3.6.02.002 containing PAR 782.																			05Oct12
			
			HF 3.6.02.003 containing NFS 783 (see 3.5.04.003 below).													06Nov12
			
			HF 3.6.02.004 containing PAR 787 (see 3.5.04.004 below).													26Nov12
			
			PAR 789. UE 1035 when setting up application alias
			
			HF 3.6.02.005 containing PAR 789.																			03Jan13
			
			NFS 800. Request by JADE Plant to force a process dump on UE 1010
			
			HF 3.6.02.006 containing NFS 800.																			22Mar13
			
			PAR 805. JADE 7.0 JournalClaseAction default changed from None to Move
			
			HF 3.6.02.007 containing PAR 805.																			24May13
			
			HF 3.6.02.008 containing PAR 940 (refer to 3.6.01 below).													21Jul16

3.6.01		Sources forked.

			PAR 729. Stack dump returning different values for parameters and local variables.
			
			Added database structure state replication feature. 26Oct11
			
			Provide ini file setting 'DisableBackupNotifications' so that KCDatabaseBackupMulti
			does not try to issue notifications when no user application available to subscribe.
			
			Release 3.6.00.001 for Qual and UAT.																		14Nov11
			
			PAR 744. SDS Structure States not being created on SDS Primary when structure frozen or offline
			
			PAR 747. SDS Structure State Replication issues identified during Qualification.
			
			Cut 3.6.01.000 as production candidate.																		24Nov11
			
			Cust 3.6.01.001 to include PAR 749 (see 3.5.03 below)														30Nov11
			
			HF 3.6.01.002 containing PAR 752 (3.5.01 below).															13Dec11
			
			PAR 756. CnCntrl::zSetupLoggingOptions - app.computerName used to generate filename with invalid 
			characters
			
			PAR 757. CnTransactionStack methods need to strip invalid filename characters from app.computerName
			
			PAR 767. (3.5.03 below) UE 4 in app CardSchema::KCCMgr of UKAPINV on UKALCYS1 when monitored application 
			terminates before ping can start
			
			HF 3.6.01.003 containing PARs 756, 757, 767.																01May12
			
			PAR 769. Added diagnostic to identify possible issue with karma.dll being suffixed .bad where
			database, app server and thin-clients using same server and binaries.

			PAR 770. When JADE environment is a JADECare managed environment, then force diagnostic logging to be
			true regardless of ini file settings.
			
			HF 3.6.01.004 containing PARs 769 (3.5.01 below) and 770													30May12
			
			HF 3.6.01.005 containing PAR 772 (3.5.03 below)																06Jul12
			
			PAR 773. Message "SDS secondary not connected to primary, still tracking." is confusing
			
			PAR 775. Thinclient startup always incurs a 5 second delay
			
			HF 3.6.01.006 containing PARs 773 and 775 (3.5.03 below)													17Jul12
			
			NFS 777. HPSM transport mechanism returned unexpected node.networkAddress causing system to loop
			
			HF 3.6.01.007 containing NFS 777 and NFS 714 (3.5.03 below)													06Aug12
			
			PAR 940. KCVerifyJournal is not verifying any journals once first startup check cycle completed
			
			HF 3.6.01.008 containing PAR 940.																			21Jul16
			
=========================================================================================================================================
3.5.04		PAR 781. Backup rendered invalid when mapfile is instantiated during backup window (see 3.3.03 below)

			Release cut 3.5.04.																							28Aug12
			
			PAR 782. Thinclient IDE process incorrectly renaming karma.dll to karma.dll.bad
			
			HF 3.5.04.002 containing PAR 782.																			05Oct12
			
			NFS 783. KCDummy application to update [SyncDbService]DatabaseRole on remote JADE environments
			
			HF 3.5.04.003 containing NFS 783.																			06Nov12
			
			PAR 786. [SyncDbService] DatabaseRole=1 update caused by hotfix 3.5.04.003 causing RPS connection issue.
			
			PAR 787. KCOnlineBackup failing with 1284 and not reporting this fact to JSA.
			
			HF 3.5.04.004 containing PAR 786, 787.																		26Nov12
			
			PAR 821. KCOnLineBackup reporting incorrect percent done for database structures
			
			PAR 843. SMTP email header date for foreign language locales is incorrectly formed.
			
			HF 3.5.04.005 containing PAR 843.																			03Jun14
			
			PAR 876. UE 1035 and UE 1267 in KCDatabaseBackupMulti
			
			HF 3.5.04.006 containing PAR 876																			22Apr15
			
			PAR 963. KCStartAppInNode does not start app in jadrap node; returns OK result even when app failed to start
			
			HF 3.5.04.008 containing PAR 963																			02Jun17

3.5.03		Minimum JADE release 6.3.07.

			PAR 749. Lengthily logins due to Thin Client connection balancing implementation in JADE Care start.
			
			Final production candidate 3.5.03.000																		30Nov11
			
			PAR 767. UE 4 in app CardSchema::KCCMgr of UKAPINV on UKALCYS1 when monitored application terminates 
			before ping can start
			
			HF 3.5.03.002 containing PAR 767.																			01May12
			
			HF 3.5.03.003 containing PAR 769 (3.5.01 below).															30May12
			
			PAR 772. UE 4029 in CnLdapConnection::cnOpen(1416) - Following migration to 64-Bit JADE 7.0
			
			HF 3.5.03.004 binary fix for cnldap for PAR 772.															06Jul12
			
			PAR 773. Message "SDS secondary not connected to primary, still tracking." is confusing
			
			PAR 775. Thinclient startup always incurs a 5 second delay
			
			HF 3.5.03.005 containing PARs 773 and 775.																	17Jul12
			
			NFS 714. Provide ability to run JADECare managed applications as fat-clients in RPS environment
			
			HF 3.5.03.006 containing NFS 714.																			06Aug12

3.5.02		Minimum JADE release 6.3.07 :
			- allow restore from / to multiple volumes

			NFS 667. FTP/HTTP interface now allows user/password to be max length.

			PAR 679. Handle backup failure due to user sign-on disabled.
			
			PAR 680. KCDatabaseBackupMulti ini file keyword values differ from command line keywords causing
			confusion.
			
			NFS 681. Move the error code in stack dump title to end of file name
			
			NFS 692. Allow for extended lock checks to request more than 10,000 locks and, if greater then
			10,000 to start new application to handle lock checking.

			PAR 703. lock_exceptions.csv column hdg typo and source line could contain embedded commas etc
			causing unexpected formatting issues in Excel.
			
			Fix. Change application KCDummy to be Non_GUI rather than GUI, NoForms
			
			Merge message changes for ODBC monitoring. 23/4/2011 12:42
			
			First candidate cut for Qualification and UAT 3.5.02.000													05Aug11
			
			Change [PersistentDb] ObjectCacheSizeLimit to use JADE default of 4M rather than zero.
			
			PAR 730. SessionClose advice being issued for incorrect application
			
			Final candidate cut for UAT and production 3.5.02.001														09Sep11
			
			PAR 735. KCDatabaseBackupMulti Exception 1267: Notification info object too big
			
			Final production candidate 3.5.02.002																		27Sep11
			
			PAR 739.Backup initiated on customer server failed with 1090 as unable to locate server host
			
			HF 3.5.02.003 containing PAR 739, 736 (3.5.01 below).														07Oct11
			
			Updated production candidate 3.5.02.003.																	13Oct11
			
			PAR 746. Transient leaks in CardSchema method CnJadeDatabaseAdmin::getAllPartitionInfoForDbFile
			
			HF 3.5.02.004 containing PAR 746, 748 (3.5.01 below).														25Nov11
			
			HF 3.5.02.005 containing PAR 752 (3.5.01 below).															13Dec11
			
			HF 3.5.02.006 containing PAR 769 (3.5.01 below).															30May12
				
3.5.01		Release cut for UAT 3.5.01.000.																				27Sep10

			Minimum JADE release 6.3.05:
			- references delta database feature
			- uses new SDS global constants

			PAR 666. Modify CnStackDump::dumpStack to show web exception form if web-enabled AND non-GUI_web 
			application type
			
			PAR 667. Provide censored dumpstack option to suppress printing of machine names, usercodes and 
			IP addresses
			
			Release cut for UAT and Production 3.5.01.001.																08Nov10
			
			PAR 671. SSL details derived from incorrect ini file and date details invalid.
			
			HF 3.5.01.002 containing PAR 671.
			
			PAR 670. Rework of KCNodeControl to use shared transient rather than persistent locks and new 
			application KCBatch with changes to activate / deactive delta database
			
			PAR 672. Web Services exception can cause notification overflow exception 1267.
			
			Release cut for Production 3.5.01.003.																		01Dec10
			
			PAR 674. Convert FQDN of localhost.localdomain to approp machine FQDN and IP address
			
			PAR 675. Leaking iterator transient in CnFileDetailsAdvice for Database Data
			
			PAR 678. (see 3.4.03 below).
			
			HF 3.5.01.004 containing PAR 674, 675 and 678																14Jan11
			
			PAR 684. Leaked transients in a couple of classes
			
			JSM PAR 4504. Product validation form showing version mismatches.
			
			HF 3.5.01.005 containing PARs 684 and JSM PAR 4504
			
			JSM PAR 4512. RPS node KCCMgrsession open failing with large version string
			
			HF 3.5.01.006 containing JSM PAR 4512.
			
			JSM PAR 4523. Application Monitoring values not converted correctly when JSA changes to 3.5.01
			
			HF 3.5.01.007 containing JSM PAR 4523																		18Feb11
			
			PAR 694. Attempt to get SSL details failes with UE 1413 Index used in string operation is out of bounds
			
			HF 3.5.01.008 containing PAR 694.																			09Mar11
			
			PAR 695. Deadlock exception handler doesn't cater for terminated process when generating  dump info
			
			PAR 696. CnBackupInfo::interpretBackupInfo byte ordering issue as remote architecture is not set.
			
			JSM PAR 4545. JSA with multiple JSM IP Addresses defined gets hung on one IP Address
			
			HF 3.5.01.009 containing PARs 695, 696 and JSM PAR 4545.													15Mar11
			
			PAR 699. UDR file size being reported to JSM is half the actual size.
			
			HF 3.5.01.010 containing PAR 699.																			16Mar11
			
			PAR 697. UE 1300 (Array index out of bounds) in KCOnLineBackup when attempting to send progress 
			notification back to JSM.
			
			PAR 700. 3120 error logged in jommsg.log after upgrade to CardSchema 3.5.01
			
			PAR 702. TimeStampInterval::cnHours returns incorrect hour value
			
			HF 3.5.01.011 containing PAR 697, 700, 702																	17Mar11
			
			PAR 706. User-patch details were not being returned as collection was ascending and should 
			be descending
			
			HF 3.5.01.012 containing PAR 706.																			29Mar11
			
			Fix. KCBatch action stopKCCMgr was restarting KCCMgr rather than stopping KCCMgr
			
			PAR 712. Applications running in same node appear incorrectly in JSM's System View
			
			HF 3.5.01.013 containing Fix and PAR 712.																	27Apr11
			
			HF 3.5.01.014 containing PAR 712 (patched in 3.4.03 below).
			
			PAR 680. Trailing slash on System Directory causing backup failure. CompressFiles was not previously
			a command line option.
			
			PAR 720. 3.5.01 database backups generating a lot of log output and seem to be slower.
			
			HF 3.5.01.015 containing PAR 680 and 720.																	04Jul11
			
			PAR 722. backup bytesdone progress events are not handling JadeByte files (UDR) and causing 
			'no response' alerts in JSM
			
			HF 3.5.01.016 containing PAR 722.																			21Jul11
			
			PAR 727. Stackdump file incurs UE 1436 due to invalid characters in file name from app.computerName
			
			PAR 738. During backups always use Status_Resident to define structures to backup regardless of fileLength.
			
			PAR 734. Smtp Error 100005 'You have not provided a 'sendTo' property' despite bcc attribute being defined.
			
			HF 3.5.01.017 containing PAR 727, 738, 734.																	26Sep11
			
			PAR 736. Virtual property that invokes CardSchema method is causing stackdump failures
			
			PAR 748. UE 1035 'String too long' in backup where map file with large name is also partitioned.
			
			HF 3.5.01.018 containing PAR 736, 748.																		25Nov11
			
			PAR 752. Unicode user environment Application Servers not reporting SSL details correctly

			HF 3.5.01.019 containing PAR 752.																			13Dec11
			
			PAR 769. Thinclient running on same binaries as database and app server renames karma.dll to karma.dll.bad
			
			HF 3.5.01.020 containing PAR 769.																			30May12
			
3.5.00		Sources forked 6Jan10

			Update. Increased AppServerMonitor applications from 50 to 100 to allow for more fat-clients to be
			managed and monitored.
			
			Modify CnInternet class so that Http and Ftp sessions can use a proxy server.								23Mar10
			
			PAR 633. Non-managed environment id exceeding 30 bytes causes UE 1035, truncate to 30 bytes					06Apr10
			
			PAR 636. Reimplement patch introduced in 3.3.02 but using JADE 6.2.18 / 6.3.06 feature
			Process::isUserDataPump																						05May10
			
			PAR 618. 1090 UE in CnCntrl::nodeMonitorChange when interval changed before file instantiated.				25May10
			
			PAR 648. CnMIME::deleteFileObject was causing a 1072 object already deleted when application was
			executing finalize.
			
			NFS 649. Add errorcode to stackdump file name.
			
			Merge common backup routines for KCOnlineBackup and KCDatabaseBackupMulti - RCG 							15Jul10
			
			First cut for Qualification 3.5.00.001.																		09Aug10
			
			Fix_1. JSM UE 4031 on receipt of BackupSpecCmd as CnBackupSpec::assembleMsg unconditionally c
			ontains 3.5 items
			
			Fix_2. Add new class constant Advice_Type_Install_State to CnMessage
			
			JSM Par 4378. Diagnostics for Restore issue plus additional feature to expand Sets in a stackdump.
			
			Second full cut for Qualification 3.5.00.002.																19Aug10
			
			NFS 658 Part 1. KCDatabaseBackupMulti did not handle where [PersistentDb] JournalRootDirectory
			could contain a partial node name (eg JournalRootDirectory=logs)
			
			Fix_3. Failing to get version details of karma.dll.ansi63 and similarly named files
			
			Fix_4. When SDS takeover occurs, tracking halts and is being processed while role changes causing 
			UE 1011 trying to derive tracking status

3.4.04		PAR 781. Backup rendered invalid when mapfile is instantiated during backup window (see 3.3.03 below)

			Release cut 3.4.04.																							28Aug12
			
3.4.03		Source forked 18:20 27/1/10

			Patches for Silverlight stackdumps to suppress properties for Xaml objects being
			dumped and having to be retrieved from Silverlight applet.
			
			Patches for KCDatbaseBackupMulti.
			
			Remove providing details of JadeExecuteFlagCategory constants and ini file settings and 
			rename category to Cn_JadeExecuteFlagCategory.
			
			Cut full release of CardSchema 3.4.03.000 - production candidate											03Feb10
			
			Implement PAR 626 patch (see 3.4.02 hf 3.4.02.008 below).
			
			PAR 620 part III. KCDatabaseBackupMulti fails with Exception 1270.
			
			HF 3.4.03.001 release for Qual containing PARs 626 and 620.													23Feb10
			
			Cut production release of CardSchema 3.4.03.001																25Feb10
			
			PAR 632. Unicode host environment UE 4039 in transaction stats submission
			
			HF 3.4.03.002 release containing PAR 632.																	30Mar10
			
			PAR 635. Non-managed environment using thinclient connection balancing requires KCCMgr
			which is failing as JadeAutoUpdate etc is not valid.
			
			HF 3.4.03.003 release containing PAR 632.																	12Apr10
			
			HF 3.4.03.004 release (repackaged 3.4.03.003 as 003 accidentally released as Beta hotfix)					13Apr10

			PAR 637. Extremely large timevalues being returned from transaction stats.
			
			HF 3.4.03.005 release containing PAR 637 and 
			patches to 3.4.02 PARs 635, 636 (refer below HF 3.4.02.010 and 011).										02Jun10

			HF 3.4.03.006 release containing PAR 646 (refer HF 3.4.02.012 below).										09Jun10
			
			HF 3.4.03.007 containing karma binaries only.
			
			PAR 651. Starting KCDatabaseBackupMulti with no command line entries results in 1090.
			
			JSM PAR 4343 (refer 3.4.02 below).
			
			JSM PAR 4389 (refer 3.4.02 below).
			
			NFS 664. (refer to 3.4.02 below).
			
			HF 3.4.03.008 containing PAR 651, NFS 664 and JSM PARs 4343 and 4389.										30Sep10
			
			PAR 678. KCDatabaseBackupMulti variables from ini file were not being implemented.
			
			HF 3.4.03.009 containing PAR 678.																			14Jan11
			
			PAR 712. Applications running in same node appear incorrectly in JSM's System View
			
			HF 3.4.03.010 containing PAR 712.																			02May11

3.4.02		Set CnMessage class constant Current_Protocol_Version to 19.

			PAR 591. Change KCDatabaseBackup to always exclude database system files from database
			backup as these are now treated as binaries.
			
			PAR 593. SDS tracking status change during SDS takeover attempted to get tracking disabled
			status after database role had changed to SDS primary.
			
			PAR 594. Cater for KCDatabaseBackup incurring 3162 exception when backing up offline mapfile.
			
			NFS 595. Provide ability to enable lock checking for a processas converse to disable lock 
			checking (CardSchema::cnDisableLockChecks).
			
			NFS JSM 4059 Part 1. Return valid reason string when stop tracking reason = 12 being that 
			database moved into delta mode.
			
			NFS 599. Provide ability to start up application in a designated node and avoid having to
			cycle a node or the environment.
			
			PAR 597. 1091 Binary too long caused by Object::cnEndTransactionEx(4227)
			
			PAR 604. UE 1400 (The receiver has already registered a timer with the specified tag) when KCCMgr
			has created transients for all JADE processes found, then exits initialize and finds one or more
			create events for processes KCCMgr has already registered.
			
			JSM PAR 4001. Meta File : Control File Mismatch. Cn_DbFiles_Backup.txt creation to occur after the 
			backup rather than before as mapfiles could be instantiated while in backup state and caused 
			checks to fail.
			
			Candidate cut to Qual																						07Oct09
			
			NFS 603. Add IP address to cn_tranlog such that thin-client station IP address is shown.
			
			HF 3.4.02.001 containing PAR 609 (refer to 3.3.02 below) and NFS 603 above.
			
			PAR 610. Stackdump of JadeDynamicObject was curtailed if element contained a reference rather 
			than a primitive value.
			
			PAR 608. Patch for PAR 574 causing issue when thin-client, app server and database server all use
			common files and execute on same server.
			
			Cut for qualification.																						30Oct09
			
			Merge KCDatabaseBackupMulti changes with RCG. 5/11/09 17:19.
			
			NFS 612. Provide the ability to suppress user generated alerts.
			
			HF 3.4.02.002 containing patches for KCDatabaseBackupMulti, File cnGetLength methods
							and NFS 612.																				11Nov09
							
			HF 3.4.02.003 containing patches since HF 3.4.02.002														23Nov09
			
			Cut full release of CardSchema 3.4.02.004 - production candidate											26Nov09
			
			JSM PAR 4217. 4031 exception during report run of mapfile growth.

			PAR 616. Global constant OK needs to be reinstated.
			
			HF 3.4.02.005 containing patches JSM PAR 4217 and 616.														06Jan10
			
			JSM PAR 4221. Avoid trying to get FileVersion details for JADE system files (.bin)
			
			PAR 619. Handle unknown buildArchitecture on Sliverlight application
			
			PAR 620. KCDatabaseBackupMulti missing files from system folder during backup
			
			PAR 621. Locking and 1090 issues in establishNodeControl.
			
			HF 3.4.02.006 containing PARs 619, 620, 621 and JSM PAR 4221.												21Jan10
			
			PAR 620/622 II. CnDatabaseAdmin shared transient property was being updated out of transient
			transaction state.
			
			HF 3.4.02.007 containing PAR 620/622 II.																	03Feb10
			
			PAR 626. Managed and non-managed backups did not always include JadeBytes file length.
			
			HF 3.4.02.008 containing PAR 626.																			17Feb10
			
			JSM PAR 4278. Error 8 (Not enough memory resource) when getting file version of Linux debug file.
			
			HF 3.4.02.009 containing JSM PAR 4278

			PAR 635. KCCMgr failing when launched by background process activating karma control and ini file
			KarmaControl=false.
			
			3.4.02.010 containing PAR 635.																				14Apr10
			
			PAR 636. User datapump failing in initialize while instantiating CnKarmaCntrl from package.			
			
			HF 3.4.02.011 containing PAR 636.																			02Jun10
			
			PAR 646. SchemaEntity::cnGetModifierName incurring 1090 exception in JADE 6.3 releases
			
			3.4.02.012 containing PAR 646.	
			
			3.4.02.013 containg karma binaries only.
			
			JSM PAR 4343. Provide ability to analyze transient file and to dump transient details in log 
			every 30 minutes.
			
			JSM PAR 4389. Repeated UE 8 exceptions during JARI assembly or print of JARI.
			
			3.4.02.014 containing JSM PARs 4343 and 4389.
			
			NFS 664. Provide details for lock exceptions that were retried successfully.
			
			3.4.02.015 containing NFS 664

3.4.01		Qual and JUO release cut.																					25Jun09

			JSM PAR 3995. Compaction advice failures are not being reported back to JSM correctly.
			
			Hotfix number bumped, no hot fix cut as not generally released.
			
			HF 3.4.01.002 containing PAR 590 (refer to 3.3.02 below).
			
			HF 3.4.01.003 containing PAR 592 (refer to 3.3.02 below).

			HF 3.4.01.004 containing PAR 600 (refer to 3.3.02 below).
			
			PAR 601. Thinclient O/S version and details being incorrectly derived from the node, 
			karma.dll rename has an exception causing thinclient startup to fail.
			
			HF 3.4.01.005 containing PAR 601.
			
			PAR 606. Ftp functions in karma.dll on 64-bit require argument of MemoryAddress and not Integer.
			
			HF 3.4.01.006 containing PAR 606.
			
			HF 3.4.01.007 containing PAR 609 (refer to 3.3.02 below).
			
			PAR 611. UE 1090 in CnCntrl::zJadeProcessUpdate, timing issue.
			
			HF 3.4.01.008 containing PAR 611.

3.4.00		Release to support JADE 6.3 32-bit and 64-bit.

			PAR 574. Thin-client with old karma library failing with 1006 entry point not in library.
			Reworked for multi-OS in 3.4.01.
			
			Candidate cut 3.4.00 to qual. 13/5/09 16:38.																12May09
			
			HF 3.4.00.001.
			
			3.4.00.002 full cut to include hotfixes for PARs 544, 577 and 578 from 3.1.11 (see below)					22May09
			
			HF 3.4.00.003 containing NFS 581 (see 3.3.02 below).
			
			HF 3.4.00.004 containing PAR 583 (see 3.3.01 below).

			PAR 584. CnStackDump::zGetStartCallStackIndex gets 1090 on delete of objArray
			when not in exception state.
			
			Candidate cut 3.4.00.005 (released to Qual and JUO)															17Jun09

3.3.93		Cut to include hotfixes for PARS 544, 577 and 578 (see 3.1.11 below).										22May09

			HF 3.3.93.001 containing NFS 581 (see 3.3.02 below).
			
			HF 3.3.93.002 containing PAR 583 (see 3.3.01 below).

3.3.92		Released for JADE 6.3.03 General Release																	29Apr09

			PAR 570. 1035 in CnKarmaCntrl::create when non-managed environment and enviroment id 
			10 or more characters.
			
			HF 3.3.92.001 containing #570.
			
			PAR 574. Thin-client with old karma library failing with 1006 entry point not in library.
			
			HF 3.3.92.002 containing #574.
			
			HF 3.3.92.003 containing binaries for #572 and #573.
			
			PAR 575. UE 1406 when using large cache sizes in 64-bit JADE
			
			HF 3.3.92.004 containing #575.
			
			HF 3.3.92.005 containing PAR 558 and PAR 576 (from 3.3.01 version below)

3.3.91		When CardSchema version prior to 3.4 and JADE 6.3 64-bit, disallow KarmaControl.

			Change logging and dump to detect new architectures 64_BigEndian and 64_LittleEndian.
			
			Modify CnLdapConnection interfaces to cnldap library to use MemoryAddress when referencing handles
			rather than Integer.
			
			Released for JADE 6.3.02 (BETA 2)																			26Mar09

3.3.90		Released for JADE 6.3.01 (BETA 1).																			13Feb09

3.3.03		PAR 781. Backup rendered invalid when mapfile is instantiated during backup window

			Release cut 3.3.03.																							28Aug12

3.3.02.		PAR 544. KCDatabaseBackup application does not return userExitCode when error or exception 
			encountered.
			
			PAR 547. 5029 UE when [CardLog] section doesn't define LogFileName.
			
			PAR 548. Allow CnKarmaCntrl usage with ODBC driver (read-only access).
			
			3.3.02.002 full cut to include hotfixes for PARS 544, 577 and 578 (see 3.1.11 below).						22May09
			
			NFS 581. Allow any AppServer application to register node for thin-client connection balancing.
			
			HF 3.3.02.003 containing NFS 581.
			
			HF 3.3.02.004 containing PAR 583 (see 3.3.01 below).
			
			PAR 590 (JSM PAR 3995). Compaction advice failures are not being reported back to JSM correctly.
			
			HF 3.3.02.005 containing PAR 590.
			
			PAR 590 - Revisions to previous compaction changes.
			
			HF 3.3.02.006 containing PAR 590 revisions.
			
			PAR 592. Correct transient leak caused by Compaction messages
			
			HF 3.3.02.007 containing PAR 592.
			
			PAR 600. Avoid potential for 1025 exception when activating KarmaControl.

			HF 3.3.02.008 containing PAR 600.
			
			PAR 609. Application monitoring failing as test is case-sensitive.
			
			PAR 3.3.02.009 containing PAR 609.

3.3.01		JSM PAR 3789. Modify SMTP connection to ignore blank email address entitites rather than fail.

			PAR 540. Non-GUI application can get 1291 exception when trying to display message box in
			CnCntrl::zSetControlOptions.
			
			Final candidate release to ensure PAR 542 fix issued.														23Jan09
			
			HF 3.3.01.001 containing PAR 545 (patched 3.3.00.015).
			
			PAR 551. Application monitoring where packages imported ignore ping command.
			
			HF 3.3.01.002 containing PAR 551.
			
			PAR 546. JadeRpsDataPump causing activate Karma Control when package initialize method invoked. This
			causes deployments to hang when KCCMgr isn't running and CnRoot sharedTransient not created.
			
			HF 3.3.01.003 containing PAR 546.
			
			PAR 555. 1090 exception when initializing AppServerMonitor introduced in hotfix 002.
			
			HF 3.3.01.004 containing PAR 555.
			
			PAR 536 part II. Process.networkAddress still being used in places invoked during exception.
			
			HF 3.3.01.005 containing PAR 536 part II.
			
			PAR 558. Derivation of app server nodeId is using the app.cnComputerName when should be
			app.cnComputerNameAppServer which is causing issues for JSM displayed in SystemView.
			
			HF 3.3.01.006 containing PAR 558.
			
			PAR 576. Node monitoring should only occur on AppServers.
			
			HF 3.3.01.007 containing PAR 576.
			
			PAR 583. LDAP entities expect app.myCnCntrl to have been instantiated causing 1090 
			exceptions.
			
			HF 3.3.01.008 containing PAR 583.

3.3.00		PAR 441. Modify CardSchema to minimise use of serverExecutions when obtaining
			Node.networkAddress and Process.networkAddress
			
			PAR 464. cn_tranlog.csv to include extra column to identify the transaction id
			nested level for analysis purposes.
			
			PAR 469. 1092 exception (Object not available) in cnGlobalLockExceptionHandler
			
			PAR 470. CnStackDump::dumpStack displays dump-in-progress form even when AppExceptions
			SuppressManagementDialogs is true.
			
			JSM NFS 3491. Remove/minimise usage of system.nodes and node.processes to avoid 
			possible lock contention.
			
			PAR 431. CardLog logging options being overwritten or not defined depending on 
			Logging being set or not.
			
			PAR 443. Handle case where object reference is for a deleted class such that oid
			is provided rather than object reference is null.
			
			Merge RCG compaction classes to-date. Time 6/6/08 15:46.
			
			NFS 489. Replace changing of Decimal to Binary to Decimal (messaging) to use 
			RootSchema methods Decimal.asBinary and Binary.asDecimal rather than typecast.
						
			JSM NFS 3247. Add queued locks information to transaction stats.
			
			NFS 494. Provide mini dump to string method on CnStackDump

			JSM NFS 3247. Change CnServerStatistics to use System::getRequestStats and use
			Integer64 values as well as providing Queued_Locks< Lock_Queue_Time and Cause_Events
			statistics. Stats now version 6.
			
			NFS 504. Add ApplicationType_Non_GUI_Web to checks in cnGlobalExceptionHandler.
			
			Tracker PAR 751. Add server time variable when raising appilcation or karma alert for
			inclusion in Tracker call details.
			
			PAR 508. JadeMultiWorkerTcpTransport will get exception and sometimes
			the connection object will be null. Modify TCP exception handler to pass back rather than
			get a 1090.
			
			Merged with RCG 5/9/08 12:06.
			
			3.3.00.001 release cut for qual. 12Sep08
			
			Modify CnKarmaCntrl::create and CnStackDump::dumpStack to also list any JadeExecuteFlagCategory
			values that are set in the ini file or are true for the node.
			
			PAR 523. Always create specific CardSchema CnLockTargets so SDS Secondary can lock them and 
			doesn't attempt to create them and incurring a 1295 exception.
			
			3.3.00.002 release cut for qual. 25Sep08.
			
			3.3.00.003 release cut for qual. 06Oct08.
			
			PAR 526. Old version of karma.dll on thin-client causing 1006 exception during initialization.
			
			3.3.00.004 final candidate release 20Oct08.
			
			3.3.00.005 see PAR 530 resolved in 3.2.04 and patched against 3.2.03.
			
			PAR 531. New host environment was attempting to check existent of lock targets
			before CnRoot object was created.  HF 3.3.00.006
			
			PAR 508. Further work arising from JADE 49516. HF 3.3.00.007
			
			PAR 532. CnFTP::cnGetFileInfo incorrectly using simple name and not full file name including path.
			HF 3.3.00.008.
			
			PAR 533. KCCMgr on SDS Secondary issueSessionOpenAdvice failed with exception 3116 (Database file
			locked for reorganization).  HF 3.3.00.009.
			
			JSM PAR 3756. Create Cn_DbFiles_Backup.txt to allow JSA to detect mismatch between meta-schema and
			control file.
			
			Full release 3.3.00.010 cut.																		03Dec08
			
			Fix tranlog and logical transaction log placement of 'level' when node control sampling not running.
			
			PAR 536. Avoid potential hang accessing other processes networkAddress during deadlock exception.
			
			Release 3.3.00.011 cut for general release.																	18Dec08
			
			JSM PAR 3783. Change path derivation to also handle 'runtime' Linux directory.
			
			HF 3.3.00.012 containing JSM PAR 3783.
			
			HF 3.3.00.013 containing JSM PAR 3790 - patched in 3.2.03
			
			PAR 542. Check for activateKarmaControl issues alerts when:
			- executing workspace or JadeScript from IDE
			- getAndAvalidateUser and/or isValidUser delay sign-on (eg logon form modal)
			
			HF 3.3.00.014 containing PAR 542.
			
			PAR 545. KCNodeControl on Linux 1035 exception as node name uses fully qualified server name.
			
			HF 3.3.00.015 containing PAR 545.
			
			PAR 536 part II. Process.networkAddress still being used in places invoked during exception.
			
			HF 3.3.01.005 containing PAR 536 part II.
----------------------------------------------   Forked for 3.3  10Apr08 -------------------------------------------------------------
3.2.05		Cut to include hotfixes for PARS 544, 577 and 578 (see 3.1.11 below).										22May09

3.2.04		PAR 517. 1027 exception in KCOnLineBackup issued failure advice to InstallationMgr and 
			caused the deploy to abort but cnGlobalLockExceptionHandler successfully retried the lock.
			
			PAR 515. 1090 on SDS Primary when doing offline backup
			
			JSM PAR 3660. Modify cnTcpExceptionHandler to retry connection of connectionType 
			continuousListenerMaster.
			
			PAR 530. Handle 3204 and 3212 exceptions when doing SDS Primary checks.
			
			PAR 536. Do not reference network address of other process during deadlock exception unless
			JADE 6.2.17 or later.

			Full cut of 3.2.04 released.																				15Dec08

			PAR 537. CnSDSAdvice assembleMsg timestamp not converted to UTC time results in JSM alerts 
			showing time in the future.  HF 3.2.03.003, 3.2.04.001.
			
			JSM PAR 3790. Avoid string too long issue in WatchInfo when monitoring mount point wth name
			longer than 62 bytes.
			
3.2.03		PAR 468. CnCntrl.setupControlOptions incorrectly deriving the root directory in Linux for
			non-managed environment.
			
			PAR 473. Stackdumps on Linux using CrLf as end of line.
			
			PAR 475. Exception dialog doesn't show large stackdump names.
			
			PAR 481. ExceptionHandlerDesc transient leak in CnStackDump::zGetStartCallStackIndex.
			
			PAR 482. 1309 exception when invoking cnActivateKarmaControl more than once for same
			application.
			
			PAR 484. 1090 exceptions from packages that activate Karma Control and are imported into
			schema that is not a sub-schema of CardSchema.
			
			PAR 486. Alert advising user schema patch string exceeds .6MB doesn't identify environment.
			
			NFS 487. Process.getRequestStatistics returns JadeDynamicObject with Integer64 rather than
			Decimal values. Wrap-around algorithm change required.
			
			New. Implement thin-client connection balancing in AppServerMonitor applications.
			
			Candidate cut																								7 Jul 2008
			
			NFS 496. Display stable and replay timestamps when checking SDS replay lag.
			
			PAR 486. User patches alert does not identify host environment.
			
			PAR 498. 1090 exception in cnWriteLog if CardLog section not defined correctly.
			
			Final release cut @ 08:42																					29 Jul 2008
			
3.2.02		Production release cut.																						18 Apr 2008


3.2.02b		PAR 451. cnSetTransactionError and cnSuspendTransaction needlessly had 'updating' in signature.

			PAR 453. KCCMgr start up on new system not creating persistent CnRoot object.
			
			PAR 455. User exception handlers invoking CardSchema::cnGlobalExceptionHandler means that the 
			default stack offset of 4 starts listing the stack array from the user exception handler. This
			causes the Exception Advice processing in JSM to consider some exceptions as duplicates,
			notably 1027 and 1081 exceptions.
			
			Cut for qual 10 Mar 2008 08:40

3.2.01		PAR 438. Change syncmode from JournalBlockWrite to JournalSwitch (and vice-versa) was
			not being detected unless KCCMgr cycled whereas environment actioned this on next journal
			change / reconnect.
			
			PAR 445. User subscribing to Object_Delete_Event on class Process did not have their own
			sysNotification class defined and were inheriting CardSchema's sysNotification. And as 
			app.cnActivateKarmaControl is not being used, the environmental singletons were not
			instantiated causing a 1090.
			
			NFS 169. If backup threads do not get started then at minimum alert and if none can be
			started to do backup, fail backup.

3.2.00		Released.																									15 Oct 2007

3.2.00j		Cut to JUO for UAT.																							08 Oct 2007.

3.2.00i		NFS 426. Alert when mapfile has embedded or trailing space on managed backup start.

			NFS 	 Modify CnLdap classes so that any sorting is handled by JADE rather than
					 within the cnldap.dll.
					 
			NFS 427. When bad message header occurs, ensure that TCP connection object leaks stop occurring.
					 When userAppliedPatches size exceeds 0.6MB stop sending these details as part of SOA and
					 issue appropriate alert that this is occurring.
					 
			Cut for qual																								03 Oct 2007
																						
3.2.00h		Cut for qual 																								08 Aug 2007

3.2.00g		JADE PAR 41731 advises that from 6.2 node cpuTime will change to be microseconds. Modify to report
			milliseconds as all previous time values are in milliseconds.
			
			PAR 372. Delete class CnNamedPipe. Super-class NamedPipe being deleted by JADE 6.2
			
			Extract 3.2.00b for development use 6Dec06.
			
			NFS. Added CnDiskUsageAdvice and new messaging constants for 'Disk Usage History'.
			
			PAR 370. UE 3201 in KCCMgr when secondary forces hostile takeover. SDS service not running when tracking
			change event caused and connection state is being checked.
			
			PAR 387. Instrumented transaction details could be lost if application never idled before termination,
			application terminated before sample interval occurred, application executed inst trans after sample
			interval.
			
			NFS. Delete verify attribute usage from managed backup processes as KCOnlineBackupWorker always sets this 
			to true. Note that BackupCmd still leaves space where verify used to be to avoid conflict with JSM 3.2
			interfacing to JSA 3.1.
			
			Chg. JADE 6.2 signature change to JadeDatabaseAdmin::rpsStartDataPump required change to method
			CnSDSDatabaseAdmin::cnRpsStartDataPump.
			
			Chg. JADE 6.2 new primitives require changes to stackdump (StringUtf8)
			
			Chg. Implement CnStackDump methods dumpExceptionHandlerStack and dumpExceptionHandlerStack to dump 
			exception handler stack details. Modify CnStackDump::dumpStack to include the exception stack details.
			
			Chg. When SDS backup restored as new system, if the role not cleared and ini file does not have SDS 
			parameters declared, the system would run but not accept any commands from JSA as KCCMgr connection
			logic was getting UE 3201 (SDS not initialized) in sendPingReplyAdvice and getting Ex_Abort_Action.
			
			Cut for qualification and beta release (3.2.00e Beta 1)														30 Apr 07
			
			NFS 402. Provide access to stack dump file name after exception handler forced stack dump and display
			in GUI and Web exception forms displayed.
			
			PAR 403. Handle 1270 exception being incurred by gathering cache statistics.
			
			Fix. When sending versions of binary files, now include versions of database system files (.bin)
			
			Fix. Avoid parsing system.nodes or node.processes where possible.
			
			NFS 418. Methods listed in CardSchema stackdump (exception handler and in call stack) list patch number, 
				 modified date and modified by details. CnStackDump::dumpCallStack call stack methods similarly.
				 
			Cut for first qualification 3.2.00g																			24 Jul 2007
				 
----------------------------------------------   Forked for 3.2  29 Aug 2006 -------------------------------------------------------------
3.1.11		PAR 457. CardSchema singletons being deleted too early, before final application finalize, causing 1090 and 
			nested exceptions.
			
			PAR 479. Large transaction times due to suspending already suspended transaction or 
			resuming already resumed transaction.
			
			PAR 480. AppServerMonitor alias causes pinging to fail for specified AppServerMonitor.
			
			PAR 499. Do checks on SDS Primary that replay timestamp for secondaries connected and tracking is increasing
			if committed timestamp on primary is changing.
			
			PAR 577. KCDatabaseBackup and JADECare managed backups were deriving the abort journal number after backup
			was committed when should be before backup starts.
			
			NFS 578. Allow KCDatabaseBackup to backup journals from archive path in the case when JournalCloseAction 
			is defined as Move.
			
			PAR 544. Provide for KCDatabaseBackup exitcodes of 1 when error has occurred and 2 when completed OK.
			exitcode of 0 indicates unhandled exception.
			
			Cut 3.1.11 for general release.																				22 May 2009

			
3.1.10		PAR 378. Stackdump progress form was not being displayed for thin-clients.

			Cut for release with JSM 3.1.09 																			08 Jan 2007
			
			PAR 381. Re-implement cnGetCommandLine external function from kernel32 to karma library to
			cater for Linux. Utilise in Node::cnGetCommandLine to return command line from
			the appropriate node (database server, application server, thin-client node).
			
			PAR 389. Exception 3074 in KCCMgr when doing dbFile.getFileStatus when mapfile has explicit path
			location and path does not exist.
			
			Check for mapfiles that have explicit paths declared and generate alert warning naming such.
			
			PAR 391. CardSchema::finalize method was prematurely deleting transients as not last 'Application'
			for this process stack when executing application that execute Package methods.
			
			PAR 392. KCDatabaseBackup was not checking for unique environment id at first directory node for Windows
			and 2 node directory for Linux.
			
			JSM PAR 3092. Remote server SOA sending log path which is database server JournalRootDirectory path rather
			than local app server [Cardlog] LogPath.
			
			PAR 394. KCCMgr failing on RPS node due to CnGate class being present and attempt to access instances.
			Modified by making dependent on other than SDS Secondary database role.
			
			PAR 395. WinCE thinclient using app server where binary path defined to be a UNC name highlighted
			situation where incorrent path being checked for fat client vs database server.
			
			PAR 397. Nested suspended transactions could result in elapsed time exceeding Max_Integer value.
			
			PAR 398. Avoid thin-clients doing client binary check (app server vs database server) when using 
			JadeAdmin to maintain application server binaries (app server [JadeAutoUpdate] EnableAutoUpdate=true).
			
			PAR 399. Stackdump taking excessive time when attempting to get size of virtual collections as this
			requires all objects in collection to be referenced.
			
			PAR 406. CnRoot object locked for too long while establishing node control process.
			
			PAR 409. KCDatabaseBackup failing with 1090 as JADE 6.1.10 now compresses journals put into system file
			directory when EnableArchivalRecovery=false.

			PAR 412. CnFtp::cnGetFile is case-sensitive due to emFtpFindFirstFile. Develop CnFtp::cnGetFileBasic which
			avoids using emFtpFindFirstFile. This means that the last modified timestamp of ftp'ed file will not match 
			that of the file on Ftp server and no progress dialog will be displayed, if run from a GUI application.
				
			PAR 415. Allow AppServerMonitor apps to be meaningfully named for view in SystemView form.
			
			PAR 416. CnPingCmd::processMsg was instrumented and shouldn't be.
			
			PAR 420. SDS replay lag check causd 1090 when alert was to be raised.
			
			PAR 391. Further changes to only instantiate CnKarmaCntrl once when using packages and then for the main 
			application for the	process and propagate the values to package applications.
			
			PAR 444. Avoid ObjectArray leak in KCVerifyJournal.
			
3.1.09		PAR 358. CnGate class not deleted as instances exist and referenced by collection.		

			PAR 359. JADE 6.1 changed process CPUTime values from milliseconds to microseconds whereas all other
			times were milliseconds.
			
			JSM PAR 2887. Replace usage of String::cnPadVersion with String::cnFormatVersion to ensure binary and
			library versions are consistent with JSM.
			
			JSM PAR 2925. For Linux only and JADE releases of 6.1, define custom exit value of 32 for JADE
			exception 8525.
			
			PAR 365. CnTransactionstack::delta method code is not deriving max decimal correctly.
			
			PAR 366. Prevent launch of KCVerifyJournal appl on SDS secondary.
			
			PAR 368. Exception 4 in CnNodeControl::establishNodeControl as process in collection no longer exists.
			
			PAR 369. CnStackDump was getting nested exceptions when 5003 exception on file due to property value
			not being initialized and not being available leaving previous value in place and causing 4029 exception
			when typecasting.
			
			PAR 371. Remove/replace usage of unpublished JADE methods.
			
			PAR 373. Identify if server exception handler was invoked or not when 1242 (Method in another node
			aborted) detected by client exception handler.
			
			PAR 374. If, after a negotiated takeover, the primary is cycled, then cluster information is updated so that
			the former primary CnRoot object contains incorrect cluster information. If another negotiated takeover occurs
			so the original primary is again the primary and KCCMgr is not cycled, then the cluster info is incorrect
			should the JSA/JSM or JSA/env connection get dropped.
			
			PAR 376. If <env>_bin.ver file on app server was missing or mismatched database server, SCHEMACP.EXE was
			not being launched. Code missing from CnKarmaCntrl::create has been re-introduced for 3.1.09 and 3.2.
			
			Cut 3.1.09 for release																						01 Dec 2006
			
3.1.08		PAR 352 : change to only show stack dump progress for GUI apps : patched in CnStackDump methods
			::showDumpProgressForm and ::unloadDumpProgressForm.
			
			PAR 353 : patches in CnDatabaseAdmin, and elsewhere to change KCVerifyJournal to be a permanently-
			running process.
			
			PAR 354 : Problem with repeated use of CnLdapEntry::cnGetAllAttributeValues. If multiple values were
			present for an LDAP attribute, then these values were only able to be accessed once.
			
			Added new method String::cnFormatVersion.																	23 Aug 06

3.1.07		PAR 2782 : patch in CnJadeDatabaseExternal::getConnectionState to return exit code 10 when SDS
			secondary not connected to the primary.  This patch requires that the JSA on the host server is
			at level 3.1.07, or has 3.1.06 plus hot fix 2782 installed.													28 Jul 06
			
3.1.06		Production Candidate																						18 Jul 06

3.1.05		Beta #5																										03 Jul 06

3.1.04		Beta #4																										21 Jun 06

3.1.03		PAR 309 : CnLdapEntry::cnClearAttribute method added														14 Jun 06

3.1.02		Beta #2																										31 May 06

3.1.01		Beta candidate #1																							19 May 06

3.1.00		Enhancements:

			-  Deleted unused property CnCntrl::backgroundClientExceptionsOnly and associated references.
			
			-  Added logging of object creationTime to CnStackDump::objVars
			
			Fixes:
			------
			
			PAR 1880 : Added new long date formats for US dates and updated Date::cnUserFormat.
			
			PAR 299	: CnStackDump tries to dump all the properties of an invalid object : patched in
					  CnStackDump::dumpObjVars @ lines 94-97.
			
			PAR 310 : fix for SDSEnvironmentId not defined for KCCMgr in singleUser mode.
			
			PAR 2333 : KCCMgr to detect undefined preferredHost for cluster and terminate during initialize.
			
			NFS 321 : display message box if GUI and node has wrong karma.dll.  Patched in CnKarmaCntrl::create	
			          at about line 282
					
----------------------------------------------   Forked for 3.1  7 Sept 2004 -------------------------------------------------------------

3.0.20		PAR 327 : Fix for UE 14003 when displaying CnMsgForm
		
			
3.0.19		PAR 302 : change logging level in CnKarmaCntrl::handleTranStatsRequestEvent.

			PAR 2286 : Patch in CnTransactionStack::writeLog to correctly form file name at log roll-over.
			
			PAR 309 : Clear existing attribute values when doing an LDAP_MOD_REPLACE.
			
			PAR 312 : lock exception handling in KCOnLineBackup.

			PAR 317 : Non-compliance with RFC 2045 : trailing semicolons after attachment file name.
			Patched in CnSmtpStateDATA::sendFileAttachments and ::sendInLines.  CnSmtpConnection Version 26
			in 3.0, version 27 in 3.1.
			
			PAR 318 : for SDS secondary backups, use abortJournalNo as start log number.  Patch in
			CnDatabaseAdmin::managedBackup.
			
			PAR 320 : defeat lock check reporting on SDS secondary for JadePrimaryServerAgentApp.
			
			PAR 322 : NFS : add signOnUserCode to details of extended lock alarm, in app::cnCheckLockStatus.
			
3.0.18		PAR 297 : exclude .bin files from 6.1.05 database backup : reverse 3.0.17 patch in
			CnDatabaseAdmin::managedBackup.
			
			Removed copyright symbol from CnSmtpConnection class text and schema text, and replaced with (c),
			to address issue encountered when loading the schema into certain Unicode environments.
			
3.0.17		PAR 252 : Remove line nulling sessionHandle from CnInternet::cnCloseConnection : this resulted in
			leaking session handles.
			
			PAR 267 : fix error 3201 in CnSdsAdmin::doSecondaryChecks, during negotiated takeovers.
			
			Patch in CnDatabaseAdmin::managedBackup to include system files in 6.1.03 backups.
			
3.0.16		Patch in CnExceptionForm::load to remove 'write' statement invoked when exception class is
			simply 'Exception'.
			
			PAR 238 : fix bin path comparison in CnKarmaCntrl::create at around line 440, which could result
			in erroneous call to cnGetDriveMapping and downstream Windows error 487.
			
			PAR 243 : change log entries in CnKarmaCntrl::timerEvent to be diagnostic only.
			
			PAR 257 : fix for error 487 in app::cnGetDriveMapping : extend length of allocated string in
			external function cnGetDriveMapping.																		04 Apr 2005
			
3.0.15		PAR 217 : patch in CnKarmaCntrl::zRemoveThinClientFiles to address 'drive not ready' problem
			due to CardSchema looking in wrong drive and directory for obsolete files.
			
			PAR 218 : UE 5003 in Linux : patch in CnCntrl::setOsVersionAndDistro.
			
			PAR 214 : move restart of Tran_Stats_Timer to epilog of CnKarmaCntrl::timerEvent.
			
			Handle UE 3079 (database locked for archive backup) in CnSdsAdmin.
			
			PAR 219 : UE 1035 in WhiteBox : extend CnCntrl::osDistributionEx to 100 bytes.
			
			PAR 221 : UE 4 in ::cnGlobalExceptionHandler during ::finalize : fixed premature deletion of
			CnKarmaCntrl object.
			
			PAR 227 : UE 1300 in CnNodeControl::create : add check to stop scanning command line after endJade.
			
			PAR 230 : KCCMgr being auto-started in single user mode by KCNodeControl : defeated in CnKarmaCntrl::create.
			
3.0.14		PAR 215 : patch in CnSessionOpenAdvice::assembleMsg to only add schema patch info when the
			advice is for KCCMgr itself.
			
			PAR 216 : patch to Object::cnEndTransactionEx to fix negative elapsed times (regression from
			PAR 205).																									06 Oct 2004
			
3.0.13		Changed all global constants in Cn_EventTags category, plus appropriate class constants in
			CnKarmaCntrl and CnCntrl so that eventType values conform to range limitations defined in
			CardSchema User Guide subject 6.3.2 (i.e. where these events may be caused on environmental objects).
			
			PAR 203 : fixes in CardSchema::cnGetClientMiscPath, ::cnGetServerMiscPath, ::cnClientOSPlatformIsWindows
			to return correct path when running under Linux.
			
			PAR 205 : handle wraparound of relativeMachineTime counter in Object::cnEndTransactionEx,
			::cnSuspendTransaction and ::cnResumeTransaction (now discards transaction(s)).
			
			PAR 206 : fix frame mis-alignment on CnDumpForm and replace graphics with smaller .PNG versions.
			
			PAR 207 : handle 3059 exception (database locked for reorg) without passing back to JADE :
			::cnGlobalExceptionHandler now calls ::dumpStack with noDump set, resulting in alert or Tracker fault.
			
			PAR 209 : spurious alert when SDS secondary which was a clone of a clustered primary is sent a
			SessionOpenAdvice request by JSA.  Patch in CnControlCmd::sendKCCMgrSessionOpenAdvice.
			
			PAR210 : UE 1291 in CnKarmaCntrl::startSchemaCpOnFatClient : patch to suppress msgBox display if
			application is not type GUI.
			
			PAR 211 : Patched in CnCntrl, CnNodeControl and CardSchema classes to add new option [JSMStats]
			LogLocalCacheStats, default=false. This option when true enables the logging of cache stats in
			a CSV file for each node, regardless of the setting of KarmaControl.
			
			PAR 212 : Patch in Object::cnAnsiBinary to correctly handle null Unicode string values.						28 Sep 2004
			
3.0.12		PAR 173 : implement retry mechanism when UE 5030 (file in use) occurs when removing scan logs
			in CnDatabaseAdmin::verifyJournal.
			
			Patch CnCntrl::setOsVersionAndDistro to avoid leaking file transient in Windows.
			
			PAR 182 : Add application type Non_GUI_Web as condition in multiple methods.
			
			PAR 185 : UE 4 in CnSessionOpenAdvice::processMsg if submitting process goes away : added new
			exception handler app::cnHandleSpecifiedInvalidObjectRef and armed in ::processMsg.
			
			PAR 187 : Extend CnTcpConnection::computerName from 50 to 64 bytes.  Note : this is current limit
			for FQDN in JSM tool set.
			
			PAR 192 : UE 1291 in CnTcpConnection::user_cnIssueErrorMsg when connection breaks.
			
			JSM PAR 1723 : changed logging in CnTcpConnection::cnListenContinuous to include value of localInterface.
			
			Enhancements to CnSdsAdmin class, to provide phase II SDS monitoring (tracking & connection status).
			This change added a new property to CnRoot, so results in a reorg.											27 Aug 2004
			
3.0.11		PAR 179 : Don't remove deploy.htm in CnKarmaTcpConnection::cnOpenNotify if running singleUser.

			PAR 178 : If KCCMgr node wasn't running KCNodeControl, then other nodes didn't capture node process
			or cache stats.  Patched in CnNodeControl::doSamplingStatusChange.											29 June 2004
			
3.0.10		PAR 172 : KCDummy causing extended lock alarms when server and fat client (clustered) on same host
			but with different binaries path : fix in CnKarmaCntrl::startSchemaCpOnFatClient.
			
			Fix UE 4035 in JSM triggered by badly-formed thinClientComputerName field in ExceptionAdvice message.
			Patches in CnExceptionAdvice::assembleMsg and ::loadMsg.												
			
			For management apps, override DefeatNodeSampling option (to false) in CnKarmaCntrl::create.				
			
			PAR 174 : Patch for UE 1090 in CnControlCmd::issueKCCMgrSessionOpenAdvice									17 Jun 2004
			
3.0.09		Changed sampling options setup in CnCntrl::setupControlOptions so that [JSMStats]DefeatNodeSampling
			defaults to TRUE.																							11 Jun 2004
			
3.0.08		PAR 167 : patched CnDatabaseAdmin::sysNotification to handle variable order of notes when
			interrupting backup on fast machine.																		02 Jun 2004
			
3.0.07		PAR 163 : UE 1090 in CnKarmaCntrl::handleTranStatsRequestEvent on finalize when KarmaControl=true
			and running singleUser and SamplingNode=true : fix in ::handleTranStatsRequest event and
			improve logging of establishNodeControl call in CnKarmaCntrl::create.
			
			Enhance app::cnComputerName to return NO_COMPUTERNAME when app::computerName returns null (JADE
			PAR 34058).
			
			Patched ::cnGlobalExceptionHandler to return Ex_Abort_Action for thin client UEs 14143 and 14147.
			
			PAR 164 : Patches in CardSchema::cnGetApplicationType and CnKarmaCntrl::sysNotification to handle
			application type Non_GUI_Web correctly.
			
			PAR 166 : Broad range of patches to implement node stats capture for server apps and singleUser
			apps.  Mainly in CnKarmaCntrl, CnTranmsactionStack.															27 May 2004
			
3.0.06		PAR 161 : fixes to Object::cnStartTransaction and ::cnEndTransactionEx to prevent UE 1090 when
			running with KarmaControl=false.
			
			Fix UE 4 in CardSchema::cnFinalizeKCNodeControl.															21 May 2004
			
3.0.05		JSM PAR 1597 : fix to ::cnRaiseJossAlert to fix duplicate alerts caused by 3.0 regression.

			PAR 159 : fixes to CnExceptionAdvice to allow reporting thinClientComputerName in Tracker reports,
			also changed in CnStackDump::reportException.																18 May 2004
			
3.0.04		PAR 157 : Changes to CnDatabaseAdmin class to only set up progress event interval based on
			largest map file, at start of backup.
			
			General release.																							10 May 2004	
			
3.0.03		Production Candidate	16:30 21/4/04																		21 Apr 2004

3.0.02		UAT Cut #2																									02 Apr 2004

3.0.01		First UAT cut.																								02 Mar 2004

3.0.00a		Source forked 10 June 2003, for Unix / Linux portation :

				-  CnMessage and subclasses changed to handle disparate byte ordering
				
				-  Changes to CnKarmaCntrl::create, to handle Unix differences
				
				-  Changes to other CnKarmaCntrl methods to handle Unix file paths
				
				-  New method app.cnGetPath, new attributes app.cnOSArchitecture, cnOSPlatform
				
				-  Changed ::CnMessage::buildMsg to set up protocolVersion and architectureRemote.
				
			Some other features (see release notes for complete list):
				
				-  CnKarmaCntrl::create now deletes old thin client deployment files and
				   updates ini file InitializationHandlerLibrary specification if necessary.
				
				-  Dynamic node sampling
				
			PAR 85 (NFS) : ::cnGlobalExceptionHandler now merely logs error 14144 and returns
			Ex_Abort_Action, to avoid production of unwanted application call stack dumps.
			
			CnFtp::cnGetFile has new parameter usePresentationFileSystem, used to define
			output file location.
			
			CnKarmaCntrl::create now always sets up CnRoot singleton, regardless of setting of
			KarmaControl option in ini file.  Addresses 1090 problem in KCOnLineBackup.
			
			CnSmtpConnection Class Version 24
			---------------------------------
			Bug fixes:
			
			If the message was being read from a file, and an exception occurred, the file was not closed.
			Send RSET after getting validation error in DATA state.
			
			NFS:
			
			Allow file attachments of zero length.
			Allow user to specify whether an attachment file is on the presentation client or the app server
			(new attribute physicalFileLocation on CnMIME class).
			Optionally disconnect TCP/IP when a validation error occurs. This ensures that the whole message,
			with attachments, gets aborted (new attribute disconnectOnValidationError on CnSmtpConnection class).
			________________
			
			CnDatabaseAdmin class changed so that when abnormalTermination flag is set, no further map files
			will be processed by any worker thread.
			
			NFS : CnStackDump::stackStartIndex allows developer to specify starting stack position for
			dump.  If zero, then CardSchema default values are used.
			
			PAR 1206 (JSM) : patch CardSchema::cnInitializeOnLineBackupWorker to handle exception after exclusive
			lock of shared transient CnDatabaseAdmin, instead of checking for valid object.
			
			PAR 111 : in ::cnCheckForTransients extend list of classes that can have singletons that don't get
			logged.
			
			Recoded references to process.adminInfo that were being used to derive application name, to use
			process.persistentApp.name.  However process.adminInfo remains in use to store System_Stopping
			state information.
			
			Multiple patches to CnDatabaseAdmin to address journal roll over issue, and timing issues
			which caused exceptions when backups were interrupted.
			
			Added new CnInternet method emInternetSetNumericOption and clas constants.

-----------------------------------   CardSchema 3.0  --------------------------------------------------------

2.9.65		PAR 101 : add conditions to display of msgBox in CnTcpConnection::cnOpen.

			Fix handling of systemShutDownEvent in CnCntrl::userNotification and
			app::cnHandleSystemShutDownEvent.
			
			PAR 104 : Patch to CardSchema::cnPurgeFileTransientsColl and ::cnPurgeFileTransientsExHandler to
			correctly handle subclasses of JadeLog.
			
			PAR 1311 : productionMode not reported when JSA bounced : fix in CnControlCmd::sendKCCMgrSessionOpenAdvice.
			
			PAR 119 : KCDatabaseBackup failure when EnableArchivalRecovery=false : patches in CnDatabaseAdmin methods
			::userNotification, ::backupLogFiles, ::getLogNumberFromFileName.
			
2.9.64		Add logging in ::initializeKCOnLineBackupWorker to log fact that worker is
			terminating due to no more map files.
			
			Changed CnDatabaseAdmin::backupDbFile to enforce verifyCheckSums operation.
			
2.9.63		Added explicit open to output file in CnFtp::cnGetFile.
			Patch to CnMessage::receiveMsg (PAR 77) to fix up clientFQDN when received from a
			client via shared memory transport.
			
			PAR 83 : thin client using UNC name in binaries path terminates in CnKarmaCntrl::create
			after error 1200 from cnGetDriveMapping.  Patched CnKarmaCntrl::create.
			
			PAR 80 : change app::cnCheckForTransients to exclude app.class.name and JadeLog
			(app.myCnLog).
			
			PAR 82 : allow KCOnLineBackup and worker to run correctly when KarmaControl=false :
			patch for 1090 error, in CnKarmaCntrl::create.
			
			Patch to CnDatabaseAdmin::managedBackup to close timing hole between getAllDbFiles
			and ::beginBackup.																							30 Jul 2003
			
2.9.62		Patches for 1072 in ::cnPurgeFileTransients.  Cut for production.											20 Jun 2003

2.9.61		Version for JADE 6.0 (6.0.16.8 minimum)																		13 Jun 2003

2.9.60		Version for JADE 6.0 (6.0.16.7 minimum)

2.9.00		Development Version.

			Deleted CnAlertAdvice class (obsolete).

			Patch in CnStackDump::dumpStack to fix intermittent duplicate line at end of
			localVars in dump.
			
			NFS 591 : app server with no version control files now creates dummy ones and
			initiates schemacp.exe.
			
			Preparatory changes to messaging classes to handle JADE 6.0 licencing.
			
			PAR 33 : Changed CnDatabaseAdmin::copyFilesFromDirectory to ignore ALL .tmp
			files (previously only ignored tmp files in system directory).
			
			CnFtp::cnPutFile now only waits 1 second after closing file before attempting to
			close the connection.
			
-------------------------------------  CardSchema 2.9  -----------------------------------------------------

2.8.13		Patched CnKarmaCntrl::userNotification to avoid use of cnGetIntegerConstantName,
			because of performance issues with deep schema hierarchies.
			
			Object::cnStartTransaction and associated methods now explicitly clientExecution.

			Fix MethodCallDesc leaks in methods that call Process::currentStack.
			
			CnSmtpConnection Class Version 23 : move 'MIME Version 1.0' statement to main message
			header, as per RFC 1521. The incorrect location of this statement caused problems
			when opening attachments in Novell GroupWise.
			
			PAR 38 : change to CnKarmaCntrl::create to use GCardSchema (global) as single-threading
			target instead of currentSchema's global.
			
			PAR 43 : relax recursion check in CardSchema::cnGlobalExceptionHandler.
			
2.8.12		Recut to fix errors in two methods introduced by above global change, found during
			Qual.
								
			Updated V3 of CnSmtpConnection::resetConnectionObject added.												20 Jan 03
			
2.8.11		PAR 28 : Change CnSchemaCopyCmd::processMsg to perform case-insensitive comparison of
			server vs. client bin directory, if client is on same computer as server.
			
			Change all uses of "global." (typically global.isValidObject) to use transient
			instance of GCardSchema : CnCntrl.myTransientGlobal.  Affected 70 methods.  This
			was done to address locking issues and 1092 problems with cnGlobalLockExceptionHandler						20 Jan 03									20 Jan 03				
						
2.8.10		Changes in cnGlobalLockExceptionHandler, cnShowLockErrorMessage and new method
			cnMsgBoxClient, to ensure any message boxes displayed during lock exception
			handling in server methods are displayed on the client.
			
			Moved emIsService check in CnKarmaCntrl::create to be after karma.dll presence
			checks.
			
			Delete PropertyColl transient in CnStackDump::dumpObjVars.
			
			CardSchema::userNotification logging moved into event handling code, to avoid
			illegal typecasting of userInfo if userInfo is an object ref.
			
			Further fix in CnKarmaCntrl::getAddressInfo to fix problem with app server application
			when using shared memory transport.
			
			PAR 24 : Fix for 1035 in CnKarmaCntrl::getBinariesInfo when file is read only : set
			file mode to Mode_Input.
			
			Added File::cnGetFileLength to get sizes of files > 4 GB.
			
			Changed signature on Binary::cnConvertNullsToQueries to pass stricter JADE edits.							17 Jan 03
			
2.8.09		Fix in CnStackDump::dumpStack to log last line of local vars before starting
			dump of receiver details.
			
			Patch in CnKarmaCntrl::getAddressInfo to detour loop in emGetHostByAddress when
			using shared memory RPC (JADE PAR 25419).
			
			Patch in CardSchema::cnRaiseAlert and ::cnRaiseJossAlert for same reason.
			
			Change signature of CnTcpIpConnection::user_cnTcpRestart to allow user to specify
			exception return code.
			
			Patch in CardSchema::cnTcpExceptionHandler to add handling of error codes in
			range 10048 to 10061.																						17 Oct 02
			
2.8.08		Fix 1035 in CnClusterInfo due to serviceName field : was 30 bytes now 256.
			Remove tran stats instrumentation from CnMessage::receiveMsg.						
			CnCntrl::checkTransientsOnShutDown now defaults to false.													18 Sep 02
			
2.8.07		SARMS fault #1314 : error 4 in GCardSchema::cnGetUserprocess : method now checks
			for valid object.
			CnSchemaAnalyzer::countSourceLines now excludes lines starting with "//".									11 Sep 02
			
			--------  Forked for 2.9 Program  --------
			
2.8.06		Add new method app::cnGetApplicationVersion, now used by stack dumper.  Can be
			reimplemented in subschemas.																				06 Sep 2002
			
2.8.05		Fix problem in CnCntrl::setupControlOptions where wrong ini file name was used when
			accessing setting for ClientTranStats on thin client.							
			Cut for production.																							27 Aug 02
			
2.8.04		Changed CnSkinsLoader::reload to validate length of skin name.

			CnSmtpConnectionClass Version 22 :
			---------------------------------
			New attribute CnSmtpConnection.removeStatesOnDeletion. If this attribute is set to true,
			it will cause the CnSmtpState objects to be removed when the CnSmtpConnection
			object is deleted. See SMTPClass.doc, Section 7 for more details.
			CnSmtpConnection::cnCloseNotify has been reimplemented, and the completion notification
			is now sent from this method. Previously, the notification was sent from the state machine.
			t was possible to get into a situation where the notification arrived before the
			cnCloseNotify. If the user then deleted the connection object, JADE was unable to
			perform the callback. The result was that JSM Start did not log a "successfully closed"
			message.
			
			Increased number of AppServerMonitorXX applications to 50.
			
			Cut for production.																							20 Aug 02
			
2.8.03		Production Candidate Release																				13 Aug 02

2.8.02		Cut for JUO UAT																								05 Aug 02

2.8.01		Cut for JUO UAT																								24 Jul 02

2.8.00		New features :

			-  Changes for Microsoft cluster support (CnSessionOpenAdvice etc).
			
			-  KCCMgr now captures and reports JADE licence expiry date, app versions,
			   binary versions etc.
			
			-  KCCMgr now captures database type (deployment or development).
			
			-  Apps now report application version info, computerName.
			
			-  CnFtp class now also supports passive mode FTP connections
			
			Bug fixes / changes:
			
			-  Fixed CnSchemaCopyCmd::processMsg so that non-GUI app (AppServerMonitor) doesn't
			   display download message.
			
			-  Refactored Object::cnGetIntegerConstantName to search initially in current schema
			   then successively through superschemas until constant category is found.
			
			-  App::cnActivateKarmaCntrl now explicitly clientExecution.
			
			-  CnKarmaCntrl::create now compares binaries path of client and server as well as
			   computer name in order to determine setting of clientOnServer boolean.  This is
			   to ensure that schemacp.exe gets initiated when an app server has its own binaries
			   yet is on the same computer as the server.
			
			-  Changes to CnMessage to support new BackupSpecCmd.
			
			-  cnGlobalExceptionHandler no longer attempts to take stack dump for 1209 exceptions
			   (application terminate request - JADE internal error).
			
			-  KCCMgr now uses timers to schedule application launches from ini file.
			
			-  CnDumpForm now uses ini file option to control which graphic is displayed
			   (the green frog returns !). Re-implementable method app.cnGetExceptionDisplayPicture
			   allows user to provide own graphic.
			
			-  CnStackDump now only takes minidump for 1018 (no memory for buffers). ErrorItem display
			   now taken outside of loop through stack array.  Method parameters and local vars of
			   type PrimType now truncated after first 100K bytes.
			
			-  cnGlobalExceptionHandler now detects recursion, and returns Ex_Abort_Action
			
			-  CnSmtpConnection Class Version 19 : Ensure Base64-encoded lines do not exceed 76 characters
			   when new attachment block is read. Most email clients seem more tolerant of longer lines,
			   but Novell GroupWise is not.  In	CnSmtpStateDATA::sendFileAttachments (V6).
			
			
------------------------------   Forked for 2.8  -----------------------------------------								04 Mar 2002

2.7.22		Replace use of ProgressDialog with CnProgressDialog.  This patch addresses three
			problems:
			
			1.  The RootSchema ProgressDialog in 5.2 used app.doWindowEvents which can
			    cause unwanted side-effects during exception handling
			
			2.  The RootSchema ProgressDialog's cancel button results in a display of a
			    confirmation message box.  An abortTransaction had not been performed
			    at that point, and if users left this dialog on the screen the system
			    could hang up.			
			
			3.  CardSchema::cnGlobalLockExceptionHandler was not releasing locks
			    before showing the Lock Retry Limit Exceeded dialog.  If users left
			    this dialog on the screen then the system could hang up.												14 May 2002
			
			
2.7.21		Changes to CnStackDump::dumpStack to handle null targetLockedBy situation.
			Fix regression in Object::cnExTransactionEx introduced in 2.7.19, to get
			correct stats timings (change local variable back from Decimal to Integer)	    							12 April 2002

2.7.20		Fixed CnTcpConnection::cnProcessHeader to return message body length where
			a null preamble is used with a headerLength > 0.
			Change CnStackDump::dumpStack to always do full stack dump for CardSchema apps.
			CnSmtpConnection version 18 : now allows user to set shareMode property of
			attachment file.																							12 Feb 2002
			
2.7.19		Only show version mismatch form if application type is GUI, or if CnCntrl
			suppressManagementDialogs=true, in CnKarmaCntrl::create.
			Added print of app.userName in CnKarmaCntrl::create and CnStackDump::dumpStack.
			Added new transaction statistics capture methods on Object : cnSuspendTransaction,
			cnResumeTransaction, cnDiscardTransaction.																	31 Jan 2002
			
2.7.18		Changes in CnDatabaseAdmin::userNotificationManaged, ::closeTranlogAndAdvise
			and app::cnIntializeOnLineBackupWorker to ensure that correct log to be backed
			up is advised to KarmaBackupMgr if JADE does a log switch when commitBackup is
			performed.																									21 Jan 2002
			
2.7.17		Fix 1406 error (integer overflow) in CnTransactionData::handleTranStatsSubmissionEvent.
			Change CnStackDump::dumpStack to always perform full stack dump for CardSchema apps.
			Changed cnGlobalExceptionHandler to include app server name in alerts for
			application exceptions if thin client is in use.
			Fix CardSchema::cnCheckForTransients and zLogTransientDetails to clear collection
			before re-use.
			CnDatabaseAdmin::managedBackup change to assume that backup destination dirs were
			created and cleared by JSA (BackupMgr).
			Reworked app::cnGetClassAndOid to fix 1046 exceptions due to use of transient
			classes by ReportWriterSchema.
			Change references to currentSession to use app.ApplicationType_Web_Enabled, for
			more reliable web app identification.
			CnTransactionStack::writeLog method now explicitly clientExecution in order to
			allow for cnStartTransaction/cnEndTransaction pair in a server method.
			Changed CnKarmaCntrl::handleTranStatsRequestEvent to adhere to 48K limit for
			notification string size and to raise alert if data is truncated.
			Changed CnDatabaseAdmin::backupExceptionHandler to preevent nested exceptions if
			CnJadeDatabaseAdmin object is not valid.
			Added diagnostic to CnJadeDatabaseAdmin::delete to dump call stack, to track
			down intermittent 1092 in KCOnLineBackupWorker when backup is aborted.
			Changed CnDatabaseAdmin::userNotificationManaged to use local var cdba2
			instead of reusing cdba (precautionary only).
			Changes to cnGlobalExceptionHandler to deal with 1242 (remote node) exceptions
			more elegantly, and to handle licence breach exceptions for web apps.  Also
			changed app::cnShowExceptionWebForm code as part of this.
			Changed cnGlobalExceptionHandler to fix nested exceptions problem when
			handling 1200 error (class needs reorganisation).								
			Cater for SMTP recipient string that ends with a semicolon (e.g. fbloggs@jade.co.nz;)
			The string should not end with a semicolon, but if it did, it caused an index
			exception. Fix in CnSmtpConnection::parseRecipients.														16 Jan 2002
			
2.7.16		CnCntrl::Default_LogFileMaxSize increased from 100KB to 1 MB. Ini files
			with old default will be upgraded to new default by CnCntrl::setupControlOptions.
			CnKarmaCntrl::create now suppresses logging to interpreter window if running
			as a service.																		
			Fix to CnJadeSkinsLoader::unload to close file after unloading each skin.
			Purge locks in array in ::cnCheckLockStatus, MethodCallDesc objects in
			ProcessStackArray in CnStackDump.																			03 Oct 2001
			
2.7.15		Change to CnCntrl::setupControlOptions so that KCCMgr and JossCommsMgr always
			set [PersistentDb] BackupThreadPriority=Lowest (fault #255).
			Patch to CnControlCmd::processMsg to handle error 4 when KCCMgr told to shut
			down.
			Patch to CardSchema::cnIsAppRunning to remove sensitivity to invalid object
			references (added ::cnHandleInvaldiObjectReference method).													13 Sep 2001
			
2.7.14		Fix 1090 in CardSchema::sysNotification when cnProcessesWithNoLockChecks=null.
			Changed CnStackDump::dumpStack to write process.networkAddress into dump
			header for thin client (was previously using kc.thinClientComputerIpAddress).
			First general release for 2.7.																				05 Sep 2001
			
2.7.12		Changed global constants used for System events to values in 550001xx range.
		    Moved subscriber to CN_WRITER_SERVER_LOG to CnKarmaCntrl and CnJossCntrl.			
		    Production cut.																								24 Aug 2001
		
2.7.11		Added ::cnWriteServerLog on app.
			Modified CnStackDump::dumpCallStack to allow specification of server or client log.
			Enhanced ::dumpStack to dump bottom of stack method receiver.
			Enhanced exception handling in CnDatabaseAdmin to handle issues arising from
			aborted on-line backups.			
			Production candidate cut.																					23 Aug 2001
			
2.7.10		Added LogMiniDumpForLocks option.
			Changes for backup fixes.
			Release to UAT																								17 Aug 2001
			
2.7.09		Added code to CnMsgForm::bClose_click.
			New class constants on CnMessage for backup.
			Release to UAT.																								14 Aug 2001
			
2.7.08		Remove profiler code from cnGlobalExceptionHandler.
			Replace crying frog on exception handler form.										
			Release to UAT.																								30 July 2001
			
2.7.07		Changed global::cnGetUserprocess to use iterators, to reduce window for
			locks or deadlocks.
			Added ::cnCheckLockStatus and properties to app.
			Added cnCheckShareLocks to app.
			Addded handling for ServerApplications in [Karma] section of ini file,
			CnCntrl::startUserServerApplications.
			Performance enhancements to stack dump.
			Changes to CnMessage and subclasses to better support machines not in our DNS.
			Release to UAT.																								20 July 2001
			
2.7.06		Enhancements to cnGlobalLockExceptionHandler.  New property on app
			cnIsForegroundClient, new method cnShowLockErrorMessage.
			Patched CnDatbaseAdmin::prepareBackupDirectories to ensure that files in
			cnwbackup environment base directory are also removed.
			Release to UAT.																								09 July 2001
			
2.7.05		Fix to cnGlobalLockExceptionHandler to avoid 1090 when in tryLock loop and
			le.lockTarget is null.
			Multiple UAT fixes.																							03 July 2001
			
2.7.04		Patches to app::cnGetDriveMapping and CnKarmaCntrl::create to fix directory
			(drive letter) problem when thin client has karma.dll.
			Refinements to CnKarmaCntrl::startSchemaCpOnFatClient to log details of which
			process has CnGate locked when multiple apps starting, and relaxed the locking of
			CnRoot in same method.
			Fix FileNode::cnGetSimpleFileName for directory names with trailing delimiter.
			Loaded CnSmtp version 16.
			Released as UAT patch consolidation.																		26 June 2001
			
2.7.03		Added CnCntrl.logEntries and modified cnWriteLog method so that committed	
			writes take place at least every 20 entries.
			Changed Object::cnEndTransactionEx to use timestamp from app server's clock.								05 June 2001
			
2.7.02		Changed cnStartTransaction to return transaction tag.  New method
			cnEndTransactionEx to allow passing tag.											
			Added new method Method::cnGetPriorMethod.
			Patched File::cnGetFileInfo to use external method for app server files.									21 May 01
			
2.7.01		Full UAT version.																							24 Apr 01

2.7.00k		Added CnFtp::emFtpFindNextFile, made emFtpFindFirstFile public.
			LDAP classes v.4 : Close connection if handle is still non-null
			(i.e. connection is still open).
			Beta release to JDO.																						02 Apr 01
			
2.7.00j		Added cnSystemType to application class.

2.7.00i		Changed CnDatabaseAdmin::finalize to fix update when not in tran state when
			deleting self or self.myLog.
			
			Fix in TimeStamp::cnSecondsDifference for integer overflow problem when days
			difference > 28.
			
2.7.00h		Alpha test version for JDO.																					20 Nov 00

2.7.00		Fork for CardSchema 2.7 - Development Version												10 Aug 2000

			Patches
			-------
			
			- SMTP classes updated for Unicode
			
			- CnStackDump progress methods updated to not show form if application type is
			  Non_GUI (fix 14003 errors in JADE 5.1).
			  Also updated CnKarmaCntrl::displayClientStartupProgress for same reason,
			  Also updated cnGlobalExceptionHandler for app type Non-GUI.
			
			- Fix JadeDatabaseAdmin::cnGetMapFileInfo to correct 3054 error.
			
			- Fix CnKarmaCntrl::startSchemaCpOnThinClient to handle unicode commandline.
			
			- Changed CnStackDump::dumpStack to add process instance id to dump file name, to
			  fix problem where two simultaneously dumping processes use same file.  Also,
			  if dumping process uses thin client then computer name is now part of dump file name.
			  Millisecond part of dump file name now has leading zeros padded.
			
			- Stack dump now adds obect edition and collection size where applicable.
			
			- Changes stack dump procedures to avoid creating progress forms when 14063
			  exception (Window create failed) occurs, to enable taking stack dump.
			  cnGlobalExceptionHandler now passes this type of exception back to JADE
			  once the stack dump has been taken.
			
			- Fix problems when running non-GUI app in JADE.EXE, where app attempts to
			  doWindowEvents or perform form methods in the following methods :
			  (JADE 5.1 introduced stricter rules here) :
			
			  	- CnInternet::delete
			  	- CardSchema::cnInitializeKCCMgr
			  	- CnFtp::cnGetFile
			  	- CnFtp::cnPutFile
			  	- CnHttp::cnGetFile
			  	- CnKarmaCntrl::userNotification
			  	
			 - Add ::endTimer call to CnControlCmd::processMsg to address possible 1400
			   exception when changing tran stats timer interval.
			
			 - CnCntrl::cnWriteLog now pads leading zeros in the millsecond part of log entry
			   time stamps.
			
			 - CardSchema log for thin clients now uses app server's clock for timestamps
			   in log entries.
			
			 - TimeStamp::cnZeroSeconds no longer erroneously modifies self.
			
			 - App::cnGetServerMiscPath no longer serverExecution.
			  	

			New features:
			------------
			
			- KCOnLineBackup application for on line and quiesced backups under JSM control.
			
			- CardSchema::cnSetExceptionHandlerType allows developer to override ini file setting.
			
			- cnGlobalDeadlockExHandler extended to handle deadlocks originating from any
			  event, not just Form or Control events.  New classes CnDeadlockHandler, CnVariant,
			  CnVariantArray.
			
			- CnStackDump class has new method dumpCallStack for taking call stack snapshot from
			  any method.
			
			- CnFtp::renameFile method, signature change on CnFtp::cnPutFile.
			
			- CardSchema::cnRemoveDirectory method.
			
			- CnCntrl::cnWriteLogCommit committed write, cnWriteLog now does cached write.
			
			- Added property cnPort to CnTcpConnection class and changed CnTcpConnectionDict
			  to use cnPort instead of TcpIpConnection.port.  TcpIpConnection.port may become
			  a virtual property in JADE 5.2 as part of move to allow TCP shared transients.
			
			- New option in CardLog section of ini file LogNamesUseIPAddress which if true in
			  app server's ini file will use thin client IP address in log file name
			  instead of computer name.  No effect for fat clients.
			
--------------------------------------------------------------------------------------------------------------

2.6.100		Unicode/ANSI version, forked from 2.6.51.

--------------------------------------------------------------------------------------------------------------
			
2.6.52		Changed exception handlers to use abortTransientTransaction instruction.
			Changed cnGlobalExceptionHandler to upperCase the environment id when raising
			alert to JSM.
			Changed cnGlobalExceptionHandler to not show exception form if application type
			is Non_GUI.
			Changed cnGlobalExceptionHandler not to dump if error is thin client errors
			14135 thru 14149. Also checks that app.myCnCntrl object is still valid before
			attempting to log.
			Changed CnFtp::cnGetFileInfo to handle file names containing spaces.
			
2.6.51		Added CardSchema::cnInitializeAppServerMonitor and new apps AppServerMonitor1-5,
			for use by JSM when monitoring app servers.
			Fixes to CnDatabaseAdmin to fix exceptions when backing up a database when
			EnableArchivalRecovery=false.
			
2.6.50		Patches to app::cnInitialiseKCDbBackupWorker and CnDataBaseAdmin for 5.1
			changes.  Removed JadeLog::initialise and ::resetOptions method calls.
			CnBackupCmd & CnBackupAdvice classes added for 2.7.									12 July 2000
			
--------------------------------------------------------------------------------------------------------------

2.6.03		Add serverType to CnInternet.  Change CnFtp::cnGetFileInfo to handle serverType=
			Server_Type_Novell.	
			
2.6.02		In CardSchema::finalize, move delete of CnKarmaCntrl to be AFTER cnCheckForTransients
			to avoid nested exceptions if a stack dump that occurs during check for transients.
			Loaded new version of SMTP classes, moves CnAttachment from subclass of Object.		11 July 2000
			
2.6.01		First production candidate, relative to 5.0.16.										28 June 2000

2.6.00i		Patch in CnSchemaCopyCmd::processMsg to avoid initiation of KCSchemaCopy if
			process is running out of server binaries on server machine.

2.6.00h		Patches in CnMessage::sendMessage to handle JossCommsMgr send to self.				21 June 2000

2.6.00g		Fix CnSchemaCopyCmd::processMsg to not start KCSchemaCopy if KCDatabaseBackup or
			KCDbBackupWorker.
			CnFtp::cnPutFile signature change to add usePresentationFileSystem.
			New method cnShowExceptionWebForm on app to allow reimplementation by subschemas.

2.6.00f		Fix Object::cnSetTransactionError to return if not capturing stats.					09 June 2000

2.6.00e		Removed diagnostics in cnCheckForTransients.
			Changed signature on cnRaiseNormalException.										08 June 2000

2.6.00d		Changed maxArrayElementsInDump default to 100 (was 500).  Reworked CnStackDump::dumpArray
			to improve performance.
			Changed CnCntrl::cnWriteLog to limit log entry to 9920 bytes as detour to JADE limit/bug.
																								02 June 2000
2.6.00c		Rework various methods in CnDatabaseAdmin class to ensure that backup failure is
			logged and alerted in a consistent manner.
			Fix CnStackDump::dumpStack to report oid in localVars the same way as dumpObjVars does.
																								27 May 2000

2.6.00		Dev sources forked from 2.5.03 18 January 2000.
			CnLdap classes updated to LDAP Classes Version 2:
		 	-  Changes to handling of CnLdapSyntax object
		 	-  Changes for case-sensitivity in CnLdapSyntax, CnLdapEntry and CnLdapAttribute.
		 	Change signature of external function cnGetEnvironmentVariable to allow
		 	specification of maxLength for returned string. Update app.cnGetEnvironmentVariable.
		 	Changed Object::cnGetInstanceId to use reversePos method.
		 	Added new option in CardLog section : CheckTransientsOnShutDown, changed app::finalize.
		 	CnStackDump modified to create new dump file for each stack dump.
		 	Changed app.cnCheckForTransients, added new method zCnLogTransientDetails, to make
		 	transient checks more comprehensive, and to improve check performance.
		 	CnGate class added for use in CnKarmaCntrl::startSchemaCpOnFatClient, to ensure that
		 	only one process on a node starts schemacp.exe.
		 	New ini file option ExceptionHandler=JadeDebug, to allow catch of exceptions in non-GUI apps
		 	when in development mode.
		 	Changes to all methods using CnKarmaCntrl::fileExceptionHandler, to reset fileRetryNo where
		 	appropriate.
		 	CnMessage::Current_Protocol_Version set to 8, for v2.6.
		 	Enhanced CnStackDump to correctly dump methods that were called recursively in the stack.

---------------------------------------   Version 2.6   --------------------------------------------------

            for on-line backups.																17 May 2000					

            Tightened editing on ini file backup destination root directory specification
            handler for FileBackupCompletedEvents to handle dbFile not found on getFileLength.	
            on line backups.  Change to CnDatabaseAdmin::userNotification to arm exception
            cnGlobalExceptionHandler change to pass back 3036 exceptions encountered during
            cnDeadlockExHandler enhanced with added diagnostic log entries.	
            ini file), getting deadlock between Process and ProcessNDict.						
            multiple apps started simultaneously (e.g. via ServerApplication statements in
2.5.12		GCardSchema::cnGetUserProcess : address problem where deadlocks occurred when
2.5.11		CnSmtpConnection Class Version 11 : Changes to cater for text lines that
		    straddle two blocks.																31 Mar 2000

2.5.10		Change CnCntrl.logFileName to length 50.  Change CnCntrl::setLoggingDefaults to
			set correct default logfile name in ini file if thin client.						24 Mar 2000

2.5.10		Change CnCntrl.logFileName to length 50.  Change CnCntrl::setLoggingDefaults to
			set correct default logfile name in ini file if thin client.

2.5.08		Modify global exception handlers to commitTransientTransaction as part of aborts.
			Add new dummy methods Object::cnStartTransaction and ::cnEndTransaction ready
			for CardSchema v2.6.
			Enhance app::cnCompareFileVersions for better diagnostics when directory access
			errors, and to avoid downstream 1090 error if access errors occur.
			Changes to CnStackDump::dumpStack and cnGlobalExceptionHandler to take minidump
			and return standard values based on ini file setting for ExceptionHandler when
			4021 or 4035 errors occur, rather than simply returning Ex_Abort_Action.			
			Add endTimer to CnExceptionForm::unload.

2.5.07		Remove unnecessary resynch(process) from CardSchema::cnIsAppRunning.
			Changes to CnKarmaCntrl::fileExceptionHandler to provide retry count.  Change
			to CnDatabaseAdmin to retry copy of transaction log when in use due to
			verify after release.																09 Mar 2000

2.5.06		Patches to cnGlobalLockExceptionHandler and cnGlobalExceptionHandler to address
		    problems with lock exceptions where lockTarget is node or global.
		    LDAP Classes Version 3 : Changes to CnLdapEntry::cnAddMultiAttribute (V2):
			Use array copy instead of array cast, to avoid truncation.
			CnKarmaCntrl.environmentId extended to 30 bytes for non-managed applications.
			Fix error msg for no server binaries version control file found, in CnKarmaCntrl::create.
			Fix bug with start of schemacp.exe in CnKarmaCntrl::startSchemaCpOnThinClient.		21 Feb 00

2.5.05		Fix cnGlobalExceptionHandler and cnRaiseAlert to correct exception reporting problems
			where an application exception triggered a 'nested exceptions exceeded' error, because
			CardSchema encountered exceptions when trying to report the original exception to
			the JADE Systems Manager.

2.5.04		Remove redundant setup of deadlockRetryLimit in CnKarmaCntrl::create.
			Add new methods to app to detour 5030 errors with File::lastModified in 5.0.15 :
			cnFileLastModified, cnFileInUseExceptionHandler, cnGetServerFileVersions,
			cnCompareFileVersions, cnGetServerFileLastModified.

2.5.03		Patch to CnKarmaCntrl::userNotification to fix problem with server application
			attempting to display deployment notification form (CnMsgForm).
			Patches to app.cnAppIsRunning to lock objects.
			Patches to app.cnInitializeKCDatabaseBackup to allow only one copy to run.
			Corrected application type on KCDbBackupWorker to be GUI-NoForms.
			Patch to CnDatabaseAdmin::raiseAlert to issue notification for JOSS ( via System)
			if backup fails for environment whose name includes 'JOSS'.
			Added external function cnGetCommandLine.
			Changed CnKarmaCntrl::startSchemaCpOnThinClient to use cnGetCommandLine rather
			than derive command line as previously done.
			CnCntrl::cnWriteLog now unlocks log lock record in epilog, and logs name of
			application which initiates logfile rename operation.
			CnLdap class updated to 26.11.99 version.
			Patches to CnKarmaCntrl::create to undo prior patches detouring isMultiUser bugs
			in JADE versions prior to 5.0.15.

2.5.02		Patch to CnKarmaCntrl::create and ::setEnvironmentId to allow use of 				20 Dec 99
			KCDatabaseBackup application when KarmaControl=false.
			Patch to CnKarmaCntrl::create to set up cnIsServerApp based on execution
			location only, as detour to JADE bugs with isMultiUser (see PARs 15248, 13615, also 15510),
			also set up cnIsServerApp prior to arming any exception handlers.
			CnSmtpConnection Class: Version 10 When CnSmtpConnection::genDate builds the date
			in the message header, it now includes the time differential from GMT.
			Example: Date: Thu, 16 Dec 1999 09:34:37 +1300

2.5.01		Internal production candidate														10 Dec 99

2.5.00		Version 2.5 Development Version.
			New global constants.
			Extensive changes in CnMessage subclasses to support feature content in Joss 2.5
			Revised app::cnRaiseJossAlert - new signature
			New method TimeStamp::cnSecondsDifference
			New methods TimeStamp::cnGetGMTBiasAppServer, cnGMTAppServer, cnLocalTimeAppServer
			New method Node::cnGetComputerName

			Fixes:

				-  Change to CnStackDump::dumpStack to dump only the method call stack when handling a
				   1201 error (kernel stack overflow).
				-  Enhanced diagnostics in deadlock exception handler.


			change event caused and connection state is being checked.
------------------------------------------------  Version 2.5  ---------------------------------------

2.4.06		Patches to CnFtp::cnGetFile and CnHttp::cnGetFile to zero milliseconds when
			setting timestamps for copied file.
			Patch to CnKarmaCntrl::create to exclude milliseconds from file version
			comparison (serverVer vs clientVer).
			Patch to CnDatabaseAdmin::backupAllDbFiles to fix problem with update of
			droppedFilesArray when not in transientTransactionState.
			Patch to CnDatabaseAdmin::copyFilesFromDirectory to ignore .tmp files.

2.4.05		Patch to CnStackDump::dumpStack to only do minidump if 14135 app server stack overflow.	
			Patch to cnGlobal & cnGlobalLock exception handlers to log fact that they
			are initiating stack dump (rather than a subschema method).
			Patch to CnStackDump::dumpStack to report dumping application type.
			Patch to CnCntrl::cnWriteLog to detour 5003 error when using File::fileLength twice.

2.4.04		Patch in CnKarmaCntrl::create to stop updating of process.userInfo if not null.
			Patch to app::cnActivateKarmaControl to stop issue of SessionOpenAdvice if KaramControl=false.

2.4.03		Add check on cnForeignApp in epilog of CnKarmaCntrl::displayClientStartUpProgress
			to fix not found error in VB apps.
			Change in App::cnGlobalDeadlockExHandler to capture more information when JADE doesn't
			provide a valid heldBy reference in the exception object.
			Patch in CnKarmaCntrl::create to allow correct running of app in singleUser mode when
			KarmaControl=true in .ini file.

2.4.01		Enhancement to CnFtp::cnGetFileInfo to handle Unisys A Series response
		    to DIR.
		    All uses of node.networkAddress changed to process.networkAddress.
		    Enhancement to CnMessage::receiveMessage for Joss-to-JossCommsMg messages
		    (related to service and windows station desktop checks).
		    Fix to CnInternet::delete to allow serverExecution.
		    Enhance CnKarmaCntrl::create to improve diagnostics relating to
		    setting of clientOnServer boolean.
		    Modify CnDirectorySelect to use external functions required to
		    execute on thin client.													02 Aug 99
		    For KCDummy, always set suppressManagementDialogs true.
		    Reinstate app::cnGetDriveMapping as external function (for thin clients).
		    Change File::cnGetFileVersion to use external function (for thin client).
		    Enhance cnGlobalExceptionHandler to improve diagnostics for NotificationExceptions.
		    Added app::cnAppServerIsOnServer, set up in CnKarmaCntrl::create, used in
		    CnSchemaCopyCmd::processMsg.
		    Fix in CnKarmaCntrl::displayClientStartupProgress so that only GUI apps with forms
		    display startup progress dialog.
		    Add check to SchemaCopy::userNotify for DeploymentFileServer in [Karma] section of
		    .ini file.
		    Added new app KCSchemaCopyAppServer to handle requirement to suppress management dialogs
		    in SchemaCopy::userNotify.
		    Added new method CnMessage::handleProcessException and armed in CnMessage::forwardMsg
		    to address timing hole in ::forwardMsg if process being forwarded to has gone away.
		    Add code in cnGlobalExceptionHandler to abort gracefully without strack dump when
		    thin client connection to app server breaks.


2.4.00		Development / JUO acceptance test version for :								23 Jul 99

				-  Support for clients running as server apps
				-  JADE 5.0

			Miscellaneous changes:

				-  Changes to exception attributes in CnKarmaCntrl.  May require
				   minor changes in	any subschemas that used these (exObjErrorCode
				   now exceptionErrorCode, etc)

				-  Additions to CardSchema (app) class : cnDbPath, app::dbPath and
				   app::isMultiUser	methods, to support VB apps running with CardSchema.

				-  patch to String::cnGetTokens to fix incorrect handling.

				-  New method String::cnGetTokensUsingTruthSet.

				-  Prep for protocolVersion 7 (v2.5) : implement extended header in
				   CnKarmaTcpConnection, to allow for message lengths > 1 MB.

				-  Stack dump now causes Cn_Unhandled_Exception event on Process.

//////////////////////////      Version 2.4   ///////////////////////////////////////////////////////

2.2.25		Change app::cnGetServerFileVersions to not include subdirs of c_bin.
			Patch to GCardSchema::cnGetUserProcess to fix 3075 error.
			Patch to CnFtp::getFileInfo to handle foundfile longer than file being

2.2.24		Fix for environment id recognition problem, in CnKarmaCntrl.setEnvironmentId.	
			CnSmtpConnectionException Class Version 2, 19th May 1999:
			  - When a CnSmtpConnectionException is raised, a reference to the associated
			    CnSmtpConnection object is now placed in the exception's 'mySmtpConnection'
			    property.
			CnSmtpStateDATA Class, Version 2, 19th May 1999
			  - Only the last node of the attachment filename is sent, 					RM 19 May 99
			    rather than the whole pathname.

2.2.23		CnSmtpConnection class patches.										RM 10 May 99

2.2.22		Patch to globalExceptionHandler to avoid invocation of .class method
			causing 1092 when handling lock exceptions.
			Patch to CnFtp::cnGetFile to clean up file object in epilog.
			Patch to CnKarmaCntrl::create to set up process.userInfo with app name when
			KarmaControl=false in ini file.
			Patch to CnKarmaTcpConnection::cnOpenNotify to delete any existing deploy.htm
			file at time KCCMgr connects to Karma.

2.2.21		Patch to SchemaCopy::userNotify to suppress dialogs after copy if					RM 08 Apr 99
			suppressManagementDialogs is set.
			Patch in CnMessage::sendMessage to handle Joss command with tcp=null
			for protocolVersion setup, COS fault 278093

2.2.20		Patches to CnKarmaCntrl::create and CnSchemaCopyCmd::processMsg to					RM 24 Mar 99
			enable binaries-only deployments.
2.2.20e2	Patch to derive CnCntrl::javaThinClient in app::cnActivateKarmaControl					RM 16 Mar 99

2.2.20e		Engineering field test release 1.									RM 15 Mar 99

2.2.19      Patch to cnGlobalExceptionHandler to pass back exceptions due to		RM <not released>
            attempt to lock CnLogLock.
            Patch to CnStackDump::dumpStack to correctly display error object,
            particularly for 1227's but affects all exceptions.
            New method app::cnRaiseAlertAdvice, to allow applications to raise JOSS
            alerts.
            New method app::cnRaiseNormalException, for general purpose exceptions.
            Patch to CnKarmaCntrl::findBackgroundCommsMgr to single-thread through part
            of this : stop two threads from starting two copies KCCmgr on multi-processor box.
            Enhancements to support protocol version 5 (application ping).
            Patch CnPingCmd::processMsg to stop spurious error message being logged.
            Patch app::cnGlobalLockExceptionHandler for improved diagnostics, and to not display
            progress dialog during retries if ini file option SupressManagementDialogs=true.
            Add new .ini file option 'LogMiniStackDump'.
            Added new SMTP classes, courtesy Robin Arzoni.
            Fix to CnSchemaCopyCmd::processMsg to ensure always return a return code.
            Added KarmaControlAdvice to CnMessage::getClassName for Joss 2.2.19g.

2.2.18		Add code to CnMessage for new Joss class FtpProgressAdvice.				RM 15 feb 99

2.2.17		Enhance CnDirectorySelect::load to order drive list combo box in drive	RM 10 Feb 99
			letter order.
			Change id and comment attribute lengths in CnAlertDefCmd and CnAlertAdvice.

2.2.16		Fix to SchemaCopy::copyFile and new method SchemaCopy::getServerGMTBias
			to fix problem with file timestamps after FTP copy to client.			RM 01 Feb 99
2.2.15		cnGlobalLockExceptionHandler modified to retry locks for locktimeout
			period rather than only 100 mS.  Retries for maximum of approx 60 seconds.
			Add new method Global::cnGetServerLogRootDir.
			Add new method CnKarmaCntrl::renameFile.								RM 29 Jan 99

2.2.14		Assign CnKarmaCntrl to app when KarmaControl=false, in constructor.
			Fix key used (ClientFileAccessUserId) in SchemaCopy::userNotify for
			FTP userid/password.
			Added extra logging to CnKarmaCntrl::findBackgroundCommsMgr and
			CnKarmaCntrl::displayClientStartupProgress for KCCMgrStartDelay.		RM 26 Jan 99

2.2.13		Change to CnDumpForm::load to add instanceId to app display, and to
            add app and process instanceId to lock exception progress dialog.
            Fix arming order of server global exception handlers.
            Remove redundant begin/commitTransactions from globalExceptionHandler :
            not necessary in JADE 4.1.												RM 15 Jan 99

2.2.12		Changes to allow KarmaFtp across timezones with IIS 4.0 handling of		RM 17 Dec 98
			FTP timestamps.  Prior to IIS 4.0, IIS returned times in GMT
			format.  IIS 4.0 returns them in local time.  The serverGMTBias	
			property of the CnFtp class now allows developers to specify the
			bias to be used for conversions that use CnFtp::cnGetLastModifiedTimeGMT.
			Note that as of this date, IIS 4.0 needs installation of a hot fix
			to handle daylight saving properly for FTP.


2.2.11		Unload progress dialog when retry limit exceeded in 					RM 16 Dec 98
			cnGlobalLockExceptionHandler.
			Changed listen/open/read etc to allow different header lengths for
			different subclasses of CnTcpConnection.
			Enhanced CnStackDump to speed up stack dumps : array processing much
			faster, and objects are now only dumped once

2.2.09		Add endNotificationForSubscriber(kc) in app::finalize					RM 04 Dec 98

2.2.08		Add extra checks at start up for karma.dll, environment id length.		RM 03 Dec 98
			Check for only one KCCMgr.
			Enhance diagnostics in CnTcpConnection::user_cnIssueErrorMsg.
			Add modeAscii boolean to CnFtp and use in CnFtp::cnGetFile & putFile.

2.2.07		JUO acceptance test fixes, official 4.1.7 release						RM 25 Nov 98

2.2.06		JUO acceptance test fixes												RM 19 Nov 98

2.2.05		Various pre-release fixes												RM 11 Nov 98

2.2.04		Apply CS 2.1.18 patch for tcp connection retry timer when duplicate		RM 06 Nov 98
			connection exceptions occur : affects CnTcpConnection methods
			cnSetCnRetryTimerRunning and cnJossTcpRestart, and
			app::cnTcpExceptionHandler.

2.2.03		Remove detour to 4.1.6 bug in getSystemVersion							RM 02 Nov 98

2.2.02		Change app.cnCheckForTransients to handle un-instantiated CnCntrl		RM 29 Oct 98

2.2.00s		Upgrade to JADE 4.1.5.  Changes to CnDumpStack and global exception		RM 27 Oct 98
			handlers to reflect revised JADE behaviours with exceptions in 4.1.

2.2.00r		Upgrade to JADE 4.1.4													RM 20 Oct 98

2.2.00q		Upgrade to JADE 4.1.3													RM 01 Oct 98

2.2.00p		Added SuppressManagementDialogs and currentSession checks to			RM 16 Sep 98
			CnSchemaCopy::processMsg and CnStackDump::dumpStack

2.2.00k		Added patch for dumpStack to display correct oids for receivers			RM 19 Aug 98

2.2.00h		Added 2.1.17 patch for Joss::doSNMPReporting							RM 11 Aug 98

2.2.00g		Added 2.1.16 patches													RM 29 July 98
			searched for.

2.2.00f		Added process id to log entries, CardSchema and JADE version info		RM 28 July 98
		    to startup and dump logging.

2.2.00e		Installed changes through to 2.1.14.									RM 13 July 98

2.2.00d		Added workaround for WINS problem with Win 95 : new method				RM 07 July 98
			app::cnGetOSVersion, CnKarmaCntrl::getAddressInfo.  Other
			changes from 2.1.08 and 2.1.09 have been installed.

2.2.00c		Completed CnDirectorySelect class.										RM 18 June 98

2.2.00b		Dev Version.  Added 2.0.57 and 2.0.58 resiliency enhancements			RM 17 June 98
			to CnStackDump, and new ini file option ExceptionHandler.

2.2.00a		Development version.  Added exception handler and stack dumper			RM 05 June 98
			enhancements from 2.0.56

`
	)
	ActiveXAutomation completeDefinition
	(
	)
	ActiveXInterface completeDefinition
	(
	)
	IUnknown completeDefinition
	(
	)
	IDispatch completeDefinition
	(
	)
	Application completeDefinition
	(
	)
	RootSchemaApp completeDefinition
	(
	)
	CardSchema completeDefinition
	(
	constantDefinitions
		CN_CREATE_FILE:                Integer = 2 number = 1001;
		CN_REMOVE_FILE:                Integer = 1 number = 1002;
	attributeDefinitions
		cnAppAlias:                    String[101] readonly, number = 15, ordinal = 1;
		documentationText
		`Used by JSA applications but as from 12Aug08 also by JADE Master Terminal.
`
		cnAppServerIsOnServer:         Boolean readonly, number = 1, ordinal = 2;
		cnApplicationRootDir:          String[129] readonly, number = 33, ordinal = 35;
		cnApplicationType:             Character readonly, number = 39, ordinal = 41;
		cnCheckShareLocks:             Boolean protected, number = 20, ordinal = 3;
		cnCurrentLocaleDefaultCountryCode:Integer readonly, number = 48, ordinal = 54;
		cnDatabaseSubrole:             Integer number = 32, ordinal = 34;
		cnDbPath:                      String[129] readonly, number = 2, ordinal = 4;
		documentationText
`This attribute is used only by VB apps that use CardSchema.  If you assign a value
to this attribute, app::dbPath will return the value of cnDbPath instead of the
JADE app.dbPath.`
		cnDistributionNode:            String[41] readonly, number = 42, ordinal = 46;
		cnDistributionProcess:         String[41] readonly, number = 43, ordinal = 47;
		cnExceptionHandlerType:        Integer readonly, number = 14, ordinal = 5;
		cnFileRetryCount:              Integer number = 3, ordinal = 6;
		cnForeignApp:                  Boolean readonly, number = 4, ordinal = 7;
		documentationText
		`Indicates that this is a VB app i.e. not a JADE.EXE`
		cnIsForegroundClient:          Boolean readonly, number = 17, ordinal = 8;
		documentationText
`
If the subschema developer has set this to true (only do this for user-attended GUI clients)
then CardSchema's global lock exception handler will call cnShowLockErrorMessage if a 
lock cannot be acquired.  

The developer can reimplement this message if desired.`
		cnIsServerApp:                 Boolean readonly, number = 5, ordinal = 9;
		cnLockCheckInterval:           Integer readonly, number = 18, ordinal = 10;
		cnMaxLockTimeBeforeAlarm:      Integer protected, number = 19, ordinal = 11;
		cnOSArchitecture:              Integer readonly, number = 26, ordinal = 27;
		documentationText
`Architecture of the fat client or server node.

For thinclient architecture, refer to cnThinClientArchitecture`
		cnOSPlatform:                  Integer readonly, number = 25, ordinal = 26;
		documentationText
`Platform of the fat client or server node.

For thinclient platform, refer to cnThinClientPlatform`
		cnOSVersion:                   String[31] readonly, number = 27, ordinal = 29;
		cnServerGlobalExHandlerDone:   Boolean readonly, number = 35, ordinal = 37;
		cnStackDumpFileName:           String[256] readonly, number = 40, ordinal = 42;
		cnSystemType:                  Integer readonly, number = 16, ordinal = 14;
		cnThinClientOSArchitecture:    Integer readonly, number = 37, ordinal = 39;
		cnThinClientOSPlatform:        Integer readonly, number = 36, ordinal = 38;
		cnThinClientOSVersion:         String[31] readonly, number = 38, ordinal = 40;
		cnUseLaunchSentinelFile:       Boolean protected, number = 28, ordinal = 30;
		cnUsedActivateMethod:          Boolean number = 6, ordinal = 15;
	referenceDefinitions
		cnMyBackupLog:                 JadeLog  readonly, number = 24, ordinal = 12;
		cnMyCompactLog:                JadeLog  readonly, number = 41, ordinal = 45;
		cnMyLaunchSentinelFile:        File  protected, number = 29, ordinal = 31;
		cnProcessesWithNoLockChecks:   CnProcessSet  readonly, number = 21, ordinal = 13;
		documentationText
`
Manually maintained collection of processes for which no lock check alarms are
to be issued.`
		myCnBackup:                    CnBackup  readonly, number = 44, ordinal = 48;
		myCnClusterInfo:               CnClusterInfo  readonly, number = 23, ordinal = 16;
		myCnCntrl:                     CnCntrl  number = 7, ordinal = 17;
		myCnDba:                       CnDatabaseAdmin  readonly, number = 13, ordinal = 18;
		documentationText
		`
Reference to process transient used in KCOnLineBackup.`
		myCnKarmaCntrl:                CnKarmaCntrl  number = 8, ordinal = 19;
		myCnLdapSyntax:                CnLdapSyntax  number = 9, ordinal = 20;
		myCnLockCheck:                 CnLockCheck  readonly, number = 34, ordinal = 50;
		myCnLog:                       JadeLog  readonly, number = 11, ordinal = 21;
		myCnManagerClass:              CnManagerClass  number = 45, ordinal = 49;
		myCnRoot:                      CnRoot  readonly, number = 22, ordinal = 22;
		myCnSDSDbAdmin:                CnSDSDatabaseAdmin  readonly, number = 31, ordinal = 33;
		myCnTranLogFile:               CnFile  number = 30, ordinal = 32;
		myCnTransactionStack:          CnTransactionStack  readonly, number = 12, ordinal = 23;
		myDba:                         JadeDatabaseAdmin  readonly, number = 10, ordinal = 24;
		myJadeTestCaseListener:        CnJadeTestCaseListenerIf  number = 47, ordinal = 53;
		myTransientCnIpAddress:        CnIpAddress  readonly, number = 46, ordinal = 52;
	jadeMethodDefinitions
		cnActivateKarmaControl(
			pClientType: Integer; 
			pThinClientComputerIpAddress: String; 
			pThinClientComputerName: String) updating, clientExecution, number = 1001;
		cnAppIsRunning(
			schemaName: String; 
			appName: String; 
			computer: String; 
			procc: Process output): Boolean number = 1002;
		cnArmServerDeadlockExHandler() updating, serverExecution, number = 1003;
		cnArmServerGlobalExceptHandler() updating, serverExecution, number = 1004;
		cnArmServerLockExceptHandler() updating, serverExecution, number = 1005;
		cnBuildFQDN(netBiosName: String): String number = 1082;
		cnCheckForTransients() updating, number = 1006;
		cnCheckLaunchSentinelFile(action: Integer) updating, protected, subschemaHidden, final, number = 1112;
		cnClearLogicalTransactionStack() number = 1056;
		cnClientOSPlatformIsWindows(): Boolean number = 1107;
		cnComputerName(): String number = 1101;
		cnComputerNameAppServer(): String number = 1102;
		cnContainsKarma(str: String): Boolean number = 1091;
		cnConvertPathNameToBackSlashes(pathname: String): String updating, number = 1008;
		cnConvertPathNameToFwdSlashes(pathname: String): String updating, number = 1009;
		cnDisableLockChecks() number = 1076;
		cnEnableLockChecks() number = 1148;
		cnFileInUseExceptionHandler(exObj: FileException): Integer updating, number = 1011;
		cnFileLastModified(file: File): TimeStamp updating, number = 1012;
		cnFinalizeKCBatch() number = 1159;
		cnFinalizeKCCMgr() updating, number = 1013;
		cnFinalizeKCNodeControl() updating, number = 1114;
		cnFinalizeKCOnLineBackup() updating, number = 1089;
		cnFinalizeKCOnLineBackupM() updating, number = 1151;
		cnFinalizeKCOnLineBackupWorker() updating, number = 1088;
		cnFinalizeKCOnLineCmpactWorker() updating, number = 1143;
		cnFinalizeKCOnLineCompact() updating, number = 1142;
		cnFinalizeKCOnLinePartitionWorker() updating, number = 1167;
		cnFinalizeKCSDSChecks() updating, number = 1007;
		cnGenericExceptionHandler(
			pExObj: Exception; 
			pExpectedErrorCode: Integer; 
			pArmedForObject: Object; 
			pHadException: Boolean output): Integer number = 1131;
		cnGetApplicationType(): String number = 1014;
		cnGetApplicationVersion(): String number = 1084;
		cnGetBackupPathDatabase(
			pBackupDir: String; 
			pEnvId: String; 
			pSystemNode: String; 
			pBackupSystemNode: String): String number = 1168;
		cnGetCardSchemaApp(pRequireKarmaControl: Boolean): CardSchema number = 1137;
		cnGetCardSchemaVersion(): String number = 1138;
		cnGetClassAndOid(obj: Object): String number = 1015;
		cnGetClassForObject(obj: Object): Class number = 1016;
		cnGetClientMiscPath(thinClient: Boolean): String clientExecution, number = 1017;
		cnGetClientRelativeMachineTime(): Decimal clientExecution, number = 1110;
		cnGetClientTime(): TimeStamp clientExecution, number = 1067;
		cnGetDriveMapping(
			driveName: String; 
			mapName: String output; 
			errorText: String output): Integer updating, number = 1018;
		cnGetEnvVariableAppServer(variable: String): String number = 1019;
		cnGetEnvironmentId(): String number = 1153;
		cnGetEnvironmentVariable(variable: String): String number = 1020;
		cnGetErrorText(error: Integer): String number = 1119;
		cnGetExceptionDisplayPicture(): Binary number = 1080;
		cnGetIniFileSectionName(section: String): String number = 1109;
		cnGetJadeVersion(): String number = 1094;
		cnGetNetworkAddressNode(): String number = 1124;
		cnGetNetworkAddressProcess(): String number = 1163;
		cnGetPath(
			pRoot: String; 
			pEnvId: String; 
			pNode: String; 
			pPathType: String; 
			pFormatStd: Boolean): String updating, number = 1098;
		cnGetPathPartUnix(pPathType: String): String updating, protected, number = 1106;
		cnGetPathUnix(
			pRoot: String; 
			pEnvId: String; 
			pNode: String; 
			pPathType: String; 
			pFormatStd: Boolean): String updating, number = 1105;
		cnGetPathWindows(
			pRoot: String; 
			pEnvId: String; 
			pNode: String; 
			pPathType: String; 
			pFormatStd: Boolean): String updating, number = 1104;
		cnGetProfileStringServer(
			section: String; 
			key: String; 
			default: String): String serverExecution, number = 1074;
		cnGetRootDirectory(pEnvironmentId: String): String number = 1169;
		cnGetServerFileLastModified(filename: String): TimeStamp updating, serverExecution, number = 1021;
		cnGetServerIniFileName(): String serverExecution, number = 1170;
		cnGetServerMiscPath(): String number = 1023;
		cnGetServerTime(): TimeStamp number = 1066;
		cnGetSharedTransient(
			pClass: Class; 
			pMaxAttempts: Integer): Object number = 1120;
		cnGlobalDeadlockExHandler(exObj: DeadlockException): Integer updating, number = 1024;
		cnGlobalExceptionHandler(exObj: Exception): Integer updating, number = 1025;
		cnGlobalLockExceptionHandler(pExObj: LockException): Integer updating, number = 1026;
		cnHandleAndBypassAnyException(
			pExObj: Exception; 
			pAppServerGroupName: String; 
			pHadError: Boolean output): Integer number = 1048;
		cnHandleInvalidObjectReference(
			exObj: Exception; 
			badObject: Boolean output): Integer number = 1078;
		cnHandleNullOrInvObjectRef(
			pExObj: Exception; 
			pObj: Object; 
			pError: Boolean output): Integer number = 1118;
		cnHandleReorgException(
			pExObj: SystemException; 
			pErrorCode: Integer output; 
			pErrorText: String output): Integer number = 1164;
		cnHandleSpecifiedInvalidObjRef(
			exObj: SystemException; 
			obj: Object; 
			badObject: Boolean output): Integer number = 1092;
		cnHandleStartupException(exObj: Exception): Integer number = 1061;
		cnHandleSystemShutDownEvent() updating, number = 1068;
		cnInitializeAppServerMonitor() number = 1058;
		cnInitializeKCBatch(initParam: Object) number = 1158;
		cnInitializeKCCMgr() updating, number = 1027;
		cnInitializeKCDatabaseBackup() updating, number = 1028;
		cnInitializeKCDatabaseBackupM(pObject: Object) updating, number = 1150;
		cnInitializeKCDbBackupWorker(cdb: CnDatabaseAdmin input) updating, number = 1029;
		cnInitializeKCDummy() updating, number = 1030;
		cnInitializeKCLockCheck() updating, number = 1126;
		cnInitializeKCNodeControl() updating, number = 1108;
		cnInitializeKCOnLineCompact(cdba: CnDatabaseAdmin io) updating, number = 1141;
		cnInitializeKCSDSChecks() number = 1022;
		cnInitializeKCStartAppInNode(pObject: Object) number = 1149;
		cnInitializeKCStartMonitorBack() number = 1053;
		cnInitializeKCStatsCollector() updating, number = 1087;
		cnInitializeKCValidateMethods(initParam: Object) number = 1176;
		cnInitializeKCVerifyJournal() updating, number = 1111;
		cnInitializeOnLineBackupWorker(cdba: CnDatabaseAdmin io) updating, number = 1062;
		cnInitializeOnLineCmpactWorker(cdba: CnDatabaseAdmin io) updating, number = 1140;
		cnInitializeOnlinePartitionWorker(cdba: CnDatabaseAdmin io) updating, number = 1171;
		cnInitializeTodaysDate() number = 1073;
		cnIntializeKCOnLineBackup(cdba: CnDatabaseAdmin io) updating, number = 1060;
		cnIsRPSNode(): Boolean number = 1052;
		cnJadeTestCaseDebug(
			pMethod: Method; 
			pLogText: String) number = 1172;
		cnLocalLockExceptionHandler(
			pExObj: LockException; 
			pHadLockException: Boolean output; 
			pLockedByApp: String output; 
			pLockedByInfo: String output; 
			pLockedByNodeName: String output; 
			pLockedByProcId: String output; 
			pLockedByUserCode: String output): Integer protected, final, number = 1135;
		cnLocalLockExceptionHandler2(
			pExObj: LockException; 
			pHadLockException: Boolean output): Integer protected, final, number = 1155;
		cnManagerLog(text: String) clientExecution, number = 1147;
		cnMsgBoxClient(
			msg: String; 
			title: String; 
			flags: Integer) clientExecution, number = 1085;
		cnOSPlatformIsUnix(): Boolean number = 1099;
		cnOSPlatformIsWindows(): Boolean number = 1097;
		cnObjNotFoundExceptionHandler(
			exObj: Exception; 
			error: Boolean output): Integer protected, number = 1075;
		cnRaiseAlert(
			pShortText: String; 
			pLongText: String; 
			pStatus: Character; 
			pWhenRaised: TimeStamp; 
			pAppName: String; 
			pClientFQDN: String; 
			pClientIpAddress: String) updating, number = 1031;
		cnRaiseJossAlert(
			pAlertType: Integer; 
			pShortText: String; 
			pLongText: String; 
			pStatus: Character; 
			pWhenRaised: TimeStamp; 
			pAppName: String; 
			pEnvironmentName: String; 
			pClientFQDN: String; 
			pClientIpAddress: String; 
			pTcp: CnKarmaTcpConnection input) updating, number = 1032;
		cnRaiseNormalException(
			errorcode: Integer; 
			erroritem: String; 
			errortext: String; 
			resumable: Boolean) updating, number = 1033;
		cnRemoveDirectory(dirName: String): Boolean updating, number = 1063;
		cnReportDeploymentStatus() protected, number = 1121;
		cnSdsReadAccessEnabled(): Boolean updating, number = 1096;
		cnSendHeartbeat() number = 1117;
		cnSendSDSTrackingAdviceMsg(
			pAdviceType: String; 
			pTrackingStoppedReason: Integer; 
			pTrackingStoppedSubReason: Integer; 
			pText: String) number = 1122;
		cnSetCurrentLocaleDefaultCountryCode(pValue: Integer) updating, number = 1173;
		cnSetDistributionNode(pValue: String) updating, number = 1090;
		cnSetDistributionProcess(pValue: String) updating, number = 1093;
		cnSetExceptionHandlerType(handlerType: Integer) updating, number = 1064;
		documentationText
`Valid values are:

	CnCntrl.Exception_Handler_Jade		// default JADE exception handler
	CnCntrl.Exception_Handler_CardSchema	// CardSchema exception handlers are
						// armed - locks, deadlocks, global
	CnCntrl.Exception_Handler_Both		// As for previous line, except that exceptions
						// are passed back after handling
	CnCntrl.ExceptionHandler_Jade_Debug	// Handles lock exceptions, displays Jade Unhandled 
						// dialog for all others, including exceptions in Non-GUI apps.`
		cnSetIsForegroundClient(set: Boolean) updating, number = 1069;
		cnSetMyBackupLog(log: JadeLog) updating, number = 1086;
		cnSetMyCompactLog(log: JadeLog) updating, number = 1144;
		cnSetOSArchitecture(osArch: Integer) updating, number = 1103;
		cnSetOSPlatform(osPlatform: Integer) updating, number = 1113;
		cnSetOSVersion(version: String) updating, number = 1115;
		cnSetPackageAppProperties(pProcessApp: CardSchema) updating, protected, number = 1132;
		cnSetProfileStringServer(
			section: String; 
			key: String; 
			default: String) serverExecution, number = 1157;
		cnSetServerGlobalExHandlerDone(pBool: Boolean) updating, number = 1125;
		cnSetSystemType() updating, number = 1050;
		cnSetThinClientOSArchitecture(osArch: Integer) updating, number = 1128;
		cnSetThinClientOSPlatform(osPlatform: Integer) updating, number = 1129;
		cnSetThinClientOSVersion(osVersion: String) updating, number = 1130;
		cnShowExceptionForm(exObj: Exception) updating, clientExecution, number = 1034;
		cnShowExceptionFormPlus(
			pExObj: Exception; 
			pExceptionStack: String) updating, clientExecution, number = 1100;
		cnShowExceptionWebForm(exObj: Exception) clientExecution, number = 1059;
		cnShowLockErrorMessage(
			lockDetails: String; 
			lockingAppDetails: String; 
			methodDetails: String) clientExecution, number = 1070;
		cnShowProgress(
			progressDialog: CnProgressDialog input; 
			msg1: String; 
			msg2: String; 
			msg3: String): Integer updating, clientExecution, number = 1035;
		cnShowProgressDialog(lockTarget: String): CnProgressDialog updating, clientExecution, number = 1036;
		cnShowProgressUnload(progressDialog: CnProgressDialog input) updating, clientExecution, number = 1037;
		cnStandardizePathName(pathname: String): String updating, number = 1038;
		cnStartApplicationOnServer(
			pSchema: String; 
			pApplication: String): Process serverExecution, number = 1095;
		cnTcpExceptionHandler(exObj: ConnectionException): Integer updating, number = 1039;
		cnTerminate() updating, number = 1083;
		cnThinClientOSIsWindows(): Boolean number = 1010;
		cnThinClientOSIsWindowsMobile(): Boolean number = 1127;
		cnUserCleanUp(exObj: Exception) updating, number = 1071;
		cnUserLockReport(pLockMsg: String) protected, number = 1134;
		cnValidateBackupPath(
			pBackupDir: String; 
			pDatabaseRole: Integer): Boolean updating, number = 1174;
		cnWriteServerLog(text: String) number = 1077;
		dbPath(): String number = 1040;
		finalize() updating, number = 1041;
		isMultiUser(): Boolean number = 1042;
		setCnAppAlias(pAlias: String) updating, number = 1065;
		setCnAppServerIsOnServer(set: Boolean) updating, number = 1043;
		setCnApplicationRootDir(dir: String) updating, number = 1116;
		setCnApplicationType(pType: Character) updating, number = 1133;
		setCnDbPath(dbPath: String) updating, number = 1044;
		setCnForeignApp(set: Boolean) updating, number = 1045;
		setCnIsServerApp(set: Boolean) updating, number = 1046;
		setCnStackDumpFileName(pStackDumpFileName: String) updating, number = 1136;
		setMyCnClusterInfo(ci: CnClusterInfo) updating, number = 1081;
		setMyCnLog(log: JadeLog) updating, number = 1057;
		setMyCnRoot(root: CnRoot) updating, number = 1079;
		setMyCnSDSDbAdmin(dba: CnSDSDatabaseAdmin) updating, number = 1054;
		setMyCnTransactionStack(stack: CnTransactionStack) updating, number = 1055;
		setMyDba(dba: JadeDatabaseAdmin) updating, number = 1047;
		timerEvent(eventTag: Integer) updating, number = 1072;
		userNotification(
			eventType: Integer; 
			theObject: Object; 
			userTag: Integer; 
			userInfo: Any) updating, number = 1049;
		zCheckLockTargets() protected, number = 1139;
		zCheckUnbufferedIniSettings() protected, number = 1145;
		zCnCheckAndUpdateRemoteIniFiles() protected, number = 1175;
		zCnDataPumpIniFileSettings() protected, number = 1154;
		zCnPreShutDownChecks(): Boolean protected, number = 1162;
		zCnThinClientConnBalancing() protected, number = 1146;
		zCnUser_TransientsToIgnore(pObjectArray: ObjectArray input) protected, number = 1156;
		zCnUser_ViewTransientObjects(pObjectArray: ObjectArray input) protected, number = 1160;
		zGetLockedByDetails(
			pExObj: LockException; 
			pLockedByApp: String output; 
			pLockedByInfo: String output; 
			pLockedByNodeName: String output; 
			pLockedByProcId: String output; 
			pLockedByUserCode: String output) protected, number = 1161;
		zHandleAndBypassAnyTCBExcept(
			pExObj: Exception; 
			pAppServerGroupName: String; 
			pHadError: Boolean output): Integer protected, number = 1123;
		zNetworkAddressConvert(pNetworkAddress: String io) protected, number = 1165;
		zStackDumpClass(): Class protected, number = 1152;
		z_RaiseAlertCommon(
			pAlertType: Integer; 
			pShortText: String; 
			pLongText: String; 
			pAppName: String; 
			pEnvironmentName: String; 
			pClientFQDN: String; 
			pClientIpAddress: String; 
			pStatus: Character; 
			pWhenRaised: TimeStamp; 
			pTcp: CnKarmaTcpConnection) updating, protected, number = 1166;
	externalMethodDefinitions
		cnGetDriveMappingEM(
			driveName: String; 
			mapName: String output): Integer is "emGetDriveMapping" in "karma" updating, number = 1051;
	)
	CnAdmin completeDefinition
	(
		documentationText
		`Superclass of new administrative classes.`
	)
	CnApplicationLauncher completeDefinition
	(
	attributeDefinitions
		applicationName:               String[101] readonly, subschemaHidden, number = 2, ordinal = 1;
		databaseRole:                  Integer readonly, subschemaHidden, number = 4, ordinal = 4;
		delay:                         Integer readonly, subschemaHidden, number = 3, ordinal = 3;
		schemaName:                    String[101] readonly, subschemaHidden, number = 1, ordinal = 2;
	jadeMethodDefinitions
		getDetails(
			pSchemaName: String output; 
			pApplicationName: String output; 
			pDatabaseRole: Integer output; 
			pDelay: Integer output) number = 1003;
		loadSelf(
			pSchemaName: String; 
			pAppName: String; 
			pDatabaseRole: Integer; 
			pDelay: Integer) updating, number = 1002;
		timerEvent(eventTag: Integer) updating, number = 1001;
	)
	CnDatabaseAdmin completeDefinition
	(
	constantDefinitions
		Backup_Failed:                 Integer = 0 number = 1001;
		Backup_Interrupted:            Integer = 1 number = 1002;
		Backup_OK:                     Integer = 2 number = 1003;
		Compact_Failed:                Integer = 10 number = 1004;
		Compact_Interrupted:           Integer = 11 number = 1005;
		Compact_OK:                    Integer = 12 number = 1006;
		Verify_Check_Timer:            Integer = 100 number = 1007;
	attributeDefinitions
		abnormalTermination:           Boolean readonly, number = 18, ordinal = 1;
		abortRequested:                Boolean readonly, number = 23, ordinal = 2;
		backupCompletionText:          String[251] protected, number = 16, ordinal = 38;
		backupCompletionType:          String[11] protected, number = 22, ordinal = 37;
		backupDir:                     String[129] readonly, number = 1, ordinal = 4;
		documentationText
`
This is the destination directory for the database (system) files part of the backup.`
		backupLocations:               CnStringArray readonly, subId = 11, number = 41, ordinal = 56;
		documentationText
		`Contains the full path name as defined by JSA.`
		backupPartitionIds:            Integer64Array readonly, subId = 13, number = 43, ordinal = 58;
		backupRemainingFilesInSystem:  Boolean readonly, number = 5, ordinal = 51;
		backupRootDir:                 String[71] readonly, number = 2, ordinal = 5;
		documentationText
`
This is the root directory for the backup. For Windows, typically <drive>:/cnwbackup_temp/<env>.
For Unix, typically /opt/jsm_backups/cnwbackup_temp/<env>.`
		backupStructureNames:          CnStringArray readonly, subId = 12, number = 42, ordinal = 57;
		backupWorkerIds:               IntegerArray readonly, subId = 7, number = 25, ordinal = 6;
		backupWorkers:                 Integer readonly, number = 26, ordinal = 7;
		cancelBackup:                  Boolean readonly, number = 14, ordinal = 8;
		commitCoherentBackup:          Boolean readonly, number = 15, ordinal = 76;
		compactCompletionText:         String[251] protected, number = 35, ordinal = 44;
		compactCompletionType:         String[11] protected, number = 36, ordinal = 45;
		compactStructureNames:         CnStringArray readonly, subId = 10, number = 40, ordinal = 59;
		compactWorkerIds:              IntegerArray readonly, subId = 1, number = 34, ordinal = 43;
		compactWorkers:                Integer readonly, number = 13, ordinal = 42;
		completedBackupIsCommitCoherent:Boolean readonly, number = 46, ordinal = 77;
		compressFiles:                 Boolean readonly, number = 3, ordinal = 9;
		currentFileInProgress:         BooleanArray readonly, subId = 3, number = 10, ordinal = 61;
		documentationText
`Indicates that we've already received at least one BackupOperationEvent notification`
		currentFilePhases:             CharacterArray readonly, subId = 2, number = 21, ordinal = 36;
		documentationText
		`"B" = Backing up file
"V" = Verifying

Maybe others later`
		currentFileProgresses:         Integer64Array readonly, subId = 5, number = 27, ordinal = 10;
		currentFileSizes:              Integer64Array readonly, subId = 4, number = 29, ordinal = 60;
		currentFiles:                  CnStringArray readonly, subId = 6, number = 28, ordinal = 11;
		databaseDirectory:             String[261] readonly, number = 48, ordinal = 65;
		documentationText
`Attribute is only used by KCDatabaseBackupMulti to avoid
copying database files in the app.dbPath.`
		dbFileLengths:                 Integer64Array readonly, subId = 18, number = 51, ordinal = 71;
		dbFileNames:                   CnStringArray readonly, subId = 19, number = 50, ordinal = 69;
		disableBackupNotify:           Boolean readonly, number = 37, ordinal = 63;
		documentationText
		`Only applicable to KCDatabaseBackupMulti.`
		droppedDbFileNames:            CnStringArray readonly, subId = 20, number = 52, ordinal = 70;
		enableArchiveRecovery:         Boolean readonly, number = 4, ordinal = 14;
		environmentId:                 String[31] readonly, number = 38, ordinal = 50;
		errorCode:                     Integer readonly, number = 31, ordinal = 39;
		errorText:                     String[401] readonly, number = 32, ordinal = 40;
		failureReason:                 String[257] readonly, number = 19, ordinal = 34;
		isManaged:                     Boolean readonly, number = 49, ordinal = 72;
		mustBeCommitCoherentBackup:    Boolean readonly, number = 47, ordinal = 78;
		overwriteFiles:                Boolean readonly, number = 6, ordinal = 19;
		quiesce:                       Boolean readonly, number = 7, ordinal = 21;
		scheduleTimeStamp:             TimeStamp readonly, number = 39, ordinal = 48;
		startLogNo:                    Integer readonly, number = 8, ordinal = 22;
		startTime:                     TimeStamp readonly, number = 9, ordinal = 23;
		stateOverflowDirectory:        String[261] readonly, number = 17, ordinal = 33;
		documentationText
		`
Only used by KCDatabaseBackup and KCDatabaseBackupMulti.`
		tranLogClosed:                 Boolean readonly, number = 24, ordinal = 24;
	referenceDefinitions
		allCnDatabaseStructures:       CnDatabaseStructureByNameDict  implicitMemberInverse, readonly, subId = 14, number = 44, ordinal = 52;
		documentationText
		`This collection is used to get all database structures by name only.`
		allCnDatabaseStructuresBySize: CnDatabaseStructureBySizeDict   explicitInverse, readonly, subId = 9, number = 30, ordinal = 62;
		documentationText
`This collection is used to get all database structures from largest to smallest and
is the parent of CnDatabaseStructure transients.`
		allCnDatabaseStructuresForThreading:CnDatabaseStructureArray  implicitMemberInverse, readonly, subId = 17, number = 53, ordinal = 73;
		allPartitionedDbFiles:         DbFileArray  implicitMemberInverse, readonly, subId = 21, number = 54, ordinal = 74;
		allPartitionedDbFilesForThreading:DbFileArray  implicitMemberInverse, readonly, subId = 22, number = 55, ordinal = 75;
		documentationText
`Temporary stack of partitioned files that enables backup threads to 
remove a file from the stack when it backs up its control and index files.`
		droppedFiles:                  DbFileArray  readonly, number = 11, ordinal = 13;
		myCurrentDbFile:               DbFile  readonly, number = 20, ordinal = 35;
		myCurrentDbPartition:          JadeDbFilePartition  readonly, number = 45, ordinal = 53;
		myDba:                         JadeDatabaseAdmin  readonly, number = 12, ordinal = 17;
		processSet:                    ObjectSet  implicitMemberInverse, readonly, subId = 8, number = 33, ordinal = 41;
	jadeMethodDefinitions
		armServerExceptionHandler(
			pDba: CnDatabaseAdmin; 
			pApplication: String) updating, serverExecution, number = 1037;
		backupAllDbFiles() updating, number = 1001;
		backupDbFile(
			pDbFile: DbFile; 
			pDbPartition: JadeDbFilePartition; 
			jdba: JadeDatabaseAdmin; 
			pBackupLocation: String) updating, number = 1041;
		backupExceptionHandler(
			exObj: Exception; 
			dba: CnDatabaseAdmin input; 
			localDba: CnDatabaseAdmin): Integer updating, number = 1036;
		backupLogFile(
			dba: JadeDatabaseAdmin; 
			logNo: Integer; 
			sourcePath: String; 
			destPath: String; 
			verifyLogs: Boolean; 
			compressLogs: Boolean; 
			overwriteLog: Boolean): Boolean updating, number = 1044;
		backupLogFiles(
			dba: JadeDatabaseAdmin; 
			endLogNo: Integer io): String updating, serverExecution, number = 1002;
		backupNonDbFiles(): String updating, number = 1003;
		buildUserInfoNonManagedBackup(
			pFileNameArray: CnStringArray; 
			pFileSizeArray: Integer64Array; 
			pEventTag: Integer; 
			pStatusText: String) number = 1076;
		calculateStartLogNo(
			startLogNo: Integer; 
			abortLogNo: Integer): Integer number = 1040;
		checkDirectories(
			dir: String input; 
			createIfAbsent: Boolean): Boolean updating, number = 1004;
		checkDirectory(
			dir: String; 
			createIfAbsent: Boolean): Boolean updating, number = 1005;
		checkForAbortedBackup() number = 1028;
		checkForAbortedCompact() number = 1059;
		closeTranLogAndAdvise() updating, number = 1039;
		compactExceptionHandler(
			exObj: Exception; 
			dba: CnDatabaseAdmin input; 
			localDba: CnDatabaseAdmin): Integer updating, number = 1064;
		compactMapFile(
			pDbFile: DbFile; 
			jdba: JadeDatabaseAdmin) updating, number = 1060;
		copyFile(
			sourceFile: String; 
			destFile: String; 
			failIfExists: Boolean; 
			errText: String output): Boolean updating, number = 1006;
		copyFilesFromDirectory(
			sourceDir: String; 
			destDir: String; 
			logPath: String; 
			failIfExists: Boolean; 
			errText: String output): Boolean updating, number = 1007;
		create() updating, number = 1008;
		createBackupAdviceMessage(adviceType: String): CnBackupAdvice updating, number = 1030;
		createCompactAdviceMessage(pAdviceType: String): CnCompactAdvice number = 1056;
		directoryExists(dirname: String): Boolean updating, number = 1009;
		ehGeneralExceptionHandler(
			exObj: Exception; 
			errorCode: Integer output; 
			errorText: String output): Integer number = 1050;
		finalizeAndTerminate() updating, number = 1042;
		finalizeAndTerminateCompact() updating, number = 1071;
		getAbortJournalNumber(pFileName: String) number = 1099;
		getBackupCompletionText(): String number = 1087;
		getBackupCompletionType(): String number = 1065;
		getBackupLog(): JadeLog number = 1011;
		getCommitCoherentBackupMaxTries(): Integer number = 1095;
		getCommitCoherentBackupRetryInterval(): Integer number = 1096;
		getCompactLog(): JadeLog number = 1058;
		getCurrentJournalNumber(pFileName: String) number = 1051;
		getElapsedTime(): String updating, number = 1012;
		getLogNumberFromFileName(str: String): Integer number = 1033;
		globalBackupExceptionHandler(exObj: Exception): Integer updating, number = 1052;
		globalCompactExceptionHandler(exObj: Exception): Integer updating, number = 1067;
		handle3004Exception(
			exObj: Exception; 
			error: Boolean output; 
			errText: String output): Integer number = 1053;
		handle3036Exception(
			pExObj: Exception; 
			pHadError: Boolean output): Integer number = 1066;
		handleObjectNotFoundException(exObj: Exception): Integer number = 1034;
		handleVerifyJournalException(
			pExObj: Exception; 
			pHadError: Boolean output): Integer updating, number = 1048;
		locateJournal(
			pFile: File input; 
			pJournalNumber: Integer; 
			pCurrent: String; 
			pArchive: String; 
			pPath: String output): Boolean number = 1078;
		logAndTerminateBackup(errorText: String) updating, number = 1022;
		logAndTerminateCompact(errorText: String) updating, number = 1072;
		managedBackup() updating, number = 1026;
		managedCompact() updating, number = 1061;
		moveFile(
			sourceFile: String; 
			destFile: String; 
			overWrite: Boolean): Boolean number = 1013;
		nonManagedMultiWorkerBackup(pDatabaseRole: Integer) updating, number = 1073;
		prepareBackupDirectories(): String updating, number = 1014;
		raiseAlert(
			pText: String; 
			pBackupProcess: Boolean) updating, number = 1015;
		removeFilesFromDirectory(dir: String): Boolean updating, number = 1016;
		setBackupCompletionText(pValue: String) updating, number = 1086;
		setBackupCompletionType(pValue: String) updating, number = 1084;
		setBackupRootDir(dir: String) updating, number = 1024;
		setBackupWorkers(cnt: Integer) updating, number = 1043;
		setCancelBackup(set: Boolean) updating, number = 1025;
		setCommitCoherentBackup(pCommitCoherentBackup: Boolean) updating, number = 1092;
		setCompactWorkers(pWorkers: Integer) updating, number = 1063;
		setCompressFiles(set: Boolean) updating, number = 1038;
		setDisableBackupNotify(pBool: Boolean) updating, number = 1031;
		setEnvironmentId(pValue: String) updating, number = 1077;
		setErrorCode(code: Integer) updating, number = 1046;
		setErrorText(txt: String) updating, number = 1047;
		setMustBeCommitCoherentBackup(pMustBeCommitCoherentBackup: Boolean) updating, number = 1093;
		setMyCurrentDatabaseEntity(
			pDbFile: DbFile; 
			pDbPartition: JadeDbFilePartition) updating, number = 1029;
		setMyDba(dba: JadeDatabaseAdmin) updating, number = 1017;
		setQuiesce(set: Boolean) updating, number = 1035;
		setScheduleTime(pScheduleTimeStamp: TimeStamp) updating, number = 1069;
		setupProgressEventInterval(jdba: JadeDatabaseAdmin) updating, number = 1049;
		simpleBackup() updating, number = 1018;
		sysNotification(
			eventType: Integer; 
			theObject: Object; 
			eventTag: Integer) updating, number = 1032;
		terminateCompact(
			str: String; 
			terminationType: Integer) updating, number = 1062;
		terminateManagedBackup(
			str: String; 
			terminationType: Integer) updating, number = 1027;
		timerEvent(eventTag: Integer) updating, number = 1054;
		userNotification(
			eventType: Integer; 
			theObject: Object; 
			eventTag: Integer; 
			userInfo: Any) updating, number = 1019;
		userNotificationBackup(
			theObject: Object; 
			eventType: Integer; 
			userInfo: Any) updating, number = 1074;
		userNotificationCompact(
			theObject: Object; 
			eventType: Integer; 
			userInfo: Any) updating, number = 1070;
		verifyJournal(param: CnParam io) updating, serverExecution, number = 1045;
		verifyJournalCheck() updating, number = 1055;
		zAlertCouldNotTakeCommitCoherentBackup(pAlertText: String) updating, number = 1098;
		zBackupCommonGetStructDetails() updating, protected, number = 1081;
		zBackupCommonInitiatePartitionWorkers(pBackupWorkers: Integer) updating, protected, number = 1088;
		zBackupCommonInitiateWorkers() updating, protected, number = 1082;
		zBackupCommonSetAbortJournalEnterBackupState(pJdba: JadeDatabaseAdmin) updating, protected, number = 1089;
		zBackupCommonSubscribeNotify(pJdba: CnJadeDatabaseAdmin) updating, protected, number = 1083;
		zBackupJournalsAndNonDbFiles(pLogText: String) updating, protected, number = 1075;
		zBackupRemainingFilesInSystem(): String protected, number = 1020;
		zBackupWorkersTerminated() updating, protected, number = 1057;
		zCommitBackup() number = 1094;
		zCommitCoherentBackup(): Boolean updating, number = 1080;
		zCommitCoherentBackupExceptionHandler(
			pException: Exception; 
			pCommitErrorCode: Integer output): Integer number = 1091;
		zCompactWorkersTerminated() updating, protected, number = 1068;
		zCreateCnDbFiles() protected, number = 1079;
		zGetScanFileContents(pScanFileName: String): String protected, number = 1100;
		zHandleJournalTransferEvent(pUserInfo: Any) number = 1023;
		zPartitionWorkersTerminated() updating, protected, number = 1090;
		zSetStartJournalNumber(pJdba: JadeDatabaseAdmin) updating, protected, number = 1085;
		zSuppressEmbeddedSpaceAlert(): Boolean protected, number = 1010;
		zTryBackupCoherentCommit(): Boolean updating, number = 1097;
		zValidationChecks(): String protected, number = 1021;
	)
	CnJadeSkinsLoader completeDefinition
	(
		documentationText
		`Unload and reload JADE skins.`
	jadeMethodDefinitions
		reload(
			fileName: String; 
			initDir: Boolean; 
			gui: Boolean): Boolean updating, number = 1002;
		unload(
			outDir: String; 
			initDir: Boolean) updating, number = 1001;
	)
	CnNodeControl completeDefinition
	(
		documentationText
`There is one shared-transient of this type created per JADE node,
when the environment is executing in multi-user mode.`
	constantDefinitions
		DeBug:                         Boolean = false number = 1001;
	attributeDefinitions
		nodeId:                        String[213] readonly, number = 7, ordinal = 7;
		nodeType:                      Character readonly, number = 8, ordinal = 8;
		sampleCacheStats:              Boolean readonly, number = 4, ordinal = 4;
		sampleProcessStats:            Boolean readonly, number = 3, ordinal = 3;
		samplingDefeated:              Boolean readonly, number = 9, ordinal = 10;
		samplingFrequency:             Integer number = 2, ordinal = 9;
		documentationText
		`
Only used for non-managed apps.`
		samplingNode:                  Boolean readonly, number = 10, ordinal = 11;
		samplingTag:                   Integer protected, number = 1, ordinal = 1;
	referenceDefinitions
		allNodeControlCnCntrlArray:    CnNodeControlCnCntrlArray  implicitMemberInverse, readonly, subId = 1, number = 11, ordinal = 15;
		documentationText
`This is a manually maintained collection to ensure
that the creation / deletion of CnCntrl instances
does not always required shared transient transaction 
state.`
		cacheDataPersistent:           JadeDynamicObject  protected, number = 5, ordinal = 5;
		cacheDataTransient:            JadeDynamicObject  protected, number = 6, ordinal = 6;
	jadeMethodDefinitions
		create() updating, protected, number = 1003;
		delta(
			jdo1: JadeDynamicObject; 
			jdo2: JadeDynamicObject; 
			attributeName: String): Real protected, number = 1007;
		doCacheStatsRequest() updating, number = 1006;
		doSamplingStatusChange(
			proc: Boolean; 
			cache: Boolean) updating, number = 1004;
		endSampling() updating, protected, number = 1002;
		establishNodeControlProcess() number = 1009;
		getCacheStats(
			cacheType: Integer; 
			csvStr: String output): Binary updating, protected, number = 1008;
		sendOrStoreMessage(bin: Binary) updating, protected, number = 1001;
		timerEvent(eventTag: Integer) updating, number = 1005;
		zDebugJdoContents(
			pCacheType: String; 
			pJdo: JadeDynamicObject) number = 1011;
		zDebugWrite(pText: String) protected, number = 1010;
	)
	CnNodeControlCnCntrl completeDefinition
	(
		documentationText
`The sole purpose of this class is to be created as a shared transient
to be attached to the node shared transient singleton CnNodeControl
and allows each process to identify if they are the first KarmaControl
registered process in this node.

At the moment (3.5.01) this is solely used for derivation of
SSL details for an App Server.`
	)
	CnParam completeDefinition
	(
	attributeDefinitions
		journalNo:                     Integer number = 1, ordinal = 1;
	)
	CnSchemaAnalyser completeDefinition
	(
	constantDefinitions
		BOLD:                          Boolean = true number = 1001;
		CHECK:                         String = "** CHECK **" number = 1002;
		INDENT:                        String = "     " number = 1003;
		MODIFIED_TIMESTAMP:            String = "setModifiedTimeStamp" number = 1004;
	attributeDefinitions
		completeClassDefinition:       Boolean protected, number = 5, ordinal = 1;
		completeSchemaDefinition:      Boolean protected, number = 3, ordinal = 2;
		currentLine:                   String[256] protected, number = 9, ordinal = 3;
		currentLineLength:             Integer protected, number = 8, ordinal = 4;
		endOfFile:                     Boolean protected, number = 10, ordinal = 6;
		forkDate:                      TimeStamp protected, number = 15, ordinal = 7;
		lastRecord:                    Boolean protected, number = 11, ordinal = 9;
		pos:                           Integer protected, number = 4, ordinal = 13;
		printAll:                      Boolean protected, number = 14, ordinal = 14;
	referenceDefinitions
		currentType:                   Type  protected, number = 6, ordinal = 5;
		inFile:                        File  protected, number = 2, ordinal = 8;
		myForm:                        CnSchemaAnalysisOutputForm  protected, number = 13, ordinal = 10;
		outFile:                       File  protected, number = 1, ordinal = 11;
		pTable:                        Table  protected, number = 12, ordinal = 12;
		targetSchema:                  Schema  protected, number = 7, ordinal = 15;
	jadeMethodDefinitions
		analyse(
			specificClass: Class; 
			lincStats: Boolean) updating, number = 1005;
		countSourceLines(
			methDict: MethodNDict; 
			lines: Integer io; 
			amethods: Integer io; 
			rmethods: Integer io) updating, protected, number = 1004;
		discardUntil(str: String): String updating, protected, number = 1016;
		displayUnexpectedToken(
			methodName: String; 
			token: String) protected, number = 1011;
		doClassConstantDefinitions(): String updating, protected, number = 1023;
		doGlobalConstantDefinitions(): String updating, protected, number = 1015;
		doInverseDefinitions() updating, protected, number = 1006;
		doJadeMethodDefinitions(jadeMethods: Boolean): String updating, protected, number = 1009;
		doPropertyDefinitions(references: Boolean): String updating, protected, number = 1007;
		doTypeDefinitions(): String updating, protected, number = 1003;
		formatTimeStamp(
			ts: TimeStamp; 
			modifier: String): String updating, protected, number = 1019;
		getNextToken(newLine: Boolean output): String updating, protected, number = 1014;
		getTimeStamp(modifier: String output): TimeStamp updating, protected, number = 1012;
		isGroupHeading(token: String): Boolean protected, number = 1010;
		isSectionHeading(heading: String): Boolean protected, number = 1013;
		polishTable(table: Table input) updating, protected, number = 1020;
		printComparison(
			line: String; 
			ts: TimeStamp; 
			ts2: TimeStamp; 
			fontBold: Boolean) protected, number = 1021;
		printIt(
			str: String; 
			bold: Boolean) protected, number = 1002;
		printReport() updating, protected, number = 1018;
		reportChangesSinceForkDate(
			forkdate: TimeStamp; 
			schemaFileName: String; 
			outputFileName: String; 
			printAllEntities: Boolean) updating, number = 1001;
		setupPrinter() updating, protected, number = 1008;
		setupTableHeadings() updating, protected, number = 1017;
		skipDocumentationText(newLine: Boolean output): String updating, protected, number = 1022;
	)
	CnServerStatistics completeDefinition
	(
		documentationText
		`Singleton for server statistics retention.`
	attributeDefinitions
		remainingProcessAlertThreshold:Integer protected, subschemaHidden, number = 7, ordinal = 25;
		remainingProcessAlertTimeStamp:TimeStamp protected, subschemaHidden, number = 8, ordinal = 26;
		statsSummaryV1:                Binary[188] protected, subschemaHidden, number = 1, ordinal = 27;
		documentationText
`Used to temporarily store results of Version 1 captureSystemStats.  
Length of this binary should be length of system stats (currently 23 Integer64 values) plus 4 for length.`
		statsSummaryV2:                Binary[112] protected, subschemaHidden, number = 9, ordinal = 28;
		documentationText
`Binary containing the database cache statistics.

The length item is held in the first 4 bytes of statsSummaryV1 and caters for
the number of items held in this binary.

As at 3.7.05 and JADE 7.0 this contains
14 Integer64 values (14 * 8) - 112 bytes`
		useFirst:                      Boolean protected, number = 16, ordinal = 18;
	referenceDefinitions
		jadeLicenceInfo:               JadeLicenceInfo  protected, number = 17, ordinal = 21;
		jdoDatabaseStats1:             JadeDynamicObject  protected, number = 18, ordinal = 23;
		jdoDatabaseStats2:             JadeDynamicObject  protected, number = 19, ordinal = 24;
		jdoDbCacheStats1:              JadeDynamicObject  protected, subschemaHidden, number = 2, ordinal = 29;
		jdoDbCacheStats2:              JadeDynamicObject  protected, subschemaHidden, number = 10, ordinal = 30;
		jdoRequestStats1:              JadeDynamicObject  protected, number = 20, ordinal = 22;
		jdoRequestStats2:              JadeDynamicObject  protected, number = 21, ordinal = 17;
	jadeMethodDefinitions
		captureSystemStatistics() updating, number = 1001;
		copyTransientsToArray(pObjectArray: ObjectArray input) number = 1006;
		create() updating, number = 1002;
		delete() updating, number = 1004;
		getStatsSummary(): Binary number = 1003;
		zCheckProcessLicenceCount(pProcessesLeft: Integer) updating, protected, number = 1007;
		zGetOrSetRemainingProcessAlertThreshold(pIniFileVerb: String): Integer protected, subschemaHidden, number = 1009;
		zGetRemainingProcessAlertThreshold() updating, protected, subschemaHidden, number = 1008;
		zGetSDSReplayLagTime(): Integer64 protected, number = 1005;
	)
	CnTransactionData completeDefinition
	(
	attributeDefinitions
		rpcCauseEvents:                RealArray readonly, subId = 33, number = 33, ordinal = 33;
		rpcCpuTimes:                   RealArray readonly, subId = 25, number = 25, ordinal = 25;
		rpcCreateObjects:              RealArray readonly, subId = 29, number = 29, ordinal = 29;
		rpcDeleteObjects:              RealArray readonly, subId = 31, number = 31, ordinal = 31;
		rpcEndTransactions:            RealArray readonly, subId = 32, number = 32, ordinal = 32;
		rpcGetObjects:                 RealArray readonly, subId = 26, number = 26, ordinal = 26;
		rpcLockObjects:                RealArray readonly, subId = 27, number = 27, ordinal = 27;
		rpcLockQueueWaitsTimes:        RealArray readonly, subId = 36, number = 36, ordinal = 36;
		rpcServerExecutionTimes:       RealArray readonly, subId = 35, number = 35, ordinal = 35;
		rpcServerExecutions:           RealArray readonly, subId = 34, number = 34, ordinal = 34;
		rpcUnlockObjects:              RealArray readonly, subId = 28, number = 28, ordinal = 28;
		rpcUpdateObjects:              RealArray readonly, subId = 30, number = 30, ordinal = 30;
		tcBytesAppServers:             RealArray readonly, subId = 38, number = 38, ordinal = 38;
		tcBytesClients:                RealArray readonly, subId = 40, number = 40, ordinal = 40;
		tcMsgsAppServers:              RealArray readonly, subId = 37, number = 37, ordinal = 37;
		tcMsgsClients:                 RealArray readonly, subId = 39, number = 39, ordinal = 39;
		tcNetworkTimes:                RealArray readonly, subId = 41, number = 41, ordinal = 41;
		tcTranCounts:                  IntegerArray readonly, subId = 42, number = 42, ordinal = 42;
		tranCounts:                    IntegerArray readonly, subId = 24, number = 24, ordinal = 1;
		tranCounts100ms:               IntegerArray readonly, subId = 3, number = 3, ordinal = 2;
		tranCounts10sec:               IntegerArray readonly, subId = 15, number = 15, ordinal = 3;
		tranCounts1sec:                IntegerArray readonly, subId = 6, number = 6, ordinal = 4;
		tranCounts20sec:               IntegerArray readonly, subId = 16, number = 16, ordinal = 5;
		tranCounts250ms:               IntegerArray readonly, subId = 4, number = 4, ordinal = 6;
		tranCounts2sec:                IntegerArray readonly, subId = 7, number = 7, ordinal = 7;
		tranCounts3sec:                IntegerArray readonly, subId = 8, number = 8, ordinal = 8;
		tranCounts4sec:                IntegerArray readonly, subId = 9, number = 9, ordinal = 9;
		tranCounts500ms:               IntegerArray readonly, subId = 5, number = 5, ordinal = 10;
		tranCounts50ms:                IntegerArray readonly, subId = 2, number = 2, ordinal = 11;
		tranCounts5sec:                IntegerArray readonly, subId = 10, number = 10, ordinal = 12;
		tranCounts6sec:                IntegerArray readonly, subId = 11, number = 11, ordinal = 13;
		tranCounts7sec:                IntegerArray readonly, subId = 12, number = 12, ordinal = 14;
		tranCounts8sec:                IntegerArray readonly, subId = 13, number = 13, ordinal = 15;
		tranCounts9sec:                IntegerArray readonly, subId = 14, number = 14, ordinal = 16;
		tranCountsTot:                 IntegerArray readonly, subId = 1, number = 1, ordinal = 17;
		tranErrors:                    IntegerArray readonly, subId = 17, number = 17, ordinal = 18;
		tranIds:                       CnTransactionIdArray readonly, subId = 18, number = 18, ordinal = 19;
		tranMaxTimes:                  IntegerArray readonly, subId = 19, number = 19, ordinal = 20;
		tranMinTimes:                  IntegerArray readonly, subId = 20, number = 20, ordinal = 21;
		tranSumOfTimes:                RealArray readonly, subId = 21, number = 21, ordinal = 22;
		tranSumSquaresOfTimes:         RealArray readonly, subId = 22, number = 22, ordinal = 23;
		tranTimes:                     IntegerArray readonly, subId = 23, number = 23, ordinal = 24;
	jadeMethodDefinitions
		handleTranStatsSubmissionEvent(userInfo: Any) updating, number = 1002;
		sendTranStatsToKarma() number = 1003;
		storeResponseTimes(
			index: Integer; 
			elapsed: Integer) protected, number = 1001;
	)
	CnTransactionStack completeDefinition
	(
		documentationText
`Diagnostics will be logged depending on [Karma] TestMode setting

TestMode > 0
	then every 60 seconds the process will dump details about
	CnJadeDynamicObjects stored in the processPersistentStatsObjects and 
	processThinClientStatsObjects collections and also how many JadeDynamicObject
	transients exist for the application.
	
TestMode = 2
	every create/delete of CnJadeDynamicObject entities will be logged. The
	deletion entry will identify the created timestamp.`
	attributeDefinitions
		currentLogDate:                Date readonly, number = 6, ordinal = 1;
		startTimes:                    DecimalArray readonly, subId = 1, number = 1, ordinal = 3;
		tags:                          IntegerArray readonly, subId = 4, number = 4, ordinal = 4;
		transactionErrors:             BooleanArray readonly, subId = 3, number = 3, ordinal = 5;
		transactionIds:                CnTransactionIdArray readonly, subId = 2, number = 2, ordinal = 6;
		transactionStates:             CharacterArray readonly, subId = 5, number = 7, ordinal = 7;
	referenceDefinitions
		myLog:                         JadeLog  readonly, number = 5, ordinal = 2;
		processPersistentStatsObjects: CnJadeDynamicObjectArray  readonly, number = 8, ordinal = 8;
		processThinClientStatsObjects: CnJadeDynamicObjectArray  readonly, number = 9, ordinal = 9;
	jadeMethodDefinitions
		create() updating, number = 1002;
		delete() updating, number = 1010;
		delta(
			jdo1: CnJadeDynamicObject; 
			jdo2: CnJadeDynamicObject; 
			attributeName: String): Real number = 1004;
		exceptionHandler(
			exObj: Exception; 
			error: Boolean output): Integer number = 1006;
		getLocalProcessStats(): Binary protected, number = 1009;
		getProcessStats(): Binary number = 1008;
		getRpcProcessStats(): Binary protected, number = 1003;
		getThinClientProcessStats(): Binary number = 1007;
		setUpLogicalTranLogHeadings() updating, number = 1005;
		timerEvent(eventTag: Integer) updating, number = 1011;
		writeLog(str: String) updating, clientExecution, number = 1001;
		zLogDynamicObjects() updating, number = 1012;
	)
	CnTransactionStatistics completeDefinition
	(
	attributeDefinitions
		data:                          Binary readonly, subId = 1, number = 1, ordinal = 1;
		dataLength:                    Integer readonly, number = 2, ordinal = 2;
	jadeMethodDefinitions
		sendTranStats() updating, number = 1003;
		setData(bin: Binary) updating, number = 1001;
		setDataLength(length: Integer) updating, number = 1002;
	)
	CnUtility completeDefinition
	(
		documentationText
		`CardSchema internal utility methods.  Not supported for external use.`
	jadeMethodDefinitions
		extractDatabaseStructureInfo() number = 1011;
		extractDbFileInfo() number = 1008;
		initializeMapFilePaths() number = 1003;
		jc24CheckCommandLine() number = 1009;
		renameMapfile(pNames: String) number = 1005;
		resetUserAppliedPatchesAll() number = 1002;
		schemaFilesFreezeThaw(pFreezeOrThaw: String) number = 1006;
		startMonitorBackgroundServer() serverExecution, number = 1007;
		validateMethods() number = 1001;
		zJC24GetSchemaCollection(
			pSchema: Schema; 
			pSchemaColl: SchemaColl input) protected, number = 1010;
	)
	CnApp completeDefinition
	(
	attributeDefinitions
		appName:                       String[101] readonly, number = 9, ordinal = 9;
		appSchemaName:                 String[101] readonly, number = 10, ordinal = 10;
		environmentId:                 String[10] readonly, number = 1, ordinal = 2;
		isRunning:                     Boolean readonly, number = 2, ordinal = 3;
		logonTime:                     TimeStamp readonly, number = 3, ordinal = 4;
	referenceDefinitions
		allCnProcesses:                CnProcessDict   explicitInverse, readonly, subId = 1, number = 5, ordinal = 1;
		myCnCntrl:                     CnCntrl  readonly, number = 6, ordinal = 5;
		myCnMachine:                   CnMachine   explicitEmbeddedInverse, readonly, number = 7, ordinal = 6;
		myKarmaCntrl:                  CnKarmaCntrl  readonly, number = 8, ordinal = 7;
	jadeMethodDefinitions
		setAppName(appname: String) updating, number = 1008;
		setAppSchemaName(pValue: String) updating, number = 1009;
		setEnvironmentId(id: String) updating, number = 1001;
		setLogonTime(ts: TimeStamp) updating, number = 1002;
		setMyCnCntrl(cc: CnCntrl) updating, number = 1003;
		setMyKarmaCntrl(kc: CnKarmaCntrl) updating, number = 1004;
		setMyMachine(mach: CnMachine) updating, number = 1005;
		userNotification(
			eventType: Integer; 
			theObject: Object; 
			eventTag: Integer; 
			userInfo: Any) updating, number = 1007;
	)
	CnClusterInfo completeDefinition
	(
	attributeDefinitions
		clusterGroup:                  String[65] readonly, number = 8, ordinal = 8;
		clusterName:                   String[31] readonly, number = 2, ordinal = 1;
		jawsVersion:                   String[31] readonly, number = 1, ordinal = 2;
		possibleHosts:                 StringArray readonly, subId = 1, number = 7, ordinal = 3;
		preferredHost:                 String[31] readonly, number = 6, ordinal = 4;
		serviceName:                   String[257] readonly, number = 4, ordinal = 5;
		virtualMachineName:            String[31] readonly, number = 5, ordinal = 6;
		windowStation:                 String[65] readonly, number = 3, ordinal = 7;
	jadeMethodDefinitions
		create() updating, protected, number = 1001;
	externalMethodDefinitions
		clusterVirtualOnMe(
			virtualName: String io; 
			machineName: String output): Boolean is "emClusterVirtualOnMe" in "karma" updating, number = 1003;
		getClusterInfo(
			jawsVersion: String output; 
			clusterName: String output; 
			windowStation: String output; 
			serviceName: String output; 
			virtualMachineName: String output; 
			preferredHost: String output; 
			hosts: String output; 
			clusterGroup: String output; 
			errorText: String output): Integer is "emMMapInfo2" in "karma" updating, protected, number = 1002;
	)
	CnCntrl completeDefinition
	(
		documentationText
`General purpose control class for CardSchema, automatically instantiated as a singleton
by CnKarmaCntrl's constructor.  

------------------------------------------------------------------------------------------
>>>>>>>>  This is a private class.  Do not subclass or instantiate directly. <<<<<<<<<<<<<
------------------------------------------------------------------------------------------


(See text for constant CardSchema_Version for full version history.)`
	constantDefinitions
		Application_Process:           String = "APP" number = 1001;
		CardSchema_Version:            String = "No longer used, refer to A_VersionClass constants" number = 1002;
		CnLogComment:                  Integer = 9004 number = 1003;
		CnLogConnect:                  Integer = 9005 number = 1004;
		CnLogDiag:                     Integer = 9003 number = 1005;
		CnLogErrors:                   Integer = 9006 number = 1006;
		CnLogMsgAssemble:              Integer = 9009 number = 1033;
		CnLogMsgLoad:                  Integer = 9010 number = 1034;
		CnLogProgramError:             Integer = 9007 number = 1007;
		CnLogQual:                     Integer = 9008 number = 1032;
		CnLogReceive:                  Integer = 9001 number = 1008;
		CnLogTransmit:                 Integer = 9002 number = 1009;
		Cn_Control_Command:            Integer = 55000111 number = 1010;
		Cn_ETX:                        String = #"03" number = 1011;
		Cn_OK:                         String = "OK" number = 1012;
		Cn_SOH:                        String = #"01" number = 1013;
		Cn_STX:                        String = #"01" number = 1014;
		CommsMgr_To_JK_Foreground:     Integer = 601 number = 1015;
		Default_LogFileMaxSize:        Integer = 1000000 number = 1016;
		Default_LogFileName:           String = "cn_log.log" number = 1017;
		Default_Windows_LogPath:       String = "c:\temp" number = 1018;
		Exception_Handler_Both:        Integer = 2 number = 1019;
		Exception_Handler_Both_NotSvce:Integer = 5 number = 1020;
		documentationText
		`BothIfNotService`
		Exception_Handler_CardSchema:  Integer = 1 number = 1021;
		Exception_Handler_Jade:        Integer = 4 number = 1022;
		Exception_Handler_Jade_Debug:  Integer = 3 number = 1023;
		False:                         String = "false" number = 1024;
		JK_Foreground_To_CommsMgr:     Integer = 602 number = 1025;
		JossCommsMgr_Process:          String = "JCM" number = 1026;
		Joss_Foreground_Process:       String = "JFG" number = 1027;
		KCCMgr_Process:                String = "KCC" number = 1028;
		KarmaCommsMgr_Process:         String = "KCM" number = 1029;
		Karma_Application_Process:     String = "KAP" number = 1030;
		documentationText
		`Karma applications such as KarmaSecurityMgr.`
		True:                          String = "true" number = 1031;
	attributeDefinitions
		appName:                       String[101] readonly, number = 1, ordinal = 3;
		documentationText
		`Contains the application name of the Process Application.`
		appSchemaName:                 String[101] readonly, number = 83, ordinal = 87;
		documentationText
		`Contains the schema name of the Process Application.`
		archivalRecoveryEnabled:       Boolean readonly, number = 64, ordinal = 66;
		autoReListen:                  Boolean readonly, number = 2, ordinal = 4;
		autoReOpen:                    Boolean readonly, number = 3, ordinal = 5;
		checkTransientsOnShutDown:     Boolean readonly, number = 5, ordinal = 7;
		clientTranStats:               Boolean readonly, number = 6, ordinal = 8;
		clientUsesReadOnlySchema:      Boolean readonly, number = 7, ordinal = 9;
		computerName:                  String[31] readonly, number = 8, ordinal = 10;
		connectionCount:               Integer readonly, number = 9, ordinal = 11;
		connectionNo:                  Integer readonly, number = 10, ordinal = 12;
		connectionResponseTime:        Integer readonly, number = 11, ordinal = 13;
		connectionRetryDelay:          Integer readonly, number = 12, ordinal = 14;
		connectionRetryLimit:          Integer readonly, number = 13, ordinal = 15;
		dbLogPath:                     String[129] readonly, number = 74, ordinal = 76;
		deadlockRetryLimit:            Integer readonly, number = 14, ordinal = 16;
		defaultMaxLocalProcesses:      Integer readonly, number = 76, ordinal = 79;
		developmentProcessPidArray:    IntegerArray readonly, subId = 3, number = 84, ordinal = 88;
		dumpXamlObjectProperties:      Boolean readonly, number = 86, ordinal = 90;
		exceptionDisplayModal:         Boolean readonly, number = 15, ordinal = 17;
		exceptionDisplayTimeout:       Integer readonly, number = 16, ordinal = 18;
		exceptionFormPicture:          Integer readonly, number = 55, ordinal = 19;
		exceptionHandlerType:          Integer readonly, number = 18, ordinal = 20;
		headerLength:                  Integer readonly, number = 19, ordinal = 21;
		immediateCommit:               Boolean protected, number = 51, ordinal = 22;
		isService:                     Boolean readonly, number = 75, ordinal = 77;
		javaThinClient:                Boolean readonly, number = 20, ordinal = 23;
		documentationText
`If true means that this process is a presentation server for a Java thin client.
Set by ini file option JavaThinClient in [AppEnvironment].
Normally, when using this you need to set SuppressManagementDialogs=true.`
		karmaControl:                  Boolean readonly, number = 21, ordinal = 24;
		lockRetryTime:                 Integer readonly, number = 22, ordinal = 25;
		lockTimeOut:                   Integer readonly, number = 4, ordinal = 78;
		logCallStackDump:              Boolean readonly, number = 23, ordinal = 26;
		logCommsBuffers:               Boolean readonly, number = 24, ordinal = 27;
		documentationText
		`If true, will result in logging receive and transmit buffers to cn_comms.log`
		logCommsComputer:              String[51] readonly, number = 25, ordinal = 28;
		documentationText
`If computer name is specified, limits any comms logging to the specified computer name.`
		logCommsConnections:           Boolean readonly, number = 26, ordinal = 29;
		documentationText
		`If true, results in logging of comms connection data to cn_comms.log`
		logDiagnostics:                Boolean readonly, number = 27, ordinal = 30;
		logEntries:                    Integer protected, number = 53, ordinal = 31;
		documentationText
`
Count of log writes using cnWriteLog since last committed write (JadeLog::log).`
		logErrors:                     Boolean readonly, number = 28, ordinal = 32;
		logFileMaxSize:                Integer readonly, number = 29, ordinal = 33;
		logFileName:                   String[51] readonly, number = 30, ordinal = 34;
		logImmediateCommit:            Boolean readonly, number = 31, ordinal = 35;
		logLocalCacheStats:            Boolean readonly, number = 73, ordinal = 75;
		logLogicalTransactions:        Boolean readonly, number = 50, ordinal = 36;
		logMessaging:                  Boolean readonly, number = 93, ordinal = 97;
		documentationText
		`Added in 3.8.09.

Default is false.`
		logMiniStackDump:              Boolean readonly, number = 32, ordinal = 37;
		logMiniStackDumpForLocks:      Boolean readonly, number = 54, ordinal = 38;
		logPath:                       String[129] readonly, number = 33, ordinal = 39;
		logPathError:                  Boolean readonly, number = 61, ordinal = 63;
		documentationText
`
This boolean gets set if the log path is set to a default value because
it was not defined in the ini file.`
		logStackDumpCensored:          Boolean readonly, number = 88, ordinal = 92;
		logStackDumpOnTerminate:       Boolean readonly, number = 56, ordinal = 40;
		logStackDumpTruncateObjectString:Boolean readonly, number = 91, ordinal = 95;
		logToScreen:                   Boolean readonly, number = 34, ordinal = 41;
		logging:                       Boolean readonly, number = 35, ordinal = 42;
		maxArrayElementsInDump:        Integer readonly, number = 36, ordinal = 43;
		maxMessageSize:                Integer readonly, number = 37, ordinal = 44;
		nameFromCommandLine:           String[51] readonly, number = 59, ordinal = 62;
		noPingReplies:                 Boolean readonly, number = 38, ordinal = 48;
		nodeMonitoringCheckInterval:   Integer readonly, number = 78, ordinal = 81;
		documentationText
		`This check interval is in minutes.`
		nodeMonitoringDate:            Date protected, number = 80, ordinal = 83;
		nodeMonitoringMaxProcessDef:   Integer readonly, number = 82, ordinal = 85;
		nodeMonitoringPath:            String[31] protected, number = 81, ordinal = 84;
		nodeMonitoringThresholdPercent:Integer readonly, number = 77, ordinal = 80;
		omitBinaryVersionControlCheck: Boolean readonly, number = 39, ordinal = 49;
		osDistribution:                String[31] readonly, number = 66, ordinal = 68;
		osDistributionEx:              String[101] readonly, number = 72, ordinal = 74;
		osVersion:                     String[31] readonly, number = 67, ordinal = 69;
		readOnlySchema:                Boolean readonly, number = 40, ordinal = 50;
		reportExceptions:              Boolean readonly, number = 41, ordinal = 51;
		documentationText
		`If true then exceptions get reported to Joss.  Requires KarmaControl=true.`
		reportExceptionsAll:           Boolean readonly, number = 58, ordinal = 58;
		documentationText
		`
Internal use only. Subschema developers must not change this property.`
		resolveRemoteName:             Boolean readonly, number = 42, ordinal = 52;
		sampleCacheStats:              Boolean readonly, number = 70, ordinal = 72;
		documentationText
		`
Set from ini file option SampleCacheStatistics, for non-managed systems.`
		sampleProcessStats:            Boolean readonly, number = 71, ordinal = 73;
		samplingDefeated:              Boolean readonly, number = 62, ordinal = 64;
		samplingFrequency:             Integer readonly, number = 68, ordinal = 70;
		documentationText
		`
Used for node cache stats on non-managed apps`
		samplingNode:                  Boolean readonly, number = 63, ordinal = 65;
		serverLogFileName:             String[31] readonly, number = 43, ordinal = 53;
		serverLogPath:                 String[129] readonly, number = 44, ordinal = 54;
		suppressAlerts:                Boolean readonly, number = 85, ordinal = 89;
		suppressManagementDialogs:     Boolean readonly, number = 45, ordinal = 55;
		documentationText
`If set, indicates that certain dialogs and forms (e.g. SchemaCopy Advice, crying frog dump screen) are not to be displayed`
		suppressStackDump:             Boolean readonly, number = 90, ordinal = 94;
		systemShutDownEvent:           Integer readonly, number = 52, ordinal = 56;
		tcpExceptionHandlerArmed:      Boolean readonly, number = 17, ordinal = 57;
		documentationText
		`Indicates TCP global exception handler(s) have been armed.`
		terminatingDuplicateProcess:   Boolean readonly, number = 89, ordinal = 93;
		testMode:                      Integer readonly, number = 92, ordinal = 96;
		verifyDatabaseJournals:        Boolean readonly, number = 65, ordinal = 67;
	referenceDefinitions
		allCnTcpClients:               CnTcpClientDict   explicitInverse, readonly, subId = 1, number = 46, ordinal = 1;
		allCnTcpConnections:           CnTcpConnectionDict   explicitInverse, readonly, subId = 2, number = 47, ordinal = 2;
		myBackgroundClientProcess:     Process  readonly, number = 48, ordinal = 45;
		myNodeCacheStatsFile:          File  number = 69, ordinal = 71;
		myNodeControl:                 CnNodeControl  readonly, number = 60, ordinal = 61;
		myNodeControlCnCntrl:          CnNodeControlCnCntrl  readonly, number = 87, ordinal = 91;
		myNodeMonitoringFile:          File  protected, number = 79, ordinal = 82;
		myProcess:                     Process  readonly, number = 49, ordinal = 46;
		myRPSProcesses:                ObjectSet  implicitMemberInverse, readonly, subId = 4, number = 94, ordinal = 98;
		documentationText
`// PAR 1042 - added 4.0.02
Holds process objects that are for the datapump application - either JadeRpsDataPump or user data pumtp`
		myTransientGlobal:             GCardSchema  readonly, number = 57, ordinal = 47;
		documentationText
`Transient instance of global, to allow calling Global methods without causing locking issues.`
	jadeMethodDefinitions
		bumpConnectionCount() updating, number = 1001;
		bumpConnectionNo() updating, number = 1002;
		cnLogCallStack(id: String) updating, number = 1003;
		cnWriteLog(
			entryType: Integer; 
			msg: String; 
			tcp: CnTcpConnection) updating, clientExecution, number = 1006;
		cnWriteLogCommit(
			entryType: Integer; 
			msg: String; 
			tcp: CnTcpConnection) updating, clientExecution, number = 1062;
		create() updating, number = 1007;
		decrementConnectionCount() updating, number = 1008;
		delete() updating, number = 1005;
		deriveNodeId(
			pNode: Node; 
			pIniFileName: String; 
			pNodeType: Character output; 
			pNodeId: String output) updating, number = 1073;
		doLockControlSetup(
			pSchemaName: String; 
			pApplicationName: String; 
			pAllowDuplicateProcesses: Boolean) updating, number = 1070;
		getBaseFileName(filename: String): String number = 1010;
		getProcessForLock(
			pSchemaName: String; 
			pAppName: String; 
			pApplyCollectionLock: Boolean): Process number = 1068;
		initializeProcesses() updating, number = 1077;
		isInTestMode(): Boolean number = 1093;
		logDevelopmentActivity(pCnJadeProcess: CnJadeProcess) number = 1091;
		nodeMonitorChange(
			pCheckInterval: Integer; 
			pThresholdPercent: Integer; 
			pDefaultMaxLocalProcesses: Integer): String updating, number = 1084;
		setAutoReListen(set: Boolean) updating, number = 1013;
		setAutoReOpen(set: Boolean) updating, number = 1014;
		setCheckTransientsOnShutDown(set: Boolean) updating, number = 1016;
		setClientTranStats(set: Boolean) updating, number = 1017;
		setClientUsesReadOnlySchema(set: Boolean) updating, number = 1018;
		setComputerName(name: String) updating, number = 1019;
		setConnectionResponseTime(seconds: Integer) updating, number = 1020;
		setConnectionRetryDelay(delay: Integer) updating, number = 1021;
		setConnectionRetryLimit(limit: Integer) updating, number = 1022;
		setDeadlockRetryLimit(retries: Integer) updating, number = 1023;
		setDefaultMaxLocalProcesses(pValue: Integer) updating, number = 1080;
		setDumpXamlObjectProperties(pValue: Boolean) updating, number = 1089;
		setExceptionDisplayModal(set: Boolean) updating, number = 1024;
		setExceptionDisplayTimeout(timeout: Integer) updating, number = 1025;
		setExceptionHandlerType(type: Integer) updating, number = 1027;
		setFullDiagnostics(set: Boolean) updating, number = 1028;
		setHeaderLength(length: Integer) updating, number = 1029;
		setIsService(set: Boolean) updating, number = 1012;
		setJavaThinClient(set: Boolean) updating, number = 1030;
		setKarmaControl(set: Boolean) updating, number = 1031;
		setLockForProcess(
			pSchemaName: String; 
			pAppName: String; 
			pSet: Boolean; 
			pApplyCollectionLock: Boolean): Boolean updating, number = 1069;
		setLockRetryTime(millisecs: Integer) updating, number = 1032;
		setLockTimeOut(pMilliSeconds: Integer) updating, number = 1015;
		setLogCallStackDump(set: Boolean) updating, number = 1033;
		setLogCommsBuffers(set: Boolean) updating, number = 1034;
		setLogCommsComputer(computer: String) updating, number = 1035;
		setLogCommsConnections(set: Boolean) updating, number = 1036;
		setLogDiagnostics(set: Boolean) updating, number = 1037;
		setLogErrors(set: Boolean) updating, number = 1038;
		setLogFileMaxSize(size: Integer) updating, number = 1039;
		setLogFileName(name: String) updating, number = 1040;
		setLogImmediateCommit(set: Boolean) updating, number = 1041;
		setLogLogicalTransactions(set: Boolean) updating, number = 1004;
		setLogMessaging(pValue: Boolean) updating, number = 1097;
		setLogMiniStackDump(set: Boolean) updating, number = 1042;
		setLogMiniStackDumpForLocks(set: Boolean) updating, number = 1067;
		setLogPath(pLogPath: String) updating, number = 1043;
		setLogPathError(set: Boolean) updating, number = 1071;
		setLogStackDumpCensored(pValue: Boolean) updating, number = 1090;
		setLogStackDumpTruncateObjectString(pValue: Boolean) updating, number = 1094;
		setLogToScreen(set: Boolean) updating, number = 1044;
		setLogging(set: Boolean) updating, number = 1045;
		setMaxArrayElementsInDump(count: Integer) updating, number = 1047;
		setMaxMessageSize(int: Integer) updating, number = 1048;
		setMyBackgroundClientProcess(proc: Process) updating, number = 1049;
		setMyNodeControl(nodeControl: CnNodeControl input) updating, number = 1072;
		setNoPingReplies(set: Boolean) updating, number = 1050;
		setNodeMonitoringThresholdInfo(
			pCheckInterval: Integer; 
			pThresholdPercent: Integer) updating, number = 1083;
		setOmitBinaryVersionControlChk(set: Boolean) updating, number = 1051;
		setOsDistroAndVersion() updating, number = 1074;
		setReadOnlySchema(set: Boolean) updating, number = 1052;
		setReportExceptions(set: Boolean) updating, number = 1053;
		setResolveRemoteName(set: Boolean) updating, number = 1054;
		setSamplingDefeated(set: Boolean) updating, number = 1011;
		setServerLogFileName(name: String) updating, number = 1055;
		setServerLogPath(path: String) updating, number = 1056;
		setSuppressAlerts(pValue: Boolean) updating, number = 1088;
		setSuppressManagementDialogs(set: Boolean) updating, number = 1057;
		setSuppressStackDump(pValue: Boolean) updating, number = 1092;
		setSystemShutDownEvent(eventTag: Integer) updating, number = 1063;
		setTcpExceptionHandlerArmed(set: Boolean) updating, number = 1026;
		setTerminatingDuplicateProcess(pValue: Boolean) updating, number = 1009;
		setTestMode(pValue: Integer) updating, number = 1095;
		setTestModeFromIni() updating, number = 1096;
		setupControlOptions() updating, number = 1058;
		setupExceptionDefaults(pIniFile: String) updating, number = 1059;
		setupExceptionFlags() updating, number = 1060;
		setupForSystemShutDown() updating, number = 1065;
		startUserServerApplications(
			pIniFileName: String; 
			pDatabaseRole: Integer; 
			pLaunch: Boolean) updating, number = 1066;
		sysNotification(
			eventType: Integer; 
			theObject: Object; 
			eventTag: Integer) updating, number = 1076;
		timerEvent(eventTag: Integer) updating, number = 1078;
		userNotification(
			eventType: Integer; 
			theObject: Object; 
			eventTag: Integer; 
			userInfo: Any) updating, number = 1064;
		zCheckNodeMonitorFile() updating, protected, number = 1086;
		zFileJadeDevelopmentActivity(pFile: File input) number = 1046;
		zHandleNodeControl() protected, number = 1099;
		zHandleProcessCreateUpdate(
			pJadeProcess: Process; 
			pEventType: Integer) protected, number = 1098;
		zHandleProcessDelete(pJadeProcess: Process) protected, number = 1100;
		zJadeApplicationCreate() protected, number = 1082;
		zJadeProcessCreate(
			pJadeProcess: Process; 
			pKCCMgrStartUp: Boolean) protected, number = 1079;
		zJadeProcessDelete(pObject: Object) protected, number = 1081;
		zJadeProcessUpdate(pJadeProcess: Process) protected, number = 1061;
		zRpsNodeAdded(
			pType: Integer; 
			pJadeProcess: Process; 
			pAlreadyStarted: Boolean): Boolean number = 1101;
		zSetupLoggingOptions(pIniFile: String) updating, protected, number = 1087;
		zTimerNodeMonitor() updating, protected, number = 1085;
	)
	CnDeadlockHandler completeDefinition
	(
	attributeDefinitions
		deadlockRetryCount:            Integer readonly, number = 4, ordinal = 1;
		methodName:                    String[101] readonly, subschemaHidden, number = 3, ordinal = 2;
	referenceDefinitions
		myParameterArray:              CnVariantArray  readonly, number = 1, ordinal = 3;
		myReceiver:                    Object  readonly, number = 2, ordinal = 4;
	jadeMethodDefinitions
		setDeadlockRetryCount(count: Integer) updating, number = 1006;
		setMethodName(name: String) updating, number = 1003;
		setMyParameterArray(array: CnVariantArray) updating, number = 1005;
		setMyReceiver(obj: Object) updating, number = 1002;
		userNotification(
			eventType: Integer; 
			theObject: Object; 
			eventTag: Integer; 
			userInfo: Any) updating, number = 1001;
	externalMethodDefinitions
		callMethodWith0Param(
			receiver: Object; 
			methodName: String) is "emCallMethod" in "karma" protected, number = 1007;
		callMethodWith10Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any; 
			param6: Any; 
			param7: Any; 
			param8: Any; 
			param9: Any; 
			param10: Any) is "emCallMethod" in "karma" protected, number = 1010;
		callMethodWith11Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any; 
			param6: Any; 
			param7: Any; 
			param8: Any; 
			param9: Any; 
			param10: Any; 
			param11: Any) is "emCallMethod" in "karma" protected, number = 1009;
		callMethodWith12Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any; 
			param6: Any; 
			param7: Any; 
			param8: Any; 
			param9: Any; 
			param10: Any; 
			param11: Any; 
			param12: Any) is "emCallMethod" in "karma" protected, number = 1008;
		callMethodWith1Param(
			receiver: Object; 
			methodName: String; 
			param1: Any) is "emCallMethod" in "karma" protected, number = 1004;
		callMethodWith2Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any) is "emCallMethod" in "karma" protected, number = 1018;
		callMethodWith3Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any) is "emCallMethod" in "karma" protected, number = 1017;
		callMethodWith4Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any) is "emCallMethod" in "karma" protected, number = 1016;
		callMethodWith5Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any) is "emCallMethod" in "karma" protected, number = 1015;
		callMethodWith6Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any; 
			param6: Any) is "emCallMethod" in "karma" protected, number = 1014;
		callMethodWith7Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any; 
			param6: Any; 
			param7: Any) is "emCallMethod" in "karma" protected, number = 1013;
		callMethodWith8Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any; 
			param6: Any; 
			param7: Any; 
			param8: Any) is "emCallMethod" in "karma" protected, number = 1012;
		callMethodWith9Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any; 
			param6: Any; 
			param7: Any; 
			param8: Any; 
			param9: Any) is "emCallMethod" in "karma" protected, number = 1011;
	)
	CnInternet completeDefinition
	(
		documentationText
		`'32-bit' implementation.

Restricted to files up to 2GB.`
	constantDefinitions
		All_Info:                      Integer = 22 number = 1001;
		FTP_Block_Size:                Integer = 8192 number = 1002;
		File_Length:                   Integer = 5 number = 1003;
		HTTP_Block_Size:               Integer = 8192 number = 1004;
		INT_OPTION_CONNECT_TIMEOUT:    Integer = 2 number = 1005;
		INT_OPTION_DATA_RCV_TIMEOUT:   Integer = 8 number = 1006;
		INT_OPTION_DATA_SEND_TIMEOUT:  Integer = 7 number = 1007;
		INT_OPTION_RECEIVE_TIMEOUT:    Integer = 6 number = 1008;
		INT_OPTION_SEND_TIMEOUT:       Integer = 5 number = 1009;
		Last_Modified_Date:            Integer = 11 number = 1010;
		Server_Type_Novell:            Integer = 1 number = 1011;
		Server_Type_Windows_IIS:       Integer = 0 number = 1012;
		Status_Code:                   Integer = 19 number = 1013;
		Status_Text:                   Integer = 20 number = 1014;
	attributeDefinitions
		connectionHandle:              MemoryAddress readonly, number = 1, ordinal = 1;
		counter:                       Integer readonly, number = 2, ordinal = 2;
		currentFileLastModified:       TimeStamp readonly, number = 3, ordinal = 3;
		currentFileName:               String[513] readonly, number = 4, ordinal = 4;
		currentFileSize:               Integer readonly, number = 5, ordinal = 5;
		fileBytesTransferred:          Integer readonly, number = 6, ordinal = 6;
		fileHandle:                    MemoryAddress number = 7, ordinal = 7;
		password:                      String readonly, subId = 1, number = 8, ordinal = 9;
		serverName:                    String[129] readonly, number = 9, ordinal = 10;
		serverType:                    Integer readonly, number = 15, ordinal = 11;
		sessionHandle:                 MemoryAddress number = 10, ordinal = 12;
		totalBytesToBeTransferred:     Integer number = 11, ordinal = 13;
		totalBytesTransferred:         Integer readonly, number = 12, ordinal = 14;
		useProxy:                      Boolean readonly, number = 16, ordinal = 16;
		userId:                        String readonly, subId = 2, number = 13, ordinal = 15;
	referenceDefinitions
		myNotifyObject:                Object  readonly, number = 14, ordinal = 8;
		documentationText
`Typically this is a reference to a persistent object.  CardSchema will cause progress events on
this object, if valid, during file transfers.`
	jadeMethodDefinitions
		cnCloseConnection() updating, number = 1021;
		cnCloseFile() updating, number = 1008;
		cnCloseSession() updating, number = 1015;
		cnConnect(): String updating, abstract, number = 1001;
		cnGetFile(
			sourceFile: String; 
			destFile: String; 
			usePresentationFileSystem: Boolean): String updating, abstract, number = 1002;
		cnGetFileInfo(
			fileName: String; 
			attributes: String output; 
			filesize: Integer output; 
			lastModified: TimeStamp output): String updating, abstract, number = 1003;
		cnGetFileSize(
			filename: String; 
			filesize: Integer output): String updating, number = 1004;
		cnGetInternetError(errorCode: Integer): String number = 1005;
		cnGetLastModifiedTimeGMT(
			filename: String io; 
			lastModified: TimeStamp output): String updating, abstract, number = 1006;
		cnGetWindowsErrorText(errorCode: Integer): String number = 1022;
		cnOpenConnection(): String updating, protected, number = 1024;
		cnSetModifyTime(
			filename: String; 
			ts: TimeStamp; 
			pUsePresentationFileSystem: Boolean): String updating, number = 1007;
		delete() updating, number = 1009;
		setCurrentFileLastModified(ts: TimeStamp) updating, number = 1010;
		setMyNotifyObject(obj: Object) updating, number = 1011;
		setServerName(name: String) updating, number = 1012;
		setServerType(type: Integer) updating, number = 1020;
		setUseProxy(pUseProxy: Boolean) updating, number = 1025;
		setUserId(
			user: String; 
			pw: String) updating, number = 1013;
		zLogResult(
			pResult: Integer; 
			pQualifier: String) protected, number = 1019;
	externalMethodDefinitions
		emCloseHandle(handle: MemoryAddress): Integer is "emInternetCloseHandle" in "karma" protected, number = 1014;
		emGetInternetError(
			errorCode: Integer; 
			errorText: String output): Integer is "emGetInternetError" in "karma" protected, number = 1016;
		emHttpSendRequestEx(
			requestHandle: MemoryAddress; 
			headers: String; 
			extraInfo: Binary): Integer is "emHttpSendRequestEx" in "karma" updating, protected, number = 1026;
		emInternetReadFile(
			fileHandle: MemoryAddress; 
			buffer: Binary output; 
			bytesWanted: Integer; 
			bytesRead: Integer output): Integer is "emInternetReadFile" in "karma" protected, number = 1017;
		emInternetSetNumericOption(
			sessionHandle: MemoryAddress; 
			internetOption: Integer; 
			internetOptionValue: Integer): Integer is "emInternetSetNumericOption" in "karma" protected, number = 1023;
		emOpenInternetSession(
			handle: MemoryAddress output; 
			appName: String): Integer is "emInternetOpen" in "karma" protected, number = 1018;
		emOpenInternetSessionPreConfig(
			handle: MemoryAddress output; 
			appName: String): Integer is "emInternetOpenPreConfig" in "karma" protected, number = 1027;
	)
	CnFtp completeDefinition
	(
		documentationText
`//______________________________________________________________________________________
//                +-------------------------------------+
//                |   CardSchema (Jade) Class Library   |
//                +-------------------------------------+

//		This material is proprietary to Cardinal Group Limited (Cardinal) and is  
//		not to be reproduced, used or disclosed except upon written permission of     
//		Cardinal.                                                                     
//
//   		COPYRIGHT (C) CARDINAL GROUP LIMITED 1998 - ALL RIGHTS RESERVED
//_____________________________________________________________________________________`
	constantDefinitions
		Default_FTP_PortNumber:        Integer = 21 number = 1003;
		FTP_ASCII:                     Boolean = true number = 1001;
		FTP_Binary:                    Boolean = false number = 1002;
	attributeDefinitions
		modeAscii:                     Boolean readonly, number = 1, ordinal = 1;
		documentationText
`If false, files transferred using cnGetFile or cnPutFile will be transferred in
binary mode.  If true, transfer is in ASCII mode.  Application program needs to
set this boolean after creating the CnFtp object, if ASCII transfer is required.`
		passive:                       Boolean number = 3, ordinal = 2;
		portNumber:                    Integer number = 4, ordinal = 5;
		documentationText
		`Added in 3.8.09`
		serverGMTBias:                 Integer readonly, number = 2, ordinal = 3;
		documentationText
`See CnCntrl.CardSchema_Version text for release 2.2.12 for information about this item.`
	jadeMethodDefinitions
		cnConnect(): String updating, number = 1001;
		cnGetFile(
			sourceFile: String; 
			destFile: String; 
			pUsePresentationFileSystem: Boolean): String updating, number = 1002;
		cnGetFileBasic(
			sourceFile: String; 
			destFile: String; 
			pUsePresentationFileSystem: Boolean): String updating, number = 1026;
		cnGetFileInfo(
			pFileName: String; 
			pAttributes: String output; 
			pFilesize: Integer output; 
			pLastModified: TimeStamp output): String updating, number = 1003;
		cnGetLastModifiedTimeGMT(
			filename: String io; 
			lastModified: TimeStamp output): String updating, number = 1004;
		cnPutFile(
			sourceFile: String; 
			destFile: String; 
			pUsePresentationFileSystem: Boolean; 
			closeConnectionWhenFinished: Boolean): String updating, number = 1005;
		cnRenameFile(
			oldName: String; 
			newName: String): String number = 1016;
		setModeAscii(set: Boolean) updating, number = 1006;
		setServerGMTBias(bias: Integer) updating, number = 1007;
	externalMethodDefinitions
		emFtpCommand(
			connectionHandle: MemoryAddress; 
			commandString: String): Integer is "emFtpCommand" in "karma" number = 1024;
		emFtpConnect(
			connHandle: MemoryAddress output; 
			sessHandle: MemoryAddress; 
			serverName: String; 
			user: String; 
			password: String): Integer is "emFtpConnect" in "karma" number = 1008;
		emFtpConnectEx(
			connHandle: MemoryAddress output; 
			sessHandle: MemoryAddress; 
			serverName: String; 
			user: String; 
			password: String; 
			flags: Integer): Integer is "emFtpConnectEx" in "karma" number = 1019;
		emFtpConnectEx2(
			ftpHandle: MemoryAddress output; 
			sessionHandle: MemoryAddress; 
			ftpServer: String; 
			user: String; 
			password: String; 
			flags: Integer; 
			portnbr: Integer): Integer is "emFtpConnectEx2" in "karma" number = 1025;
		emFtpCreateDirectory(
			connectionHandle: MemoryAddress; 
			directory: String): Integer is "emFtpCreateDirectory" in "karma" number = 1020;
		emFtpDeleteFile(
			ftpConnectionHandle: MemoryAddress; 
			fileName: String): Integer is "emFtpDeleteFile" in "karma" number = 1018;
		emFtpFindFirstFile(
			fileHandle: MemoryAddress output; 
			connectionHandle: MemoryAddress; 
			mask: String; 
			fileInfo: Binary output; 
			fileName: String output; 
			isDirectory: Boolean output): Integer is "emFtpFindFirstFile" in "karma" number = 1009;
		emFtpFindNextFile(
			fileHandle: MemoryAddress io; 
			fileInfo: Binary output; 
			fileName: String output; 
			isDirectory: Boolean output): Integer is "emFtpFindNextFile" in "karma" number = 1017;
		emFtpGetCurrentDirectory(
			connectionHandle: MemoryAddress; 
			directory: String output): Integer is "emFtpGetCurrentDirectory" in "karma" number = 1023;
		emFtpGetFile(
			connHandle: MemoryAddress; 
			sourceFile: String; 
			destFile: String): Integer is "emFtpGetFile" in "karma" number = 1010;
		emFtpGetFileExt(
			handle: MemoryAddress; 
			sourceFileName: String; 
			destFileName: String; 
			ftpFlags: Integer; 
			fileFlags: Integer): Integer is "emFtpGetFileExt" in "karma" number = 1011;
		documentationText
`ftpFlags
--------

	1 = ASCII mode transfer
	2 = Binary mode transfer

fileFlags
---------

	1 		= Read-only
	2 		= Hidden
	4 		= System
	16    	= Directory
	32		= Archive
	48		= Normal
	2048	= Compressed`
		emFtpOpenFile(
			fileHandle: MemoryAddress output; 
			connectionHandle: MemoryAddress; 
			fileName: String; 
			writing: Boolean; 
			ascii: Boolean): Integer is "emFtpOpenFile" in "karma" number = 1012;
		emFtpRemoveDirectory(
			connectionHandle: MemoryAddress; 
			directory: String): Integer is "emFtpRemoveDirectory" in "karma" number = 1021;
		emFtpRenameFile(
			connectionHandle: MemoryAddress; 
			fileName: String; 
			newFileName: String): Integer is "emFtpRenameFile" in "karma" protected, number = 1015;
		emFtpSetCurrentDirectory(
			connectionHandle: MemoryAddress; 
			directory: String): Integer is "emFtpSetCurrentDirectory" in "karma" number = 1022;
		emGetFileInfo(
			fileInfo: Binary; 
			fileName: String output; 
			attributes: String output; 
			fileSize: Integer output; 
			creationDate: Integer output; 
			creationTime: Integer output; 
			accessDate: Integer output; 
			accessTime: Integer output; 
			updateDate: Integer output; 
			updateTime: Integer output): Integer is "emGetFileInfo" in "karma" protected, number = 1013;
		emInternetWriteFile(
			fileHandle: MemoryAddress; 
			buffer: Binary; 
			bytesToWrite: Integer; 
			bytesWritten: Integer output): Integer is "emInternetWriteFile" in "karma" protected, number = 1014;
	)
	CnHttp completeDefinition
	(
	attributeDefinitions
		requestHandle:                 MemoryAddress readonly, number = 1, ordinal = 1;
		secure:                        Boolean readonly, number = 2, ordinal = 2;
	jadeMethodDefinitions
		cnConnect(): String updating, number = 1001;
		cnGetFile(
			sourceFile: String; 
			destFile: String; 
			pUsePresentationFileSystem: Boolean): String updating, number = 1002;
		cnGetFileInfo(
			filename: String; 
			attributes: String output; 
			filesize: Integer output; 
			lastModified: TimeStamp output): String updating, number = 1003;
		cnGetHttpQueryStatus(status: String): String protected, number = 1004;
		cnGetLastModifiedTimeGMT(
			filename: String io; 
			lastModified: TimeStamp output): String updating, number = 1005;
		setSecure(set: Boolean) updating, number = 1006;
	externalMethodDefinitions
		emHttpConnect(
			connHandle: MemoryAddress output; 
			sessHandle: MemoryAddress; 
			serverName: String; 
			user: String; 
			password: String; 
			secure: Boolean): Integer is "emHttpConnect" in "karma" number = 1007;
		emHttpOpenRequest(
			requestHandle: MemoryAddress output; 
			connectionHandle: MemoryAddress; 
			command: String; 
			fileName: String; 
			secure: Boolean): Integer is "emHttpOpenRequest" in "karma" protected, number = 1008;
		emHttpQueryInfo(
			requestHandle: MemoryAddress; 
			attribute: Integer; 
			buffer: String output): Integer is "emHttpQueryInfo" in "karma" protected, number = 1009;
		emHttpSendRequest(
			requestHandle: MemoryAddress; 
			headers: String): Integer is "emHttpSendRequest" in "karma" protected, number = 1010;
	)
	CnInternet64 completeDefinition
	(
		documentationText
		`'64-bit' implementation.

Restricted to files up to 8 Exobytes.`
	constantDefinitions
		All_Info:                      Integer = 22 number = 1001;
		FTP_Block_Size:                Integer = 8192 number = 1002;
		File_Length:                   Integer = 5 number = 1003;
		HTTP_Block_Size:               Integer = 8192 number = 1004;
		INT_OPTION_CONNECT_TIMEOUT:    Integer = 2 number = 1005;
		INT_OPTION_DATA_RCV_TIMEOUT:   Integer = 8 number = 1006;
		INT_OPTION_DATA_SEND_TIMEOUT:  Integer = 7 number = 1007;
		INT_OPTION_RECEIVE_TIMEOUT:    Integer = 6 number = 1008;
		INT_OPTION_SEND_TIMEOUT:       Integer = 5 number = 1009;
		Last_Modified_Date:            Integer = 11 number = 1010;
		Server_Type_Novell:            Integer = 1 number = 1011;
		Server_Type_Windows_IIS:       Integer = 0 number = 1012;
		Status_Code:                   Integer = 19 number = 1013;
		Status_Text:                   Integer = 20 number = 1014;
	attributeDefinitions
		connectionHandle:              MemoryAddress readonly, number = 1, ordinal = 1;
		counter:                       Integer readonly, number = 2, ordinal = 2;
		currentFileLastModified:       TimeStamp readonly, number = 3, ordinal = 3;
		currentFileName:               String[513] readonly, number = 4, ordinal = 4;
		currentFileSize:               Integer64 readonly, number = 5, ordinal = 5;
		fileBytesTransferred:          Integer64 readonly, number = 6, ordinal = 6;
		fileHandle:                    MemoryAddress readonly, number = 7, ordinal = 7;
		password:                      String readonly, subId = 2, number = 8, ordinal = 8;
		serverName:                    String[129] readonly, number = 9, ordinal = 9;
		serverType:                    Integer readonly, number = 15, ordinal = 10;
		sessionHandle:                 MemoryAddress readonly, number = 10, ordinal = 11;
		totalBytesToBeTransferred:     Integer64 number = 11, ordinal = 12;
		totalBytesTransferred:         Integer64 readonly, number = 12, ordinal = 13;
		useProxy:                      Boolean readonly, number = 16, ordinal = 16;
		userId:                        String readonly, subId = 1, number = 13, ordinal = 14;
	referenceDefinitions
		myNotifyObject:                Object  readonly, number = 14, ordinal = 15;
		documentationText
`Typically this is a reference to a persistent object.  CardSchema will cause progress events on
this object, if valid, during file transfers.`
	jadeMethodDefinitions
		cnCloseConnection() updating, number = 1021;
		cnCloseFile() updating, number = 1008;
		cnCloseSession() updating, number = 1026;
		cnConnect(): String updating, abstract, number = 1001;
		cnGetFile(
			sourceFile: String; 
			destFile: String; 
			usePresentationFileSystem: Boolean): String updating, abstract, number = 1002;
		cnGetFileInfo(
			fileName: String; 
			attributes: String output; 
			filesize: Integer64 output; 
			lastModified: TimeStamp output): String updating, abstract, number = 1003;
		cnGetFileSize(
			filename: String; 
			filesize: Integer64 output): String updating, number = 1004;
		cnGetInternetError(errorCode: Integer): String number = 1005;
		cnGetLastModifiedTimeGMT(
			filename: String io; 
			lastModified: TimeStamp output): String updating, abstract, number = 1006;
		cnGetWindowsErrorText(errorCode: Integer): String number = 1022;
		cnOpenConnection(): String updating, protected, number = 1019;
		cnSetModifyTime(
			filename: String; 
			ts: TimeStamp; 
			pUsePresentationFileSystem: Boolean): String updating, number = 1007;
		delete() updating, number = 1009;
		setCurrentFileLastModified(ts: TimeStamp) updating, number = 1010;
		setMyNotifyObject(obj: Object) updating, number = 1011;
		setServerName(name: String) updating, number = 1012;
		setServerType(type: Integer) updating, number = 1020;
		setUseProxy(pUseProxy: Boolean) updating, number = 1015;
		setUserId(
			user: String; 
			pw: String) updating, number = 1013;
		zLogResult(
			pResult: Integer; 
			pQualifier: String) protected, number = 1027;
	externalMethodDefinitions
		emCloseHandle(handle: MemoryAddress): Integer is "emInternetCloseHandle" in "karma" protected, number = 1014;
		emGetInternetError(
			errorCode: Integer; 
			errorText: String output): Integer is "emGetInternetError" in "karma" protected, number = 1016;
		emHttpSendRequestEx(
			requestHandle: MemoryAddress; 
			headers: String; 
			extraInfo: Binary): Integer is "emHttpSendRequestEx" in "karma" updating, protected, number = 1025;
		emInternetReadFile(
			fileHandle: MemoryAddress; 
			buffer: Binary output; 
			bytesWanted: Integer64; 
			bytesRead: Integer64 output): Integer is "emInternetReadFile" in "karma" protected, number = 1017;
		emInternetSetNumericOption(
			sessionHandle: MemoryAddress; 
			internetOption: Integer; 
			internetOptionValue: Integer): Integer is "emInternetSetNumericOption" in "karma" protected, number = 1023;
		emOpenInternetSession(
			handle: MemoryAddress output; 
			appName: String): Integer is "emInternetOpen" in "karma" protected, number = 1018;
		emOpenInternetSessionPreConfig(
			handle: MemoryAddress output; 
			appName: String): Integer is "emInternetOpenPreConfig" in "karma" protected, number = 1024;
	)
	CnFtp64 completeDefinition
	(
		documentationText
`//______________________________________________________________________________________
//                +-------------------------------------+
//                |   CardSchema (Jade) Class Library   |
//                +-------------------------------------+

//		This material is proprietary to Cardinal Group Limited (Cardinal) and is  
//		not to be reproduced, used or disclosed except upon written permission of     
//		Cardinal.                                                                     
//
//   		COPYRIGHT (C) CARDINAL GROUP LIMITED 1998 - ALL RIGHTS RESERVED
//_____________________________________________________________________________________`
	constantDefinitions
		Default_FTP_PortNumber:        Integer = 21 number = 1003;
		FTP_ASCII:                     Boolean = true number = 1001;
		FTP_Binary:                    Boolean = false number = 1002;
	attributeDefinitions
		modeAscii:                     Boolean readonly, number = 1, ordinal = 1;
		documentationText
`If false, files transferred using cnGetFile or cnPutFile will be transferred in
binary mode.  If true, transfer is in ASCII mode.  Application program needs to
set this boolean after creating the CnFtp object, if ASCII transfer is required.`
		passive:                       Boolean number = 3, ordinal = 2;
		portNumber:                    Integer number = 4, ordinal = 5;
		documentationText
		`Added in 3.8.09`
		serverGMTBias:                 Integer readonly, number = 2, ordinal = 3;
		documentationText
`See CnCntrl.CardSchema_Version text for release 2.2.12 for information about this item.`
	jadeMethodDefinitions
		cnConnect(): String updating, number = 1001;
		cnGetFile(
			sourceFile: String; 
			destFile: String; 
			pUsePresentationFileSystem: Boolean): String updating, number = 1002;
		cnGetFileBasic(
			sourceFile: String; 
			destFile: String; 
			pUsePresentationFileSystem: Boolean): String updating, number = 1026;
		cnGetFileInfo(
			pFileName: String; 
			pAttributes: String output; 
			pFilesize: Integer64 output; 
			pLastModified: TimeStamp output): String updating, number = 1003;
		cnGetLastModifiedTimeGMT(
			filename: String io; 
			lastModified: TimeStamp output): String updating, number = 1004;
		cnPutFile(
			sourceFile: String; 
			destFile: String; 
			pUsePresentationFileSystem: Boolean; 
			closeConnectionWhenFinished: Boolean): String updating, number = 1005;
		cnRenameFile(
			oldName: String; 
			newName: String): String number = 1016;
		setModeAscii(set: Boolean) updating, number = 1006;
		setServerGMTBias(bias: Integer) updating, number = 1007;
	externalMethodDefinitions
		emFtpCommand(
			connectionHandle: MemoryAddress; 
			commandString: String): Integer is "emFtpCommand" in "karma" number = 1024;
		emFtpConnect(
			connHandle: MemoryAddress output; 
			sessHandle: MemoryAddress; 
			serverName: String; 
			user: String; 
			password: String): Integer is "emFtpConnect" in "karma" number = 1008;
		emFtpConnectEx(
			connHandle: MemoryAddress output; 
			sessHandle: MemoryAddress; 
			serverName: String; 
			user: String; 
			password: String; 
			flags: Integer): Integer is "emFtpConnectEx" in "karma" number = 1019;
		emFtpConnectEx2(
			ftpHandle: MemoryAddress output; 
			sessionHandle: MemoryAddress; 
			ftpServer: String; 
			user: String; 
			password: String; 
			flags: Integer; 
			portnbr: Integer): Integer is "emFtpConnectEx2" in "karma" number = 1025;
		emFtpCreateDirectory(
			connectionHandle: MemoryAddress; 
			directory: String): Integer is "emFtpCreateDirectory" in "karma" number = 1020;
		emFtpDeleteFile(
			ftpConnectionHandle: MemoryAddress; 
			fileName: String): Integer is "emFtpDeleteFile" in "karma" number = 1018;
		emFtpFindFirstFile(
			fileHandle: MemoryAddress output; 
			connectionHandle: MemoryAddress; 
			mask: String; 
			fileInfo: Binary output; 
			fileName: String output; 
			isDirectory: Boolean output): Integer is "emFtpFindFirstFile" in "karma" number = 1009;
		emFtpFindNextFile(
			fileHandle: MemoryAddress io; 
			fileInfo: Binary output; 
			fileName: String output; 
			isDirectory: Boolean output): Integer is "emFtpFindNextFile" in "karma" number = 1017;
		emFtpGetCurrentDirectory(
			connectionHandle: MemoryAddress; 
			directory: String output): Integer is "emFtpGetCurrentDirectory" in "karma" number = 1023;
		emFtpGetFile(
			connHandle: MemoryAddress; 
			sourceFile: String; 
			destFile: String): Integer is "emFtpGetFile" in "karma" number = 1010;
		emFtpGetFileExt(
			handle: MemoryAddress; 
			sourceFileName: String; 
			destFileName: String; 
			ftpFlags: Integer; 
			fileFlags: Integer): Integer is "emFtpGetFileExt" in "karma" number = 1011;
		documentationText
`ftpFlags
--------

	1 = ASCII mode transfer
	2 = Binary mode transfer

fileFlags
---------

	1 		= Read-only
	2 		= Hidden
	4 		= System
	16    	= Directory
	32		= Archive
	48		= Normal
	2048	= Compressed`
		emFtpOpenFile(
			fileHandle: MemoryAddress output; 
			connectionHandle: MemoryAddress; 
			fileName: String; 
			writing: Boolean; 
			ascii: Boolean): Integer is "emFtpOpenFile" in "karma" number = 1012;
		emFtpRemoveDirectory(
			connectionHandle: MemoryAddress; 
			directory: String): Integer is "emFtpRemoveDirectory" in "karma" number = 1021;
		emFtpRenameFile(
			connectionHandle: MemoryAddress; 
			fileName: String; 
			newFileName: String): Integer is "emFtpRenameFile" in "karma" protected, number = 1015;
		emFtpSetCurrentDirectory(
			connectionHandle: MemoryAddress; 
			directory: String): Integer is "emFtpSetCurrentDirectory" in "karma" number = 1022;
		emGetFileInfo(
			fileInfo: Binary; 
			fileName: String output; 
			attributes: String output; 
			fileSize: Integer64 output; 
			creationDate: Integer output; 
			creationTime: Integer output; 
			accessDate: Integer output; 
			accessTime: Integer output; 
			updateDate: Integer output; 
			updateTime: Integer output): Integer is "emGetFileInfo" in "karma" protected, number = 1013;
		emInternetWriteFile(
			fileHandle: MemoryAddress; 
			buffer: Binary; 
			bytesToWrite: Integer64; 
			bytesWritten: Integer64 output): Integer is "emInternetWriteFile" in "karma" protected, number = 1014;
	)
	CnHttp64 completeDefinition
	(
	attributeDefinitions
		requestHandle:                 MemoryAddress readonly, number = 1, ordinal = 1;
		secure:                        Boolean readonly, number = 2, ordinal = 2;
	jadeMethodDefinitions
		cnConnect(): String updating, number = 1001;
		cnGetFile(
			sourceFile: String; 
			destFile: String; 
			pUsePresentationFileSystem: Boolean): String updating, number = 1002;
		cnGetFileInfo(
			filename: String; 
			attributes: String output; 
			filesize: Integer64 output; 
			lastModified: TimeStamp output): String updating, number = 1003;
		cnGetHttpQueryStatus(status: String): String protected, number = 1004;
		cnGetLastModifiedTimeGMT(
			filename: String io; 
			lastModified: TimeStamp output): String updating, number = 1005;
		setSecure(set: Boolean) updating, number = 1006;
	externalMethodDefinitions
		emHttpConnect(
			connHandle: MemoryAddress output; 
			sessHandle: MemoryAddress; 
			serverName: String; 
			user: String; 
			password: String; 
			secure: Boolean): Integer is "emHttpConnect" in "karma" number = 1007;
		emHttpOpenRequest(
			requestHandle: MemoryAddress output; 
			connectionHandle: MemoryAddress; 
			command: String; 
			fileName: String; 
			secure: Boolean): Integer is "emHttpOpenRequest" in "karma" protected, number = 1008;
		emHttpQueryInfo(
			requestHandle: MemoryAddress; 
			attribute: Integer; 
			buffer: String output): Integer is "emHttpQueryInfo" in "karma" protected, number = 1009;
		emHttpSendRequest(
			requestHandle: MemoryAddress; 
			headers: String): Integer is "emHttpSendRequest" in "karma" protected, number = 1010;
	)
	CnKarmaCntrl completeDefinition
	(
	constantDefinitions
		Copy_Parameters_Request:       Integer = 900 number = 1001;
		Copy_Parameters_Response:      Integer = 901 number = 1002;
		FTP_Complete:                  Integer = 701 number = 1003;
		FTP_Failed:                    Integer = 702 number = 1004;
		False:                         String = "false" number = 1005;
		Max_TranStats_Length:          Integer = 47800 number = 1010;
		System_Stopping:               String = "System Stopping" number = 1006;
		Tran_Stats_Request_Timer:      Integer = 1 number = 1007;
		Tran_Stats_Timer:              Integer = 8 number = 1008;
		True:                          String = "true" number = 1009;
	attributeDefinitions
		binPath:                       String[256] readonly, number = 1, ordinal = 3;
		binPathAppServer:              String[256] readonly, number = 2, ordinal = 4;
		clientFileAccessMode:          Integer readonly, number = 3, ordinal = 5;
		clientRequiresMisc:            Boolean readonly, number = 4, ordinal = 6;
		collectStats:                  Boolean readonly, number = 5, ordinal = 7;
		dbPath:                        String[256] readonly, number = 6, ordinal = 8;
		driveLetter:                   String[2] readonly, number = 8, ordinal = 9;
		environmentId:                 String[31] readonly, number = 9, ordinal = 10;
		exceptionErrorCode:            Integer readonly, number = 10, ordinal = 11;
		exceptionFileName:             String readonly, subId = 1, number = 11, ordinal = 12;
		exceptionText:                 String[101] readonly, number = 12, ordinal = 13;
		fileMaxRetries:                Integer readonly, number = 20, ordinal = 33;
		fileRetryInterval:             Integer readonly, number = 45, ordinal = 48;
		fileRetryNo:                   Integer readonly, number = 39, ordinal = 14;
		hadFileException:              Boolean readonly, number = 13, ordinal = 16;
		jossFQDN:                      String[65] readonly, number = 14, ordinal = 17;
		lastSampleTime:                TimeStamp readonly, number = 16, ordinal = 19;
		localFQDN:                     String[65] readonly, number = 17, ordinal = 20;
		localIpAddress:                String[66] readonly, number = 18, ordinal = 21;
		managedEnvironmentName:        String[31] readonly, number = 46, ordinal = 49;
		documentationText
`
As of 3.0, this property is set to the same value as environmentId.  The property is
essentially redundant but should not (cannot) be deleted due to extensive usage.`
		masterEnvironmentId:           String[31] readonly, number = 26, ordinal = 34;
		messageNameArray:              CnSmallStringArray readonly, subId = 8, number = 42, ordinal = 45;
		networkAddressNode:            String[66] readonly, number = 29, ordinal = 37;
		networkAddressProcess:         String[66] readonly, number = 31, ordinal = 38;
		sdsAlertIssued:                Boolean protected, number = 27, ordinal = 35;
		thinClientComputerIpAddress:   String[66] readonly, number = 22, ordinal = 29;
		thinClientComputerName:        String[65] readonly, number = 23, ordinal = 30;
		tranStatsAlertTimeStamp:       TimeStamp readonly, number = 21, ordinal = 50;
		tranStatsInterval:             Integer readonly, number = 25, ordinal = 31;
		usesJadeThinClient:            Boolean readonly, number = 30, ordinal = 32;
		v6IpAddress:                   String[66] readonly, number = 44, ordinal = 47;
	referenceDefinitions
		allCnJadeApplications:         CnJadeApplicationDict   explicitInverse, readonly, subId = 6, number = 38, ordinal = 41;
		allCnJadeNodes:                CnJadeNodeDict   explicitInverse, readonly, subId = 4, number = 32, ordinal = 39;
		allCnJadeProcesses:            CnJadeProcessDict   explicitInverse, readonly, subId = 5, number = 33, ordinal = 40;
		allCnProcesses:                CnProcessDict   explicitInverse, readonly, subId = 1, number = 7, ordinal = 1;
		allMachines:                   CnMachineDict   explicitInverse, readonly, subId = 2, number = 24, ordinal = 2;
		appsActivatedKarma:            ObjectSet  implicitMemberInverse, readonly, subId = 3, number = 28, ordinal = 36;
		form:                          Form  readonly, number = 34, ordinal = 15;
		messageClassArray:             CnClassArray  implicitMemberInverse, readonly, subId = 7, number = 41, ordinal = 42;
		myCnProcess:                   CnProcess  readonly, number = 35, ordinal = 22;
		myCnServerStatistics:          CnServerStatistics  number = 40, ordinal = 23;
		myDeadlockHandler:             CnDeadlockHandler  readonly, number = 19, ordinal = 24;
		myJadeProfiler:                JadeProfiler  protected, number = 43, ordinal = 46;
		myKarmaCommsMgrProcess:        Process  readonly, number = 36, ordinal = 25;
		myParentTcp:                   CnKarmaTcpConnection  number = 37, ordinal = 26;
		myTransactionData:             CnTransactionData  readonly, number = 55, ordinal = 27;
	jadeMethodDefinitions
		buildDummyVersionControlFile(
			path: String; 
			fileName: String; 
			ts: TimeStamp) updating, number = 1070;
		buildDummyVersionControlFiles() updating, number = 1064;
		captureSystemStatistics() updating, number = 1067;
		checkDllType(file: File): Boolean number = 1028;
		copyFile(
			sourceFile: String; 
			destFile: String; 
			failIfExists: Boolean): Boolean number = 1004;
		create() updating, number = 1005;
		decodeTransactionStatsHeader(
			pUserInfo: Binary; 
			pComputerName: String output; 
			pComputerNameNode: String output; 
			pNetworkAddress: String output; 
			pUserName: String output; 
			pAppName: String output; 
			pNodeStats: Boolean output): Integer number = 1046;
		delete() updating, number = 1006;
		deleteFile(fileName: String): Boolean number = 1007;
		displayClientStartupProgress(
			schemaName: String; 
			backgroundClientName: String; 
			labeldata: String): Process updating, number = 1008;
		dumpNodeClient() clientExecution, number = 1088;
		dumpNodeServer() serverExecution, number = 1089;
		establishNodeControl() number = 1074;
		executeJadeProfiler(pRestart: Boolean) updating, number = 1057;
		fileExceptionHandler(exObj: FileException): Integer updating, number = 1009;
		findBackgroundCommsMgr(pBackgroundClientName: String) updating, number = 1010;
		getAddressInfo(
			ipAddress: String output; 
			fqdn: String output): Integer updating, number = 1011;
		getAndSendSSLDetails() updating, number = 1002;
		getBackgroundCommsMgrProcess(
			pSchemaName: String; 
			pBackgroundClientName: String): Process number = 1072;
		getBinariesInfo(
			pNames: HugeStringArray input; 
			pVersions: StringArray input; 
			pMD5Hashes: StringArray input; 
			pModifyTimes: TimeStampArray input; 
			pFileTypes: CharacterArray input) updating, number = 1040;
		getCallStackPosition(): Integer number = 1045;
		getClientProcessObject(clientname: String): Process updating, number = 1012;
		getEnvironmentId(pPath: String): String number = 1044;
		getFileRoot(): String number = 1013;
		getHostForAddress(
			ipAddress: String; 
			fqdn: String output): String number = 1026;
		getLibrariesInfo(
			pNames: HugeStringArray input; 
			pVersions: StringArray input; 
			pModifyTimes: TimeStampArray input; 
			pFileTypes: CharacterArray input) updating, number = 1085;
		getMessageClass(pMessageClassName: String): Class number = 1090;
		getReadOnlySchemaPath(): String updating, number = 1014;
		getSystemStatistics(): Binary updating, number = 1015;
		getThinClientVersions(
			c_bin: TimeStamp output; 
			c_misc: TimeStamp output; 
			n_bin: TimeStamp output; 
			n_misc: TimeStamp output) number = 1016;
		getTransactionStatsHeader(): Binary number = 1062;
		handleTranStatsRequestEvent() updating, number = 1069;
		initiateUpgradeForAppServer() updating, number = 1017;
		isMultiUserCapable(): Boolean number = 1095;
		isSingleUserAppServer(): Boolean number = 1097;
		issueKCCMgrSessionOpenAdvice(
			tcp: CnKarmaTcpConnection input; 
			machine: CnMachine; 
			cnproc: CnProcess) updating, number = 1071;
		issueSessionOpenAdvice() updating, number = 1018;
		moveFile(
			sourceFile: String; 
			destFile: String): Boolean number = 1019;
		moveFileEx(
			sourceFile: String; 
			destFile: String; 
			errText: String output): Boolean number = 1073;
		removeFile(filename: String) updating, number = 1020;
		renameFile(
			fileName: String; 
			newFileName: String; 
			override: Boolean): String updating, number = 1021;
		requestCacheStatistics() number = 1075;
		sdsExceptionHandler(
			pExObj: Exception; 
			pObj: Object): Integer number = 1081;
		sdsGetConnectionStateString(state: Integer): String number = 1082;
		sdsGetStateString(state: Integer): String number = 1083;
		sdsGetTrackingString(trackingDisabled: Boolean): String number = 1084;
		sendBinaryDetails(
			pTcp: CnKarmaTcpConnection input; 
			pMachine: CnMachine) number = 1091;
		sendOrStoreTranStats(pValue: Binary): String updating, number = 1068;
		sendPingReplyAdvice(
			pSchemaName: String; 
			pAppName: String; 
			pProcessId: Integer; 
			pUnsolicited: Boolean; 
			pTimeStamp: TimeStamp) updating, number = 1086;
		setBinPath(path: String) updating, number = 1022;
		setBinPathAppServer(path: String) updating, number = 1023;
		setClientFileAccessMode(mode: Integer) updating, number = 1024;
		setClientRequiresMisc(set: Boolean) updating, number = 1025;
		setDbPath(path: String) updating, number = 1027;
		setDriveLetter() updating, number = 1029;
		setEnvironmentId() updating, number = 1030;
		setExceptionErrorCode(code: Integer) updating, number = 1031;
		setExceptionFileName(str: String) updating, number = 1032;
		setExceptionText(text: String) updating, number = 1033;
		setFileMaxRetries(retries: Integer) updating, number = 1077;
		setFileRetryInterval(pValue: Integer) updating, number = 1055;
		setFileRetryNo(retry: Integer) updating, number = 1066;
		setForm(frm: Form) updating, number = 1034;
		setHadFileException(set: Boolean) updating, number = 1035;
		setJossFQDN(fqdn: String) updating, number = 1036;
		setLocalFQDN(fqdn: String) updating, number = 1038;
		setLocalIpAddress(addr: String) updating, number = 1039;
		setManagedEnvironmentName(name: String) updating, number = 1056;
		setMyCnProcess(cnproc: CnProcess) updating, number = 1041;
		setMyKarmaCommsMgrProcess(proc: Process) updating, number = 1042;
		setMyParentTcp(tcp: CnKarmaTcpConnection) updating, number = 1043;
		setNetworkAddressNode(pAddress: String) updating, number = 1076;
		setNetworkAddressProcess(pAddress: String) updating, number = 1080;
		setThinClientComputerIpAddress(pIpAddress: String) updating, number = 1047;
		setThinClientComputerName(name: String) updating, number = 1048;
		setTranStatsAlertTimeStamp(pValue: TimeStamp) updating, number = 1065;
		setTranStatsInterval(int: Integer) updating, number = 1049;
		setUpTranLogFile() updating, number = 1078;
		setUpTranLogHeadings(file: CnFile) updating, number = 1079;
		timerEvent(eventTag: Integer) updating, number = 1052;
		userNotification(
			eventType: Integer; 
			theObject: Object; 
			eventTag: Integer; 
			userInfo: Any) updating, number = 1053;
		zAnalyzeTransients() protected, number = 1092;
		zBuildTransactionStatsHeader(): Binary protected, number = 1087;
		zCheckJadeAutoUpdateRequired(): String protected, number = 1096;
		zCheckMappedExtentClasses(pRPSMappingName: String) protected, subschemaHidden, final, number = 1058;
		zClassInMappedExtent(
			pClassName: String; 
			pRPSMappingName: String): Boolean protected, subschemaHidden, final, number = 1059;
		zDoKCCMgrFunctions(pMsg: CnPingReplyAdvice) updating, protected, number = 1051;
		zForwardTransactionStatistics(pObject: Object) updating, number = 1037;
		zIssueSSLAdvice(
			pRPCEncryptionEnabled: Boolean; 
			pSSLSecurePort: String; 
			pCertFileName: String; 
			pCertFileResident: Boolean; 
			pCertFileSubject: String; 
			pCertFileExpiry: Date; 
			pCertAuthFileName: String; 
			pCertAuthFileResident: Boolean; 
			pCertAuthFileSubject: String; 
			pCertAuthFileExpiry: Date; 
			pSSLMethodName: String; 
			pSSLCiphers: StringArray) number = 1003;
		zReportLockException(
			pObject: Object; 
			pUserInfo: Any) protected, number = 1093;
		zSetupMessagingClassDetails() updating, protected, number = 1094;
		zSetupTcpTransportDetails(): Integer protected, number = 1050;
	externalMethodDefinitions
		callMethodWith1Param(
			receiver: Object; 
			methodName: String; 
			param1: Any) is "emCallMethod" in "karma" protected, number = 1054;
		emShellExecute(
			hwnd: Integer; 
			operation: String; 
			fileName: String; 
			parameters: String; 
			directory: String; 
			showHow: Integer): Integer is "emShellExecute" in "karma" number = 1060;
		getProcessId(procId: Integer output): Integer is "emGetProcessId" in "karma" number = 1061;
		killProcess(procId: Integer): Integer is "emKillProcess" in "karma" number = 1063;
	)
	CnLdap completeDefinition
	(
		documentationText
`Abstract placeholder for LDAP classes.

Methods and constants that are common to all LDAP classes are 
defined in this class.

NOTE: To use the LDAP classes, you MUST have cnldap.dll and nsldapssl32v30.dll in your JADE bin directory.`
	constantDefinitions
		ALL_ENTRIES_AVAILABLE:         Integer = 3 number = 1001;
		documentationText
`Returned by cnPollSearchAsync when retrieval mode is LDAP_MSG_ALL
(i.e. "Get all entries and return them at the same time"), and all
entries are available for processing.`
		CN_LDAP_ERROR_BASE:            Integer = 101000 number = 1021;
		CN_LDAP_ADMINLIMIT_EXCEEDED:   Integer = CN_LDAP_ERROR_BASE + 11 number = 1002;
		documentationText
`This result code indicates that the "look through limit" on a search operation has been exceeded. 

When working with the Netscape Directory Server, keep in mind the following: 


If you are bound as the root DN, the server sets an infinite "look through limit". 

If you are not bound as the root DN, the server sets the time limit to the value specified by the lookthroughtimelimit directive in the server's slapd.conf configuration file. 
The "look through limit" is the maximum number of entries that the server will check when gathering a list of potential search result candidates. See the Netscape Directory Server Administrator's Guide for details.`
		CN_LDAP_AFFECTS_MULTIPLE_DSAS: Integer = CN_LDAP_ERROR_BASE + 71 number = 1003;
		documentationText
`This result code indicates that the requested operation needs to be performed on multiple servers, where this operation is not permitted. 

Currently, the Netscape Directory Server does not send this result code back to LDAP clients.`
		CN_LDAP_ALIAS_DEREF_PROBLEM:   Integer = CN_LDAP_ERROR_BASE + 36 number = 1004;
		documentationText
`This result code indicates that a problem occurred when dereferencing an alias. 

Currently, the Netscape Directory Server does not send this result code back to LDAP clients.`
		CN_LDAP_ALIAS_PROBLEM:         Integer = CN_LDAP_ERROR_BASE + 33 number = 1005;
		documentationText
`This result code indicates that a problem occurred when dereferencing an alias. 

Currently, the Netscape Directory Server does not send this result code back to LDAP clients.`
		CN_LDAP_ALL_ENTRIES:           Integer = 2 number = 1006;
		documentationText
`Indicates that cnPollSearchAsync is returning all entries at the same time (in the search object).`
		CN_LDAP_ALREADY_EXISTS:        Integer = CN_LDAP_ERROR_BASE + 68 number = 1007;
		documentationText
`This result code indicates that the request is attempting to add an entry that already exists in the directory. 

The Netscape Directory Server sends this result code back to the client in the following situations: 


The request is an add request, and the entry already exists in the directory. 

The request is a modify DN request, and the new DN of the entry already identifies another entry. 

The request is adding an attribute to the schema, and an attribute with the specified name or OID already exists.`
		CN_LDAP_ATTRS_ONLY:            Integer = 1 number = 1008;
		documentationText
`Value written to CnLdapConstraints::attrsOnly to indicate that only atribute names should be returned by a search.`
		CN_LDAP_ATTRS_VALUES:          Integer = 0 number = 1009;
		documentationText
`Value written to CnLdapConstraints::attrsOnly to indicate that both attribute names and attribute values should be returned
by a search.`
		CN_LDAP_AUTH_UNKNOWN:          Integer = CN_LDAP_ERROR_BASE + 86 number = 1010;
		documentationText
`This result code indicates that an unknown authentication method was specified. 

The LDAP API library sets this result code if ldap_bind() or ldap_bind_s() are called and an authentication method other than LDAP_AUTH_SIMPLE is specified. (These functions only allow you to use simple authentication.)`
		CN_LDAP_BUSY:                  Integer = CN_LDAP_ERROR_BASE + 51 number = 1011;
		documentationText
`This result code indicates that the server is currently too busy to perform the requested operation. 

At this point in time, neither the LDAP API library nor the Netscape Directory Server return this result code.`
		CN_LDAP_CLIENT_LOOP:           Integer = CN_LDAP_ERROR_BASE + 96 number = 1012;
		documentationText
`This result code indicates that the LDAP client (API library) detected a loop, for example, when following referrals.`
		CN_LDAP_CONFIDENTIALITY_REQ:   Integer = CN_LDAP_ERROR_BASE + 13 number = 1013;
		documentationText
`This result code indicates that confidentiality is required for the operation. 

Currently, the Netscape Directory Server does not send this result code back to LDAP clients.`
		CN_LDAP_CONNECTION_EXISTS:     Integer = CN_LDAP_ERROR_BASE + 142 number = 1014;
		documentationText
		`Generated by cnOpen if an ldapHandle already exists for this object.`
		CN_LDAP_CONNECT_ERROR:         Integer = CN_LDAP_ERROR_BASE + 91 number = 1015;
		documentationText
`This result code indicates that the LDAP client cannot establish a connection (or has lost the connection) with the LDAP server. 

The LDAP API library sets this result code. If you have not established an initial connection with the server, verify that you have specified the correct hostname and port number and that the server is running.`
		CN_LDAP_CONSTRAINT_VIOLATION:  Integer = CN_LDAP_ERROR_BASE + 19 number = 1016;
		documentationText
`This result code indicates that a value in the request does not comply with certain constraints.

The Netscape Directory Server sends this result code back to the client in the following situations:


The request adds or modifies the userpassword attribute, and one of the following is true: 

The server is configured to check the password syntax, and the length of the new password is less than the minimum password length. 

The server is configured to check the password syntax, and the new password is the same as one of the values of the uid, cn, sn, givenname, ou, or mail attributes. 

The server is configured to keep a history of previous passwords, and the new password is the same as one of the previous passwords. 

The request is a bind request, and the user is locked out of the account. (For example, the server can be configured to lock a user out of the account after a given number of failed attempts to bind to the server.)`
		CN_LDAP_CONTROL_NOT_FOUND:     Integer = CN_LDAP_ERROR_BASE + 93 number = 1017;
		documentationText
`This result code indicates that a requested LDAP control was not found. 

The LDAP API library sets this result code when parsing a server response for controls and not finding the requested controls. For example:


ldap_parse_entrychange_control() is called, but no entry change notification control is found in the server's response. 

ldap_parse_sort_control() is called, but no server-side sorting control is found in the server's response. 

ldap_parse_virtuallist_control() is called, but no virtual list view response control is found in the server's response.`
		CN_LDAP_DECODING_ERROR:        Integer = CN_LDAP_ERROR_BASE + 84 number = 1018;
		documentationText
`This result code indicates that the LDAP client encountered an error when decoding the LDAP response received from the server.`
		CN_LDAP_ENCODING_ERROR:        Integer = CN_LDAP_ERROR_BASE + 83 number = 1019;
		documentationText
`This result code indicates that the LDAP client encountered an error when encoding the LDAP request to be sent to the server.`
		CN_LDAP_ENTRIES:               Integer = 1 number = 1020;
		documentationText
`Used with CnLdapConstraints.mode.

This value indicates that directory entries are to be extracted from the search results.`

		CN_LDAP_FILTER_ERROR:          Integer = CN_LDAP_ERROR_BASE + 87 number = 1022;
		documentationText
`This result code indicates that an error occurred when specifying the search filter. 

The LDAP API library sets this result code if it cannot encode the specified search filter in an LDAP search request.`
		CN_LDAP_GENERAL_ERROR:         Integer = CN_LDAP_ERROR_BASE + 133 number = 1023;
		CN_LDAP_INAPPROPRIATE_AUTH:    Integer = CN_LDAP_ERROR_BASE + 48 number = 1024;
		documentationText
`This result code indicates that the type of credentials are not appropriate for the method of authentication used. 

The Netscape Directory Server sends this result code back to the client if simple authentication is used in a bind request,
but the entry has no userpassword attribute.`
		CN_LDAP_INAPPROPRIATE_MATCHING:Integer = CN_LDAP_ERROR_BASE + 18 number = 1025;
		documentationText
`This result code indicates that an extensible match filter in a search request contained a matching rule that does not apply to the specified attribute type. 

Currently, the Netscape Directory Server does not send this result code back to LDAP clients.`
		CN_LDAP_INDEX_RANGE_ERROR:     Integer = CN_LDAP_ERROR_BASE + 61 number = 1026;
		documentationText
`This result code indicates that the search results exceeded the range specified by the requested offsets. 

This result code applies to search requests that contain "virtual list view" controls.

Note that versions of the Netscape Directory Server prior to 4.0 do not support the "virtual list view" control.`
		CN_LDAP_INSUFFICIENT_ACCESS:   Integer = CN_LDAP_ERROR_BASE + 50 number = 1027;
		documentationText
`This result code indicates that the client has insufficient access to perform the operation. 

Check the user that you are authenticating as and the access control lists for the server.`
		CN_LDAP_INVALID_ARRAY:         Integer = CN_LDAP_ERROR_BASE + 144 number = 1028;
		documentationText
`Generated when an invalid array object is supplied to a JADE LDAP method as a parameter.`
		CN_LDAP_INVALID_ATTR_ARRAY:    Integer = CN_LDAP_ERROR_BASE + 139 number = 1029;
		documentationText
`Generated when user supplies an invalid array of attributes to the cnEAddEntry method.`
		CN_LDAP_INVALID_CREDENTIALS:   Integer = CN_LDAP_ERROR_BASE + 49 number = 1030;
		documentationText
`This result code indicates that the credentials provided in the request are invalid. 

The Netscape Directory Server sends this result code back to the client if a bind request contains the incorrect credentials for a user or if a user's password has already expired.`
		CN_LDAP_INVALID_DN_SYNTAX:     Integer = CN_LDAP_ERROR_BASE + 324 number = 1031;
		documentationText
`This result code indicates than an invalid DN has been specified. 

The Netscape Directory Server sends this result code back to the client if an add request or a modify DN request specifies an invalid DN. It also sends this code when an SASL_EXTERNAL bind is attempted but certification to DN mapping fails.`
		CN_LDAP_INVALID_ENTRY_OBJECT:  Integer = CN_LDAP_ERROR_BASE + 140 number = 1032;
		documentationText
`Generated when an invalid CnLdapEntry object is supplied as a parameter (e.g. for cnAddEntry).`
		CN_LDAP_INVALID_HOST:          Integer = CN_LDAP_ERROR_BASE + 128 number = 1033;
		documentationText
		`Generated when a null hostname is supplied as a parameter to cnOpen.`
		CN_LDAP_INVALID_PORT:          Integer = CN_LDAP_ERROR_BASE + 129 number = 1034;
		documentationText
		`Generated when a null port number is supplied as a parameter to cnOpen.`
		CN_LDAP_INVALID_SEARCH_OBJECT: Integer = CN_LDAP_ERROR_BASE + 136 number = 1035;
		documentationText
`Generated when an invalid search object is supplied to a search method, e.g. cnSearch.`
		CN_LDAP_INVALID_SYNTAX:        Integer = CN_LDAP_ERROR_BASE + 21 number = 1036;
		documentationText
`This result code indicates that the request contains invalid syntax. 

The Netscape Directory Server sends this result code back to the client in the following situations: 


The server encounters an ACL with invalid syntax. 

The request attempts to add or modify an aci attribute, and the value of the attribute is an ACI with invalid syntax. 

The request is a search request with a substring filter, and the syntax of the filter is invalid. 

The request is a modify request that is attempting to modify the schema, but no values are provided (for example, the request might be attempting to delete all values of the objectclass attribute).`
		CN_LDAP_INVALID_URL:           Integer = CN_LDAP_ERROR_BASE + 143 number = 1037;
		documentationText
		`Generated when an invalid LDAP URL is supplied to the cnURLSearch method.`
		CN_LDAP_INVALID_VERSION:       Integer = CN_LDAP_ERROR_BASE + 130 number = 1038;
		documentationText
		`Generated when an invalid protocol version is supplied to cnOpen.`
		CN_LDAP_IS_LEAF:               Integer = CN_LDAP_ERROR_BASE + 35 number = 1039;
		documentationText
`This result code indicates that the specified entry is a leaf entry. 

Currently, the Netscape Directory Server does not send this result code back to LDAP clients.`
		CN_LDAP_LOCAL_ERROR:           Integer = CN_LDAP_ERROR_BASE + 82 number = 1040;
		documentationText
		`This result code indicates that an error occurred in the LDAP client.`
		CN_LDAP_LOOP_DETECT:           Integer = CN_LDAP_ERROR_BASE + 54 number = 1041;
		documentationText
`This result code indicates that the server was unable to perform the requested operation because of an internal loop. 

Currently, the Netscape Directory Server does not send this result code back to LDAP clients.`
		CN_LDAP_MORE_RESULTS_TO_RETURN:Integer = CN_LDAP_ERROR_BASE + 95 number = 1042;
		documentationText
`This result code indicates that there are more results in the chain of results.

The LDAP API library sets this result code when the ldap_parse_result() function is called to retrieve the result code of an operation, and additional result codes from the server are available in the LDAP structure.`
		CN_LDAP_NAMING_VIOLATION:      Integer = CN_LDAP_ERROR_BASE + 64 number = 1043;
		documentationText
`This result code indicates that the request violates the structure of the DIT. 

Currently, the Netscape Directory Server does not send this result code back to LDAP clients.`
		CN_LDAP_NOT_ALLOWED_ON_NONLEAF:Integer = CN_LDAP_ERROR_BASE + 66 number = 1044;
		documentationText
`This result code indicates that the requested operation is allowed only on entries that do not have child entries (entries that are "leaf" entries, as opposed to "branch" entries). 

The Netscape Directory Server sends this result code back to the client if the request is a delete request or a modify DN request and the entry is a parent entry. (You cannot delete or move a branch of entries in a single operation.)`
		CN_LDAP_NOT_ALLOWED_ON_RDN:    Integer = CN_LDAP_ERROR_BASE + 67 number = 1045;
		documentationText
`This result code indicates that the requested operation will affect the RDN of the entry. 

The Netscape Directory Server sends this result code back to the client if the request is a modify request and the request deletes attribute values from the entry that are used in the RDN of the entry. (For example, if the DN is "uid=bjensen,ou=People,o=Airius.com", the request removes the attrib
ute value "uid=bjensen" from the entry.)`
		CN_LDAP_NOT_SUPPORTED:         Integer = CN_LDAP_ERROR_BASE + 92 number = 1046;
		documentationText
`This result code indicates that the LDAP client is attempting to use functionality that is not supported.

The LDAP API library sets this result code if the client identifies itself as an LDAP v2 client, and the client is attempting to use functionality available in LDAP v3. For example:


You are passing LDAP controls to a function. 

You are calling ldap_extended_operation(), ldap_extended_operation_s(), or ldap_parse_extended_result() to request an extended operation or to parse an extended response. 

You are calling ldap_rename() or ldap_rename_s(), and you are specifying a new "superior DN" as an argument. 

You are calling ldap_sasl_bind(), ldap_sasl_bind_s(), or ldap_parse_sasl_bind_result() to request SASL authentication or to parse a SASL bind response. 

You are calling ldap_parse_virtuallist_control() to parse a virtual list control from the server's response. 
If you want to use these features, make sure to specify that your LDAP client is an LDAP v3 client.`
		CN_LDAP_NO_MEMORY:             Integer = CN_LDAP_ERROR_BASE + 90 number = 1047;
		documentationText
`This result code indicates that no memory is available.

The LDAP API library sets this result code if a function cannot allocate memory (for example, when creating an LDAP request or an LDAP control).`
		CN_LDAP_NO_OBJECT_CLASS_MODS:  Integer = CN_LDAP_ERROR_BASE + 69 number = 1048;
		documentationText
`This result code indicates that the request is attempting to modify the object class that should not be modified (for example, a structural object class). 

Currently, the Netscape Directory Server does not send this result code back to LDAP clients.`
		CN_LDAP_NO_RESULTS_RETURNED:   Integer = CN_LDAP_ERROR_BASE + 94 number = 1049;
		documentationText
`This result code indicates that no results were returned from the server.

The LDAP API library sets this result code when the ldap_parse_result() function is called but no result code is included in the server's response.`
		CN_LDAP_NO_SUCH_ATTRIBUTE:     Integer = CN_LDAP_ERROR_BASE + 15 number = 1050;
		documentationText
`This result code indicates that the specified attribute does not exist in the entry.

The Netscape Directory Server might send this result code back to the client if, for example, a modify request specifies the modification or removal of a non-existent attribute or if a compare request specifies a non-existent attribute.`
		CN_LDAP_NO_SUCH_OBJECT:        Integer = CN_LDAP_ERROR_BASE + 32 number = 1051;
		documentationText
`Returned by the API when a base-level search did not find the specified entry.

This result code indicates that the server cannot find an entry specified in the request. 

The Netscape Directory Server sends this result code back to the client if it cannot find a requested entry and if it cannot refer your client to another LDAP server.`
		CN_LDAP_OBJECT_CLASS_VIOLATION:Integer = CN_LDAP_ERROR_BASE + 65 number = 1052;
		documentationText
`This result code indicates that the request specifies a change to an entry or a new entry that does not comply with the server's schema. 

The Netscape Directory Server sends this result code back to the client in the following situations:


The request is an add request, and the new entry does not comply with the schema. (For example, the new entry does not have all the required attributes, or the entry has attributes that are not allowed in the entry.) 

The request is a modify request, and the change will make the entry noncompliant with the schema. (For example, the change removes a required attribute or adds an attribute that is not allowed.) 
Check the server error logs for more information, and check the schema for the type of entry that you are adding or modifying.`
		CN_LDAP_ONE_ENTRY:             Integer = 1 number = 1053;
		documentationText
`Indicates that cnPollSearchAsync or cnPollReadAsync is returning a single entry in the search object.`
		CN_LDAP_OPEN_ERROR:            Integer = CN_LDAP_ERROR_BASE + 135 number = 1054;
		CN_LDAP_OPERATIONS_ERROR:      Integer = CN_LDAP_ERROR_BASE + 1 number = 1055;
		documentationText
`This is a general result code indicating that an error has occurred. 

The Netscape Directory Server might send this code if, for example, memory cannot be allocated on the server. 

To troubleshoot this type of error, check the server's error logs. You may need to increase the log level of the server to get additional information.`
		CN_LDAP_OPTION_ERROR:          Integer = CN_LDAP_ERROR_BASE + 131 number = 1056;
		documentationText
		`Generated when an error occurs setting an LDAP option.`
		CN_LDAP_OTHER:                 Integer = CN_LDAP_ERROR_BASE + 80 number = 1057;
		documentationText
`This result code indicates than an unknown error has occurred. 

At this point in time, neither the LDAP API library nor the Netscape Directory Server return this result code.`
		CN_LDAP_PARAMETER_ERROR:       Integer = CN_LDAP_ERROR_BASE + 141 number = 1058;
		documentationText
`Generated when there is an error in a parameter supplied to the JADE LDAP interface.`
		CN_LDAP_PARAM_ERROR:           Integer = CN_LDAP_ERROR_BASE + 89 number = 1059;
		documentationText
`This result code indicates that an invalid parameter was specified. 

The LDAP API library sets this result code if a function was called and invalid parameters were specified (for example, if the LDAP structure is NULL).`
		CN_LDAP_PROTOCOL_ERROR:        Integer = CN_LDAP_ERROR_BASE + 2 number = 1060;
		documentationText
`This result code indicates that the LDAP client's request does not comply with the LDAP protocol. 

The Netscape Directory Server sends this result code back to the client in the following situations:


The server cannot parse the incoming request. 

The request specifies an attribute type that uses a syntax not supported by the server. 

The request is a SASL bind request, but your client identifies itself as an LDAP v2 client. 

Make sure to specify that your LDAP client is an LDAP v3 client.


The request is a bind request that specifies an unsupported version of the LDAP protocol. 

Make sure to specify that your LDAP client is either an LDAP v2 client or an LDAP v3 client.


The request is an add or a modify request that specifies the addition of an attribute type to an entry, but no values are specified. 

The request is a modify request, and one of the following is true: 

An unknown modify operation is specified (an operation other than LDAP_MOD_ADD, LDAP_MOD_DELETE, and LDAP_MOD_REPLACE). 

No modifications are specified. 

The request is a modify DN request, and one of the following is true: 

The new RDN is not a valid RDN. 

A new superior DN is specified, but your client identifies itself as an LDAP v2 client. 

Note that the Netscape Directory Server 3.x and 4.0 do not support the ability to move an entry from under one DN to another DN. If you specify a new superior DN, the request will not be processed. 


The request is a search request, and one of the following is true: 

An unknown scope is specified (a scope other than LDAP_SCOPE_BASE, LDAP_SCOPE_ONELEVEL, and LDAP_SCOPE_SUBTREE). 

An unknown filter type is specified. 

The filter type LDAP_FILTER_GE or LDAP_FILTER_LE is specified, but the type of attribute contains values that cannot be ordered. (For example, if the attribute type uses a binary syntax, the values of the attribute contain binary data, which cannot be sorted.) 

The request contains an extensible filter (a filter using matching rules), but your client identifies itself as an LDAP v2 client. (Make sure to specify that your LDAP client is an LDAP v3 client.)

The request contains an extensible filter (a filter using matching rules), but the matching rule is not supported by the server. 

The request is a search request with a server-side sorting control, and one of the following is true: 

The server does not have a syntax plug-in that supports the attribute used for sorting. 

The syntax plug-in does not have a function for comparing values of the attribute. (This compare function is used for sorting.) 

The type of attribute specified for sorting contains values that cannot be sorted in any order. (For example, if the attribute type uses a binary syntax, the values of the attribute contain binary data, which cannot be sorted.) 

The server encounters an error when creating the sorting response control (the control to be sent back to the client). 

When sorting the results, the time limit or the "look through limit" is exceeded. (The "look through limit" is the maximum number of entries that the server will check when gathering a list of potential search result candidates. See the Netscape Directory Server Administrator's Guide for details.
) 

The request is an extended operation request, and the server does not support that extended operation. 

In the Netscape Directory Server, extended operations are supported through extended operation server plug-ins. Make sure that the server is loading a plug-in that supports the extended operation. Check the OID of the extended operation in your LDAP client to make sure that it matches the OID of 
the extended operation registered in the server plug-in. 

For more information on extended operation server plug-ins, see the Netscape Directory Server Plug-In Programmer's Guide. 


An authentication method other than LDAP_AUTH_SIMPLE or LDAP_AUTH_SASL is specified. 
To troubleshoot this type of error, check the server's error logs. You may need to increase the log level of the server to get additional information.`
		CN_LDAP_REFERENCES:            Integer = 2 number = 1061;
		documentationText
`Used with CnLdapConstraints.mode.

This value indicates that references are to be extracted from the search results.`
		CN_LDAP_REFERRAL:              Integer = CN_LDAP_ERROR_BASE + 10 number = 1062;
		documentationText
`This result code indicates that the server is referring the client to another LDAP server. When sending this code to a client, the server includes a list of LDAP URLs that identify another LDAP server. 

This result code is part of the LDAP v3 protocol. For LDAP v2 clients, the Netscape Directory Server sends an LDAP_PARTIAL_RESULTS result code instead.`
		CN_LDAP_REFERRAL_LIMIT_EXCEED: Integer = CN_LDAP_ERROR_BASE + 97 number = 1063;
		documentationText
`This result code indicates that the "referral hop limit" was exceeded. 

The LDAP API library sets this result code when following referrals, if the client is referred to other servers more times than allowed by the "referral hop limit".`
		CN_LDAP_RESULTS_TOO_LARGE:     Integer = CN_LDAP_ERROR_BASE + 70 number = 1064;
		documentationText
`This result code indicates that the results of the request are too large. 

Currently, the Netscape Directory Server does not send this result code back to LDAP clients.`
		CN_LDAP_SASL_BIND_IN_PROGRESS: Integer = CN_LDAP_ERROR_BASE + 14 number = 1065;
		documentationText
`This result code is used in multi-stage SASL bind operations. The server sends this result code back to the client to indicate that the authentication process has not yet completed.`
		CN_LDAP_SERVER_DOWN:           Integer = CN_LDAP_ERROR_BASE + 81 number = 1066;
		documentationText
`This result code indicates that the LDAP API library cannot establish a connection (or lost the connection) with the LDAP server. 

The LDAP API library sets this result code. If you have not established an initial connection with the server, verify that you have specified the correct hostname and port number and that the server is running.`
		CN_LDAP_SIZELIMIT_EXCEEDED:    Integer = CN_LDAP_ERROR_BASE + 4 number = 1067;
		documentationText
`This result code indicates that the maximum number of search results to return has been exceeded. 

The size limit is specified in the search request. If you specify no size limit, the server will set the time limit. 

When working with the Netscape Directory Server, keep in mind the following: 


If you are bound as the root DN and specify no size limit, the server enforces no size limit at all. 

If you are not bound as the root DN and specify no size limit, the server sets the size limit to the value specified by the sizelimit directive in the server's slapd.conf configuration file. 

If the size limit that you specify exceeds the value specified by the sizelimit directive in the server's slapd.conf configuration file, the server uses the size limit specified in the configuration file.`
		CN_LDAP_SORT_CONTROL_MISSING:  Integer = CN_LDAP_ERROR_BASE + 60 number = 1068;
		documentationText
`This result code indicates that server did not receive a required server-side sorting control. 

The Netscape Directory Server 4.0 sends this result code back to the client if the server receives a search request with a "virtual list view" control but no server-side sorting control. 

The "virtual list view" control requires a server-side sorting control. 

Note that versions of the Netscape Directory Server prior to 4.0 do not support the "virtual list view" control.`
		CN_LDAP_STRONG_AUTH_NOT_SUPP:  Integer = CN_LDAP_ERROR_BASE + 7 number = 1069;
		documentationText
`This result code is returned as the result of a bind operation. This code indicates that the server does not recognize or support the specified authentication method.`
		CN_LDAP_STRONG_AUTH_REQUIRED:  Integer = CN_LDAP_ERROR_BASE + 8 number = 1070;
		documentationText
`This result code indicates that a stronger method of authentication is required to perform the operation. 

Currently, the Netscape Directory Server does not send this result code back to LDAP clients.`
		CN_LDAP_TIMELIMIT_EXCEEDED:    Integer = CN_LDAP_ERROR_BASE + 3 number = 1071;
		documentationText
`This result code indicates that the time limit on a search operation has been exceeded. 

The time limit is specified in the search request. If you specify no time limit, the server will set the time limit. 

When working with the Netscape Directory Server, keep in mind the following: 


If you are bound as the root DN and specify no time limit, the server enforces no size limit at all. 

If you are not bound as the root DN and specify no time limit, the server sets the time limit to the value specified by the timelimit directive in the server's slapd.conf configuration file. 

If the time limit that you specify exceeds the value specified by the timelimit directive in the server's slapd.conf configuration file, the server uses the time limit specified in the configuration file.`
		CN_LDAP_TIMEOUT:               Integer = CN_LDAP_ERROR_BASE + 85 number = 1072;
		documentationText
`This result code indicates that the LDAP client timed out while waiting for a response from the server.

The LDAP API library sets this result code in the LDAP structure if the timeout period (for example, in a search request) has been exceeded and the server has not responded.`
		CN_LDAP_TYPE_OR_VALUE_EXISTS:  Integer = CN_LDAP_ERROR_BASE + 20 number = 1073;
		documentationText
`This result code indicates that the request attempted to add an attribute type or value that already exists. 

The Netscape Directory Server sends this result code back to the client in the following situations:


The request attempts to add values that already exist in the attribute. 

The request is adding an attribute to the schema of the server, but the OID of the attribute is already used by an object class in the schema. 

The request is adding an object class to the schema of the server, and one of the following occurs: 

The object class already exists. 

The OID of the object class is already used by another object class or an attribute in the schema. 

The superior object class for this new object class does not exist.`
		CN_LDAP_UNAVAILABLE:           Integer = CN_LDAP_ERROR_BASE + 52 number = 1074;
		documentationText
`This result code indicates that the server is unavailable to perform the requested operation. 

At this point in time, neither the LDAP API library nor the Netscape Directory Server return this result code.`
		CN_LDAP_UNAVAIL_CRIT_EXTENSION:Integer = CN_LDAP_ERROR_BASE + 12 number = 1075;
		documentationText
`This result code indicates that the specified control or matching rule is not supported by the server. 

The Netscape Directory Server might send back this result code if the request includes an unsupported control or if the filter in the search request specifies an unsupported matching rule.`
		CN_LDAP_UNDEFINED_TYPE:        Integer = CN_LDAP_ERROR_BASE + 17 number = 1076;
		documentationText
`This result code indicates that the request specifies an undefined attribute type.

Currently, the Netscape Directory Server does not send this result code back to LDAP clients.`
		CN_LDAP_UNWILLING_TO_PERFORM:  Integer = CN_LDAP_ERROR_BASE + 53 number = 1077;
		documentationText
`This result code indicates that the server is unwilling to perform to requested operation. 

The Netscape Directory Server sends this result code back to the client in the following situations: 


The client has logged in for the first time and needs to change its password, but the client is requesting to perform other LDAP operations. 

In this situation, the result code is accompanied by an expired password control. 


The NT Synch Service is running, and an operation is "vetoed" by the service. 

The request is a modify DN request, and a "superior DN" is specified. (At this point in time, the Netscape Directory Server does not support the ability to use the modify DN operation to move an entry from one location in the directory tree to another location.) 

The database is in read-only mode, and the request attempts to write to the directory. 

The request is a delete request that attempts to delete the root DSE. 

The request is a modify DN request that attempts to modify the DN of the root DSE. 

The request is a modify request to modify the schema entry, and one of the following occurs: 

The operation is LDAP_MOD_REPLACE. (The server does not allow you to replace schema entry attributes.) 

The request attempts to delete an object class that is the parent of another object class. 

The request attempts to delete a read-only object class or attribute. 

The server uses a database plug-in that does not implement the operation specified in the request. For example, if the database plug-in does not implement the add operation, sending an add request will return this result code.`
		CN_LDAP_USER_CANCELLED:        Integer = CN_LDAP_ERROR_BASE + 88 number = 1078;
		documentationText
`This result code indicates that the user cancelled the LDAP operation. 

Currently, the Netscape Directory Server does not send this result code back to LDAP clients.`
		DEFAULT_FILTER:                String = "objectclass=*" number = 1079;
		documentationText
		`Used in cnReadEntry as the default filter for a base-level search.`
		ENTRY_AVAILABLE:               Integer = 1 number = 1080;
		documentationText
`Returned by cnPollSearchAsync and cnPollReadAsync when there is an entry waiting to be processed.`
		ENTRY_NOT_FOUND:               Integer = 3 number = 1081;
		documentationText
`Returned by cnPollReadAsync when an LDAP_NO_SUCH_OBJECT was received from the server.`
		LDAPS_PORT:                    Integer = 636 number = 1082;
		documentationText
		`Default port for SSL connection.`
		LDAP_COMPARE_FALSE:            Integer = 5 number = 1083;
		documentationText
		`Returned from the compare function in the API.`
		LDAP_COMPARE_TRUE:             Integer = 6 number = 1084;
		documentationText
		`Returned from the compare function in the API.`
		LDAP_MASTER_VERSION:           Integer = 4 number = 1085;
		documentationText
`This is an overall version number for the LDAP facility, and reflects any changes made to any of the LDAP classes.

Each subclass of CnLdap also has its own version number (in the 'version' property).

Version 4: 14.03.2001

			CnLdapConnection(V2)::delete (V2)
			
			Close connection if handle is still non-null (i.e. connection is still open);
			
Version 3: 07.02.2000

			CnLdapEntry::cnAddMultiAttribute (V2)

			Use array copy instead of array cast (the cast was causing truncation).

Version 2: The CnLdapSyntax object is now referenced by app.myCnLdapSyntax.
			CnLdapSyntax::create - sets the app reference.
			CnLdapSyntax::cnModify - case-sensitivity changes.
			CnLdapAttribute::cnSetName finds the CnLdapSyntax object via the app reference.
			CnLdapAttribute::cnSetName - case-sensitivity changes.
			CnLdapAttribute::cnSetSyntax - case-sensitivity changes.
			CnLdapEntry::cnModifyAttribute - case-sensitivity changes.

Version 1: Initial Release (integrated into CardSchema).`
		LDAP_MSG_ALL:                  Integer = 1 number = 1086;
		documentationText
`If written to CnLdapSearch::asyncRetrievalType, indicates that all results are
to be returned in one hit at the end of an asynchronous search.`
		LDAP_MSG_ONE:                  Integer = 0 number = 1087;
		documentationText
`CnLdapSearch::asyncRetrievalType value, indicating that one entry is to be retrieved from the server on each call of cnPollSearchAsync.`
		LDAP_MSG_RECEIVED:             Integer = 2 number = 1088;
		LDAP_NO_LIMIT:                 Integer = 0 number = 1089;
		documentationText
`Indicates that the search is to return an unlimited number of results (see CnLdapConstraints::cnSetMaxResults).`
		LDAP_NO_SUCH_OBJECT:           Integer = 32 number = 1090;
		documentationText
`Returned by the API when a base-level search did not find the specified entry.

This result code indicates that the server cannot find an entry specified in the request. 

The Netscape Directory Server sends this result code back to the client if it cannot find a requested entry and if it cannot refer your client to another LDAP server.`
		LDAP_OPT_PROTOCOL_VERSION:     Integer = 17 number = 1091;
		documentationText
`Parameter to cnESetOption, indicating that this API call is setting the protocol version parameter.`
		LDAP_OPT_SIZELIMIT:            Integer = 3 number = 1092;
		documentationText
`Parameter to cnESetOption: indicates that the search is to return a limited number of results (see CnLdapConstraints::cnSetMaxResults).`
		LDAP_OPT_TIMELIMIT:            Integer = 4 number = 1093;
		documentationText
		`Parameter to cnESetOption: the time limit for a search.`
		LDAP_PORT:                     Integer = 389 number = 1094;
		documentationText
		`Default port for non-SSL connection.`
		LDAP_RES_ANY:                  Integer = -1 number = 1095;
		documentationText
`When calling ldap_result, specifies that the results of ANY outstanding operation are to be returned.`
		LDAP_RES_SEARCH_ENTRY:         Integer = #64 number = 1096;
		documentationText
		`Returned by the API to indicate that there is an entry waiting to be processed.`
		LDAP_RES_SEARCH_RESULT:        Integer = #65 number = 1097;
		documentationText
`Returned by the API to indicate that all the results of the search are waiting to be processed.`
		LDAP_SCOPE_BASE:               Integer = 0 number = 1098;
		documentationText
		`Search only on same level as base DN.`
		LDAP_SCOPE_ONELEVEL:           Integer = 1 number = 1099;
		documentationText
		`Search one level below base DN.`
		LDAP_SCOPE_SUBTREE:            Integer = 2 number = 1100;
		documentationText
		`Search all levels below base DN.`
		LDAP_SUCCESS:                  Integer = 0 number = 1101;
		documentationText
		`Indicates LDAP operation had no errors.`
		NO_DATA_YET:                   Integer = 0 number = 1102;
		documentationText
`Returned by cnPollSearchAsync and cnPollReadAsync when there are no search entries waiting to be processed.`
		NO_MORE_ENTRIES:               Integer = 2 number = 1103;
		documentationText
`Returned by cnPollSearchAsync and cnPollReadAsync when there are no more entries available in LDAP_MSG_ONE mode (i.e. "get one entry at a time").`
		SSL_SERVER_AUTH:               Integer = 1 number = 1104;
		documentationText
`Bit set in ssl property to indicate client should initialise using SSL, with server authentication.`
	jadeMethodDefinitions
		cnCurrentTimeInMilliseconds(): Integer number = 1001;
		cnRaiseLdapException(
			pErrorCode: Integer; 
			pErrorItem: String; 
			pExErrorText: String) updating, number = 1002;
		cnScopeToInteger(pScopeString: String): Integer number = 1003;
		cnScopeToString(pScope: Integer): String number = 1004;
	)
	CnLdapAttribute completeDefinition
	(
		documentationText
		`Represents an attribute in an LDAP directory entry.`
	constantDefinitions
		CN_VERSION:                    Integer = 2 number = 1001;
		documentationText
`Version 2 21.01.2000

cnSetName: 	Force attribute name to lower case when searching CnLdapSyntax object.
			Look for the syntax object in app.myCnLdapSyntax. We no longer use firstProcessTransientInstance.
cnSetSyntax:Force syntax value to lower case.`
	attributeDefinitions
		allStringValues:               HugeStringArray readonly, subId = 1, number = 1, ordinal = 2;
		isBinary:                      Boolean readonly, number = 2, ordinal = 4;
		documentationText
`Mapping method sets this to true if the allBinaryValues collection is not empty.`
		isNull:                        Boolean readonly, number = 3, ordinal = 5;
		documentationText
`Mapping method sets this to true if both the allBinaryValues and allStringValues collections are empty.`
		isString:                      Boolean readonly, number = 4, ordinal = 6;
		documentationText
`Mapping method sets this to true if the allStringValues collection is not empty.`
		modifyOperator:                Integer readonly, number = 5, ordinal = 7;
		name:                          String[65] readonly, number = 6, ordinal = 9;
		syntax:                        String[4] readonly, number = 7, ordinal = 11;
	referenceDefinitions
		allBinaryValues:               CnLdapBinaryArray   explicitInverse, readonly, subId = 2, number = 8, ordinal = 1;
		binaryIterator:                Iterator  readonly, number = 9, ordinal = 3;
		myEntry:                       CnLdapEntry   explicitEmbeddedInverse, readonly, number = 10, ordinal = 8;
		stringIterator:                Iterator  readonly, number = 11, ordinal = 10;
	jadeMethodDefinitions
		cnAsString(): String updating, number = 1001;
		cnAttributeIsBinary(pName: String): Boolean number = 1026;
		cnBase64Decode(
			pMessage: String input; 
			pDecodedMessage: Binary output): Integer updating, number = 1002;
		cnBase64Encode(pMessage: Binary input): String updating, number = 1003;
		cnCloneSelf(pTransient: Boolean): CnLdapAttribute updating, number = 1004;
		cnGetNextBinary(binaryValue: Binary output): Boolean updating, number = 1005;
		cnGetNextBinaryAsLDIF(ldifValue: String output): Boolean updating, number = 1006;
		cnGetNextBinaryAsShortLDIF(ldifValue: String output): Boolean updating, number = 1007;
		cnGetNextString(stringValue: String output): Boolean updating, number = 1008;
		cnGetNextStringAsLDIF(stringValue: String output): Boolean updating, number = 1009;
		cnGetPreviousBinary(binaryValue: Binary output): Boolean updating, number = 1010;
		cnGetPreviousBinaryAsLDIF(ldifValue: String output): Boolean updating, number = 1011;
		cnGetPreviousBinaryAsShortLDIF(ldifValue: String output): Boolean updating, number = 1012;
		cnGetPreviousString(stringValue: String output): Boolean updating, number = 1013;
		cnGetPreviousStringAsLDIF(stringValue: String output): Boolean updating, number = 1014;
		cnResetBinaryIterator() updating, number = 1015;
		cnResetStringIterator() updating, number = 1016;
		cnSetModifyOperator(pOp: Integer) updating, number = 1017;
		cnSetMyEntry(pEntry: CnLdapEntry) updating, number = 1018;
		cnSetName(pName: String) updating, number = 1019;
		cnSetSyntax(pSyntax: String) updating, number = 1020;
		create() updating, number = 1021;
		delete() updating, number = 1022;
		isBinary(
			set: Boolean; 
			_value: Boolean io) mapping, number = 1023;
		isNull(
			set: Boolean; 
			_value: Boolean io) mapping, number = 1024;
		isString(
			set: Boolean; 
			_value: Boolean io) mapping, number = 1025;
	)
	CnLdapBinary completeDefinition
	(
		documentationText
`Represents the binary value of an attribute.

Defining this class allows us to build an array of CnLdapBinary objects
whose binary values are of max size. It is not possible to build a BinaryArray
whose members are of max size.`
	constantDefinitions
		CN_VERSION:                    Integer = 1 number = 1001;
	attributeDefinitions
		binaryValue:                   Binary readonly, subId = 1, number = 1, ordinal = 1;
		length:                        Integer readonly, virtual, number = 2, ordinal = 2;
	referenceDefinitions
		myAttribute:                   CnLdapAttribute   explicitEmbeddedInverse, protected, number = 3, ordinal = 3;
	jadeMethodDefinitions
		cnGetBinaryValue(): Binary number = 1001;
		cnSetBinaryValue(pBinary: Binary) updating, number = 1002;
		cnSetMyAttribute(pAttribute: CnLdapAttribute) updating, number = 1003;
		length(
			set: Boolean; 
			value: Integer io) mapping, number = 1004;
	)
	CnLdapConnection completeDefinition
	(
		documentationText
`Main class for handling LDAP operations; for example, open, search, add, modify, delete and close.`
	constantDefinitions
		CN_VERSION:                    Integer = 2 number = 1001;
		documentationText
`Version 2	14.03.01	

CnLdapConnection::delete	:	Close connection if it's still open. We had a problem whereby users were omitting to
								do a cnClose, resulting in connections being left open at the server end.`
	attributeDefinitions
		errorCode:                     Integer readonly, number = 2, ordinal = 2;
		documentationText
`Result of ldap_get_lderrno function, which also sets errorString to a description of the error,
and matchedString to the part of the DN that the search was able to match.`
		errorString:                   String[101] readonly, number = 3, ordinal = 3;
		documentationText
`Result of ldap_get_lderrno function, which also sets errorCode to the error code,
and matchedString to the part of the DN that the search was able to match.`
		host:                          String readonly, subId = 1, number = 4, ordinal = 4;
		initWithoutBind:               Boolean protected, number = 5, ordinal = 5;
		ldapHandle:                    MemoryAddress readonly, number = 6, ordinal = 6;
		loggingRequired:               Boolean readonly, number = 7, ordinal = 7;
		matchedString:                 String[101] readonly, number = 8, ordinal = 8;
		documentationText
`Result of ldap_get_lderrno function, which also sets errorCode to the error code,
and errorString to the description of the error.

matchedString is the part of the DN that the server was able to match during the search.`
		oldSortStyle:                  Boolean protected, number = 18, ordinal = 18;
		port:                          Integer readonly, number = 9, ordinal = 10;
		protocolVersion:               Integer readonly, number = 10, ordinal = 11;
		scope:                         Integer readonly, number = 11, ordinal = 12;
		searchAttributeList:           CnStringArray protected, subId = 1, number = 12, ordinal = 13;
		sortAttributeList:             CnStringArray protected, subId = 2, number = 13, ordinal = 14;
		sortAttributeMulti:            BooleanArray protected, subId = 6, number = 22, ordinal = 22;
		sortAttributeNumeric:          BooleanArray protected, subId = 5, number = 21, ordinal = 21;
		sortAttributeSize:             IntegerArray protected, subId = 7, number = 23, ordinal = 23;
		sortRequired:                  Boolean protected, number = 24, ordinal = 24;
		ssl:                           Integer readonly, number = 14, ordinal = 15;
	referenceDefinitions
		attributesToPurge:             ObjectSet  implicitMemberInverse, protected, subId = 3, number = 19, ordinal = 19;
		interimEntryArray:             CnLdapEntryArray  implicitMemberInverse, protected, subId = 4, number = 20, ordinal = 20;
		mySearchConstraints:           CnLdapConstraints   explicitEmbeddedInverse, readonly, number = 15, ordinal = 9;
		tempAttributeArray:            CnStringArray  protected, number = 16, ordinal = 16;
		tempStringValues:              HugeStringArray  protected, number = 17, ordinal = 17;
	jadeMethodDefinitions
		cnAbandonReadAsync(pEntry: CnLdapEntry input) updating, number = 1001;
		cnAbandonSearchAsync(pSearch: CnLdapSearch io) updating, number = 1002;
		cnAddEntry(pEntry: CnLdapEntry input) updating, number = 1003;
		cnClearSearchAttributes() updating, number = 1004;
		cnClearSortAttributes() updating, number = 1005;
		cnClose() updating, number = 1006;
		cnCompare(
			pDn: String; 
			pAttributeName: String; 
			pValue: Any): Boolean updating, number = 1007;
		cnDeleteEntry(pDn: String) updating, number = 1008;
		cnISearchAsync(
			pURLSearch: Boolean; 
			pURL: CnLdapURL; 
			pBase: String; 
			pFilter: String; 
			pSearch: CnLdapSearch io) updating, number = 1013;
		cnModifyEntry(pEntry: CnLdapEntry input) updating, number = 1015;
		cnOpen(
			pHost: String; 
			pDn: String; 
			pPassword: String) updating, number = 1016;
		cnPollReadAsync(pEntry: CnLdapEntry io): Integer updating, number = 1017;
		cnPollSearchAsync(pSearch: CnLdapSearch io): Integer updating, number = 1018;
		cnRead(
			pDn: String; 
			pEntry: CnLdapEntry io) updating, number = 1019;
		cnReadAsync(
			pDn: String; 
			pEntry: CnLdapEntry io) updating, number = 1020;
		cnRemoveSearchAttribute(pAttribute: String) updating, number = 1021;
		cnRemoveSortAttribute(pAttribute: String) updating, number = 1022;
		cnRenameEntry(
			pDn: String; 
			pNewRdn: String; 
			pNewParent: String; 
			pDeleteOldRdn: Boolean) updating, number = 1023;
		cnSearch(
			pBase: String; 
			pFilter: String; 
			pSearch: CnLdapSearch io) updating, number = 1024;
		cnSearchAsync(
			pBase: String; 
			pFilter: String; 
			pSearch: CnLdapSearch io) updating, number = 1025;
		cnSetAttrsOnly(pFlag: Integer) updating, number = 1026;
		cnSetHost(pHost: String) updating, number = 1028;
		cnSetInitWithoutBind(pInitWithoutBind: Boolean) updating, number = 1029;
		cnSetLdapHandle(pHandle: MemoryAddress) updating, number = 1030;
		cnSetLoggingRequired(pLogFlag: Boolean) updating, number = 1031;
		cnSetMaxResults(pMax: Integer) updating, number = 1032;
		cnSetMySearchConstraints(pConstraints: CnLdapConstraints) updating, number = 1033;
		cnSetOldSortStyle(pBool: Boolean) updating, number = 1078;
		cnSetPort(pPort: Integer) updating, number = 1034;
		cnSetProtocolVersion(pVersion: Integer) updating, number = 1035;
		cnSetScope(pScope: Integer) updating, number = 1036;
		cnSetSearchAttribute(pAttribute: String) updating, number = 1037;
		cnSetSearchAttributes(
			pAttributes: String; 
			pDelimiters: String) updating, number = 1038;
		cnSetSortAttribute(pAttribute: String) updating, number = 1039;
		cnSetSortAttributes(
			pAttributes: String; 
			pDelimiters: String) updating, number = 1040;
		cnSetSsl(pSsl: Integer) updating, number = 1041;
		cnSetTimeLimit(pLimit: Integer) updating, number = 1042;
		cnURLSearch(
			pURL: CnLdapURL; 
			pSearch: CnLdapSearch io) updating, number = 1044;
		cnURLSearchAsync(
			pURL: CnLdapURL; 
			pSearch: CnLdapSearch io) updating, number = 1045;
		create() updating, number = 1046;
		delete() updating, number = 1047;
		zGetAllAttributes(
			pEntryMessage: MemoryAddress input; 
			pEntryObject: CnLdapEntry input) updating, protected, number = 1079;
		zGetAllEntries(
			pSearchResults: MemoryAddress input; 
			pUserSearch: CnLdapSearch io) updating, protected, number = 1080;
		zGetBinaryValues(
			pEntryMessage: MemoryAddress; 
			pAttribute: CnLdapAttribute input) updating, protected, number = 1081;
		zISearch(
			pURLSearch: Boolean; 
			pURL: CnLdapURL; 
			pBase: String; 
			pFilter: String; 
			pSearch: CnLdapSearch io) updating, protected, number = 1082;
		zLdapLog(
			pEntryType: Integer; 
			pMessage: String) protected, number = 1083;
		zSortEntries(pSearch: CnLdapSearch) protected, number = 1084;
		zSortEntriesOld(pSearchResults: MemoryAddress io) updating, protected, number = 1085;
	externalMethodDefinitions
		zEAbandonA(
			pHandle: MemoryAddress; 
			pMsgID: Integer; 
			pServerCtrls: Integer; 
			pClientCtrls: Integer): Integer is "cn_ldap_abandon_ext" in "cnldap" protected, number = 1086;
		zEAddEntry(
			pHandle: MemoryAddress; 
			pDn: String; 
			pAttributeArray: CnLdapAttributeDict; 
			pServerCtrls: Integer; 
			pClientCtrls: Integer): Integer is "cn_ldap_add_ext_s" in "cnldap" protected, number = 1087;
		zEAllAttributes(
			pHandle: MemoryAddress; 
			pEntryMessage: MemoryAddress; 
			pAttributeArray: CnStringArray io): Integer is "cn_ldap_all_attributes" in "cnldap" protected, number = 1088;
		zECompare(
			pHandle: MemoryAddress; 
			pDn: String; 
			pAttributeName: String; 
			pValue: Binary; 
			pServerCtrls: Integer; 
			pClientCtrls: Integer): Integer is "cn_ldap_compare_ext_s" in "cnldap" updating, protected, number = 1089;
		zECountBinaryValues(
			pHandle: MemoryAddress; 
			pEntryMessage: MemoryAddress; 
			pAttName: String; 
			pPointer: MemoryAddress output): Integer is "cn_ldap_count_binary_values" in "cnldap" updating, protected, number = 1090;
		zECountEntries(
			pHandle: MemoryAddress; 
			pSearchResults: MemoryAddress): Integer is "cn_ldap_count_entries" in "cnldap" protected, number = 1091;
		zEDeleteEntry(
			pHandle: MemoryAddress; 
			pDn: String; 
			pServerCtrls: Integer; 
			pClientCtrls: Integer): Integer is "cn_ldap_delete_ext_s" in "cnldap" updating, protected, number = 1092;
		zEFetchBinaryValue(
			pPointer: MemoryAddress; 
			pIndex: Integer): Binary is "cn_ldap_fetch_binary_value" in "cnldap" updating, protected, number = 1093;
		zEFirstEntry(
			pHandle: MemoryAddress; 
			pSearchResults: MemoryAddress): MemoryAddress is "cn_ldap_first_entry" in "cnldap" protected, number = 1094;
		zEGetDn(
			pHandle: MemoryAddress; 
			pEntry: MemoryAddress): String is "cn_ldap_get_dn" in "cnldap" updating, protected, number = 1095;
		zEInit(): MemoryAddress is "cn_ldap_init" in "cnldap" updating, protected, number = 1096;
		zEModifyEntry(
			pHandle: MemoryAddress; 
			pDn: String; 
			pAttributeArray: CnLdapAttributeDict; 
			pServerCtrls: Integer; 
			pClientCtrls: Integer): Integer is "cn_ldap_modify_ext_s" in "cnldap" protected, number = 1097;
		zEMsgFree(pSearchResults: MemoryAddress): Integer is "cn_ldap_msgfree" in "cnldap" updating, protected, number = 1098;
		zEMultiSortEntries(
			pHandle: MemoryAddress; 
			pSearchResults: MemoryAddress io; 
			pAttributeList: CnStringArray; 
			pRoutine: String): Integer is "cn_ldap_multisort_entries" in "cnldap" updating, protected, number = 1099;
		zENextEntry(
			pHandle: MemoryAddress; 
			pSearchResults: MemoryAddress): MemoryAddress is "cn_ldap_next_entry" in "cnldap" protected, number = 1100;
		zEParseResult(
			pHandle: MemoryAddress; 
			pSearchResults: MemoryAddress io; 
			pReferrals: MemoryAddress io; 
			pServerCntrls: MemoryAddress io; 
			pFreeit: Integer): Integer is "cn_ldap_parse_result" in "cnldap" updating, protected, number = 1101;
		zERenameEntry(
			pHandle: MemoryAddress; 
			pDn: String; 
			pNewRdn: String; 
			pNewParent: String; 
			pDeleteOldRdn: Integer; 
			pServerCtrls: Integer; 
			pClientCtrls: Integer): Integer is "cn_ldap_rename_s" in "cnldap" updating, protected, number = 1102;
		zEResult(
			pHandle: MemoryAddress; 
			pMsgID: Integer; 
			pAll: Integer; 
			pTimeout: Integer; 
			pSearchResults: MemoryAddress io): Integer is "cn_ldap_result" in "cnldap" updating, protected, number = 1103;
		zESSLClientInit(
			pCertDbPath: String; 
			pCertDbHandle: Integer): Integer is "cn_ldapssl_client_init" in "cnldap" protected, number = 1104;
		zESSLInit(): MemoryAddress is "cn_ldapssl_init" in "cnldap" updating, protected, number = 1105;
		zESearchA(
			pHandle: MemoryAddress; 
			pBase: String; 
			pScope: Integer; 
			pFilter: String; 
			pAttrs: CnStringArray; 
			attrsOnly: Boolean; 
			serverCtrls: Integer; 
			clientCtrls: Integer; 
			pTimeout: Integer; 
			pSizeLimit: Integer; 
			pMsgID: Integer io): Integer is "cn_ldap_search_ext" in "cnldap" updating, protected, number = 1106;
		zESearchS(
			pHandle: MemoryAddress; 
			pBase: String; 
			pScope: Integer; 
			pFilter: String; 
			pAttrs: CnStringArray; 
			attrsOnly: Boolean; 
			serverCtrls: Integer; 
			clientCtrls: Integer; 
			pTimeout: Integer; 
			pSizeLimit: Integer; 
			pSearchResults: MemoryAddress io): Integer is "cn_ldap_search_ext_s" in "cnldap" updating, protected, number = 1107;
		zESetOption(
			pHandle: MemoryAddress; 
			pOption: Integer; 
			pValue: Any): Integer is "cn_ldap_set_option" in "cnldap" updating, protected, number = 1108;
		zESimpleBindS(
			pHandle: MemoryAddress; 
			pDn: String; 
			pPassword: String): Integer is "cn_ldap_simpleBind_s" in "cnldap" protected, number = 1109;
		zESortEntries(
			pHandle: MemoryAddress; 
			pSearchResults: MemoryAddress io; 
			pAttribute: String; 
			pRoutine: String): Integer is "cn_ldap_sort_entries" in "cnldap" updating, protected, number = 1110;
		zEStringValues(
			pHandle: MemoryAddress; 
			pEntryMessage: MemoryAddress; 
			pAttName: String; 
			pAttributeValues: HugeStringArray io): Integer is "cn_ldap_get_values" in "cnldap" protected, number = 1111;
		zEURLSearchA(
			pHandle: MemoryAddress; 
			pURL: String; 
			attrsOnly: Integer): Integer is "cn_ldap_url_search" in "cnldap" updating, protected, number = 1112;
		zEURLSearchS(
			pHandle: MemoryAddress; 
			pURL: String; 
			attrsOnly: Integer; 
			pSearchResults: MemoryAddress io): Integer is "cn_ldap_url_search_s" in "cnldap" updating, protected, number = 1113;
		zEUnbindS(pHandle: MemoryAddress): Integer is "cn_ldap_unbind_s" in "cnldap" protected, number = 1114;
		zEValueFreeLen(pPointer: MemoryAddress): Integer is "cn_ldap_value_free_len" in "cnldap" protected, number = 1115;
	)
	CnLdapConstraints completeDefinition
	(
		documentationText
`Allows search constraints to be specified; for example, the 
time limit for a search.`
	constantDefinitions
		CN_VERSION:                    Integer = 1 number = 1001;
	attributeDefinitions
		attrsOnly:                     Integer readonly, number = 1, ordinal = 1;
		maxResults:                    Integer readonly, number = 2, ordinal = 2;
		mode:                          Integer readonly, number = 3, ordinal = 3;
		documentationText
`Bit-coded flag that controls which API calls are used to extract information from the search results. Inclusive OR the required values.

1	=	Look for directory entries and return a collection of them in the search object
2	=	Look for references and return a collection of them in the search object`
		timeLimit:                     Integer readonly, number = 4, ordinal = 6;
	referenceDefinitions
		myLdapConnection:              CnLdapConnection   explicitEmbeddedInverse, readonly, number = 5, ordinal = 4;
		mySearchObject:                CnLdapSearch   explicitEmbeddedInverse, readonly, number = 6, ordinal = 5;
	jadeMethodDefinitions
		cnSetAttrsOnly(pFlag: Integer) updating, number = 1001;
		cnSetMaxResults(pMax: Integer) updating, number = 1002;
		cnSetMode(pMode: Integer) updating, number = 1003;
		cnSetMyLdapConnection(pLdap: CnLdapConnection) updating, number = 1004;
		cnSetMySearchObject(pSearch: CnLdapSearch) updating, number = 1005;
		cnSetTimeLimit(pLimit: Integer) updating, number = 1006;
		create() updating, number = 1007;
	)
	CnLdapEntry completeDefinition
	(
		documentationText
		`Represents an LDAP directory entry.`
	constantDefinitions
		CN_VERSION:                    Integer = 3 number = 1001;
		documentationText
`Version 3 07.02.2000

cnAddMultiAttribute (V2) changed to use array copy rather than array cast (the cast was causing truncation).

Version 2 21.01.2000

cnModifyAttribute changed for case sensitivity.`
		LDAP_DELETE_VALUE:             String = "~~vernichten^detruire&uitvegen##" number = 1002;
		LDAP_MOD_ADD:                  Integer = 0 number = 1003;
		documentationText
`Parameter to cnModifyAttribute, indicating that this attribute value is to be added.`
		LDAP_MOD_BVALUES:              Integer = #80 number = 1004;
		documentationText
`This value is ORd into the modifyOperator to indicate that a binary value is being modified.`
		LDAP_MOD_DELETE:               Integer = 1 number = 1005;
		documentationText
`Parameter to cnModifyAttribute, indicating that this attribute value is to be deleted.`
		LDAP_MOD_REPLACE:              Integer = 2 number = 1006;
		documentationText
`Parameter to cnModifyAttribute, indicating that this attribute value is to be replaced.`
	attributeDefinitions
		dn:                            String[261] readonly, number = 1, ordinal = 2;
	referenceDefinitions
		allAttributes:                 CnLdapAttributeDict   explicitInverse, readonly, subId = 1, number = 2, ordinal = 1;
		iterator:                      Iterator  readonly, number = 3, ordinal = 3;
		myReadAsyncSearchObject:       CnLdapSearch  readonly, number = 4, ordinal = 4;
		mySearchObject:                CnLdapSearch   explicitEmbeddedInverse, readonly, number = 5, ordinal = 5;
	jadeMethodDefinitions
		cnAddAttribute(
			pAttributeName: String; 
			pValue: Any) updating, number = 1001;
		cnAddDelimitedAttribute(
			pAttributeName: String; 
			pValues: String; 
			pDelimiters: String) updating, number = 1002;
		cnAddMultiAttribute(
			pAttributeName: String; 
			pValues: Array input) updating, number = 1003;
		cnAsLDIF(): String updating, number = 1004;
		cnAsString(): String updating, number = 1005;
		cnClearAttribute(pAttributeName: String) number = 1026;
		cnCloneSelf(pTransient: Boolean): CnLdapEntry updating, number = 1006;
		cnConvertToLDIF(pShortFlag: Boolean): String updating, number = 1007;
		cnGetAllAttributeValues(
			pAttributeName: String; 
			pArray: Any io) updating, number = 1008;
		cnGetAttribute(pAttributeName: String): CnLdapAttribute number = 1009;
		cnGetAttributeValue(pAttributeName: String): Any updating, number = 1010;
		cnGetNextAttribute(pAttribute: CnLdapAttribute output): Boolean updating, number = 1011;
		cnGetPreviousAttribute(pAttribute: CnLdapAttribute output): Boolean updating, number = 1012;
		cnHasAttribute(pAttributeName: String): Boolean number = 1013;
		cnModifyAttribute(
			pAttributeName: String; 
			pValue: Any; 
			pOp: Integer) updating, number = 1014;
		cnResetIterator() updating, number = 1015;
		cnSetDn(pDn: String) updating, number = 1016;
		cnSetMyReadAsyncSearchObject(pSearch: CnLdapSearch) updating, number = 1017;
		cnSetMySearchObject(pSearch: CnLdapSearch) updating, number = 1018;
		delete() updating, number = 1019;
	)
	CnLdapSearch completeDefinition
	(
		documentationText
		`Holds the entry objects built by the search functions.`
	constantDefinitions
		CN_VERSION:                    Integer = 1 number = 1001;
	attributeDefinitions
		asyncPollTimeout:              Integer readonly, number = 1, ordinal = 2;
		asyncRetrievalType:            Integer readonly, number = 2, ordinal = 3;
		attrsOnly:                     Integer readonly, number = 3, ordinal = 4;
		entryCount:                    Integer readonly, number = 4, ordinal = 5;
		msgID:                         Integer readonly, number = 5, ordinal = 7;
	referenceDefinitions
		allEntries:                    CnLdapEntryArray   explicitInverse, readonly, subId = 1, number = 6, ordinal = 1;
		iterator:                      Iterator  readonly, number = 7, ordinal = 6;
		myLdapConnection:              CnLdapConnection  readonly, number = 8, ordinal = 8;
		mySearchConstraints:           CnLdapConstraints   explicitEmbeddedInverse, readonly, number = 9, ordinal = 9;
	jadeMethodDefinitions
		cnGetEntry(pDn: String): CnLdapEntry number = 1001;
		cnGetNextEntry(pEntry: CnLdapEntry output): Boolean updating, number = 1002;
		cnGetPreviousEntry(pEntry: CnLdapEntry output): Boolean updating, number = 1003;
		cnResetIterator() updating, number = 1004;
		cnSetAsyncPollTimeout(pTimeout: Integer) updating, number = 1005;
		cnSetAsyncRetrievalType(pType: Integer) updating, number = 1006;
		cnSetAttrsOnly(pAttrsOnly: Integer) updating, number = 1007;
		cnSetEntryCount(pEntryCount: Integer) updating, number = 1008;
		cnSetMsgID(pID: Integer) updating, number = 1009;
		cnSetMyLdapConnection(pLdapConnection: CnLdapConnection) updating, number = 1010;
		delete() updating, number = 1011;
	)
	CnLdapSyntax completeDefinition
	(
		documentationText
		`Allows you to override the default syntax definitions for any
attribute.`
	constantDefinitions
		CN_VERSION:                    Integer = 2 number = 1001;
		documentationText
`Version 2 21.01.2000

'app' now has a myCnLdapSyntax reference. The reference is set in the create (V2) method of CnLdapSyntax.
firstProcessTransientInstance is no longer used.

cnModify (V2) changed for case sensitivity.`
	attributeDefinitions
		attributeNameList:             CnStringArray readonly, subId = 2, number = 1, ordinal = 1;
		attributeSyntaxList:           CnStringArray readonly, subId = 1, number = 2, ordinal = 2;
	jadeMethodDefinitions
		cnGetSyntax(pAttributeName: String): String number = 1001;
		cnModify(
			pAttributeName: String; 
			pSyntax: String) updating, number = 1002;
		cnRemove(pAttributeName: String) updating, number = 1003;
		create() updating, number = 1004;
	)
	CnLdapURL completeDefinition
	(
		documentationText
		`Allows you to search an LDAP server using LDAP URLs.`
	constantDefinitions
		CN_LDAP_URL_ERROR_BASE:        Integer = CN_LDAP_ERROR_BASE + 400 number = 1001;
		documentationText
		`Base offset for URL error codes.`
		CN_LDAP_URL_ERR_BADSCOPE:      Integer = CN_LDAP_URL_ERROR_BASE + 3 number = 1002;
		documentationText
		`URL scope string is invalid.`
		CN_LDAP_URL_ERR_MEM:           Integer = CN_LDAP_URL_ERROR_BASE + 4 number = 1003;
		documentationText
		`Can't allocate memory space.`
		CN_LDAP_URL_ERR_NODN:          Integer = CN_LDAP_URL_ERROR_BASE + 2 number = 1004;
		documentationText
		`URL has no DN (required).`
		CN_LDAP_URL_ERR_NOTLDAP:       Integer = CN_LDAP_URL_ERROR_BASE + 1 number = 1005;
		documentationText
		`URL doesn't begin with "ldap://".`
		CN_LDAP_URL_ERR_PARAM:         Integer = CN_LDAP_URL_ERROR_BASE + 5 number = 1006;
		documentationText
		`Bad parameter to an URL function.`
		CN_VERSION:                    Integer = 1 number = 1007;
	attributeDefinitions
		baseDn:                        String readonly, subId = 5, number = 1, ordinal = 1;
		errorCode:                     Integer readonly, number = 2, ordinal = 2;
		errorString:                   String[65] readonly, number = 3, ordinal = 3;
		filter:                        String readonly, subId = 3, number = 4, ordinal = 4;
		host:                          String readonly, subId = 1, number = 5, ordinal = 5;
		port:                          Integer readonly, number = 6, ordinal = 6;
		scope:                         Integer readonly, number = 7, ordinal = 7;
		ssl:                           Integer readonly, number = 8, ordinal = 9;
		url:                           String readonly, subId = 4, number = 9, ordinal = 10;
	referenceDefinitions
		searchAttributeList:           CnStringArray  readonly, number = 10, ordinal = 8;
		documentationText
`Only used when decoding/encoding the URL. When doing a search, the list of attributes is specified in the URL itself.`
	jadeMethodDefinitions
		cnClearSearchAttributes() updating, number = 1001;
		cnDecodeURL() updating, number = 1002;
		cnEncodeURL() updating, number = 1003;
		cnGetScopeText(pScope: Integer): String number = 1004;
		cnRemoveSearchAttribute(pAttribute: String) updating, number = 1005;
		cnSetBaseDn(pBaseDn: String) updating, number = 1006;
		cnSetFilter(pFilter: String) updating, number = 1007;
		cnSetHost(pHost: String) updating, number = 1008;
		cnSetPort(pPort: Integer) updating, number = 1009;
		cnSetScope(pScope: Integer) updating, number = 1010;
		cnSetSearchAttribute(pAttribute: String) updating, number = 1011;
		cnSetSearchAttributes(
			pAttributes: String; 
			pDelimiters: String) updating, number = 1012;
		cnSetSsl(pSsl: Integer) updating, number = 1013;
		cnSetURL(pUrl: String) updating, number = 1014;
		create() updating, number = 1015;
		delete() updating, number = 1016;
	externalMethodDefinitions
		cnEURLCheck(url: String): Integer is "cn_ldap_is_ldap_url" in "cnldap" number = 1017;
		cnEURLParse(
			pUrl: String; 
			rHost: String io; 
			rPort: Integer io; 
			rDn: String io; 
			rSearchAttributeList: CnStringArray io; 
			rScope: Integer io; 
			rFilter: String io; 
			rOptions: Integer io): Integer is "cn_ldap_url_parse" in "cnldap" updating, number = 1018;
	)
	CnMIME completeDefinition
	(
		documentationText
`Version 1 19.06.00	Superclass of classes that define MIME attachments and inline objects.
					CnAttachment, which was formerly under Object, is now under CnMIME, 
					and some of the CnAttachment properties have been moved up into the
					CnMIME superclass.`
	constantDefinitions
		File_Is_In_Default_Location:   Integer = 0 number = 1001;
		documentationText
`Used by the physicalFileLocation property of the CnMIME class.

The file is assumed to be on the default JADE file system.
For example, if the process is using thin client, then the file is assumed to be on the presentation client.

The rules are the same as those for the usePresentationFileSystem property of the FileNode class.`
		File_Is_On_App_Server:         Integer = 2 number = 1002;
		documentationText
`Used by the physicalFileLocation property of the CnMIME class.

The file is assumed to be on the application server.
The usePresentationFileSystem property of the internally-generated file object will be set to 'false'.`
		File_Is_On_Presentation_Client:Integer = 1 number = 1003;
		documentationText
`Used by the physicalFileLocation property of the CnMIME class.

The file is assumed to be on the presentation client.
The usePresentationFileSystem property of the internally-generated file object will be set to 'true'.`
	attributeDefinitions
		binaryImage:                   Binary subId = 3, number = 1, ordinal = 1;
		contentDescription:            String subId = 5, number = 2, ordinal = 2;
		contentID:                     String subId = 1, number = 3, ordinal = 3;
		documentationText
`This property corresponds to the MHTML Content-ID statement that is generated as part of the email.
Embedded images within an email can be referenced either by Content-ID or by Content-Location.`
		contentLocation:               String subId = 4, number = 4, ordinal = 4;
		documentationText
`This property corresponds to the MHTML Content-Location statement that is generated as part of the email.
Embedded images within an email can be referenced either by Content-Location or by Content-ID.`
		contentType:                   String[31] number = 5, ordinal = 5;
		encodingType:                  String[31] number = 6, ordinal = 6;
		fileName:                      String subId = 2, number = 7, ordinal = 7;
		isUserEncoded:                 Boolean number = 8, ordinal = 9;
		physicalFileLocation:          Integer number = 13, ordinal = 13;
		sendAsOneBlock:                Boolean number = 9, ordinal = 10;
		shareMode:                     Integer number = 12, ordinal = 11;
		sourceIsFile:                  Boolean number = 10, ordinal = 12;
	referenceDefinitions
		fileObject:                    File  readonly, number = 11, ordinal = 8;
	jadeMethodDefinitions
		deleteFileObject() updating, number = 1001;
		setContentType(pContentType: String) updating, number = 1002;
		setFileObject(pFile: File) updating, number = 1003;
	)
	CnAttachment completeDefinition
	(
		documentationText
`This material is proprietary to Cardinal Group Limited (Cardinal) and is not to be reproduced, used or 
disclosed except upon written permission of Cardinal.                                                                     

  		 COPYRIGHT (C) CARDINAL GROUP LIMITED 1999 - ALL RIGHTS RESERVED
-------------------------------------------------------------------------------------------------------`
	constantDefinitions
		CN_VERSION:                    Integer = 2 number = 1001;
		documentationText
`V2 30.3.2000 : Changes to cater for lines that straddle blocks.

fileObject now read-only.
getNextBlock method removed.`
	referenceDefinitions
		mySmtpConnection:              CnSmtpConnection   explicitEmbeddedInverse, number = 1, ordinal = 1;
	)
	CnSmtpInline completeDefinition
	(
		documentationText
`Version 1	19.06.00	New class to allow embedded objects within an SMTP multipart/related message.
						Each instance of this class represents one object (for example, an image) that
						is Base64-encoded and sent in-line with the SMTP message. This facility allows
						an email to contain multimedia files that will display in the recipient's mail
						agent even when there is no visibility to the original resource.`
	constantDefinitions
		IMG:                           String = "IMG" number = 1001;
	attributeDefinitions
		htmlEmbedType:                 String[31] number = 1, ordinal = 1;
		documentationText
`For example, IMG for image (the default).

Later, we may add other types, such as APPLET.`
	referenceDefinitions
		mySmtpConnection:              CnSmtpConnection   explicitEmbeddedInverse, number = 2, ordinal = 2;
	jadeMethodDefinitions
		create() updating, number = 1001;
	)
	CnMachine completeDefinition
	(
	attributeDefinitions
		clientFQDN:                    String[65] readonly, number = 1, ordinal = 3;
		currentClientBinVersion:       TimeStamp readonly, number = 2, ordinal = 4;
		currentClientMiscVersion:      TimeStamp readonly, number = 3, ordinal = 5;
		currentClientSchemaVersion:    TimeStamp readonly, number = 4, ordinal = 6;
		ipAddress:                     String[66] readonly, number = 5, ordinal = 7;
		isActive:                      Boolean readonly, number = 6, ordinal = 8;
		nextClientBinVersion:          TimeStamp readonly, number = 7, ordinal = 10;
		nextClientMiscVersion:         TimeStamp readonly, number = 8, ordinal = 11;
		nextClientSchemaVersion:       TimeStamp readonly, number = 9, ordinal = 12;
	referenceDefinitions
		allApps:                       CnAppDict   explicitInverse, readonly, subId = 1, number = 10, ordinal = 1;
		allProcesses:                  CnProcessDict   explicitInverse, readonly, subId = 2, number = 11, ordinal = 2;
		myKarmaCntrl:                  CnKarmaCntrl   explicitEmbeddedInverse, readonly, number = 12, ordinal = 9;
	jadeMethodDefinitions
		setClientFQDN(fqdn: String) updating, number = 1001;
		setCurrentClientVersions(
			schemaver: TimeStamp; 
			binver: TimeStamp; 
			miscver: TimeStamp) updating, number = 1002;
		setIpAddress(ipaddr: String) updating, number = 1003;
		setIsActive(set: Boolean) updating, number = 1004;
		setMyKarmaCntrl(kc: CnKarmaCntrl) updating, number = 1005;
		setNextClientVersions(
			schemaver: TimeStamp; 
			binver: TimeStamp; 
			miscver: TimeStamp) updating, number = 1006;
	)
	CnMessage completeDefinition
	(
	constantDefinitions
		Advice:                        String = "A" number = 1001;
		Advice_Type_AppMonAdv_CopyAlarm:String = "COPY_ALARM" number = 1176;
		Advice_Type_AppMonAdv_CopyClear:String = "COPY_CLEAR" number = 1177;
		Advice_Type_AppMonAdv_PingAlarm:String = "PING_ALARM" number = 1178;
		Advice_Type_AppMonAdv_PingClear:String = "PING_CLEAR" number = 1179;
		Advice_Type_Backup_Active:     String = "BKACT" number = 1002;
		Advice_Type_Backup_Advisory:   String = "BKADVSRY" number = 1181;
		Advice_Type_Backup_Cancel_Fail:String = "BKCANFL" number = 1003;
		Advice_Type_Backup_Cancel_OK:  String = "BKCANOK" number = 1004;
		Advice_Type_Backup_CompletedOK:String = "BKCOK" number = 1005;
		Advice_Type_Backup_Disabled:   String = "BKDISABL" number = 1006;
		Advice_Type_Backup_Failed:     String = "BKFAIL" number = 1007;
		Advice_Type_Backup_Interrupted:String = "BKINT" number = 1008;
		Advice_Type_Backup_Progress:   String = "BKPRG" number = 1009;
		Advice_Type_Backup_Scheduled:  String = "BKSCH" number = 1010;
		Advice_Type_Backup_Starting:   String = "BKST" number = 1011;
		Advice_Type_Backup_UnCan_Fail: String = "BKUNCFL" number = 1012;
		Advice_Type_Backup_UnCan_OK:   String = "BKUNCOK" number = 1013;
		Advice_Type_Batch_ThinClient:  String = "BITHINCL" number = 1014;
		Advice_Type_Compact_Active:    String = "CMPACT" number = 1015;
		Advice_Type_Compact_Cancl_Fail:String = "CMPCANFL" number = 1016;
		Advice_Type_Compact_Cancl_OK:  String = "CMPCANOK" number = 1017;
		Advice_Type_Compact_CompleteOK:String = "CMPOK" number = 1018;
		Advice_Type_Compact_Failed:    String = "CMPFAIL" number = 1019;
		Advice_Type_Compact_Interrupt: String = "CMPINT" number = 1020;
		Advice_Type_Compact_Progress:  String = "CMPPRG" number = 1021;
		Advice_Type_Compact_Scheduled: String = "CMPSCH" number = 1022;
		Advice_Type_Compact_Starting:  String = "CMPST" number = 1023;
		Advice_Type_Db_Stats:          String = "DB" number = 1024;
		Advice_Type_Discovery_DotNetService:String = "DOTNET" number = 1172;
		Advice_Type_Discovery_Error:   String = "ERROR" number = 1171;
		Advice_Type_Discovery_WebInfo: String = "WEBINFO" number = 1173;
		Advice_Type_Disk_Usage:        String = "DU" number = 1025;
		Advice_Type_Env_Stats:         String = "ES" number = 1026;
		Advice_Type_FileDet_BinVer:    String = "FDBINVER" number = 1027;
		documentationText
		`This will include versions for libraries for Linux hosts (filetype=L)`
		Advice_Type_FileDet_DbData:    String = "FDDBDATA" number = 1028;
		Advice_Type_FileDet_ThinClient:String = "FDTHINCL" number = 1029;
		Advice_Type_FileDet_UserPatchs:String = "FDUSERPT" number = 1030;
		Advice_Type_Install_State:     String = "STAT" number = 1031;
		Advice_Type_Map_Sizes:         String = "MS" number = 1032;
		Advice_Type_ODBC_Alarm:        String = "ODBCALRM" number = 1033;
		Advice_Type_ODBC_Alarm_Clear:  String = "ODBCACLR" number = 1034;
		Advice_Type_ODBC_DRequest:     String = "ODBCDREQ" number = 1035;
		documentationText
`Database setup request
Send a request to JSM for current ODBC monitor configurations`
		Advice_Type_ODBC_PRequest:     String = "ODBCPREQ" number = 1036;
		documentationText
		`Ping setup request`
		Advice_Type_ODBC_PingQueryResponse:String = "ODBCPQR" number = 1180;
		documentationText
		`For sending database status gathered in Ping to JSM`
		Advice_Type_ODBC_QueryResponse:String = "ODBCQRES" number = 1037;
		Advice_Type_ODBC_Version:      String = "ODBCVER" number = 1038;
		Advice_Type_Restore_Failed:    String = "RSTFAIL" number = 1039;
		Advice_Type_Restore_Interrupt: String = "RSTINT" number = 1040;
		Advice_Type_Restore_OK:        String = "RSTCOK" number = 1041;
		Advice_Type_Restore_Progress:  String = "RSTPRG" number = 1042;
		Advice_Type_Restore_Startup:   String = "RSTSTART" number = 1043;
		Advice_Type_RstorRef_QueryAns: String = "QUERYANS" number = 1044;
		Advice_Type_RstorRef_QueryErr: String = "QUERYERR" number = 1045;
		Advice_Type_SDS_Connection_Chg:String = "SDSCONN" number = 1046;
		Advice_Type_SDS_RoleChange:    String = "ROLECHG" number = 1047;
		Advice_Type_SDS_Status:        String = "SDSSTAT" number = 1048;
		Advice_Type_Script_Update:     String = "SCRPTUPD" number = 1151;
		Advice_Type_System_Stats:      String = "SS" number = 1049;
		Advice_Type_Task_Active:       String = "TSKACT" number = 1152;
		Advice_Type_Task_CompletedOK:  String = "TSKCOK" number = 1153;
		Advice_Type_Task_Disabled:     String = "TSKDISAB" number = 1154;
		Advice_Type_Task_Failed:       String = "TSKFAIL" number = 1155;
		Advice_Type_Task_Info:         String = "TSKINFO" number = 1156;
		Advice_Type_Task_SchedDelete:  String = "TSKSCHDL" number = 1157;
		Advice_Type_Task_Scheduled:    String = "TSKSCH" number = 1158;
		Advice_Type_Task_Starting:     String = "TSKSTART" number = 1159;
		Advice_Type_Task_Threshold:    String = "TSKTIME" number = 1160;
		Advice_Type_Task_Update:       String = "TSKUPDTE" number = 1161;
		Advice_Type_Tran_Stats:        String = "TR" number = 1050;
		Advice_Type_WU_DownloadComplete:String = "WUDWNLDC" number = 1186;
		Advice_Type_WU_DownloadError:  String = "WUDWNLDE" number = 1187;
		Advice_Type_WU_DownloadInterrupted:String = "WUDWNLI" number = 1236;
		Advice_Type_WU_DownloadJobComplete:String = "WUDWNLJC" number = 1188;
		Advice_Type_WU_DownloadJobCount:String = "WUDWNLJN" number = 1189;
		Advice_Type_WU_DownloadJobError:String = "WUDWNLJE" number = 1190;
		Advice_Type_WU_DownloadJobId:  String = "WUDWNLJID" number = 1233;
		Advice_Type_WU_DownloadJobProgress:String = "WUDWNLJP" number = 1191;
		Advice_Type_WU_DownloadJobStarted:String = "WUDWNLJS" number = 1192;
		Advice_Type_WU_DownloadProgress:String = "WUDWNLDP" number = 1193;
		Advice_Type_WU_DownloadStarting:String = "WUDWNLDS" number = 1194;
		Advice_Type_WU_GetLastSearchTimeForUpdates:String = "WULSTFU" number = 1195;
		Advice_Type_WU_GetLastTimeUpdatesInstalled:String = "WULTUPDI" number = 1196;
		Advice_Type_WU_GetRebootPending:String = "WUREBOOTP" number = 1197;
		Advice_Type_WU_GetUpdatesComplete:String = "WUGETUPDC" number = 1198;
		Advice_Type_WU_GetUpdatesError:String = "WUGETUPDE" number = 1229;
		Advice_Type_WU_GetUpdatesProgress:String = "WUGETUPDP" number = 1230;
		Advice_Type_WU_InstallComplete:String = "WUINSTALLC" number = 1199;
		Advice_Type_WU_InstallDownloadComplete:String = "WUINSTDC" number = 1235;
		Advice_Type_WU_InstallError:   String = "WUINSTALLE" number = 1200;
		Advice_Type_WU_InstallInterrupted:String = "WUINSTI" number = 1237;
		Advice_Type_WU_InstallJobComplete:String = "WUINSTJC" number = 1201;
		Advice_Type_WU_InstallJobCount:String = "WUINSTJN" number = 1202;
		Advice_Type_WU_InstallJobError:String = "WUINSTJE" number = 1203;
		Advice_Type_WU_InstallJobId:   String = "WUINSTJID" number = 1232;
		Advice_Type_WU_InstallJobProgress:String = "WUINSTJP" number = 1204;
		Advice_Type_WU_InstallJobStarted:String = "WUINSTJS" number = 1205;
		Advice_Type_WU_InstallProgress:String = "WUINSTP" number = 1206;
		Advice_Type_WU_InstallStarting:String = "WUINSTS" number = 1207;
		Advice_Type_WU_InterruptComplete:String = "WUINTRPTC" number = 1208;
		Advice_Type_WU_InterruptError: String = "WUINTRPTE" number = 1209;
		Advice_Type_WU_InterruptStarting:String = "WUINTRPTS" number = 1210;
		Advice_Type_WU_RebootComplete: String = "WUREBOOTC" number = 1228;
		Advice_Type_WU_RebootError:    String = "WUREBOOTE" number = 1211;
		Advice_Type_WU_RebootRetry:    String = "WUREBOOTR" number = 1231;
		Advice_Type_WU_RebootStarting: String = "WUREBOOTS" number = 1212;
		Advice_Type_WU_SetupComplete:  String = "WUSETUPC" number = 1213;
		Advice_Type_WU_SetupError:     String = "WUSETUPE" number = 1214;
		Advice_Type_WU_SetupRequest:   String = "WUSETUPR" number = 1215;
		Advisory_Advice:               String = "ADVISADV" number = 1182;
		Alert_Ctl_Command:             String = "ALERTCTL" number = 1051;
		Alert_Def_Command:             String = "ALERTDEF" number = 1052;
		Application_Monitoring_Advice: String = "APPLMON" number = 1175;
		Backup_Advice:                 String = "BKUPADV" number = 1053;
		Backup_Command:                String = "BKUPCMD" number = 1054;
		Backup_Spec_Command:           String = "BKSPCCMD" number = 1055;
		C_bin_chgs:                    String = "cl_bin_chgs.exe" number = 1056;
		C_bin_ver:                     String = "cl_bin.ver" number = 1057;
		C_misc_chgs:                   String = "cl_misc_chgs.exe" number = 1058;
		C_misc_ver:                    String = "cl_misc.ver" number = 1059;
		C_schema_full:                 String = "cl_schema.exe" number = 1060;
		C_schema_ver:                  String = "cl_schema.ver" number = 1061;
		Command:                       String = "C" number = 1062;
		Command_Type_Backup_Cancel:    String = "BKCANCEL" number = 1063;
		Command_Type_Backup_DbData:    String = "BKDBDATA" number = 1064;
		Command_Type_Backup_Spec_Del:  String = "BKSPECD" number = 1174;
		Command_Type_Backup_Specs:     String = "BKSPECS" number = 1065;
		Command_Type_Backup_Start:     String = "BKSTART" number = 1066;
		Command_Type_Backup_Stop:      String = "BKSTOP" number = 1067;
		Command_Type_Backup_UnCancel:  String = "BKUNCAN" number = 1068;
		Command_Type_Compact_Abort:    String = "CMPABORT" number = 1149;
		Command_Type_Compact_Cancel:   String = "CMPCANCL" number = 1069;
		Command_Type_Compact_Start:    String = "CMPSTART" number = 1070;
		Command_Type_Compact_Stop:     String = "CMPSTOP" number = 1071;
		Command_Type_FileDet_DbData:   String = "DBDAT" number = 1072;
		Command_Type_GetMapFileSizes:  String = "MAPSZ" number = 1073;
		Command_Type_NodeMonitorChange:String = "NDMON" number = 1074;
		documentationText
		`Node Monitor`
		Command_Type_ODBC_Delete:      String = "ODBCDEL" number = 1075;
		Command_Type_ODBC_GetVersion:  String = "ODBCGVER" number = 1150;
		Command_Type_ODBC_HostDelete:  String = "ODBCHDEL" number = 1076;
		Command_Type_ODBC_HostUpdate:  String = "ODBCHUPD" number = 1077;
		Command_Type_ODBC_InstDelete:  String = "ODBCIDEL" number = 1078;
		Command_Type_ODBC_InstUpdate:  String = "ODBCIUPD" number = 1079;
		Command_Type_ODBC_Query:       String = "ODBCQUERY" number = 1080;
		Command_Type_ODBC_Sync:        String = "ODBCSYNC" number = 1081;
		Command_Type_ODBC_Type_Update: String = "ODBCTUPD" number = 1183;
		documentationText
		`Update ODBC database type`
		Command_Type_ODBC_Update:      String = "ODBCUPD" number = 1082;
		Command_Type_Restore_Query:    String = "RSTQUERY" number = 1083;
		Command_Type_Restore_Start:    String = "RSTSTART" number = 1084;
		Command_Type_Restore_Stop:     String = "RSTSTOP" number = 1085;
		Command_Type_Script_Create:    String = "SCRPTCREAT" number = 1162;
		Command_Type_Script_Delete:    String = "SCRPTDEL" number = 1163;
		Command_Type_Script_Rename:    String = "SCRPTREN" number = 1164;
		Command_Type_Script_Update:    String = "SCRPTUPD" number = 1165;
		Command_Type_SessOpen_Request: String = "SOARQ" number = 1086;
		documentationText
		`CnControlCmd : SessionOpenAdvice Request to KCCMgr from JSA`
		Command_Type_TransStatsTimeChg:String = "TSRQ" number = 1087;
		Command_Type_UserPatchRequest: String = "USERP" number = 1088;
		Command_Type_WU_CategoryExclusions:String = "WUCATEXCL" number = 1234;
		Command_Type_WU_DownloadUpdates:String = "WUDWNLDU" number = 1216;
		Command_Type_WU_GetUpdateStatus:String = "WUGTUPDCMD" number = 1217;
		Command_Type_WU_InstallUpdates:String = "WUINSTLU" number = 1218;
		Command_Type_WU_Interrupt:     String = "WUINTERUPT" number = 1219;
		Command_Type_WU_Reboot:        String = "WUREBOOT" number = 1220;
		Command_Type_WU_RebootUnsafe:  String = "WUREBOOTU" number = 1221;
		Command_Type_WU_Setup:         String = "WUSETUP" number = 1222;
		Command_Type_WU_StartCycle:    String = "WUSRTCYCL" number = 1223;
		Command_Type_WU_StartMgr:      String = "WUSTRTMGR" number = 1224;
		Command_Type_WU_StopMgr:       String = "WUSTOPMGR" number = 1225;
		Compact_Advice:                String = "CMPADV" number = 1089;
		Compact_Command:               String = "CMPCMD" number = 1090;
		Control_Advice:                String = "CNTRLADV" number = 1091;
		Control_Command:               String = "CTLCMD" number = 1092;
		Current_Protocol_Version:      Integer = 39 number = 1093;
		documentationText
`Note : the following format is required as text is accessed programatically by method 
CnMessage::getCardSchemaProtocolVersion which is used by JSM and JadeEnvironmentMaint form.

Message Protocol Version History  
---------------------------------

<version>
39 - 4.1.02				MFJ Dec 21 - ExecuteCmd add 'scriptText' property
38 - 4.0.03				JER Apr 20 - Encode backup date in RestoreAdvice (7174), replace backupOffline with backupMode in RestoreRefreshAdvice (7413)
37 - 4.0.02				JER Aug 20 - TaskAdvice new slob for scheduled query response (7436, 7175), KarmaControlCmd to specify environment type (7585), InstallAdvice state names 
36 - 4.0.01				JER Feb 19 - BackupCmd/Advice re commitCoherentBackup, deployment re reorged files and info
35 - 3.9.03				JER Sep 18 - Change to TaskCmd to include suppressStdOut (PAR 6058), CnFileDetailsAdvice re encryption details (7050), ODBCAdvice level/edition (7261), ODBCCmd isManagedHost (7274)
34 - 3.9.02				JER May 18 - Change to TaskAdvice to include schedule id (PAR 6295), JSA SessionOpen to contain server host entity version (PAR 5848), CompactAdvice to contain compactType (PAR 6721)
33 - 3.8.10				JER Jan	18 - Message reorg free space factor in KarmaControlCmd (NFS 6757)
32 - 3.8.07				MFJ Jun 17 - New Critical App Monitoring message, change to KarmaControlAdvice
31 - 3.8.06				JER Feb 17 - Changes to ODBCCmd for RDS backup (PAR 6287), BackupSpecCmd for suppress scripts (PAR 5214)
30 - 3.8.04				MFJ Aug 16 - Changes to GlbParamCmd for GlbWeb, GlbNet + JSON formats
29 - 3.8.03				MFJ Jan 16 - New commands and advice types for Web Site Info, extensions for ODBC monitoring
28 - 3.8.02				MFJ May 15 - KarmaControlCmd updates JSA with JMT environment flag
27 - 3.8.01				JER Mar 15 - TaskCmd messages now send target and schedule unique Ids to resolve PARs 5586, 5587
26 - 3.7.05				MFJ Oct 14 - Correct Unicode messages using Boolean / Character incorrectly; additional Db Disk Cache values in StatsAdvice
25 - 3.7.04				MFJ Feb 14 - Message changes for Task Scheduling feature
24 - 3.7.03				MFJ May 13 - Message changes for ODBC database backup
23 - 3.7.01				MFJ Mar 12 - Message changes for IPV6, new and changed messaging for JOOB details
22 - 3.6.01				MFJ Aug 11 - SAO Domain Name 64 bytes, deploy test.
21 - 3.5.02				MFJ Jan 11 - Extend info in DbData, changes to RestoreRefreshCmd, ODBC data and messaging
20 - 3.5.01				MFJ Jan 10 - Changes to SOA (split out binary/library info into own advice and user patches into own advice), DbData advice
</version>

Unsupported releases (the remainder is documentation only):
19 - 3.4.02				MFJ Jun 09
18 - 3.4.00				MFJ Feb 09
17 - 3.3.00				MFJ Apr 08
16 - 3.2.00				MFJ Aug 06
15 - 3.1.00				RWM Sep 04
14 - 3.0.05				RWM May 04
13 - 3.0.00 			RWM June 03	- Changes to support CardSchema 3.0 and Joss 3.0 (Windows & Linux)
12 - 2.9.00				RWM Aug 02
11 - 2.8.00				RWM Mar 02
10 - 2.7.100			RWM Jan 02
9  - 2.7.00				RWM Sep 00 - backup classes
8  - 2.6.00				RWM Apr 00
7  - 2.5.00				RWM Sep 99
6  - 2.4.00 			RWM Apr 99 - : e.g. KarmaControlCmd, Advice, maybe others
5  - 2.2.19				RWM Feb 99 - Add new attributes to CnSessionOpenAdvice for thin clients
4  - 2.2.00				RWM Aug 98 - Add new class CnControlCmd for CardSchema/Joss, extend SchemaCopyCmd in Joss to add deployReadOnlySchema
3  - Unknown			RWM Mar 98 - Delete serverHostIpAddress and serverHostFQDN from CnMessage header
2  - Unknown			RWM Nov 97 - Change to CnSchemaCopyCompleteAdvice to allow longer copy message
1  - First release		RWM Aug 97
`
		D_bin:                         String = "bin.exe" number = 1094;
		D_bin_ver:                     String = "bin.ver" number = 1095;
		D_misc:                        String = "misc.exe" number = 1096;
		D_misc_ver:                    String = "misc.ver" number = 1097;
		D_schema:                      String = "schema.exe" number = 1098;
		D_schema_ver:                  String = "schema.ver" number = 1099;
		Debug:                         Boolean = false number = 1100;
		Discovery_Advice:              String = "DISCADV" number = 1170;
		Exception_Advice:              String = "EXCEPADV" number = 1101;
		Execute_Advice:                String = "EXECADV" number = 1184;
		Execute_Command:               String = "EXECCMD" number = 1185;
		FTP_Progress_Advice:           String = "FTPPROG" number = 1102;
		File_Details_Advice:           String = "FILDTADV" number = 1103;
		File_Details_Command:          String = "FILDTCMD" number = 1104;
		Glb_Param_Cmd:                 String = "GLBP_CMD" number = 1105;
		Install_Advice:                String = "INSTADV" number = 1106;
		Install_Command:               String = "INSTCMD" number = 1107;
		JSA_File_Transfer_Advice:      String = "FTFRADV" number = 1108;
		JSA_File_Transfer_Command:     String = "FTFRCMD" number = 1109;
		Karma_Control_Advice:          String = "KCADV" number = 1110;
		Karma_Control_Command:         String = "KCCMD" number = 1111;
		Kill_Client:                   String = "KILLC" number = 1112;
		Kill_KCCMgr_Process:           String = "KILLK" number = 1113;
		Monitor_Advice:                String = "MONADV" number = 1114;
		Monitor_Command:               String = "MONCMD" number = 1115;
		N_bin:                         String = "\n_bin\" number = 1116;
		N_misc:                        String = "\n_misc\" number = 1117;
		N_schema:                      String = "\n_schema\" number = 1118;
		Node_Stats_Advice:             String = "NODESTAT" number = 1119;
		ODBC_Advice:                   String = "ODBCADV" number = 1120;
		ODBC_Command:                  String = "ODBCCMD" number = 1121;
		Ping_Command:                  String = "PING" number = 1122;
		Ping_Reply:                    String = "PINGRPLY" number = 1123;
		Process_Advice:                String = "PROCSADV" number = 1124;
		Process_Command:               String = "PROCSCMD" number = 1125;
		Quit_Client:                   String = "QUITC" number = 1126;
		Restore_Advice:                String = "RSTORADV" number = 1127;
		Restore_Command:               String = "RSTORCMD" number = 1128;
		Restore_Refresh_Advice:        String = "RSRFADV" number = 1129;
		Restore_Refresh_Command:       String = "RSRFCMD" number = 1130;
		SDS_Advice:                    String = "SDSADV" number = 1131;
		SDS_Command:                   String = "SDSCMD" number = 1132;
		SSL_Advice:                    String = "SSLADV" number = 1133;
		Schema_Copy_Command:           String = "SCHCOPY" number = 1134;
		Schema_Copy_Complete:          String = "SCHCOPYC" number = 1135;
		Script_Advice:                 String = "SCRPTADV" number = 1166;
		Server_Down:                   String = "SERVDOWN" number = 1136;
		Session_Close:                 String = "SESSCLOS" number = 1137;
		Session_Open:                  String = "SESSOPEN" number = 1138;
		Statistics_Advice:             String = "STATADV" number = 1139;
		System_Shut_Down_Msg:          String = "SDWN" number = 1140;
		TC_bin_full:                   String = "tc_bin_full.exe" number = 1141;
		TC_misc_full:                  String = "tc_misc_full.exe" number = 1142;
		Task_Advice:                   String = "TASKADV" number = 1167;
		Thread_Advice:                 String = "THREDADV" number = 1143;
		Thread_Command:                String = "THREDCMD" number = 1144;
		Transparent_Msg_No:            Integer = Max_Integer number = 1145;
		documentationText
		`For msgParam2.`
		Trap_Advice:                   String = "TRAP-ADV" number = 1146;
		Watch_Advice:                  String = "WATCHADV" number = 1147;
		Watch_Command:                 String = "WATCHCMD" number = 1148;
		Windows_Update_Advice:         String = "WUAADV" number = 1226;
		documentationText
		`Added in 4.1.02, Windows Automatic Update feature`
		Windows_Update_Command:        String = "WUACMD" number = 1227;
		documentationText
		`Added in 4.1.02, Windows Automatic Update feature`
	attributeDefinitions
		appName:                       String[101] readonly, number = 1, ordinal = 1;
		appSchemaName:                 String[101] readonly, number = 30, ordinal = 31;
		architectureRemote:            Integer readonly, number = 29, ordinal = 29;
		clientAlias:                   String[65] readonly, number = 26, ordinal = 2;
		clientFQDN:                    String[65] readonly, number = 2, ordinal = 3;
		clientIpAddress:               String[16] readonly, number = 3, ordinal = 4;
		computerName:                  String[21] readonly, number = 28, ordinal = 5;
		documentationText
`
Node computer name i.e. app server or fat client's name as defined in Control Panel`
		creatorMethod:                 String[101] readonly, number = 4, ordinal = 6;
		documentationText
`This is used to identify the method that created this message.
It is NOT contained in the message binary.`
		destProcessType:               String[4] readonly, number = 5, ordinal = 7;
		driveLetter:                   String[2] readonly, number = 6, ordinal = 8;
		environmentId:                 String[31] readonly, number = 7, ordinal = 9;
		errorCode:                     Integer readonly, number = 8, ordinal = 10;
		hostAlias:                     String[65] protected, number = 27, ordinal = 11;
		documentationText
`
In JossCommsMgr this contains the value that was submitted by the managed host in
serverHostFQDN (if not null), else the real FQDN as known to Joss's DNS`
		managedEnvironmentName:        String[256] readonly, number = 31, ordinal = 32;
		msgClass:                      String[9] readonly, number = 9, ordinal = 12;
		msgNo:                         Integer readonly, number = 10, ordinal = 13;
		documentationText
`
If we ever use this, we will need to avoid using numbers 1 - 31 because it will
interfere with printed logs.  Not currently used.

As of 2.7, this is used to indicate message transparency by assigning a value of 
Max_Integer.`
		msgParam1:                     String[3] readonly, number = 11, ordinal = 14;
		msgParam2:                     String[3] readonly, number = 12, ordinal = 15;
		documentationText
`
Now reserved for command message transparency indicator (JSM only).  This
indicates that the message was built by other than JossCommsMgr, therefore
contains ipAddress and fqdn fields.  Internal use only.`
		msgParam3:                     String[3] readonly, number = 13, ordinal = 16;
		msgType:                       String[2] readonly, number = 14, ordinal = 17;
		notFinalBlock:                 Boolean readonly, number = 15, ordinal = 21;
		pos:                           Integer readonly, number = 16, ordinal = 22;
		processId:                     Integer readonly, number = 17, ordinal = 23;
		protocolVersion:               Integer readonly, number = 18, ordinal = 24;
		serverHostFQDN:                String[65] readonly, number = 19, ordinal = 25;
		serverHostIpAddress:           String[16] readonly, number = 20, ordinal = 26;
		sourceProcessType:             String[4] readonly, number = 22, ordinal = 28;
	referenceDefinitions
		myCnApp:                       CnApp  readonly, number = 23, ordinal = 18;
		documentationText
`This property is only used by Karma Client Comms Mgr, and only needed when
a new client is linking up for the first time.  Allows SessionOpenAdvice::processMsg
to find the instance of CnApp that applies to the message.`
		myKarmaCommsMgrProcess:        Process  readonly, number = 24, ordinal = 19;
		myTcp:                         CnTcpConnection  readonly, number = 25, ordinal = 20;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		attachField(
			bin: Binary io; 
			field: Binary) number = 1002;
		buildHeader(
			msgtype: String; 
			msgclass: String; 
			serverhostfqdn: String; 
			clientfqdn: String; 
			clientipaddress: String; 
			sourceprocesstype: String; 
			destprocesstype: String; 
			msg: CnMessage output): String updating, number = 1003;
		buildMsg(): String updating, number = 1004;
		byteOrderDate(bin: Binary): Date number = 1037;
		byteOrderDecimal(bin: Binary): Decimal number = 1036;
		byteOrderInteger(bin: Binary): Integer number = 1027;
		byteOrderInteger64(bin: Binary): Integer64 number = 1043;
		byteOrderReal(bin: Binary): Real number = 1039;
		byteOrderTime(bin: Binary): Time number = 1035;
		byteOrderTimeStamp(bin: Binary): TimeStamp number = 1038;
		createNewMsg(
			msgtype: String; 
			msgclass: String; 
			clientfqdn: String; 
			clientipaddress: String; 
			sourceprocesstype: String; 
			destprocesstype: String; 
			msg: CnMessage output): String updating, number = 1005;
		forwardMsg() updating, number = 1006;
		getCardSchemaProtocolVersion(pVersion: String): Integer number = 1047;
		getClassName(
			pMsgType: String; 
			pMsgClass: String): String number = 1007;
		getField(
			bin: Binary; 
			len: Integer): Binary updating, number = 1008;
		handleProcessException(exObj: SystemException): Integer number = 1009;
		isKCCMgrToProcessMsg(pClassMsg: Class): Boolean number = 1031;
		loadMsg(buf: Binary) updating, number = 1010;
		processMsg(proc: Process): String updating, number = 1011;
		receiveMsg(
			buf: Binary; 
			proc: Process; 
			eventType: Integer) updating, number = 1012;
		sendMessage(pTcp: CnKarmaTcpConnection input) updating, number = 1013;
		setAppName(appname: String) updating, number = 1014;
		setAppSchemaName(pValue: String) updating, number = 1045;
		setArchitectureRemote(arch: Integer) updating, number = 1041;
		setClientAlias(alias: String) updating, number = 1033;
		setClientFQDN(fqdn: String) updating, number = 1015;
		setClientIpAddress(ipaddress: String) updating, number = 1016;
		setComputerName(name: String) updating, number = 1034;
		setCreatorMethod(name: String) updating, number = 1017;
		setDestProcessType(type: String) updating, number = 1028;
		setDriveLetter(drive: String) updating, number = 1018;
		setEnvironmentId(pValue: String) updating, number = 1019;
		setErrorCode(pCode: Integer) updating, number = 1026;
		setManagedEnvironmentName(name: String) updating, number = 1029;
		setMsgParam1(param: String) updating, number = 1020;
		setMsgParam2(val: String) updating, number = 1030;
		setMyTcp(tcp: CnTcpConnection) updating, number = 1021;
		setPos(pValue: Integer) updating, number = 1044;
		setProcessId(procid: Integer) updating, number = 1022;
		setProtocolVersion(version: Integer) updating, number = 1023;
		setServerHostFQDN(fqdn: String) updating, number = 1024;
		setServerHostIpAddress(ipaddr: String) updating, number = 1025;
	)
	CnAdvice completeDefinition
	(
	jadeMethodDefinitions
		processMsg(proc: Process): String updating, number = 1001;
	)
	CnBackupAdvice completeDefinition
	(
	attributeDefinitions
		adviceType:                    String[9] readonly, number = 7, ordinal = 1;
		backupWorkerId:                Integer readonly, number = 12, ordinal = 2;
		documentationText
		`
Instance id of backup worker process.`
		completedBackupIsCommitCoherent:Boolean readonly, number = 1, ordinal = 17;
		currentFileName:               String[261] readonly, number = 4, ordinal = 3;
		droppedFileNames:              CnStringArray readonly, subId = 2, number = 5, ordinal = 4;
		endLogNo:                      Integer readonly, number = 11, ordinal = 5;
		errorText:                     String[251] readonly, number = 6, ordinal = 6;
		fileSize:                      Decimal[19] readonly, number = 9, ordinal = 7;
		percentProgress:               Integer readonly, number = 2, ordinal = 10;
		phase:                         Character readonly, number = 13, ordinal = 11;
		documentationText
`
Backup phases : S 	= Starting file backup
				" "	= Progress report or other advice
				C	= File backup complete
				T	= Worker terminated`
		startLogNo:                    Integer readonly, number = 14, ordinal = 12;
		structureNames:                CnStringArray readonly, subId = 4, number = 10, ordinal = 14;
		structureSizes:                Integer64Array readonly, subId = 5, number = 15, ordinal = 15;
		timestamp:                     TimeStamp readonly, number = 8, ordinal = 13;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1006;
		loadMsg(buf: Binary) updating, number = 1007;
		setAdviceType(type: String) updating, number = 1001;
		setBackupWorkerId(id: Integer) updating, number = 1011;
		setCompletedBackupIsCommitCoherent(pIsCommitCoherentBackup: Boolean) updating, number = 1009;
		setCurrentFileName(name: String) updating, number = 1002;
		setEndLogNo(num: Integer) updating, number = 1010;
		setErrorText(text: String) updating, number = 1003;
		setFileSize(size: Decimal) updating, number = 1008;
		setPercentProgress(pc: Integer) updating, number = 1004;
		setPhase(char: Character) updating, number = 1012;
		setStartLogNo(logNo: Integer) updating, number = 1013;
		setTimestamp(ts: TimeStamp) updating, number = 1005;
	)
	CnCompactAdvice completeDefinition
	(
	attributeDefinitions
		adviceType:                    String[9] readonly, number = 1, ordinal = 1;
		compactWorkerId:               Integer readonly, number = 2, ordinal = 2;
		currentFileName:               String[281] readonly, number = 3, ordinal = 3;
		errorText:                     String[251] readonly, number = 4, ordinal = 4;
		fileSize:                      Integer64 readonly, number = 10, ordinal = 16;
		mapFileNames:                  CnStringArray readonly, subId = 1, number = 7, ordinal = 10;
		mapFileSizes:                  Integer64Array readonly, subId = 2, number = 8, ordinal = 11;
		mapFileSizesAfter:             Integer64Array readonly, subId = 3, number = 11, ordinal = 17;
		percentProgress:               Integer readonly, number = 5, ordinal = 5;
		phase:                         Character readonly, number = 9, ordinal = 15;
		timeStamp:                     TimeStamp readonly, number = 6, ordinal = 6;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		loadMsg(buf: Binary) updating, number = 1002;
		setAdviceType(type: String) updating, number = 1003;
		setCompactWorkerId(id: Integer) updating, number = 1009;
		setCurrentFileName(pFileName: String) updating, number = 1005;
		setErrorText(text: String) updating, number = 1006;
		setFileSize(pFileSize: Integer64) updating, number = 1010;
		setPercentProgress(pc: Integer) updating, number = 1007;
		setPhase(char: Character) updating, number = 1011;
		setTimeStamp(pTimeStamp: TimeStamp) updating, number = 1012;
	)
	CnControlAdvice completeDefinition
	(
	attributeDefinitions
		adviceText:                    String[401] readonly, number = 1, ordinal = 1;
		adviceType:                    String[9] readonly, number = 3, ordinal = 2;
		commandType:                   String[6] readonly, number = 2, ordinal = 3;
		databaseRole:                  Integer readonly, number = 4, ordinal = 4;
		documentationText
		`
Obsolete in 3.1 : see CnSDSADvice class.`
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		loadMsg(buf: Binary) updating, number = 1004;
		setAdviceText(text: String) updating, number = 1002;
		setAdviceType(advType: String) updating, number = 1005;
		setCommandType(command: String) updating, number = 1003;
		setDatabaseRole(role: Integer) updating, number = 1006;
	)
	CnExceptionAdvice completeDefinition
	(
	attributeDefinitions
		codePositionA:                 Integer number = 6, ordinal = 6;
		codePositionB:                 Integer number = 7, ordinal = 7;
		errorMethodA:                  String[305] number = 4, ordinal = 4;
		errorMethodB:                  String[305] number = 5, ordinal = 5;
		exceptionCode:                 Integer number = 1, ordinal = 1;
		exceptionComment:              String subId = 1, number = 2, ordinal = 2;
		documentationText
		`
Example usage is file name for FileExceptions.`
		extendedErrorText:             String subId = 2, number = 3, ordinal = 3;
		receiver:                      String[141] number = 8, ordinal = 8;
		recursive:                     Boolean number = 11, ordinal = 11;
		stackDumpFileName:             String[101] number = 10, ordinal = 10;
		documentationText
		`
Simple file name for stack dump file.`
		thinClientComputerIpAddress:   String[66] readonly, number = 13, ordinal = 15;
		thinClientComputerName:        String[66] readonly, number = 12, ordinal = 14;
		documentationText
		`Thin client computer name, or for fat client nodes, fat client computer name.`
		timestamp:                     TimeStamp number = 9, ordinal = 12;
		documentationText
`
This timestamp is captured in local time format.  Note that this is consistent with other
performance reports.`
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		loadMsg(buf: Binary) updating, number = 1002;
		setThinClientComputerIpAddress(address: String) updating, number = 1004;
		setThinClientComputerName(name: String) updating, number = 1003;
	)
	CnExecuteAdvice completeDefinition
	(
	attributeDefinitions
		errorMessage:                  String readonly, subId = 2, number = 5, ordinal = 5;
		executeFunction:               String[101] readonly, number = 4, ordinal = 4;
		exitCode:                      Integer readonly, number = 3, ordinal = 3;
		itemIndex:                     Integer readonly, number = 1, ordinal = 1;
		itemName:                      String readonly, subId = 1, number = 2, ordinal = 2;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1005;
		loadMsg(buf: Binary) updating, number = 1006;
		setErrorMessage(pValue: String) updating, number = 1007;
		setExecuteFunction(pValue: String) updating, number = 1001;
		setExitCode(pValue: Integer) updating, number = 1004;
		setItemIndex(pValue: Integer) updating, number = 1002;
		setItemName(pValue: String) updating, number = 1003;
	)
	CnFileDetailsAdvice completeDefinition
	(
		documentationText
`All of these messages use attribute adviceType.

Binary and Library Details (constant Advice_Type_FileDet_BinVer, value FDBINVER)
- fileNameArray
- fileVersionArray
- fileModifiedArray
- fileTypeArray

Database Data (constant Advice_Type_FileDet_DbData, value FDDBDATA):
- directoryNameArray
- fileLengthArray
- fileNameArray
- fileStatusArray
- fileTypeArray
- partitionIdArray
- udrLengthArray

Thinclient details (constant Advice_Type_FileDet_ThinClient, value FDTHINCL)
- directoryNameArray
- fileNameArray
- fileVersionArray
- fileModifiedArray
- fileMD5HashArray
- fileLengthArray

User Patches (constant Advice_Type_FileDet_UserPatchs, value FDUSERPT):
- fileNameArray
- fileTypeArray
- fileModifiedArray
 `
	attributeDefinitions
		adviceType:                    String[9] readonly, number = 2, ordinal = 2;
		directoryNameArray:            HugeStringArray readonly, subId = 6, number = 7, ordinal = 7;
		fileEncryptionArray:           IntegerArray readonly, subId = 14, number = 15, ordinal = 15;
		fileFrozenArray:               BooleanArray readonly, subId = 11, number = 12, ordinal = 12;
		fileLengthArray:               Integer64Array readonly, subId = 4, number = 5, ordinal = 5;
		fileMD5HashArray:              CnSmallStringArray readonly, subId = 5, number = 6, ordinal = 6;
		fileModifiedArray:             TimeStampArray readonly, subId = 3, number = 4, ordinal = 4;
		fileNameArray:                 HugeStringArray readonly, subId = 1, number = 1, ordinal = 1;
		fileOfflineArray:              BooleanArray readonly, subId = 12, number = 13, ordinal = 13;
		fileStatusArray:               IntegerArray readonly, subId = 8, number = 9, ordinal = 9;
		fileTypeArray:                 CharacterArray readonly, subId = 7, number = 8, ordinal = 8;
		fileVersionArray:              StringArray readonly, subId = 2, number = 3, ordinal = 3;
		partitionIdArray:              Integer64Array readonly, subId = 9, number = 10, ordinal = 10;
		udrLengthArray:                Integer64Array readonly, subId = 10, number = 11, ordinal = 11;
		udrStructuresArray:            Integer64Array readonly, subId = 13, number = 14, ordinal = 14;
	jadeMethodDefinitions
		addItemDbData(
			pDir: String; 
			pName: String; 
			pStatus: Integer; 
			pEncryptionStatus: Integer; 
			pType: Character; 
			pPartitionId: Integer64; 
			pLength: Integer64; 
			pUDRLength: Integer64; 
			pUDRStructures: Integer64; 
			pFrozen: Boolean; 
			pOffline: Boolean) updating, number = 1006;
		addItemUserPatches(
			pName: String; 
			pType: Character; 
			pModified: TimeStamp) updating, number = 1005;
		assembleMsg(): Binary updating, number = 1001;
		loadMsg(buf: Binary) updating, number = 1002;
		setAdviceType(pValue: String) updating, number = 1003;
		zAssembleBinVer(pBin: Binary): Binary updating, number = 1004;
		zAssembleDbData(pBin: Binary): Binary updating, number = 1007;
		zAssembleThinClient(pBin: Binary): Binary updating, number = 1012;
		zAssembleUserPatches(pBin: Binary): Binary updating, number = 1008;
		zLoadBinVer(buf: Binary) updating, number = 1009;
		zLoadDbData(buf: Binary) updating, number = 1010;
		zLoadThinClient(buf: Binary) updating, number = 1013;
		zLoadUserPatches(buf: Binary) updating, number = 1011;
	)
	CnNodeStatsAdvice completeDefinition
	(
	attributeDefinitions
		data:                          Binary[256] readonly, number = 4, ordinal = 4;
		dataLength:                    Integer readonly, number = 3, ordinal = 3;
		nodeId:                        String[101] readonly, number = 2, ordinal = 2;
		statsVersion:                  Integer readonly, number = 5, ordinal = 5;
		timestamp:                     TimeStamp readonly, number = 1, ordinal = 1;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1005;
		loadMsg(buf: Binary) updating, number = 1006;
		setData(pData: Binary) updating, number = 1001;
		setDataLength(len: Integer) updating, number = 1003;
		setNodeId(pName: String) updating, number = 1002;
		setStatsVersion(version: Integer) updating, number = 1007;
		setTimestamp(ts: TimeStamp) updating, number = 1004;
	)
	CnPingReplyAdvice completeDefinition
	(
	attributeDefinitions
		connectedSecondaryServers:     Integer number = 21, ordinal = 21;
		connectionCheckInterval:       Integer number = 8, ordinal = 8;
		connectionState:               Integer number = 9, ordinal = 9;
		databaseRole:                  Integer number = 2, ordinal = 2;
		databaseSubrole:               Integer number = 3, ordinal = 24;
		isMultiUser:                   Boolean readonly, number = 27, ordinal = 31;
		lastReplayJournalNumber:       Integer number = 10, ordinal = 10;
		lastReplayJournalTimeStamp:    TimeStamp number = 11, ordinal = 11;
		latestReadyJournalNumber:      Integer number = 13, ordinal = 13;
		latestReadyJournalTimeStamp:   TimeStamp number = 12, ordinal = 12;
		latestReplayedAuditTimeStamp:  TimeStamp number = 5, ordinal = 22;
		latestStableAuditTimeStamp:    TimeStamp number = 22, ordinal = 23;
		documentationText
`Accessed on the secondary, this value represents the latest stable timestamp journalled by the primary.
Only valid when syncMode=BlockWrite.`
		myName:                        String[65] number = 7, ordinal = 7;
		primaryHostName:               String[65] number = 14, ordinal = 14;
		primaryServerName:             String[256] number = 15, ordinal = 15;
		reconnectInterval:             Integer number = 16, ordinal = 16;
		reorgStatus:                   Integer number = 17, ordinal = 17;
		rpsTransitionHaltCode:         Integer number = 26, ordinal = 29;
		rpsWorkers:                    Integer number = 24, ordinal = 27;
		sdsLastErrorCode:              Integer number = 23, ordinal = 26;
		sdsTracking:                   Boolean number = 19, ordinal = 25;
		sdsTrackingDisabled:           Boolean number = 25, ordinal = 28;
		sdsTrackingStoppedReason:      Integer number = 4, ordinal = 30;
		state:                         Integer number = 18, ordinal = 18;
		syncMode:                      Integer number = 20, ordinal = 20;
		timestamp:                     TimeStamp number = 1, ordinal = 1;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		loadMsg(buf: Binary) updating, number = 1002;
		setIsMultiUser(set: Boolean) updating, number = 1004;
		setTimestamp(ts: TimeStamp) updating, number = 1003;
	)
	CnSDSAdvice completeDefinition
	(
	attributeDefinitions
		adviceType:                    String[9] readonly, number = 1, ordinal = 1;
		commandType:                   String[9] readonly, number = 6, ordinal = 6;
		documentationText
		`
Used if responding to command.`
		connectionState:               Integer readonly, number = 3, ordinal = 3;
		databaseRole:                  Integer readonly, number = 4, ordinal = 4;
		databaseSubrole:               Integer readonly, number = 17, ordinal = 19;
		documentationText
`PAR 5299. When database role change occurs, ensure
database sub-role is also maintained.`
		hostileTakeover:               Boolean readonly, number = 12, ordinal = 18;
		lastReplayJournalNumber:       Integer readonly, number = 7, ordinal = 7;
		masterEnvironmentId:           String[10] readonly, number = 9, ordinal = 9;
		maxReplayedTranId:             Decimal[23] readonly, number = 8, ordinal = 8;
		raiseAlert:                    Boolean readonly, number = 10, ordinal = 10;
		rpsTransitionHaltCode:         Integer readonly, number = 2, ordinal = 17;
		documentationText
`Initially, only used for reason codes associated with the RPS_SchemaTransition event.`
		sdsLastErrorCode:              Integer readonly, number = 14, ordinal = 14;
		sdsTracking:                   Boolean readonly, number = 13, ordinal = 13;
		sdsTrackingDisabled:           Boolean readonly, number = 15, ordinal = 15;
		sdsTrackingStoppedReason:      Integer readonly, number = 16, ordinal = 16;
		text:                          String[251] readonly, number = 5, ordinal = 5;
		timestamp:                     TimeStamp readonly, number = 11, ordinal = 11;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1009;
		setAdviceType(pType: String) updating, number = 1001;
		setCommandType(pCommand: String) updating, number = 1002;
		setConnectionState(state: Integer) updating, number = 1003;
		setDatabaseRole(pRole: Integer) updating, number = 1005;
		setDatabaseSubrole(pValue: Integer) updating, number = 1017;
		setHostileTakeover(pValue: Boolean) updating, number = 1016;
		setLastReplayJournalNumber(pJournal: Integer) updating, number = 1006;
		setMasterEnvironmentId(id: String) updating, number = 1010;
		setMaxReplayedTranId(pTranId: Decimal) updating, number = 1007;
		setRaiseAlert(set: Boolean) updating, number = 1011;
		setRpsTransitionHaltCode(code: Integer) updating, number = 1004;
		setSdsLastErrorCode(code: Integer) updating, number = 1013;
		setSdsTracking(set: Boolean) updating, number = 1012;
		setSdsTrackingDisabled(set: Boolean) updating, number = 1014;
		setSdsTrackingStoppedReason(reason: Integer) updating, number = 1015;
		setText(str: String) updating, number = 1008;
	)
	CnSSLAdvice completeDefinition
	(
	attributeDefinitions
		nodeId:                        String[221] readonly, number = 10, ordinal = 10;
		rpcEncryptionEnabled:          Boolean readonly, number = 1, ordinal = 1;
		sslCertificateAuthFile:        String readonly, subId = 1, number = 2, ordinal = 2;
		sslCertificateAuthFileExpiry:  Date readonly, number = 3, ordinal = 3;
		sslCertificateAuthFileResident:Boolean readonly, number = 11, ordinal = 11;
		sslCertificateAuthFileSubject: String readonly, subId = 2, number = 4, ordinal = 4;
		sslCertificateFile:            String readonly, subId = 3, number = 5, ordinal = 5;
		sslCertificateFileExpiry:      Date readonly, number = 6, ordinal = 6;
		sslCertificateFileResident:    Boolean readonly, number = 12, ordinal = 12;
		sslCertificateFileSubject:     String readonly, subId = 4, number = 7, ordinal = 7;
		sslCipherNames:                StringArray readonly, subId = 1, number = 8, ordinal = 8;
		sslMethodName:                 String[11] readonly, number = 9, ordinal = 9;
		sslSecurePort:                 String[61] readonly, number = 13, ordinal = 13;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		loadMsg(buf: Binary) updating, number = 1008;
		setNodeId(pValue: String) updating, number = 1002;
		setRPCEncryptionEnabled(pValue: Boolean) updating, number = 1003;
		setSSLCertificateAuthDetail(
			pFileName: String; 
			pFileResident: Boolean; 
			pSubject: String; 
			pExpiryDate: Date) updating, number = 1004;
		setSSLCertificateFileDetail(
			pFileName: String; 
			pFileResident: Boolean; 
			pSubject: String; 
			pExpiryDate: Date) updating, number = 1005;
		setSSLMethodName(pValue: String) updating, number = 1006;
		setSSLSecurePort(pValue: String) updating, number = 1007;
	)
	CnSessionAdvice completeDefinition
	(
	attributeDefinitions
		currentClientBinVersion:       TimeStamp readonly, number = 1, ordinal = 1;
		currentClientMiscVersion:      TimeStamp readonly, number = 2, ordinal = 2;
		currentClientSchemaVersion:    TimeStamp readonly, number = 3, ordinal = 3;
		currentServerBinVersion:       TimeStamp readonly, number = 4, ordinal = 4;
		currentServerMiscVersion:      TimeStamp readonly, number = 5, ordinal = 5;
		currentServerSchemaVersion:    TimeStamp readonly, number = 6, ordinal = 6;
		currentThinClientBinVersion:   TimeStamp readonly, number = 7, ordinal = 7;
		currentThinClientMiscVersion:  TimeStamp readonly, number = 8, ordinal = 8;
		nextClientBinVersion:          TimeStamp readonly, number = 9, ordinal = 9;
		nextClientMiscVersion:         TimeStamp readonly, number = 10, ordinal = 10;
		nextClientSchemaVersion:       TimeStamp readonly, number = 11, ordinal = 11;
		nextServerBinVersion:          TimeStamp readonly, number = 12, ordinal = 12;
		nextServerMiscVersion:         TimeStamp readonly, number = 13, ordinal = 13;
		nextServerSchemaVersion:       TimeStamp readonly, number = 14, ordinal = 14;
		nextThinClientBinVersion:      TimeStamp readonly, number = 15, ordinal = 15;
		nextThinClientMiscVersion:     TimeStamp readonly, number = 16, ordinal = 16;
		priorClientBinVersion:         TimeStamp readonly, number = 17, ordinal = 17;
		priorClientMiscVersion:        TimeStamp readonly, number = 18, ordinal = 18;
		priorClientSchemaVersion:      TimeStamp readonly, number = 19, ordinal = 19;
		priorServerBinVersion:         TimeStamp readonly, number = 20, ordinal = 20;
		priorServerMiscVersion:        TimeStamp readonly, number = 21, ordinal = 21;
		priorServerSchemaVersion:      TimeStamp readonly, number = 22, ordinal = 22;
		schemaChangePending:           Boolean readonly, number = 23, ordinal = 23;
		timestamp:                     TimeStamp readonly, number = 24, ordinal = 24;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		buildMsg(): String updating, number = 1002;
		loadMsg(buf: Binary) updating, number = 1003;
		setCurrentClientVersions(
			schema: TimeStamp; 
			bin: TimeStamp; 
			misc: TimeStamp) updating, number = 1004;
		setCurrentServerVersions(
			schema: TimeStamp; 
			bin: TimeStamp; 
			misc: TimeStamp) updating, number = 1005;
		setCurrentThinClientVersions(
			bin: TimeStamp; 
			misc: TimeStamp) updating, number = 1006;
		setNextClientVersions(
			schema: TimeStamp; 
			bin: TimeStamp; 
			misc: TimeStamp) updating, number = 1007;
		setNextServerVersions(
			schema: TimeStamp; 
			bin: TimeStamp; 
			misc: TimeStamp) updating, number = 1008;
		setNextThinClientVersions(
			bin: TimeStamp; 
			misc: TimeStamp) updating, number = 1009;
		setPriorClientVersions(
			schema: TimeStamp; 
			bin: TimeStamp; 
			misc: TimeStamp) updating, number = 1010;
		setPriorServerVersions(
			schema: TimeStamp; 
			bin: TimeStamp; 
			misc: TimeStamp) updating, number = 1011;
		setSchemaChangePending(set: Boolean) updating, number = 1012;
		setTimestamp(ts: TimeStamp) updating, number = 1013;
	)
	CnSchemaCopyCompleteAdvice completeDefinition
	(
	attributeDefinitions
		copyFailed:                    Boolean readonly, number = 1, ordinal = 1;
		copyMessage:                   String[301] readonly, number = 2, ordinal = 2;
		isServer:                      Boolean readonly, number = 3, ordinal = 3;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		loadMsg(buf: Binary) updating, number = 1002;
		setCopyFailed(set: Boolean) updating, number = 1003;
		setCopyMessage(text: String) updating, number = 1004;
		setIsServer(set: Boolean) updating, number = 1005;
	)
	CnSessionCloseAdvice completeDefinition
	(
	)
	CnSessionOpenAdvice completeDefinition
	(
	attributeDefinitions
		applicationVersion:            String[31] readonly, number = 31, ordinal = 1;
		binDriveLetter:                Character readonly, number = 27, ordinal = 2;
		binaryModifyTimes:             TimeStampArray readonly, subId = 5, number = 30, ordinal = 3;
		binaryNames:                   StringArray readonly, subId = 3, number = 28, ordinal = 4;
		binaryVersions:                StringArray readonly, subId = 4, number = 29, ordinal = 5;
		cardSchemaVersion:             String[11] readonly, number = 1, ordinal = 6;
		clientMethodCache:             Integer64 readonly, number = 2, ordinal = 7;
		clientPersistentCache:         Integer64 readonly, number = 3, ordinal = 8;
		clientTranStats:               Boolean readonly, number = 4, ordinal = 9;
		clientTransientCache:          Integer64 readonly, number = 5, ordinal = 10;
		clusterGroup:                  String[65] readonly, number = 59, ordinal = 67;
		clusterName:                   String[31] readonly, number = 23, ordinal = 11;
		databaseRole:                  Integer readonly, number = 37, ordinal = 12;
		databaseSubrole:               Integer readonly, number = 51, ordinal = 57;
		deploymentSystem:              Boolean readonly, number = 33, ordinal = 13;
		distributionNode:              String[41] readonly, number = 60, ordinal = 68;
		distributionProcess:           String[41] readonly, number = 61, ordinal = 69;
		encryptionEnabled:             Boolean readonly, number = 20, ordinal = 71;
		encryptionMasterKeyVerified:   Boolean readonly, number = 62, ordinal = 72;
		hostsInCluster:                StringArray readonly, subId = 2, number = 24, ordinal = 14;
		isMultiUser:                   Boolean readonly, number = 34, ordinal = 15;
		isServerApp:                   Boolean readonly, number = 6, ordinal = 16;
		isSingleUserApplicationServer: Boolean readonly, number = 63, ordinal = 73;
		jadeVersion:                   String[11] readonly, number = 7, ordinal = 17;
		libraryModifyTimes:            TimeStampArray readonly, subId = 8, number = 56, ordinal = 64;
		libraryNames:                  StringArray readonly, subId = 7, number = 55, ordinal = 63;
		libraryVersions:               StringArray readonly, subId = 6, number = 54, ordinal = 62;
		licenceCompany:                String[51] readonly, number = 8, ordinal = 18;
		licenceDevelopers:             Integer readonly, number = 9, ordinal = 19;
		licenceExpiryDate:             Date readonly, number = 21, ordinal = 20;
		licenceMaxDbSize:              Integer readonly, number = 38, ordinal = 21;
		licenceNodes:                  Integer readonly, number = 35, ordinal = 22;
		licenceProcesses:              Integer readonly, number = 36, ordinal = 23;
		licenceRestriction:            Character readonly, number = 39, ordinal = 24;
		licenceSecondaries:            Integer readonly, number = 40, ordinal = 25;
		licenceSerial:                 String[41] readonly, number = 10, ordinal = 26;
		licenceUUID:                   String[51] readonly, number = 41, ordinal = 27;
		logPath:                       String[129] readonly, number = 26, ordinal = 28;
		masterEnvironmentId:           String[31] readonly, number = 50, ordinal = 56;
		nameFromCommandLine:           String[31] readonly, number = 57, ordinal = 65;
		nodeId:                        String[221] readonly, number = 11, ordinal = 46;
		nodeType:                      Character readonly, number = 42, ordinal = 45;
		osPID:                         Integer readonly, number = 12, ordinal = 30;
		platformType:                  Integer readonly, number = 43, ordinal = 49;
		documentationText
		`
0 = ANSI
1 = Unicode`
		preferredHostName:             String[31] readonly, number = 25, ordinal = 31;
		processSignOnTime:             TimeStamp readonly, number = 48, ordinal = 54;
		productionMode:                Boolean readonly, number = 32, ordinal = 32;
		rpsStorageMode:                Integer readonly, number = 58, ordinal = 66;
		sdsConnectionState:            Integer readonly, number = 52, ordinal = 58;
		sdsEnvironmentId:              String[31] readonly, number = 49, ordinal = 55;
		sdsLastErrorCode:              Integer readonly, number = 46, ordinal = 60;
		sdsPrimaryHostFQDN:            String[65] readonly, number = 45, ordinal = 51;
		sdsPrimaryServerName:          String[10] readonly, number = 44, ordinal = 50;
		sdsTracking:                   Boolean readonly, number = 47, ordinal = 61;
		sdsTrackingDisabled:           Boolean readonly, number = 53, ordinal = 59;
		serverDatabaseCache:           Integer64 readonly, number = 13, ordinal = 33;
		documentationText
		`Object cache from PersistentDb`
		serverPersistentCache:         Integer64 readonly, number = 14, ordinal = 34;
		serverRemoteTransientCache:    Integer64 readonly, number = 15, ordinal = 35;
		serverTransientCache:          Integer64 readonly, number = 16, ordinal = 36;
		thinClientComputerIpAddress:   String[66] readonly, number = 17, ordinal = 37;
		thinClientComputerName:        String[66] readonly, number = 18, ordinal = 38;
		v6IpAddress:                   String[66] readonly, number = 19, ordinal = 70;
		virtualMachineName:            String[31] readonly, number = 22, ordinal = 40;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		buildMsg(): String updating, number = 1002;
		loadMsg(buf: Binary) updating, number = 1003;
		processMsg(proc: Process): String updating, number = 1004;
		setApplicationVersion() updating, number = 1028;
		setBinDriveLetter(char: Character) updating, number = 1026;
		setCardSchemaVersion(version: String) updating, number = 1005;
		setClientMethodCache(size: Integer) updating, number = 1006;
		setClientPersistentCache(size: Integer64) updating, number = 1007;
		setClientTranStats(set: Boolean) updating, number = 1008;
		setClientTransientCache(size: Integer64) updating, number = 1009;
		setClusterDetails(
			virtualName: String; 
			clusterName: String; 
			clusterGroup: String; 
			preferredHost: String; 
			hosts: StringArray) updating, number = 1024;
		setDatabaseRole(role: Integer) updating, number = 1015;
		setDatabaseSubrole(pRole: Integer) updating, number = 1050;
		setDeploymentSystem(set: Boolean) updating, number = 1031;
		setDistributionNode(pDistributionName: String) updating, number = 1055;
		setDistributionProcess(pDistributionName: String) updating, number = 1056;
		setEncryptionEnabled(pValue: Boolean) updating, number = 1023;
		setEncryptionMasterKeyVerified(pValue: Boolean) updating, number = 1057;
		setIsMultiUser(set: Boolean) updating, number = 1032;
		setIsServerApp(set: Boolean) updating, number = 1010;
		setIsSingleUserApplicationServer(pValue: Boolean) updating, number = 1058;
		setJadeVersion(version: String) updating, number = 1011;
		setLicenceCompany(coy: String) updating, number = 1012;
		setLicenceDevelopers(dev: Integer) updating, number = 1013;
		setLicenceExpiryDate(date: Date) updating, number = 1025;
		setLicenceMaxDbSize(size: Integer) updating, number = 1036;
		setLicenceNodes(servers: Integer) updating, number = 1033;
		setLicenceProcesses(procs: Integer) updating, number = 1034;
		setLicenceRestriction(val: Character) updating, number = 1035;
		setLicenceSecondaries(num: Integer) updating, number = 1037;
		setLicenceSerial(serial: String) updating, number = 1014;
		setLicenceUUID(uuid: String) updating, number = 1039;
		setLogPath(path: String) updating, number = 1027;
		setMasterEnvironmentId(pValue: String) updating, number = 1049;
		setNameFromCommandLine(pName: String) updating, number = 1053;
		setNodeId(id: String) updating, number = 1041;
		setNodeType(pType: Character) updating, number = 1040;
		setOsPID(pid: Integer) updating, number = 1016;
		setPlatformType(pType: Integer) updating, number = 1042;
		setProcessSignOnTime(ts: TimeStamp) updating, number = 1047;
		setProductionMode(set: Boolean) updating, number = 1030;
		setRpsStorageMode(pInt: Integer) updating, number = 1054;
		setSdsConnectionState(state: Integer) updating, number = 1051;
		setSdsEnvironmentId(id: String) updating, number = 1048;
		setSdsLastErrorCode(code: Integer) updating, number = 1045;
		setSdsPrimaryHostFQDN(fqdn: String) updating, number = 1044;
		setSdsPrimaryServerName(name: String) updating, number = 1043;
		setSdsTracking(set: Boolean) updating, number = 1046;
		setSdsTrackingDisabled(set: Boolean) updating, number = 1052;
		setServerDatabaseCache(size: Integer64) updating, number = 1017;
		setServerPersistentCache(size: Integer64) updating, number = 1018;
		setServerRemoteTransientCache(size: Integer64) updating, number = 1019;
		setServerTransientCache(size: Integer64) updating, number = 1020;
		setThinClientComputerIpAddress(ipAddress: String) updating, number = 1021;
		setThinClientComputerName(name: String) updating, number = 1022;
		setV6IpAddress(pV6IpAddress: String) updating, number = 1029;
		setupLicenceDetails() updating, number = 1038;
	)
	CnStatisticsAdvice completeDefinition
	(
	attributeDefinitions
		data:                          Binary readonly, subId = 1, number = 1, ordinal = 1;
		dataLength:                    Integer readonly, number = 2, ordinal = 2;
		statsVersion:                  Integer readonly, number = 4, ordinal = 3;
		timestamp:                     TimeStamp readonly, number = 3, ordinal = 4;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		setData(bin: Binary) updating, number = 1002;
		setDataLength(length: Integer) updating, number = 1003;
		setStatsVersion(ver: Integer) updating, number = 1005;
		setTimestamp(ts: TimeStamp) updating, number = 1004;
	)
	CnThreadAdvice completeDefinition
	(
	attributeDefinitions
		numOfThreads:                  Integer readonly, number = 1, ordinal = 1;
		priority:                      IntegerArray readonly, subId = 1, number = 2, ordinal = 2;
		procId:                        Integer readonly, number = 3, ordinal = 3;
		procName:                      String readonly, subId = 1, number = 4, ordinal = 4;
		sampleTime:                    TimeStamp readonly, number = 5, ordinal = 5;
		sampleTimeGMT:                 TimeStamp readonly, number = 6, ordinal = 6;
		state:                         IntegerArray readonly, subId = 2, number = 7, ordinal = 7;
		threadId:                      IntegerArray readonly, subId = 3, number = 8, ordinal = 8;
		tiKey:                         Integer readonly, number = 9, ordinal = 9;
		waitReason:                    IntegerArray readonly, subId = 4, number = 10, ordinal = 10;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		loadMsg(buf: Binary) updating, number = 1003;
		setNumOfThreads(arg: Integer) updating, number = 1004;
		setPriority(
			indx: Integer; 
			arg: Integer) updating, number = 1005;
		setProcId(arg: Integer) updating, number = 1006;
		setProcName(arg: String) updating, number = 1007;
		setSampleTime(arg: TimeStamp) updating, number = 1008;
		setSampleTimeGMT(ts: TimeStamp) updating, number = 1009;
		setState(
			indx: Integer; 
			arg: Integer) updating, number = 1010;
		setThreadId(
			indx: Integer; 
			arg: Integer) updating, number = 1011;
		setTiKey(arg: Integer) updating, number = 1012;
		setWaitReason(
			indx: Integer; 
			arg: Integer) updating, number = 1013;
	)
	CnTrapAdvice completeDefinition
	(
	attributeDefinitions
		deviceIpAddress:               String[33] readonly, number = 1, ordinal = 1;
		enterprise:                    String[101] readonly, number = 2, ordinal = 2;
		format:                        Integer readonly, number = 3, ordinal = 3;
		genericTrapNum:                Integer readonly, number = 4, ordinal = 4;
		sourceIpAddress:               String[33] readonly, number = 5, ordinal = 5;
		specificTrapNum:               Integer readonly, number = 6, ordinal = 6;
		timestamp:                     TimeStamp readonly, number = 7, ordinal = 7;
		varNames:                      HugeStringArray readonly, subId = 3, number = 10, ordinal = 8;
		varValues:                     HugeStringArray readonly, subId = 4, number = 11, ordinal = 9;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		loadMsg(buf: Binary) updating, number = 1003;
		processMsg(proc: Process): String updating, number = 1004;
		setDeviceIpAddress(ip: String) updating, number = 1005;
		setEnterprise(ent: String) updating, number = 1006;
		setFormat(i: Integer) updating, number = 1007;
		setGenericTrapNum(num: Integer) updating, number = 1008;
		setSourceIpAddress(ip: String) updating, number = 1009;
		setSpecificTrapNum(num: Integer) updating, number = 1010;
		setTimestamp(ts: TimeStamp) updating, number = 1011;
		setVarNameAndValue(
			ix: Integer; 
			vName: String; 
			vValue: String) updating, number = 1012;
	)
	CnWatchAdvice completeDefinition
	(
	attributeDefinitions
		ctrNum:                        IntegerArray readonly, subId = 1, number = 1, ordinal = 1;
		instName:                      StringArray readonly, subId = 2, number = 2, ordinal = 2;
		numOfValues:                   Integer readonly, number = 3, ordinal = 3;
		objNum:                        IntegerArray readonly, subId = 3, number = 4, ordinal = 4;
		sampleTime:                    TimeStamp readonly, number = 5, ordinal = 5;
		sampleTimeGMT:                 TimeStamp readonly, number = 6, ordinal = 6;
		scaled:                        BooleanArray readonly, subId = 4, number = 7, ordinal = 7;
		value:                         IntegerArray readonly, subId = 5, number = 8, ordinal = 8;
		wiKey:                         Integer readonly, number = 9, ordinal = 9;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		loadMsg(buf: Binary) updating, number = 1003;
		setCtrNum(
			indx: Integer; 
			argCtrNum: Integer) updating, number = 1004;
		setInstName(
			indx: Integer; 
			argInstName: String) updating, number = 1005;
		setNumOfValues(argNumOfVals: Integer) updating, number = 1006;
		setObjNum(
			indx: Integer; 
			argObjNum: Integer) updating, number = 1007;
		setSampleTime(argTime: TimeStamp) updating, number = 1008;
		setSampleTimeGMT(ts: TimeStamp) updating, number = 1009;
		setScaled(
			indx: Integer; 
			argScaled: Boolean) updating, number = 1010;
		setValue(
			indx: Integer; 
			argValue: Integer) updating, number = 1011;
		setWiKey(argKey: Integer) updating, number = 1012;
	)
	CnCommand completeDefinition
	(
	)
	CnBackupCmd completeDefinition
	(
	attributeDefinitions
		backupDirectory:               String[256] readonly, number = 4, ordinal = 1;
		backupLocations:               CnStringArray readonly, subId = 3, number = 8, ordinal = 9;
		backupStructureNames:          CnStringArray readonly, subId = 1, number = 2, ordinal = 7;
		backupWorkers:                 Integer readonly, number = 6, ordinal = 2;
		commandType:                   String[9] readonly, number = 1, ordinal = 3;
		commitCoherentBackup:          Boolean readonly, number = 7, ordinal = 10;
		compress:                      Boolean readonly, number = 3, ordinal = 4;
		mustBeCommitCoherentBackup:    Boolean readonly, number = 9, ordinal = 11;
		quiesce:                       Boolean readonly, number = 5, ordinal = 5;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1004;
		exceptionHandler(exObj: Exception): Integer number = 1010;
		loadMsg(buf: Binary) updating, number = 1005;
		processMsg(proc: Process): String updating, number = 1006;
		sendBackupFailureResponse(errText: String) number = 1011;
		setBackupDirectory(dir: String) updating, number = 1007;
		setBackupWorkers(count: Integer) updating, number = 1009;
		setCommandType(type: String) updating, number = 1001;
		setCommitCoherentBackup(pCommitCoherentBackup: Boolean) updating, number = 1003;
		setCompress(set: Boolean) updating, number = 1002;
		setMustBeCommitCoherentBackup(pMustBeCommitCoherentBackup: Boolean) updating, number = 1012;
		setQuiesce(set: Boolean) updating, number = 1008;
	)
	CnCompactCmd completeDefinition
	(
	attributeDefinitions
		commandType:                   String[9] readonly, number = 6, ordinal = 6;
		compactWorkers:                Integer readonly, number = 1, ordinal = 1;
		mapFileNames:                  CnStringArray readonly, subId = 2, number = 4, ordinal = 7;
		timeStamp:                     TimeStamp readonly, number = 2, ordinal = 2;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1002;
		exceptionHandler(exObj: Exception): Integer number = 1006;
		loadMsg(buf: Binary) updating, number = 1001;
		processMsg(proc: Process): String updating, number = 1003;
		sendCompactFailureResponse(errText: String) number = 1007;
		setCommandType(pCmdType: String) updating, number = 1005;
		setCompactWorkers(pWorkers: Integer) updating, number = 1008;
		setMapFileNames(pMapFileNames: CnStringArray) updating, number = 1009;
		setTimeStamp(pTimeStamp: TimeStamp) updating, number = 1010;
	)
	CnControlCmd completeDefinition
	(
		documentationText
		`Control messages and process kill functions.`
	attributeDefinitions
		commandType:                   String[6] readonly, number = 1, ordinal = 1;
		commandVar:                    Integer readonly, number = 8, ordinal = 8;
		documentationText
		`22Deb10. This attribute is no longer used.

Retained for formatting purposes.`
		delay:                         Integer readonly, number = 2, ordinal = 2;
		message:                       String[501] readonly, number = 3, ordinal = 3;
		nodeMonitorMaxProcessesDef:    Integer readonly, number = 10, ordinal = 10;
		nodeMonitorThresholdPercent:   Integer readonly, number = 9, ordinal = 9;
		sampleCacheStats:              Boolean readonly, number = 7, ordinal = 7;
		sampleProcessStats:            Boolean readonly, number = 6, ordinal = 6;
		sourceComputer:                String[31] readonly, number = 4, ordinal = 4;
		targetComputer:                String[31] readonly, number = 5, ordinal = 5;
		timestamp:                     TimeStamp readonly, number = 11, ordinal = 11;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1017;
		loadMsg(buf: Binary) updating, number = 1001;
		processMsg(proc: Process): String updating, number = 1002;
		processMsgActual(proc: Process): String updating, number = 1010;
		sendControlAdvice(
			errorcode: Integer; 
			errortext: String) updating, number = 1012;
		setCommandType(command: String) updating, number = 1003;
		setDelay(time: Integer) updating, number = 1004;
		setMessage(msg: String) updating, number = 1005;
		setNodeMonitoringValues(
			pCheckInterval: Integer; 
			pThresholdPercent: Integer; 
			pMaxProcessesDefault: Integer) updating, number = 1016;
		setSampleCacheStats(set: Boolean) updating, number = 1014;
		setSampleProcessStats(set: Boolean) updating, number = 1013;
		setSourceComputer(computer: String) updating, number = 1006;
		setTargetComputer(computer: String) updating, number = 1007;
		setTimestamp(pValue: TimeStamp) updating, number = 1008;
		zSendDbFileDetails() protected, number = 1015;
		zSendMapFileSizes() protected, number = 1009;
		zSendUserPatches() protected, number = 1018;
		zTranStatsTimeChange() protected, number = 1011;
	)
	CnExecuteCmd completeDefinition
	(
	attributeDefinitions
		executeFunction:               String[101] readonly, number = 4, ordinal = 4;
		itemIndex:                     Integer readonly, number = 1, ordinal = 1;
		itemName:                      String readonly, subId = 1, number = 2, ordinal = 2;
		parameterArray:                HugeStringArray readonly, subId = 1, number = 3, ordinal = 3;
		scriptText:                    String readonly, subId = 2, number = 5, ordinal = 5;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		loadMsg(buf: Binary) updating, number = 1002;
		processMsg(proc: Process): String updating, number = 1003;
		setExecuteFunction(pValue: String) updating, number = 1005;
		setItemIndex(pValue: Integer) updating, number = 1006;
		setItemName(pValue: String) updating, number = 1007;
		setScriptText(pValue: String) updating, number = 1012;
		zExecuteCardSchemaValidateMethods() protected, number = 1011;
		zExecuteJadeRecompileAllMethods() protected, number = 1010;
		zExecuteJadeReorgApp() protected, number = 1009;
		zExecuteJadeSchemaLoader() protected, number = 1008;
		zSendFailureResponse(
			pExitcode: Integer; 
			pErrorMessage: String) protected, number = 1004;
	)
	CnPingCmd completeDefinition
	(
	attributeDefinitions
		pingInterval:                  Integer readonly, number = 2, ordinal = 2;
		timestamp:                     TimeStamp readonly, number = 1, ordinal = 1;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		buildMsg(): String updating, number = 1002;
		loadMsg(buf: Binary) updating, number = 1003;
		processMsg(proc: Process): String updating, number = 1004;
		setPingInterval(secs: Integer) updating, number = 1006;
		setTimeStamp(ts: TimeStamp) updating, number = 1005;
	)
	CnProcCmd completeDefinition
	(
	attributeDefinitions
		frequency:                     Integer readonly, number = 1, ordinal = 1;
		offOrOn:                       String[4] readonly, number = 2, ordinal = 2;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		loadMsg(buf: Binary) updating, number = 1003;
		setFrequency(f: Integer) updating, number = 1004;
		setOffOrOn(s: String) updating, number = 1005;
	)
	CnSDSCmd completeDefinition
	(
	constantDefinitions
		TrackingState_Disable:         Integer = 1 number = 1001;
		TrackingState_Enable:          Integer = 2 number = 1002;
		TrackingState_NoChange:        Integer = 0 number = 1003;
	attributeDefinitions
		command:                       String[31] readonly, number = 2, ordinal = 2;
	jadeMethodDefinitions
		loadMsg(buf: Binary) updating, number = 1002;
		processMsg(proc: Process): String updating, number = 1003;
		sendSDSAdviceMsg(destProcess: String) updating, number = 1004;
		setCommand(cmd: String) updating, number = 1001;
	)
	CnSchemaCopyCmd completeDefinition
	(
		documentationText
`This class is used by :

	Joss 			To send version change notification to Karma (processed by KarmaCommsMgr).

	Karma			To receive version change notification from Joss, and to send version change 
					notification to all clients once new versions have been	FTP-ed from the Joss server.

	Application		To receive the change notification from Karma
`
	attributeDefinitions
		clientRequiresMisc:            Boolean readonly, number = 1, ordinal = 1;
		copyMessage:                   String[255] readonly, number = 2, ordinal = 2;
		currentClientBinVersion:       TimeStamp readonly, number = 3, ordinal = 3;
		currentClientMiscVersion:      TimeStamp readonly, number = 4, ordinal = 4;
		currentClientSchemaVersion:    TimeStamp readonly, number = 5, ordinal = 5;
		nextClientBinVersion:          TimeStamp readonly, number = 6, ordinal = 6;
		nextClientMiscVersion:         TimeStamp readonly, number = 7, ordinal = 7;
		nextClientSchemaVersion:       TimeStamp readonly, number = 8, ordinal = 8;
		nextThinClientBinVersion:      TimeStamp readonly, number = 9, ordinal = 9;
		nextThinClientMiscVersion:     TimeStamp readonly, number = 10, ordinal = 10;
		serverRequiresMisc:            Boolean readonly, number = 11, ordinal = 11;
		usesJadeThinClient:            Boolean readonly, number = 12, ordinal = 12;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		loadMsg(buf: Binary) updating, number = 1002;
		processMsg(proc: Process): String updating, number = 1003;
		setClientRequiresMisc(set: Boolean) updating, number = 1004;
		setCopyMessage(msg: String) updating, number = 1005;
		setCurrentClientVersions(
			schemaversion: TimeStamp; 
			binversion: TimeStamp; 
			miscversion: TimeStamp) updating, number = 1006;
		setNextClientVersions(
			schemaversion: TimeStamp; 
			binversion: TimeStamp; 
			miscversion: TimeStamp) updating, number = 1007;
		setNextThinClientVersions(
			bin: TimeStamp; 
			misc: TimeStamp) updating, number = 1008;
		setServerRequiresMisc(set: Boolean) updating, number = 1009;
	)
	CnThreadCmd completeDefinition
	(
	attributeDefinitions
		procId:                        Integer readonly, number = 1, ordinal = 1;
		tiKey:                         Integer readonly, number = 2, ordinal = 2;
	jadeMethodDefinitions
		assembleMsg(): Binary updating, number = 1001;
		loadMsg(buf: Binary) updating, number = 1003;
		setProcId(pId: Integer) updating, number = 1004;
		setTiKey(arg: Integer) updating, number = 1005;
	)
	CnPersistentDb completeDefinition
	(
	)
	CnLockTarget completeDefinition
	(
		documentationText
		`
Used for finding process of background client and background client starter.`
	attributeDefinitions
		appName:                       String[101] readonly, number = 4, ordinal = 1;
		id:                            Integer readonly, number = 1, ordinal = 2;
		schemaName:                    String[101] readonly, number = 3, ordinal = 4;
	referenceDefinitions
		myCnRoot:                      CnRoot   explicitEmbeddedInverse, readonly, number = 2, ordinal = 3;
	jadeMethodDefinitions
		getName(): String number = 1003;
		loadSelf(
			pSchemaName: String; 
			pAppName: String) updating, number = 1001;
		setId(pId: Integer) updating, number = 1002;
	)
	CnRoot completeDefinition
	(
	attributeDefinitions
		clusterGroup:                  String[65] readonly, number = 1, ordinal = 11;
		clusterName:                   String[17] readonly, number = 3, ordinal = 3;
		deploymentStatus:              Integer readonly, number = 8, ordinal = 10;
		possibleHosts:                 StringArray readonly, subId = 2, number = 5, ordinal = 4;
		preferredHost:                 String[17] readonly, number = 4, ordinal = 5;
		virtualMachineName:            String[17] readonly, number = 2, ordinal = 6;
	referenceDefinitions
		allLockTargets:                CnLockTargetDict   explicitInverse, readonly, subId = 3, number = 6, ordinal = 2;
		allSDSStructureState:          CnSDSStructureStateDict   explicitInverse, readonly, subId = 1, number = 7, ordinal = 12;
		myKCCMgrProcess:               Process  readonly, number = 9, ordinal = 9;
		documentationText
`Reference to KCCMgr's process object.  Only valid when the node is an RPS node and
CnRoot is a shared transient`
	jadeMethodDefinitions
		clearClusterInfo() updating, number = 1002;
		initializeClusterInfo() updating, number = 1003;
		loadClusterInfo(ci: CnClusterInfo) updating, number = 1001;
		setDeploymentStatus(status: Integer) updating, number = 1005;
		setMyKCCMgrProcess(pProcess: Process) updating, number = 1006;
	)
	CnSDSStructureState completeDefinition
	(
	attributeDefinitions
		frozen:                        Boolean readonly, number = 1, ordinal = 1;
		name:                          String[116] readonly, number = 3, ordinal = 3;
		offline:                       Boolean readonly, number = 2, ordinal = 2;
		partitionId:                   Integer64 readonly, number = 4, ordinal = 4;
	referenceDefinitions
		myCnRoot:                      CnRoot   explicitEmbeddedInverse, readonly, number = 5, ordinal = 5;
	jadeMethodDefinitions
		delete() updating, number = 1005;
		setFrozen(pFrozen: Boolean) updating, number = 1002;
		setMyCnRoot(pCnRoot: CnRoot) updating, number = 1006;
		setName(pName: String) updating, number = 1001;
		setOffline(pOffline: Boolean) updating, number = 1003;
		setPartitionId(pPartitionId: Integer64) updating, number = 1004;
	)
	CnProcess completeDefinition
	(
		documentationText
`Objects of this class are created for each registered JADE applications (those that instantiate 
CnKarmaCntrl).`
	attributeDefinitions
		clientTranStats:               Boolean readonly, number = 1, ordinal = 1;
		computerName:                  String[16] readonly, number = 11, ordinal = 2;
		heartbeatTimestamp:            TimeStamp readonly, number = 12, ordinal = 15;
		osPID:                         Integer readonly, number = 2, ordinal = 8;
		processId:                     Integer readonly, number = 3, ordinal = 9;
		startTime:                     TimeStamp readonly, number = 4, ordinal = 10;
		tranStats:                     CnStatisticsSampleBinaryArray readonly, subId = 1, number = 5, ordinal = 11;
		tranStatsLength:               Integer readonly, number = 13, ordinal = 17;
	referenceDefinitions
		myCnApp:                       CnApp   explicitEmbeddedInverse, readonly, number = 6, ordinal = 3;
		myCnCntrl:                     CnCntrl  readonly, number = 7, ordinal = 4;
		myCnKarmaCntrl:                CnKarmaCntrl   explicitEmbeddedInverse, readonly, number = 8, ordinal = 5;
		myMachine:                     CnMachine   explicitEmbeddedInverse, readonly, number = 9, ordinal = 6;
		myProcess:                     Process  readonly, number = 10, ordinal = 7;
	jadeMethodDefinitions
		incrementTransStatsLength(pValue: Integer) updating, number = 1011;
		setClientTranStats(set: Boolean) updating, number = 1001;
		setComputerName(name: String) updating, number = 1008;
		setHeartbeatTimestamp(ts: TimeStamp) updating, number = 1009;
		setMyCnApp(cnapp: CnApp) updating, number = 1002;
		setMyMachine(cnmach: CnMachine) updating, number = 1003;
		setMyProcess(proc: Process) updating, number = 1004;
		setOsPID(pid: Integer) updating, number = 1005;
		setProcessId(procid: Integer) updating, number = 1006;
		setStartTime(ts: TimeStamp) updating, number = 1007;
		setTransStatsLength(pValue: Integer) updating, number = 1010;
	)
	CnSmtpState completeDefinition
	(
		documentationText
`This material is proprietary to Cardinal Group Limited (Cardinal) and is not to be reproduced, used or 
disclosed except upon written permission of Cardinal.                                                                     

  		 COPYRIGHT (C) CARDINAL GROUP LIMITED 1999 - ALL RIGHTS RESERVED
-------------------------------------------------------------------------------------------------------`
	constantDefinitions
		CN_VERSION:                    Integer = 2 number = 1001;
		documentationText
`This material is proprietary to Cardinal Group Limited (Cardinal) and is not to be reproduced, used or 
disclosed except upon written permission of Cardinal.                                                                     

  		 COPYRIGHT (C) CARDINAL GROUP LIMITED 1999 - ALL RIGHTS RESERVED
-------------------------------------------------------------------------------------------------------

Version 2	20.06.2001

			See text for CnSmtpConnection::CN_VERSION. Various state methods changed to concatenate server messages.`
		E500:                          String = "Syntax error, command unrecognised" number = 1002;
	jadeMethodDefinitions
		defaultServerErrorHandler(smtp: CnSmtpConnection input) number = 1001;
		do214(smtp: CnSmtpConnection input) number = 1002;
		do220(smtp: CnSmtpConnection input) number = 1003;
		do221(smtp: CnSmtpConnection input) number = 1004;
		do235(smtp: CnSmtpConnection input) number = 1029;
		do250(smtp: CnSmtpConnection input) number = 1005;
		do334(smtp: CnSmtpConnection input) number = 1030;
		do354(smtp: CnSmtpConnection input) number = 1006;
		do421(smtp: CnSmtpConnection input) number = 1007;
		do450(smtp: CnSmtpConnection input) number = 1008;
		do451(smtp: CnSmtpConnection input) number = 1009;
		do452(smtp: CnSmtpConnection input) number = 1010;
		do500(smtp: CnSmtpConnection input) number = 1011;
		do501(smtp: CnSmtpConnection input) number = 1012;
		do502(smtp: CnSmtpConnection input) number = 1013;
		do503(smtp: CnSmtpConnection input) number = 1014;
		do504(smtp: CnSmtpConnection input) number = 1015;
		do530(smtp: CnSmtpConnection input) number = 1032;
		do534(smtp: CnSmtpConnection input) number = 1033;
		do535(smtp: CnSmtpConnection input) number = 1031;
		do550(smtp: CnSmtpConnection input) number = 1016;
		do551(smtp: CnSmtpConnection input) number = 1017;
		do552(smtp: CnSmtpConnection input) number = 1018;
		do553(smtp: CnSmtpConnection input) number = 1019;
		do554(smtp: CnSmtpConnection input) number = 1020;
		findLastLine(
			pMessage: String input; 
			pSmtp: CnSmtpConnection input): Boolean updating, number = 1021;
		handleEvent(smtp: CnSmtpConnection input) updating, number = 1022;
		ignore(smtp: CnSmtpConnection input) number = 1023;
		markAsUndelivered(smtp: CnSmtpConnection input) number = 1024;
		sendOK(smtp: CnSmtpConnection input) number = 1025;
		sendQUIT(smtp: CnSmtpConnection input) number = 1026;
		sendRSET(smtp: CnSmtpConnection input) number = 1027;
		setCompleted(smtp: CnSmtpConnection input) number = 1028;
	)
	CnSmtpStateAUTH completeDefinition
	(
	jadeMethodDefinitions
		do235(smtp: CnSmtpConnection input) number = 1001;
		do334(smtp: CnSmtpConnection input) number = 1002;
	)
	CnSmtpStateDATA completeDefinition
	(
		documentationText
`This material is proprietary to Cardinal Group Limited (Cardinal) and is not to be reproduced, used or 
disclosed except upon written permission of Cardinal.                                                                     

  		 COPYRIGHT (C) CARDINAL GROUP LIMITED 1999 - ALL RIGHTS RESERVED
-------------------------------------------------------------------------------------------------------`
	constantDefinitions
		Content_Description:           String = "Content-Description: " number = 1001;
		Content_Disposition_Attachment:String = "Content-Disposition: attachment;" number = 1002;
		Content_Disposition_Inline:    String = "Content-Disposition: inline;" number = 1003;
		Content_ID:                    String = "Content-ID: " number = 1004;
		Content_Location:              String = "Content-Location: " number = 1005;
		Content_Transfer:              String = "Content-Transfer-Encoding: " number = 1006;
		Content_Transfer_7Bit:         String = "7bit" number = 1007;
		Content_Transfer_Base64:       String = "Base64" number = 1008;
		Content_Type:                  String = "Content-Type: " number = 1009;
		FileName_Equals:               String = "filename=" number = 1010;
		Name_Equals:                   String = "name=" number = 1011;
	jadeMethodDefinitions
		do354(smtp: CnSmtpConnection input) number = 1001;
		getLastFilenameNode(pFileName: String input): String number = 1002;
		sendFileAttachments(smtp: CnSmtpConnection input) number = 1003;
		sendInlines(smtp: CnSmtpConnection input) number = 1004;
		zHandleBase64Inline(
			pEditedMessage: String; 
			pHeader: String; 
			pEncodingType: String; 
			pFirstOne: Boolean io; 
			pSMTP: CnSmtpConnection): String number = 1008;
	)
	CnSmtpStateDATASent completeDefinition
	(
		documentationText
`This material is proprietary to Cardinal Group Limited (Cardinal) and is not to be reproduced, used or 
disclosed except upon written permission of Cardinal.                                                                     

  		 COPYRIGHT (C) CARDINAL GROUP LIMITED 1999 - ALL RIGHTS RESERVED
-------------------------------------------------------------------------------------------------------`
	jadeMethodDefinitions
		do250(smtp: CnSmtpConnection input) number = 1001;
	)
	CnSmtpStateHELO completeDefinition
	(
		documentationText
`This material is proprietary to Cardinal Group Limited (Cardinal) and is not to be reproduced, used or 
disclosed except upon written permission of Cardinal.                                                                     

  		 COPYRIGHT (C) CARDINAL GROUP LIMITED 1999 - ALL RIGHTS RESERVED
-------------------------------------------------------------------------------------------------------`
	jadeMethodDefinitions
		do250(smtp: CnSmtpConnection input) number = 1001;
	)
	CnSmtpStateMAIL completeDefinition
	(
		documentationText
`This material is proprietary to Cardinal Group Limited (Cardinal) and is not to be reproduced, used or 
disclosed except upon written permission of Cardinal.                                                                     

  		 COPYRIGHT (C) CARDINAL GROUP LIMITED 1999 - ALL RIGHTS RESERVED
-------------------------------------------------------------------------------------------------------`
	jadeMethodDefinitions
		do250(smtp: CnSmtpConnection input) number = 1001;
	)
	CnSmtpStateNOOP completeDefinition
	(
		documentationText
`This material is proprietary to Cardinal Group Limited (Cardinal) and is not to be reproduced, used or 
disclosed except upon written permission of Cardinal.                                                                     

  		 COPYRIGHT (C) CARDINAL GROUP LIMITED 1999 - ALL RIGHTS RESERVED
-------------------------------------------------------------------------------------------------------`
	)
	CnSmtpStateQUIT completeDefinition
	(
		documentationText
`This material is proprietary to Cardinal Group Limited (Cardinal) and is not to be reproduced, used or 
disclosed except upon written permission of Cardinal.                                                                     

  		 COPYRIGHT (C) CARDINAL GROUP LIMITED 1999 - ALL RIGHTS RESERVED
-------------------------------------------------------------------------------------------------------`
	jadeMethodDefinitions
		do221(smtp: CnSmtpConnection input) number = 1001;
	)
	CnSmtpStateRCPT completeDefinition
	(
		documentationText
`This material is proprietary to Cardinal Group Limited (Cardinal) and is not to be reproduced, used or 
disclosed except upon written permission of Cardinal.                                                                     

  		 COPYRIGHT (C) CARDINAL GROUP LIMITED 1999 - ALL RIGHTS RESERVED
-------------------------------------------------------------------------------------------------------`
	jadeMethodDefinitions
		cantDeliver(smtp: CnSmtpConnection input) number = 1001;
		do250(smtp: CnSmtpConnection input) number = 1002;
		do450(smtp: CnSmtpConnection input) number = 1003;
		do550(smtp: CnSmtpConnection input) number = 1004;
		do551(smtp: CnSmtpConnection input) number = 1005;
		do553(smtp: CnSmtpConnection input) number = 1006;
		do554(smtp: CnSmtpConnection input) number = 1008;
		doRCPTandDATA(smtp: CnSmtpConnection input) number = 1007;
	)
	CnSmtpStateRSET completeDefinition
	(
		documentationText
`This material is proprietary to Cardinal Group Limited (Cardinal) and is not to be reproduced, used or 
disclosed except upon written permission of Cardinal.                                                                     

  		 COPYRIGHT (C) CARDINAL GROUP LIMITED 1999 - ALL RIGHTS RESERVED
-------------------------------------------------------------------------------------------------------`
	jadeMethodDefinitions
		do250(smtp: CnSmtpConnection input) number = 1001;
	)
	CnSmtpStateTCPConnected completeDefinition
	(
		documentationText
`This material is proprietary to Cardinal Group Limited (Cardinal) and is not to be reproduced, used or 
disclosed except upon written permission of Cardinal.                                                                     

  		 COPYRIGHT (C) CARDINAL GROUP LIMITED 1999 - ALL RIGHTS RESERVED
-------------------------------------------------------------------------------------------------------`
	jadeMethodDefinitions
		do220(smtp: CnSmtpConnection input) number = 1001;
	)
	CnSmtpStateTCPDisconnected completeDefinition
	(
		documentationText
`This material is proprietary to Cardinal Group Limited (Cardinal) and is not to be reproduced, used or 
disclosed except upon written permission of Cardinal.                                                                     

  		 COPYRIGHT (C) CARDINAL GROUP LIMITED 1999 - ALL RIGHTS RESERVED
-------------------------------------------------------------------------------------------------------`
	)
	CnStackDump completeDefinition
	(
	constantDefinitions
		Max_PropertyCount:             Integer = 30 number = 1001;
		Max_String_Length:             Integer = 100000 number = 1002;
	attributeDefinitions
		currentIndent:                 Integer readonly, number = 1, ordinal = 1;
		endOfLine:                     String[3] readonly, number = 8, ordinal = 8;
		hadException:                  Boolean readonly, number = 2, ordinal = 2;
		noDump:                        Boolean number = 7, ordinal = 7;
		objectsDumpedArray:            CnStringArray readonly, subId = 1, number = 3, ordinal = 4;
		objectsDumpedByArray:          CnStringArray readonly, subId = 2, number = 4, ordinal = 5;
		stackStartIndex:               Integer number = 6, ordinal = 6;
	referenceDefinitions
		myDumpFile:                    JadeLog  readonly, number = 5, ordinal = 3;
	jadeMethodDefinitions
		closeDumpLog() updating, clientExecution, number = 1001;
		create() updating, number = 1023;
		dumpArray(
			array: Array; 
			name: String; 
			level: Integer) updating, number = 1002;
		dumpCallStack(
			logIt: Boolean; 
			onServer: Boolean): String updating, number = 1009;
		dumpExceptionHandlerStack() updating, number = 1019;
		dumpExceptionHandlerStackAll() updating, clientExecution, number = 1021;
		dumpObjVars(
			dumpParent: String; 
			obj: Object; 
			level: Integer) updating, number = 1003;
		dumpSet(
			set: Set; 
			name: String; 
			level: Integer) updating, number = 1026;
		dumpStack(pException: Exception) updating, number = 1004;
		dumpStackPlus(
			pException: Exception; 
			pExceptionDetails: String output) updating, number = 1035;
		ehFileError(
			pExObj: Exception; 
			pObj: Object; 
			pErrorStr: String output): Integer number = 1017;
		exceptionHandler(exObj: Exception): Integer updating, number = 1005;
		exceptionHandlerDeletedClass(
			pExObj: Exception; 
			pOidStr: String io): Integer updating, number = 1024;
		formatPrimType(
			type: PrimType; 
			value: Any): String number = 1015;
		getFileExceptionDetails(exObj: FileException): String updating, number = 1007;
		getTransientsOnClient() clientExecution, number = 1029;
		getTransientsOnServer() serverExecution, number = 1030;
		miniDumpToString(exObj: Exception): String updating, number = 1025;
		removeSensitiveDataFromArgs(pValue: String): String number = 1034;
		reportException(
			pStartStackOffset: Integer; 
			pPSA: ProcessStackArray; 
			pExObj: Exception; 
			pDumpFileName: String) updating, number = 1014;
		showDumpProgressForm(
			exObj: Exception; 
			size: Integer) updating, clientExecution, number = 1008;
		unloadDumpProgressForm() updating, clientExecution, number = 1010;
		updateDumpProgressForm(partsDone: Integer) updating, clientExecution, number = 1011;
		writeLine(
			str: String; 
			indent: Integer) updating, clientExecution, number = 1012;
		writeLineC(
			str: String; 
			line: String io; 
			indent: Integer) updating, clientExecution, number = 1013;
		writeLog(
			text: String; 
			onServer: Boolean) number = 1006;
		zDumpExceptionHandlerStack(
			pLocation: String; 
			pObjectArray: ObjectArray) updating, protected, number = 1020;
		zDumpStack(
			pException: Exception; 
			pExceptionDetails: String output) updating, protected, number = 1033;
		zExpandVariable(
			pLevel: Integer; 
			pMeth: Method; 
			pVarName: String; 
			pType: Type; 
			pLine: String io; 
			pEntityType: String) updating, protected, number = 1027;
		zGetMethodStackdumpLine(
			pMethodCallDesc: MethodCallDesc; 
			pMethodNameAndPosition: String output): String protected, number = 1028;
		zGetStartCallStackIndex(pProcessStackArray: ProcessStackArray input): Integer updating, protected, number = 1016;
		zRemoveNumericLiteralsFromArgs(pStr: String): String protected, number = 1031;
		zRemoveStringLiteralsFromArgs(pStr: String): String protected, number = 1032;
		zServerExceptionHandlerStack(pObjArray: ObjectArray input) protected, serverExecution, number = 1022;
		zShowDumpProgressFormOK(): Boolean protected, number = 1018;
	)
	CnTransientDb completeDefinition
	(
	)
	CnAgents completeDefinition
	(
	)
	CnFunctionAgent completeDefinition
	(
		documentationText
`The primary purpose of this class is to ensure that 
database file (DbFile and partition) state (online, offline, frozen, thawed) is consistent across nodes in a synchronized database environment.

This is required because JADE does not audit operations affecting these states and we wish contuniuty of behaviour
in the event of a takeover.

To achieve this we
1) Maintain a persistent description of primary database file state
2) When a database file state changes, the description is updated and the change is audited and replayed by secondaries.
3) When a secondary detects a change to the description, it changes the state of the database file to keep it in synch with the primary. `
	jadeMethodDefinitions
		cnGetTakeoverStateString(pTakeoverProgress: Integer): String number = 1016;
		cnHandleRoleChangeProgressEvent(
			pRoleChangeProgress: Integer; 
			pInTakeoverState: Boolean io; 
			pHostileTakeover: Boolean io) number = 1015;
		cnSDSStructureStatePrimUpdate(
			pDbFileNamesArray: CnStringArray; 
			pDbFileStatusArray: IntegerArray; 
			pPartitionIdArray: Integer64Array; 
			pFileExcludeFromBackup: BooleanArray; 
			pFrozenArray: BooleanArray; 
			pOfflineArray: BooleanArray) number = 1002;
		cnSDSStructureState_DHandler(pDbFile: DbFile) number = 1009;
		cnSDSStructureState_PHandler(
			pDbFile: DbFile; 
			pDbPartition: JadeDbFilePartition) number = 1008;
		cnSDSStructureState_Sync() updating, number = 1003;
		ehBackupReorgExceptionHandler(pExObj: SystemException): Integer number = 1012;
		ehGeneralExceptionHandler(
			pExObj: SystemException; 
			pErrorCode: Integer output; 
			pErrorText: String output): Integer number = 1011;
		getAllSchemas(pSchemaSet: ObjectSet input) number = 1013;
		parseUserAppliedSchemaPatches(
			pSchemaPatches: String; 
			pSchemaElementColl: CnSchemaElementDict input) number = 1001;
		raiseJossAlert(
			pObject: Object; 
			pErrorText: String; 
			pErrorCode: Integer) number = 1010;
		zCnSDSStructureState_Freeze(pObject: Object) protected, number = 1005;
		zCnSDSStructureState_Offline(pDbPartition: JadeDbFilePartition) protected, number = 1006;
		zCnSDSStructureState_Online(pDbPartition: JadeDbFilePartition) protected, number = 1007;
		zCnSDSStructureState_Thaw(pObject: Object) protected, number = 1004;
		zStructureState_StartSyncTimer() protected, number = 1014;
	)
	CnIniFileAgent completeDefinition
	(
	attributeDefinitions
		iniFileName:                   String subId = 1, number = 1, ordinal = 1;
	jadeMethodDefinitions
		getSSLDetails(
			pRpcEncryptionEnabled: Boolean output; 
			pSSLCertFileResident: Boolean output; 
			pSSLCertAuthFileResident: Boolean output; 
			pSSLSecurePort: String output; 
			pSSLCertFileName: String output; 
			pSSLCertFileSubject: String output; 
			pSSLCertAuthFileName: String output; 
			pSSLCertAuthFileSubject: String output; 
			pSSLMethodName: String output; 
			pSSLCertFileExpiry: Date output; 
			pSSLCertAuthFileExpiry: Date output; 
			pSSLCiphers: StringArray input) number = 1001;
	)
	CnProfilingAgent completeDefinition
	(
	jadeMethodDefinitions
		fileMethodProfileDetails() number = 1002;
		logMethodProfileDetails() number = 1001;
	)
	CnTransactionAgent completeDefinition
	(
	jadeMethodDefinitions
		sdsCauseEventCommon(pName: String) number = 1004;
		sdsStructureState_create(
			pName: String; 
			pPartitionId: Integer64; 
			pFrozen: Boolean; 
			pOffline: Boolean) updating, number = 1001;
		sdsStructureState_delete(pCnSDSStructureState: CnSDSStructureState) number = 1003;
		sdsStructureState_update(
			pCnSDSStructureState: CnSDSStructureState; 
			pFrozen: Boolean; 
			pOffline: Boolean) updating, number = 1002;
	)
	CnValidateMethodAgent completeDefinition
	(
	referenceDefinitions
		parameters:                    HugeStringArray  number = 1, ordinal = 4;
	jadeMethodDefinitions
		handleAnyException(exObj: Exception): Integer number = 1003;
		run() number = 1001;
		timerEvent(eventTag: Integer) updating, number = 1002;
	)
	CnBackup completeDefinition
	(
	constantDefinitions
		Retry_Limit:                   Integer = 6 number = 1001;
		Retry_Wait_Interval:           Integer = 10*1000 number = 1002;
	attributeDefinitions
		backupDirectory:               String[129] readonly, number = 8, ordinal = 19;
		droppedFileNames:              CnStringArray readonly, subId = 3, number = 3, ordinal = 7;
		includeDirArray:               CnStringArray readonly, subId = 6, number = 7, ordinal = 12;
		includeSubDirArray:            CnStringArray readonly, subId = 5, number = 6, ordinal = 18;
		mapFileNames:                  CnStringArray readonly, subId = 1, number = 1, ordinal = 5;
		mapFileSizes:                  CnDecimalArray readonly, subId = 2, number = 2, ordinal = 6;
		numberOfWorkers:               IntegerArray readonly, subId = 4, number = 4, ordinal = 8;
		totalSize:                     Integer64 readonly, number = 5, ordinal = 9;
	jadeMethodDefinitions
		backupDirInclusions(): String updating, serverExecution, number = 1002;
		copyFilesFromDirectory(
			pFileFolder: FileFolder; 
			pDestDir: String; 
			pCreateDirectoryIfNotFound: Boolean; 
			pIncludeSubDirectories: Boolean; 
			pVerifyIntegrity: Boolean; 
			pErrText: String output): Boolean updating, number = 1005;
		interpretBackupInfo(
			pEventType: Integer; 
			pBackupInfo: Binary; 
			pAdviceType: String output; 
			pTimeStamp: TimeStamp output; 
			pCurrentFileName: String output; 
			pFileSize: Integer64 output; 
			pTotalSize: Integer64 output; 
			pPercentProgress: Integer output; 
			pErrorText: String output; 
			pStartLogNo: Integer output; 
			pEndLogNo: Integer output; 
			pBackupWorkerId: Integer output; 
			pPhase: Character output; 
			pNonDbFileNameArray: CnStringArray input; 
			pNonDbFileSizeArray: Integer64Array input; 
			pStatusTag: Integer output; 
			pStatusText: String output) updating, number = 1004;
		removeDirectory(pBackupDir: String): String updating, number = 1006;
		removeFile(pFile: File): String number = 1008;
		runUnixCommand(pCommand: String): String updating, number = 1009;
		validateParsedParams(
			pStrArray: HugeStringArray; 
			pEnvironmentId: String output; 
			pBackupDirectory: String output; 
			pBackupWorkers: String output; 
			pCompressFiles: Boolean output; 
			pQuiesce: Boolean output; 
			pDisableBackupNotify: Boolean output): Boolean updating, serverExecution, number = 1001;
		zCopyFilesFromDirectory(
			pFileFolder: FileFolder; 
			pDestDir: String; 
			pCreateDirectoryIfNotFound: Boolean; 
			pIncludeSubDirectories: Boolean; 
			pVerifyIntegrity: Boolean; 
			pErrText: String output): Boolean updating, protected, number = 1007;
		zRemoveDirectory(pFileFolder: FileFolder): String updating, protected, number = 1010;
	)
	CnDatabaseStructure completeDefinition
	(
		documentationText
`DbFile objects are persistent.

JadeDbFilePartition objects are always transient.

As such the JadeDbFilePartition will always need to be retrieved by the
backup process using DbFile.getPartition(partition_Id) by the backup worker
process.

CnDatabaseStructure.partitionId values:
-1	Not partitioned
0	Partition control file
>1	Actual partition `
	attributeDefinitions
		backupLocation:                String[257] number = 7, ordinal = 7;
		backupPath:                    String subId = 1, number = 9, ordinal = 9;
		filePath:                      String[261] number = 8, ordinal = 8;
		name:                          String[116] number = 4, ordinal = 4;
		partitionId:                   Integer64 number = 5, ordinal = 5;
		size:                          Integer64 number = 2, ordinal = 2;
		udrFileSize:                   Integer64 number = 6, ordinal = 6;
	referenceDefinitions
		myCnDatabaseAdmin:             CnAdmin   explicitEmbeddedInverse, number = 1, ordinal = 1;
		myDbFile:                      DbFile  number = 3, ordinal = 3;
	)
	CnExternalMethods completeDefinition
	(
	jadeMethodDefinitions
		cnCauseFault() protected, number = 1002;
		cnGetCopyToClipboardErrorText(pErrorCode: Integer): String number = 1087;
		cnGetErrorText(
			pErrorRoutine: String; 
			pErrorCode: Integer): String number = 1007;
		cnGroupCheck(
			pUserName: String; 
			pGroupName: String; 
			pResult: Integer output): Boolean number = 1006;
		cnUserCheck(
			pUserName: String; 
			pPassword: String; 
			pResult: Integer output): Boolean number = 1004;
		zErrCreateProcess(pErrorCode: Integer): String protected, number = 1009;
		zErrCreateProcessReturnResults(pErrorCode: Integer): String protected, number = 1008;
	externalMethodDefinitions
		emBase64Decode(
			pMessage: String input; 
			pDecodedMessage: Binary output): Integer is "emBase64Decode" in "karma" updating, number = 1061;
		emBase64Encode(pMessage: Binary input): String is "emBase64Encode" in "karma" updating, number = 1062;
		emCauseFault(): Boolean is "emCauseFault" in "karma" protected, number = 1001;
		emCreateFolder(pFolderName: String): Integer is "emCreateFolder" in "karma" number = 1063;
		emCreateProcessReturnResults(
			command: String; 
			childStdIn: String; 
			childExitCode: Integer output; 
			binLength: Integer output; 
			binStdOut: Binary output): Integer is "emCreateProcessReturnResults" in "karma" number = 1014;
		emGetAdministratorsGroup(): String is "emGetAdministratorsGroup" in "karma" number = 1016;
		emGetDomainName(
			type: Integer output; 
			name: String output): String is "emGetDomainName" in "karma" number = 1056;
		emGetDomainNameEx(
			type: Integer output; 
			name: String output): String is "emGetDomainNameEx" in "karma" number = 1065;
		emGetEnvironmentVariable(pVariable: String): String is "emGetEnvironmentVariable" in "karma" number = 1011;
		emGetErrorText(
			pErrorCode: Integer; 
			pErrorText: String output; 
			pMaxLength: Integer): Integer is "emGetErrorText" in "karma" number = 1031;
		emGetHostByAddress(
			ipAddress: String; 
			hostName: String output): Integer is "emGetHostByAddr" in "karma" number = 1028;
		emGetHostByName(
			hostName: String; 
			maxNum: Integer io; 
			addresses: String output): Integer is "emGetHostByName" in "karma" number = 1029;
		emGetUserName(
			userName: String output; 
			maxLength: Integer io): Integer is "emGetUserName" in "karma" number = 1037;
		emGroupCheck(
			pUserName: String; 
			pGroup: String; 
			pResult: Integer output): Boolean is "emGroupCheck" in "karma" protected, number = 1005;
		emIsProcessRunning(pProcessName: String): Boolean is "emIsProcessRunning" in "karma" number = 1083;
		emIsService(): Boolean is "emIsService" in "karma" number = 1035;
		emQPDecode(
			pEncoded: String; 
			pDecoded: Binary output): String is "emQPDecode" in "karma" number = 1059;
		emQPEncode(
			nData: Binary; 
			qpEncoded: String output): String is "emQPEncode" in "karma" number = 1060;
		emResetReadOnly(pDirectory: String): Boolean is "emResetReadOnly" in "karma" number = 1027;
		emSendStdOut(str: String): Integer is "emSendStdOut" in "karma" number = 1036;
		emUserCheck(
			pUserName: String; 
			pPassword: String; 
			pResult: Integer output): Boolean is "emUserCheck" in "karma" protected, number = 1003;
	)
	CnIpAddress completeDefinition
	(
	constantDefinitions
		COLON:                         Integer = 5 number = 1001;
		DECDIGIT:                      Integer = 1 number = 1002;
		DOT:                           Integer = 4 number = 1003;
		END:                           Integer = 6 number = 1004;
		GOT2NDCOLON:                   Integer = 4 number = 1005;
		GOTCOLON:                      Integer = 3 number = 1006;
		GOTDIGIT:                      Integer = 5 number = 1007;
		GOTDOT:                        Integer = 1 number = 1008;
		GOTLEADINGCOLON:               Integer = 8 number = 1009;
		GOTSPACE:                      Integer = 2 number = 1010;
		HEXDIGIT:                      Integer = 2 number = 1011;
		OTHER:                         Integer = 7 number = 1012;
		SPACE:                         Integer = 3 number = 1013;
		STARTING:                      Integer = 0 number = 1014;
		UNKNOWN:                       Integer = 0 number = 1015;
	attributeDefinitions
		errorMessage:                  String protected, subId = 1, number = 1, ordinal = 1;
	jadeMethodDefinitions
		checkFormat(pValue: String): Integer updating, number = 1001;
		checkNumString(
			pValue: String; 
			pVersion: Integer): Integer updating, protected, number = 1002;
		convertIPv4toIPv6(pIPv4: String): String number = 1007;
		convertIPv6toIPv4(pIPv6: String): String number = 1008;
		getErrorMessage(): String number = 1003;
		hexToDisplay(hexString: String): String number = 1004;
		v4DisplayToHex(pValue: String): String updating, number = 1005;
		v6DisplayToHex(s: String): String updating, number = 1006;
	)
	CnJadeSystemClasses completeDefinition
	(
	referenceDefinitions
		myCnKarmaCntrl:                CnKarmaCntrl   explicitEmbeddedInverse, readonly, number = 1, ordinal = 1;
	)
	CnJadeApplication completeDefinition
	(
	attributeDefinitions
		alertTimeStamp:                TimeStamp readonly, number = 4, ordinal = 4;
		applicationName:               String[101] readonly, number = 2, ordinal = 2;
		ignoreRegistrationFailure:     Boolean readonly, number = 3, ordinal = 3;
		schemaName:                    String[101] readonly, number = 1, ordinal = 1;
	referenceDefinitions
		allCnJadeProcesses:            CnJadeProcessDict   explicitInverse, readonly, subId = 1, number = 6, ordinal = 6;
	jadeMethodDefinitions
		loadSelf(
			pSchemaName: String; 
			pApplicationName: String) updating, number = 1001;
		setAlertTimeStamp(pTimeStamp: TimeStamp) updating, number = 1003;
		setIgnoreRegistrationFailure(pBool: Boolean) updating, number = 1002;
	)
	CnJadeNode completeDefinition
	(
	attributeDefinitions
		alertTimeStamp:                TimeStamp readonly, number = 7, ordinal = 10;
		isDefaultValue:                Boolean readonly, number = 8, ordinal = 9;
		documentationText
`Indicates whether the attribute 'maxLocalProcesses' is the default 
value as defined in JSM or the value from the fat-client's ini file.

true 	- value is from JSM
false 	- obtained from fat-client ini file (via notification)`
		maxLocalProcesses:             Integer readonly, number = 3, ordinal = 8;
		nodeId:                        Integer readonly, number = 2, ordinal = 2;
		nodeName:                      String[256] readonly, number = 4, ordinal = 4;
		nodeType:                      Integer readonly, number = 5, ordinal = 5;
		documentationText
`Refer to JADE Class Encyclopedia Node::nodeType()

1 - Database Server
2 - Application Server
3 - Single User Application Server
4 - Standard Client (fat-client)
5 - Single User Mode


We ignore types 3 and 5.`
		osID:                          Integer readonly, number = 1, ordinal = 1;
	referenceDefinitions
		allCnJadeProcesses:            CnJadeProcessDict   explicitInverse, readonly, subId = 1, number = 6, ordinal = 6;
	jadeMethodDefinitions
		delete() updating, number = 1004;
		getNodeTypeString(): String number = 1006;
		loadSelf(
			pInstanceId: Integer; 
			pJadeNode: Node) updating, number = 1001;
		setAlertTimeStamp(pTimeStamp: TimeStamp) updating, number = 1005;
		setIsDefaultValue(pBool: Boolean) updating, number = 1003;
		setMaxLocalProcesses(pValue: Integer) updating, number = 1002;
	)
	CnJadeProcess completeDefinition
	(
	attributeDefinitions
		ipAddress:                     String[66] readonly, number = 10, ordinal = 13;
		kccmgrStartUp:                 Boolean readonly, number = 13, ordinal = 16;
		notRegistered:                 Boolean readonly, number = 2, ordinal = 7;
		processId:                     Integer readonly, number = 1, ordinal = 1;
		signOnTime:                    TimeStamp readonly, number = 8, ordinal = 11;
		signOnTimeServer:              TimeStamp readonly, number = 12, ordinal = 15;
		signOnUserCode:                String[31] readonly, number = 7, ordinal = 10;
		signedOn:                      Boolean readonly, number = 9, ordinal = 12;
		type:                          Integer readonly, number = 3, ordinal = 8;
		userCode:                      String[31] readonly, number = 5, ordinal = 9;
		usingThinClient:               Boolean readonly, number = 11, ordinal = 14;
	referenceDefinitions
		myCnJadeApplication:           CnJadeApplication   explicitEmbeddedInverse, readonly, number = 6, ordinal = 6;
		myCnJadeNode:                  CnJadeNode   explicitEmbeddedInverse, readonly, number = 4, ordinal = 4;
	jadeMethodDefinitions
		delete() updating, number = 1003;
		getName(): String number = 1004;
		loadSelf(
			pJadeProcess: Process; 
			pCnJadeNode: CnJadeNode; 
			pCnJadeApplication: CnJadeApplication; 
			pKCCMgrStartUp: Boolean) updating, number = 1001;
		timerEvent(eventTag: Integer) updating, number = 1002;
	)
	CnJadeTestCaseListenerIf completeDefinition
	(
	attributeDefinitions
		assertCount:                   Integer64 readonly, number = 5, ordinal = 6;
		assertCountTotal:              Integer64 readonly, number = 6, ordinal = 7;
		debug:                         Boolean readonly, number = 10, ordinal = 13;
		testsFailed:                   CnStringArray readonly, subId = 5, number = 9, ordinal = 12;
		testsSkipped:                  CnStringArray readonly, subId = 3, number = 7, ordinal = 10;
		testsSucceeded:                CnStringArray readonly, subId = 4, number = 8, ordinal = 11;
	referenceDefinitions
		allTestSet:                    ObjectSet  implicitMemberInverse, readonly, subId = 2, number = 3, ordinal = 4;
		allTests:                      ObjectArray  implicitMemberInverse, readonly, subId = 1, number = 2, ordinal = 3;
		myLog:                         JadeLog  readonly, number = 1, ordinal = 1;
		myTestRunner:                  JadeTestRunner  readonly, number = 4, ordinal = 5;
	jadeMethodDefinitions
		addTest(pObject: Object) number = 1009;
		addTests() number = 1010;
		create() updating, number = 1013;
		delete() updating, number = 1014;
		finish(
			pElapsedTime: Time; 
			pTestsFailed: Integer; 
			pTestsSkipped: Integer; 
			pTestsSucceeded: Integer) number = 1001;
		logDebugInfo(
			pMethod: Method; 
			pMessage: String; 
			pSingleTestApp: Boolean) number = 1016;
		message(messageText: String) number = 1002;
		methodSuccess(testMethodName: String) updating, number = 1003;
		preStart() number = 1018;
		runTests() updating, number = 1008;
		setDebug(pValue: Boolean) updating, number = 1015;
		setMyLogFileName() updating, number = 1017;
		start(numberOfTestMethods: Integer) number = 1004;
		testFailure(
			testMethodName: String; 
			callStack: String; 
			failureReason: String) number = 1005;
		testSkipped(testMethodName: String) number = 1006;
		testSuccess(testMethodName: String) updating, number = 1007;
		timerEvent(eventTag: Integer) updating, number = 1012;
		writeLog(pText: String) number = 1011;
		zCreateErrorFileSentinel(pTestsFailed: Integer) protected, number = 1019;
	implementInterfaces
		JadeTestListenerIF
		(
			finish is finish;
			message is message;
			methodSuccess is methodSuccess;
			start is start;
			testFailure is testFailure;
			testSkipped is testSkipped;
			testSuccess is testSuccess;
		)
	)
	CnLockCheck completeDefinition
	(
		documentationText
`The following ini file options within [AppExceptions] are used by this feature:
	- LockCheckInterval / LockCheckIntervalSecondary			- defines the interval at which locks are evaluated
	
    - MaxLockTimeBeforeAlarm / MaxLockTimeBeforeAlarmSecondary	- defines how long the lock is to be held before an alert is generated
	
	- MaxLocksRequested / MaxLocksRequestedSecondary			- default = 10000. 
																  May be used to specify the number of locks that are to be evaluated
								   
	- CheckShareLocks / CheckShareLocksSecondary				- default = false.
																  If true, then all lock types are evaluated.
																  If false, then share locks are not evaluated

While the LockCheckInterval value is greater than zero, any or all of the above ini file values
can be modified and will be used with the next iteration`
	attributeDefinitions
		checkShareLocks:               Boolean readonly, number = 5, ordinal = 5;
		hostileTakeover:               Boolean readonly, number = 7, ordinal = 7;
		inTakeoverState:               Boolean readonly, number = 6, ordinal = 6;
		lockCheckInterval:             Integer readonly, number = 2, ordinal = 2;
		maxLockTimeBeforeAlarm:        Integer readonly, number = 4, ordinal = 4;
		maxLocksRequested:             Integer readonly, number = 3, ordinal = 3;
	referenceDefinitions
		processesWithNoLockChecks:     CnProcessSet  implicitMemberInverse, readonly, subId = 1, number = 1, ordinal = 1;
		documentationText
`Manually maintained collection of processes for which no lock check alarms are
to be issued.

Added to when CardSchema::cnEnableLockChecks
Deleted from when CardSchema::cnDisableLockChecks`
	jadeMethodDefinitions
		exceptionHandler(
			exObj: Exception; 
			pError: Boolean output): Integer number = 1003;
		getIniFileValues(
			pLogValues: Boolean; 
			pLogValuesIfDifferent: Boolean) updating, number = 1006;
		startLockCheckIfRequired() updating, number = 1005;
		timerEvent(eventTag: Integer) updating, number = 1001;
		userNotification(
			eventType: Integer; 
			theObject: Object; 
			eventTag: Integer; 
			userInfo: Any) updating, number = 1004;
		zCheckLockStatus() updating, protected, number = 1002;
		zGetIniFileVerbsBasedOnDatabaseRole(
			pIniVerb_CheckShareLocks: String output; 
			pIniVerb_LockCheckInterval: String output; 
			pIniVerb_MaxLocksRequested: String output; 
			pIniVerb_MaxLockTimeBeforeAlarm: String output): Integer protected, number = 1007;
	)
	CnLocks completeDefinition
	(
	)
	CnKCLockCheck completeDefinition
	(
		documentationText
`This class is used purely by application KCLockCheck.

When KCLockCheck starts it attempts to locate the first shared transient instance of this class. 
Failure to do so means that it will lock the persistent CnRoot singleton (which exists for all host
environments), and then attempt to locate the first shared transient instance again.

If the shared transient still doesn't exist, it then creates it.

Once the shared transient is located, the application attempts to lock it for the applications
entire session. Failure to lock the shared transient means that another copy of KCLockCheck is 
running and the new copy will terminate.`
	)
	CnKCNodeControl completeDefinition
	(
		documentationText
`This class is used purely by application KCNodeControl.

When KCNodeControl starts it attempts to locate the first shared transient instance of this class. 
Failure to do so means that it will lock the persistent CnRoot singleton (which exists for all host
environments), and then attempt to locate the first shared transient instance again.

If the shared transient still doesn't exist, it then creates it.

Once the shared transient is located, the application attempts to lock it for the applications
entire session. Failure to lock the shared transient means that another copy of KCNodeControl is 
running and the new copy will terminate.`
	)
	CnKCSDSChecks completeDefinition
	(
		documentationText
`Created as a result of PAR 1035.

This class is used purely by application KCSDSChecks.

When KCSDSChecks starts it attempts to locate the first shared transient instance of this class. 
Failure to do so means that it will lock the persistent CnRoot singleton (which exists for all host
environments), and then attempt to locate the first shared transient instance again.

If the shared transient still doesn't exist, it then creates it.

Once the shared transient is located, the application attempts to lock it for the applications
entire session. Failure to lock the shared transient means that another copy of KCStatsCollector is 
running and the new copy will terminate.`
	)
	CnKCStatsCollector completeDefinition
	(
		documentationText
`This class is used purely by application KCStatsCollector.

When KCStatsCollector starts it attempts to locate the first shared transient instance of this class. 
Failure to do so means that it will lock the persistent CnRoot singleton (which exists for all host
environments), and then attempt to locate the first shared transient instance again.

If the shared transient still doesn't exist, it then creates it.

Once the shared transient is located, the application attempts to lock it for the applications
entire session. Failure to lock the shared transient means that another copy of KCStatsCollector is 
running and the new copy will terminate.`
	)
	CnKCVerifyJournal completeDefinition
	(
		documentationText
`This class is used purely by application KCVerifyJournal.

When KCVerifyJournal starts it attempts to locate the first shared transient instance of this class. 
Failure to do so means that it will lock the persistent CnRoot singleton (which exists for all host
environments), and then attempt to locate the first shared transient instance again.

If the shared transient still doesn't exist, it then creates it.

Once the shared transient is located, the application attempts to lock it for the applications
entire session. Failure to lock the shared transient means that another copy of KCVerifyJournal is 
running and the new copy will terminate.`
	)
	CnThinClientConnBalancing completeDefinition
	(
		documentationText
`This class is used by the AppServer node processes where Thin Client Connection Balancing is to be invoked.

When the process starts it attempts to locate the first shared transient instance of this class. 
Failure to do so means that it will lock the persistent CnRoot singleton (which exists for all host
environments), and then attempt to locate the first shared transient instance again.

If the shared transient still doesn't exist, it then creates it.

Once the shared transient is located, the application attempts to lock it for the applications
entire session.

If the first process to lock the shared transient terminates, this lock is also discharged and the next 
process logging in will then lock the shared transient and register for thin-client connection balancing.`
	)
	CnManagerClass completeDefinition
	(
	jadeMethodDefinitions
		cnDefineTransientsToIgnore(pObjectArray: ObjectArray input) number = 1003;
	)
	CnBatchMgr completeDefinition
	(
		documentationText
`This class encapsulates, as far as is possible, functionality to allow communication with JSA by
an SDS secondary / RPS node that is likely to be updating CardSchema structures and may therefore
require CardSchema class agents to be unloaded.  

Related CardSchema classes are limited to CardSchema (app) and CnDeployMgrTcpConnection.`
	attributeDefinitions
		environmentName:               String[31] number = 7, ordinal = 7;
		documentationText
`Max 30 bytes won't be exceeded as group name cannot exceed 20 characters
(where the group name is the account, aka environment name, suffixed by _g, _m or _d)`
		negotiatedTakeOverRequest:     Boolean protected, number = 4, ordinal = 4;
		secondaryNameArray:            StringArray protected, subId = 1, number = 5, ordinal = 5;
		secondaryNameHoldArray:        StringArray protected, subId = 2, number = 6, ordinal = 6;
	referenceDefinitions
		initParams:                    HugeStringArray  number = 3, ordinal = 3;
		myLog:                         File  number = 1, ordinal = 1;
	jadeMethodDefinitions
		create() updating, number = 1004;
		doAuditStopTracking(reason: Integer) number = 1012;
		exceptionHandler(exObj: Exception): Integer number = 1006;
		exceptionHandler_CreateRpsDatabase(
			exObj: Exception; 
			hadException: Boolean output): Integer number = 1032;
		exceptionHandler_rpsExtract(exObj: Exception): Integer number = 1040;
		initialize() updating, number = 1043;
		log(text: String) clientExecution, number = 1005;
		sendResponse(msg: Binary) number = 1009;
		setDeploymentStatus(status: Integer) updating, number = 1001;
		timerEvent(eventTag: Integer) updating, number = 1003;
		userNotification(
			eventType: Integer; 
			theObject: Object; 
			eventTag: Integer; 
			userInfo: Any) updating, number = 1022;
		userNotification_zAnalyzeTransients(
			pProcess: Process; 
			pUserInfo: String) protected, number = 1033;
		userNotification_zTransientFileAnalysis(
			pProcess: Process; 
			pUserInfo: String) protected, number = 1034;
		userNotification_zTransientFileInfo(
			pProcess: Process; 
			pUserInfo: String) protected, number = 1035;
		zActivateDeltaDb() protected, number = 1013;
		zCloseCurrentJournal() protected, number = 1021;
		zCreateRpsDatabase() protected, number = 1020;
		zCycleKCCMgr() protected, number = 1023;
		zDeactivateDeltaDb() protected, number = 1014;
		zExtractDatabaseStructureInfo() protected, serverExecution, number = 1024;
		zExtractRpsData() protected, number = 1039;
		zForceUnhandledException() protected, number = 1011;
		zGenerateRpsTableCreationScript() protected, number = 1010;
		zGetApplicationCount() protected, number = 1007;
		zGetDeltaDatabaseStatus() protected, number = 1018;
		zGetProductionMode() protected, number = 1025;
		zGetStatus() protected, number = 1026;
		zGetTrackingStatus(
			tracking: Boolean output; 
			trackingStoppedReason: Integer output; 
			rpsTransitionHaltCode: Integer output) protected, number = 1027;
		zHandleActions(pAction: String) updating, protected, number = 1019;
		zInitiateSDSNegotiatedTakeOver() protected, number = 1028;
		zInitiateSDSPreTakeOver() protected, number = 1029;
		zReportError(pErrorMsg: String) protected, number = 1015;
		zResetUserAppliedPatches() protected, number = 1041;
		zRestartKCCMgr(): Boolean protected, serverExecution, number = 1030;
		zSendAppServerNotification() protected, number = 1008;
		zStartTracking() protected, serverExecution, number = 1031;
		zStopKCCMgr(): Boolean protected, number = 1016;
		zSwitchJournal() protected, number = 1002;
		zTransientAnalysis() protected, number = 1036;
		zTransientFileCompact() protected, number = 1037;
		zTransientInfo() protected, number = 1038;
		zValidateUser() protected, number = 1017;
		zVerifyCardSchemaVersion() protected, number = 1042;
	)
	CnJadeCareExecutor completeDefinition
	(
	attributeDefinitions
		executeFunction:               String readonly, subId = 1, number = 2, ordinal = 2;
		fileIndex:                     Integer readonly, number = 3, ordinal = 3;
		fileName:                      String readonly, subId = 2, number = 4, ordinal = 4;
	referenceDefinitions
		parameters:                    HugeStringArray  readonly, number = 1, ordinal = 1;
	jadeMethodDefinitions
		executeCardSchemaValidateMethods(
			pExecuteFunction: String; 
			pItemIndex: Integer; 
			pItemName: String; 
			pParameters: HugeStringArray) updating, number = 1005;
		executeJadeRecompileAllMethods(
			pExecuteFunction: String; 
			pItemIndex: Integer; 
			pItemName: String; 
			pParameters: HugeStringArray) updating, number = 1006;
		executeJadeReorgApp(
			pExecuteFunction: String; 
			pItemIndex: Integer; 
			pItemName: String; 
			pParameters: HugeStringArray) updating, number = 1003;
		executeJadeSchemaLoader(
			pExecuteFunction: String; 
			pItemIndex: Integer; 
			pItemName: String; 
			pParameters: HugeStringArray) updating, number = 1001;
		sysNotification(
			eventType: Integer; 
			theObject: Object; 
			eventTag: Integer) updating, number = 1002;
		userNotification(
			eventType: Integer; 
			theObject: Object; 
			eventTag: Integer; 
			userInfo: Any) updating, number = 1004;
		zLoadSelf(
			pExecuteFunction: String; 
			pFileIndex: Integer; 
			pFileName: String) updating, protected, number = 1007;
	)
	CnSecurityManager completeDefinition
	(
	jadeMethodDefinitions
		getCertificateDetails(
			pFileName: String; 
			pSubject: String output; 
			pExpiryDate: Date output): Boolean number = 1001;
	)
	CnStartManager completeDefinition
	(
	jadeMethodDefinitions
		startMonitorBackgroundOnServer(): Integer serverExecution, number = 1001;
	)
	CnNameSizeInfo completeDefinition
	(
	attributeDefinitions
		extentSize:                    Decimal[18] readonly, number = 1, ordinal = 1;
		initialSize:                   Decimal[18] readonly, number = 2, ordinal = 2;
		name:                          String[257] readonly, number = 3, ordinal = 3;
		path:                          String[257] readonly, number = 4, ordinal = 4;
		restoredSize:                  Decimal[19] readonly, number = 5, ordinal = 5;
		size:                          Decimal[19] readonly, number = 6, ordinal = 6;
	jadeMethodDefinitions
		loadSelf(
			pName: String; 
			pDec: Decimal) updating, number = 1002;
		setMapFileItems(
			pPath: String; 
			pRestoreSize: Decimal; 
			pInitialSize: Decimal; 
			pExtentSize: Decimal) updating, number = 1004;
		setSize(pDec: Decimal) updating, number = 1003;
	)
	CnQueuedLockDepth completeDefinition
	(
	attributeDefinitions
		count:                         Integer number = 1, ordinal = 1;
	referenceDefinitions
		myProcess:                     Process  number = 2, ordinal = 2;
	)
	CnSchemaElement completeDefinition
	(
	attributeDefinitions
		appName:                       String[221] readonly, number = 1, ordinal = 8;
		appSchemaName:                 String[101] readonly, number = 6, ordinal = 9;
		lastModified:                  TimeStamp readonly, number = 5, ordinal = 6;
		schemaFileType:                Character readonly, number = 4, ordinal = 2;
		documentationText
`
S = schema file, D = ddb file.
Used for schema elements that are children of a Server object i.e. the record of RootSchema hot fixes that have been loaded.`
	jadeMethodDefinitions
		getName(): String number = 1004;
		loadSelf(
			pSchema: String; 
			pName: String; 
			pVersionTag: String; 
			pFileType: Character; 
			pLastModified: TimeStamp) updating, number = 1005;
	)
	CnVariant completeDefinition
	(
		documentationText
`Used for an 'any array' (see CnVariantArray).  For an example of
usage, see CardSchema::cnGlobalDeadLockExHandler.`
	attributeDefinitions
		oidString:                     String[181] readonly, number = 4, ordinal = 2;
		documentationText
`As of JADE 7.1 the class name can now be 100 bytes and the class numbers and instance ids can be up to Max_Integer64 which is 19 bytes, so we
need to cater for the largest oid string which is that of an exclusive collection (<class name>/<dict class num>.<parent instance>.<parent class>:<nnn>).

Object reference.  In JADE 5.2 max length of oid string is about 30 bytes, 
however this makes handsome allowance for future expansion.

This property was added for CardSchema 2.9.01 and the former direct
reference 'myObject' was deleted because of problems with sharing
exclusive references (1013 exceptions).`
		value:                         Binary protected, subId = 1, number = 1, ordinal = 3;
	referenceDefinitions
		myType:                        Type  protected, number = 2, ordinal = 1;
	jadeMethodDefinitions
		getValue(): Any number = 1002;
		setValue(val: Any) updating, number = 1001;
	)
	Connection completeDefinition
	(
	)
	NamedPipe completeDefinition
	(
	)
	CnNamedPipe completeDefinition
	(
		documentationText
`This is a preliminary version of the class, implemented for subschemas in the 
JADE Systems Manager suite.  While you may use it, it is not yet completed and
is therefore not fully supported.

However, please feel free to report any problems to cardschema@jade.co.nz.`
	attributeDefinitions
		connectionNo:                  Integer readonly, number = 5, ordinal = 1;
		headerLength:                  Integer readonly, number = 4, ordinal = 2;
		msgHeader:                     Binary[30] protected, number = 1, ordinal = 3;
		msgHeaderLength:               Integer protected, number = 2, ordinal = 4;
		retryNo:                       Integer readonly, number = 6, ordinal = 6;
	referenceDefinitions
		myReceiver:                    Object  readonly, number = 3, ordinal = 5;
	jadeMethodDefinitions
		cnArmNamedPipeExceptionHandler() number = 1007;
		cnClose(receiver: Object) updating, number = 1004;
		cnCloseNotify(tcp: CnNamedPipe input) updating, number = 1005;
		cnGetBodyLength(
			buf: Binary; 
			preambleLength: Integer): Integer protected, number = 1015;
		cnHaltConnection() updating, number = 1003;
		cnListen(
			portNo: Integer; 
			receiver: Object) updating, number = 1006;
		cnListenNotify(tcp: CnNamedPipe input) updating, number = 1009;
		cnOpen(
			computer: String; 
			pipeName: String; 
			receiver: Object) updating, number = 1001;
		cnOpenNotify(tcp: CnNamedPipe input) updating, number = 1008;
		cnProcessHeader(buf: Binary): Integer updating, number = 1013;
		cnRaiseConnectionException(
			errorCode: Integer; 
			errorText: String) updating, protected, number = 1016;
		cnRead(receiver: Object) updating, number = 1010;
		cnReadNotify(
			tcp: CnNamedPipe input; 
			buf: Binary) updating, number = 1011;
		cnReadNotifyHeader(
			tcp: CnNamedPipe input; 
			buf: Binary) updating, number = 1012;
		cnSetMyReceiver(receiver: Object) updating, number = 1002;
		cnWrite(
			body: Binary; 
			receiver: Object) updating, number = 1018;
		cnWriteNotify(tcp: CnNamedPipe input) updating, number = 1019;
		user_cnBuildHeader(body: Binary): Binary updating, number = 1017;
		user_cnGetPreambleDefinition(): Binary number = 1014;
	)
	TcpIpConnection completeDefinition
	(
	)
	CnDeployMgrTcpConnection completeDefinition
	(
		documentationText
`Private class for JADECare Systems Management.  Not for general use. 

Used during deployments to SDS secondaries and RPS nodes.
See class CnBatchMgr.`
	constantDefinitions
		HEADER_LENGTH:                 Integer = 10 number = 1001;
	attributeDefinitions
		message:                       Binary[200] number = 1, ordinal = 1;
		msgHeader:                     Binary[10] readonly, number = 2, ordinal = 3;
	referenceDefinitions
		myCnBatchMgr:                  CnBatchMgr  number = 4, ordinal = 5;
	jadeMethodDefinitions
		buildHeader(body: Binary): Binary number = 1001;
		cnGetBodyLength(
			buf: Binary; 
			preambleLength: Integer): Integer protected, number = 1008;
		cnOpen(
			computer: String; 
			portNo: Integer; 
			receiver: Object) updating, number = 1004;
		cnOpenNotify(tcp: CnDeployMgrTcpConnection input) updating, number = 1005;
		cnProcessHeader(buf: Binary): Integer updating, number = 1007;
		cnRead() number = 1010;
		cnReadNotify(
			tcp: CnDeployMgrTcpConnection io; 
			buf: Binary) updating, number = 1006;
		cnReadNotifyHeader(
			tcp: CnDeployMgrTcpConnection input; 
			buf: Binary) updating, number = 1009;
		cnWrite(
			body: Binary; 
			receiver: Object) updating, number = 1011;
		cnWriteNotify(tcp: CnDeployMgrTcpConnection input) updating, number = 1012;
		getPreambleDefinition(): Binary number = 1002;
		integerToString(
			stringlength: Integer; 
			int: Integer): String number = 1003;
	)
	CnTcpConnection completeDefinition
	(
		documentationText
`				+-------------------------------------+
                |   CardSchema (Jade) Class Library   |
                +-------------------------------------+

This material is proprietary to Cardinal Group Limited (Cardinal) and is  
not to be reproduced, used or disclosed except upon written permission of     
Cardinal.                                                                     

   COPYRIGHT (C) AORAKI CORPORATION LIMITED 1998 - ALL RIGHTS RESERVED
__________________________________________________________________________________________________

   				CnTcpConnection Class Version 2.0  21/11/97
				===========================================

This class provides methods and logging which attempt to simplify the process of coding TCP/IP
communications with another application and/or host.  So that subsequent updates of this
class can be installed, you should normally install this into your CardSchema, and subclass
the class before using it.  It is recommended that you not directly modify the methods
provided, so that subsequent updates can be applied.  Some user exit methods (titled user_cnXXX)
are provided where user code may be needed in the middle of a provided method.

Refer to the CardSchema Class Library User Guide, and the README.TXT file on the class library 
release disk, for more information. 

The core methods provided are:

	cnOpen					// opens a connection to defined target
	cnListen				// listens for single connection on port
	cnListenContinuous		// listens for multiple connections on port
	cnRead					// starts an asynchronous readBinary
	cnWrite					// prefixes the message body submitted in buffer with a header and sends it
	cnClose					// closes a connection

Each of the above methods has at least one callback notification method :

	cnOpenNotify						// occurs when an Open has been completed
	cnListenNotify						// occurs when someone connects to your listening object
	cnListenNotifyContinuous			// occurs when someone connects to your continuous listening obect
	cnReadNotify Header					// occurs when a header is read
	cnReadNotify                        // occurs when message body is read
	cnWriteNotify						// occurs when a write is completed
	cnCloseNotify						// occurs when a close operation is completed

Dependencies:
-------------

At time of writing, this class requires Jade 4.08 or higher.  
For reliable TCP operation, we recommend NT 4.0 Service Pack 3 or later.

Note that there are a number of booleans defined in CnCntrl that can be set up to
activate full or selective logging to flat file cn_comms.log.  Also, the path for this log
may be defined in CnCntrl.commsLogPath, or it will default to c:\temp.  

For sample use of these classes see sample schema CHAT.SCM.  In particular see the ChatForm::load
event for startup procedures.

Binary Body Data
----------------

In this class, start-of-header is denoted by SOH followed by "CNW".
In the event of a corrupt header being received by this class, it will attempt to locate
the start of a new header by searching for this sequence. 

-------------------------------------------------------------------------------------------------------
Author : Richard Mitchell, Jade Systems Group, JADE Direct, JADE Software Corporation Ltd., New Zealand`
	constantDefinitions
		Close:                         String = "C" number = 1001;
		Connection_Retry_Timer:        Integer = 22 number = 1002;
		ContinuousListener:            String = "A" number = 1003;
		ContinuousListenerMaster:      String = "M" number = 1004;
		Listen:                        String = "L" number = 1005;
		Listener:                      String = "L" number = 1006;
		Open:                          String = "O" number = 1007;
		Opener:                        String = "O" number = 1008;
		Read:                          String = "R" number = 1009;
		Write:                         String = "W" number = 1010;
	attributeDefinitions
		cnPort:                        Integer readonly, number = 15, ordinal = 1;
		documentationText
`
Port used for connection.  Copy of TcpIpConnection class property 'port'.  
Expected to become a virtual property in JADE 5.2.  CardSchema uses it
as a dictionary key so cnPort is new for CardSchema 2.7.`
		cnRetryTimerRunning:           Boolean readonly, number = 1, ordinal = 2;
		computerName:                  String[66] readonly, number = 2, ordinal = 3;
		connectionNo:                  Integer readonly, number = 3, ordinal = 4;
		connectionType:                String[2] readonly, number = 4, ordinal = 5;
		headerLength:                  Integer readonly, number = 5, ordinal = 6;
		documentationText
`Message header length : STX + numeric field describing the length of the message body.
"Numeric field" means right justified with preceding zeros i.e. COBOL PIC 9(nn) DISPLAY`
		lastAction:                    String[2] readonly, number = 6, ordinal = 7;
		lastIpAddress:                 String[66] readonly, number = 7, ordinal = 8;
		lastPort:                      Integer readonly, number = 8, ordinal = 9;
		msgHeader:                     Binary[30] protected, number = 9, ordinal = 10;
		msgHeaderLength:               Integer protected, number = 14, ordinal = 11;
		remoteId:                      String[129] readonly, number = 10, ordinal = 14;
		documentationText
`This property can contain EITHER an IP address or a computer name (for fully qualified domain name).
If Jade can't or doesn't resolve the IP address then the remote id will be the IP address.`
		retryNo:                       Integer readonly, number = 11, ordinal = 15;
	referenceDefinitions
		myCnCntrl:                     CnCntrl   explicitEmbeddedInverse, readonly, number = 12, ordinal = 12;
		myReceiver:                    Object  readonly, number = 13, ordinal = 13;
	jadeMethodDefinitions
		cnArmConnectionResponseTimer() updating, number = 1001;
		cnArmTcpExceptionHandler() updating, number = 1002;
		cnBumpRetryNo() updating, number = 1003;
		cnClose(receiver: Object) updating, number = 1004;
		cnCloseNotify(tcp: CnTcpConnection input) updating, number = 1005;
		cnGetBodyLength(
			buf: Binary; 
			preambleLength: Integer): Integer protected, number = 1040;
		cnGetLastActionString(): String number = 1006;
		cnGetNextJossIpAddress(): Integer updating, number = 1045;
		cnGetStateString(): String number = 1044;
		cnHaltConnection() updating, number = 1007;
		cnIntegerToString(
			stringlength: Integer; 
			int: Integer): String number = 1008;
		cnJossTcpRestart(): Boolean updating, number = 1009;
		cnKillConnection() updating, number = 1010;
		cnListen(
			portNo: Integer; 
			receiver: Object) updating, number = 1011;
		cnListenContinuous(
			portNo: Integer; 
			receiver: Object) updating, number = 1012;
		cnListenContinuousNotify(
			tcplisten: CnTcpConnection; 
			tcp: CnTcpConnection input) updating, number = 1013;
		cnListenNotify(tcp: CnTcpConnection input) updating, number = 1014;
		cnOpen(
			computer: String; 
			portNo: Integer; 
			receiver: Object) updating, number = 1015;
		cnOpenNotify(tcp: CnTcpConnection input) updating, number = 1016;
		cnProcessHeader(buf: Binary): Integer updating, number = 1017;
		cnRaiseConnectionException(
			errorCode: Integer; 
			errorText: String) updating, protected, number = 1039;
		cnRead(receiver: Object) updating, number = 1018;
		cnReadNotify(
			tcp: CnTcpConnection input; 
			buf: Binary) updating, number = 1019;
		cnReadNotifyHeader(
			tcp: CnTcpConnection input; 
			buf: Binary) updating, number = 1020;
		cnReadNotifyUserInfo(pBuffer: Binary): String number = 1041;
		cnSetCnRetryTimerRunning(set: Boolean) updating, number = 1021;
		cnSetConnectionNo(connection: Integer) updating, number = 1022;
		cnSetConnectionType(type: String) updating, number = 1023;
		cnSetHeaderLength(length: Integer) updating, number = 1024;
		cnSetLastAction(action: String) updating, number = 1025;
		cnSetMyCnCntrl(cnCntrl: CnCntrl) updating, number = 1026;
		cnSetMyReceiver(receiver: Object) updating, number = 1027;
		cnSetRemoteId(id: String) updating, number = 1028;
		cnWrite(
			body: Binary; 
			receiver: Object) updating, number = 1029;
		cnWriteNotify(tcp: CnTcpConnection input) updating, number = 1030;
		cnWriteSync(buf: Binary) updating, number = 1031;
		cnWriteUserInfo(pBuffer: Binary): String number = 1042;
		getNextJossIpAddress(): Integer updating, number = 1043;
		setCnPort(prt: Integer) updating, number = 1038;
		timerEvent(eventTag: Integer) updating, number = 1032;
		user_cnBuildHeader(body: Binary): Binary updating, number = 1033;
		user_cnGetPreambleDefinition(): Binary number = 1034;
		user_cnIssueErrorMsg(exObj: Exception) updating, number = 1035;
		user_cnTcpExceptionHandler(exObj: Exception): Integer updating, number = 1036;
		user_cnTcpRestart(): Integer updating, number = 1037;
	)
	CnKarmaTcpConnection completeDefinition
	(
	constantDefinitions
		TCP_Disconnected:              Integer = 203 number = 1001;
		TCP_Open:                      Integer = 201 number = 1002;
		TCP_Open_Complete:             Integer = 202 number = 1003;
	attributeDefinitions
		managedEnvironmentName:        String[31] readonly, number = 3, ordinal = 3;
		protocolVersion:               Integer readonly, number = 1, ordinal = 1;
	jadeMethodDefinitions
		cnOpenNotify(tcp: CnKarmaTcpConnection input) updating, number = 1001;
		cnProcessHeader(buf: Binary): Integer updating, number = 1002;
		cnReadNotify(
			tcp: CnKarmaTcpConnection input; 
			buf: Binary) updating, number = 1003;
		cnReadNotifyHeader(
			tcp: CnKarmaTcpConnection input; 
			buf: Binary) updating, number = 1004;
		cnReadNotifyHeaderExt(
			tcp: CnKarmaTcpConnection input; 
			buf: Binary) updating, number = 1005;
		setManagedEnvironmentName(pValue: String) updating, number = 1009;
		setProtocolVersion(version: Integer) updating, number = 1006;
		user_cnBuildHeader(pBody: Binary): Binary updating, number = 1008;
	)
	CnSmtpConnection completeDefinition
	(
		documentationText
`_______________________________________________________________________________________________________________________________________________________________________________

							P R O P R I E T A R Y   N O T I C E

		This software, in whole and in every part, is proprietary to Jade Software
		Corporation Limited at Christchurch, New Zealand and is not to be
		reproduced, used or disclosed except upon prior written permission of Jade
		Software Corporation Limited.
	
	   	COPYRIGHT (c) JADE SOFTWARE CORPORATION LIMITED 2019-2012 - ALL RIGHTS RESERVED

_______________________________________________________________________________________________________________________________________________________________________________


       ******************** C n S m t p C o n n e c t i o n   C l a s s  ***********************  

The Word for Windows document SMTPClass.doc ("User Guide, CnSmtpConnection Class"), which
is available from the JADE Systems Group, contains the full documentation for this class.

The text below gives the Overview, Dependencies and Quick Tutorials from that document.

_______________________________________________________________________________________________________________________________________________________________________________


									O V E R V I E W

The CnSmtpConnection class allows a JADE application to send mail. It implements the minimum
level of the SMTP protocol, as defined in RFC 821 and RFC 2821. 

An application sends a mail message by performing the following steps:

	- creating a CnSmtpConnection object
	- setting the object's properties (for example, 'sendFrom', 'sendTo', 'subject', and 'message')
	- calling the object's 'send' method

The message is sent asynchronously: in other words, the 'send' method returns immediately, without
waiting for the message transfer to complete. When the message has been accepted by the mail server,
a user notification is generated against the CnSmtpConnection object, with an eventType of
Completion_Event_Type. 

A message can be the contents of a string, or the contents of a disk file.

Messages can be sent as plain text, or as HTML.

You can send multiple file attachments with your message. An attachment can be any type of file:
for example, a text file, a WORD document, an Excel spreadsheet, an image, a movie, or a sound file.

Note: The constant Completion_Event_Type currently has a value of 20, but you can change this value
if it conflicts with other user notification eventTypes in your system.

_______________________________________________________________________________________________________________________________________________________________________________


								D E P E N D E N C I E S

The CnSmtpConnection class is a subclass of the CnTcpConnection class in CardSchema. 

The CnSmtpConnection class requires

- the CnMIME class
- the CnSmtpInline class
- the CnAttachment class
- the CnAttachmentArray class
- the CnSmtpInlineArray class
- the CnSmtpState class
- the subclasses of CnSmtpState
- the CnSmtpConnectionException class

The sending machine must be capable of establishing a TCP/IP connection, as the TCP protocol
is used for carrying the SMTP exchanges with the mail server.

The CardSchema file karma.dll must be in your JADE Bin directory.

JADE versions below 4.1 are not supported.
_______________________________________________________________________________________________________________________________________________________________________________


							  Q U I C K   T U T O R I A L S

							S e n d i n g   A   M e s s a g e

Note: This code assumes that you have already instantiated a cnKarmaCntrl object
(preferably in the Application::initialize method, using CardSchema::cnActivateKarmaCntrl).

To send the message "Have a nice day!", write the following code in a form method,
changing the parameter values to suit your situation:

vars

	sm:CnSmtpConnection;

begin

	create sm;											// Create SMTP Control

	//Subscribe to message completion notification

	self.beginNotification(sm, CnSmtpConnection.Completion_Event_Type, Response_Cancel, 0); 											

	/* Trap validation exceptions in a local exception handler ("validationExceptionHandler",
	   which is NOT part of the CnSmtpConnection class). */

	on CnSmtpConnectionException do validationExceptionHandler(exception);	

	sm.clientName	:=	"cnwxyz1a.smg.cnw.co.nz";		// Set up mail client name: this is the machine sending the mail
	sm.name			:=	"cnwsmtp.cnw.co.nz";           	// Set up mail server name

	sm.sendFrom		:=	"jsmith@cardinal.co.nz";  		// Who the message is from ...							
	sm.sendTo		:=	"ajones@cardinal.co.nz"; 		// Who the message is to ...
	sm.subject		:=	"This is a test message";		// The message subject ...                    		
    sm.message		:=	"Have a nice day!";				// The message text itself ...
    sm.send; 											// Send it!                                                             

end;

_______________________________________________________________________________________________________________________________________________________________________________


							S e n d i n g   A   M e s s a g e   W i t h   A t t a c h m e n t s


This example shows how to send the message "Here are some attachments", which has two attachments,
an Excel spreadsheet and a video clip.


vars

	attachment	:	CnAttachment;
	sm			:	CnSmtpConnection;

begin

	create sm;										// Create SMTP Control

	// Subscribe to the notification 
	self.beginNotification(sm, CnSmtpConnection.Completion_Event_Type, Response_Cancel, 0);

	//Arm my local exception handler 											
	on CnSmtpConnectionException do validationExceptionHandler(exception);

	//Set up the mail client name: this is the machine sending the mail		
	sm.clientName	:=	"cnwxyz1a.smg.cnw.co.nz";		

	//Set up the mail server name
	sm.name			:=	"cnwsmtp.cnw.co.nz";                	

	//Set up the message parameters
	sm.sendFrom		:=	"jsmith@cardinal.co.nz";			// Who the message is from ...							
	sm.sendTo		:=	"ajones@cardinal.co.nz";  			// Who the message is to ...
	sm.subject		:=	"Message with attachments";			// The message subject ...                    		
    sm.message		:=	"Here are some attachments";		// The message text itself ...

    //Create the attachment for the spreadsheet file
    create attachment;								
    attachment.fileName			:=	"C:\Excel\network.xls";	
	attachment.mySmtpConnection	:=	sm;

	//Create the attachment for the video clip
	create attachment;
    attachment.fileName			:=	"C:\WINNT\clock.avi";	
	attachment.mySmtpConnection	:=	sm;

    //Send the message and its attachments
    sm.send; 										

end;

_______________________________________________________________________________________________________________________________________________________________________________


				C h e c k i n g   T h a t   t h e   M e s s a g e   H a s   B e e n   S e n t


A notification is generated when the message has been accepted by the mail server,
or when an error occurs.

In the above examples, we subscribed to the Completion_Event_Type notification on
the CnSmtpConnection object, specifying the form as the receiver. The userNotify method
of the form is therefore called when the notification arrives.

In this example, we display a message on the form's status line if the message was sent
successfully. If an error occurred, we display a message box.

userNotify(eventType : Integer; theObject : Object; eventTag : Integer; userInfo : Any) updating;

vars
	sm	:	CnSmtpConnection;

begin
	sm	:=	theObject.CnSmtpConnection;

// Show a message box if an error occurred
	if sm.result.bitAnd(CnSmtpConnection.Error_Occurred) <> null then
		app.msgBox(sm.extendedErrorText,  "SMTP Error " & sm.errorCode.String,	MsgBox_OK_Only);
	else
	    statusLine.caption := "Message sent";
	endif;

	delete sm;
end;


_______________________________________________________________________________________________________________________________________________________________________________`
	constantDefinitions
		Avi:                           String = "video/x-msvideo" number = 1001;
		Base64:                        String = "base64" number = 1002;
		Bmp:                           String = "image/bmp" number = 1003;
		Boundary_Equals:               String = "boundary=" number = 1004;
		CN_VERSION:                    Integer = 29 number = 1005;
		documentationText
`Version 29
12.10.07	Remove reference to isValidObject and unncessary local variables

Version 28

30.08.07	PAR 413. Attachment with trailing period caused 4031 exception when trying to determine content-type using file
			type (suffix).
			
			CnSMTPConnection::initializeMIMEEntity

Version 27

30.01.06	Non-compliance with RFC 2045 : attachment file names in header followed by superfluous semicolon : caused
			problems with latest version of GroupWise.  Patches in CnSmtpStateDATA::sendFileAttachments and ::sendInLines.

Version 26

25.06.04	Provide for keeping SMTP connection open between email messages.
			Add timings of open and message elapsed times when logging set.
			CnSmtpStateDATASent::do250 (V2)
			CnSmtpStateRSET::do250 (V2)
			CnSmtpConnection new attributes d1Open, d1Message, d2Open, d2Message type Decimal[20]
			CnSmtpConnection::cnOpenNotify (V4)
			CnSmtpConnection::delete (V6)
			CnSmtpConnection::resetConnectionObject (V5)
			CnSmtpConnection::send (V
			CnSmtpConnection::setCompleted (V2)

Version 25

17.03.04	To: addressee was always preceded by CrLf (caused problems for MailMarshal).  Fixed in CnSmtpConnection
			::buildMessageHeader V7.  See PAR #106.

Version 24

04.09.03	If the message was being read from a file, and an exception occurred, the file was not closed. See PAR #49.
			CnSmtpConnection::validationExceptionHandler (V4).
			
			Allow file attachments of zero length. See PAR #52.
			CnSmtpStateDATA::sendFileAttachments (V7).
			
			Allow user to specify whether an attachment file is on the presentation client or the app server. See PARS #53 and 67.
			CnSmtpConnection::initializeMIMEEntity (V4). New attribute physicalFileLocation on CnMIME class.
			
			Send RSET after getting validation error in DATA state.
			CnSmtpConnection::validationExceptionHandler (V5).
			
			Disconnect TCP/IP on validation error, if user requested it. This ensures that the whole message, with attachments, gets aborted.
			See PAR #73.
			CnSmtpConnection::validationExceptionHandler (V6).
			CnSmtpConnection: new attribute disconnectOnValidationError.
			
			CnSmtpConnection::resetConnectionObject (V4) - set disconnectOnValidationError to false;
			
Version 23	

05.02.03	Move 'MIME Version 1.0' statement to main message header. Microsoft clients did not complain about this,
			but Novell GroupWise did. Previously, the MIME statement was located after the message boundary that 
			followed the main message header.
			
			CnSmtpConnection::buildMessageHeader (V5).
			
Version 22	New attribute CnSmtpConnection.removeStatesOnDeletion. If set to true, will cause CnSmtpState
			objects to be deleted when the CnSmtpConnection object is deleted (but only if there are no
			other instances of CnSmtpConnection or its subclasses in the process).
			
			CnSmtpConnection::delete (V5).
			CnSmtpConnection::deleteStateObjects (new method).
			CnSmtpConnection::resetConnectionObject (V3).
			
			CnSmtpConnection::parseRecipients (V3). Moved array clear code to start of method.
			If pRecipientList is null, arrays will now be null.
			
Version 21	Reimplemented CnSmtpConnection::cnCloseNotify, and now send completion notification from there.
			It was possible to get into a situation where the completion notification, sent from the state
			machine, arrived before the cnClose callback did. If the user was deleting the connection object
			in a userNotification method, this meant that JADE could not find a connection object to call back.
			This didn't result in any loss of data, but no "successfully closed" message would appear in the
			CardSchema log.
			
			CnSmtpConnection::cnCloseNotify (new method).
			CnSmtpState::do421 (V3).
			CnSmtpState::findastLine (V2).
			CnSmtpStateQUIT::do221 (V2).
			
			Released to internal Beta testers (JHA) only.
			
Version 20

26.06.02	CnSmtpConnection.extendedErrorText contains no text on errors 31004 (Connection failed to establish)
			and 31002 (Invalid connection host).
 
			CnSmtpConnection::user_cnTcpExceptionHandler (V2) modified to concatenate the exception object 'text' string
			and the property extendedErrorText.

Version 19

23.05.02	Ensure Base64-encoded lines do not exceed 76 characters when new attachment block read.
			Base64-encoded lines must not exceed 76 characters. Most email clients seem more tolerant of longer
			lines, but Novell GroupWise is not. A line could exceed 76 characters when the first line of a new block
			was appended to the last line of the previous block.
			
			Changed CnSmtpStateDATA::sendFileAttachments (V6).
			
			We should also check at some stage whether the CnSmtpStateDATA::sendInLines method needs similar changes.    
			 
Version 18

18.01.02	Allow user to set shareMode for a cnMIME entity (NFS from JHA).
			CnSmtpConnection::initializeMIMEEntity (V3). New constant CnSmtpConnection::MIMEShareModeFlag.
	
Version 17

14.01.02	Cater for recipient string that ends with a semicolon (e.g. fbloggs@jade.co.nz;). The string should never 
			end with a semicolon, but if it does, it causes an index exception.
			
			parseRecipients (V2).
			
Version 16	

21.06.01	Cater for behaviour of JungleDrum mail server. This mail server sends a 554 (fatal error) when it can't deliver to a recipient.
				CnSmtpStateRCPT::do554 (new method).
			
22.06.01	Allow user to specify unqualified email addresses (addresses without an '@' sign or domain):
				New Boolean allowUnqualifiedNames
				Changed method checkNameLength (V3).
			
Version 15

20.06.01	Fix bug whereby self.serverMessage was being cleared on each cnRead. Multiple buffers from the 
			server were therefore not being concatenated in serverMessage.
			
			The serverMessage property should not be cleared until we are ready to read a new message from the 
			server (a complete new message, not just a new buffer).
			
			Changes to the following methods:
			
			cnOpenNotify (V3)
			cnRead (V3)
			validationExceptionHandler (V3)
			CnSmtpState::ignore (V2)
			CnSmtpState::sendOK (V3)
			CnSmtpState::sendQUIT (V3)
			CnSmtpState::sendRSET (V3)
			CnSmtpStateDATA::do354 (V6)
			CnSmtpStateHELO::do250 (V5)
			CnSmtpStateMAIL::do250 (V4)
			CnSmtpStateRCPT::doRCPTAndDATA (V4)
			CnSmtpStateTCPConnected::do220 (V3)
			clearServerMessageAndRead (new method)
			resetConnectionObject (V2) [set 'completed' property to default of 'false'.]
			  
Version 14

21.09.00	Support for UNICODE systems.

			Changes to the following methods:
			
			(CnSmtpConnection)
			buildMessageHeader (V4)
			cnReadNotify (V3)
			cnWrite (V3)
			send (V3)
			validateMessage (V4)
			validationExceptionHandler (V2)
			
			(CnSmtpState)
			handleEvent (V3)
			sendOK (V2)
			sendQUIT (V2)
			sendRSET (V2)
			
			(CnSmtpStateDATA)
			do354 (V5)
			sendFileAttachments (V5)
			sendInlines (V2)
			
			(CnSmtpStateHELO)
			do250 (V4)
			
			(CnSmtpStateMAIL)
			do250 (V3)
			
			(CnSmtpStateRCPT)
			doRCPTandDATA (V3)
			
			(CnSmtpStateTCPConnected)
			do220 (V2)
			
	
Version 13

20.06.00	Support for inline images in HTML emails.
			Allow name to be sent with each recipient, and also with 'sender' and 'replyTo'.
			Literal error numbers replaced by constants.
			Base64 encode and decode rewritten in C and moved to karma.dll for efficiency.
			CnAttachment becomes a subclass of new class CnMIME; several CnAttachment properties and methods moved up to CnMIME.
			New class CnSmtpInline (subclass of CnMIME).
			Several properties changed to read-only, and 'get' methods made redundant.
			New class CnSmtpInlineArray, subclass of ObjectArray.

			New Methods	(CnSmtpConnection)					New Properties (CnSmtpConnection)

			adjustFileLocationBase							allInlines				sendToAddresses
			cnEBase64Encode									bccAddresses			sendToNames
			cnEBase64Decode                     			bccNames				senderAddress
			generateInlineBoundary                         	ccAddresses     		senderName
			genUniqueCID									ccNames					fileBase
			initializeMIMEEntity        					contentLocationBase		completed
			isRelative										inlineBoundary
			openMessageFile         						replyToAddress
			parseRecipients									replyToName
			resetConnectionObject                 			sendFromAddress
			separateNameAndAddress							sendFromName
			validateInlineContentType						

			New Method (CnSmtpStateDATA)

			sendInlines

			Changes to the following methods 
			(CnSmtpConnection)						(CnSmtpStateDATA)				(CnSmtpStateHELO)	(CnSmtpStateMAIL)

			buildMessageHeader	(V3)				do354				(V4)		do250	(V3)		do250	(V2)
            checkNameLength		(V2)				sendFileAttachments	(V4)
            cnClose				(V1)
            cnOpenNotify		(V2)
            create				(V4)
            delete				(V4)
            deleteFileObjects	(V2)				(CnSmtpStateRCPT)
            findContentType		(V2)
            stripBlanks			(V2) 				doRCPTandDATA		(V2)
            validate			(V3)				
            validateASCIIMessage(V4)
            validateMessage		(V3)

			(CnSmtpState)

			defaultServerErrorHandler	(V2)
			do421						(V2)
			handleEvent					(V2)
			markAsUndelivered			(V2)

			Redundant Methods (CnSmtpConnection)

			getAtLeastOneValidRecipient, getBoundary, getEditedMessage, getMessageFileName, getMessageFileObject,
			getMessageHeader, getMyAttachments, getRecipientArray, getRecipientArrayIndex, getServerMessage, 
			separateNameAndEmail, base64Encode, base64Decode.

Version 12

19.06.00	Correct error in version 11 whereby a truncated line followed by a line containing only LF was not being
			handled correctly. Changed CnSmtpConnection::validateASCIIMessage (V3).
Version 11

30.03.00	Cater for text file lines that straddle blocks.

			Previously, a line that straddled the end of one block and the beginning of the next block was treated as
			two separate lines. This led to problems with 'dot stuffing', which should only occur at the start of a
			genuine new line.

			CnSmtpConnection::validateMessage (V2) and validateASCIIMessage (V2) and send (V2).
			CnAttachment (V2) - removed getNextBlock method and made fileObject read-only.
			CnSmtpStateDATA (V3) ::do354 (V2) and sendFileAttachments (V3).

Version 10

16.12.99	Rewrote CnSmtpConnection::genDate (V2) to output time differential from GMT, and to insert day name
			and four-digit year in the date in the message header. Note that RFC 822 (written in 1982) specifies a
			two-digit year, but Microsoft Outlook generates a four-digit year. We now do as Microsoft does.

Version 9

27.09.99	No changes to CnSmtpConnection class, only to CnSmtpStateRCPT (V2):

			New method do501 (V1) traps '501' errors received from mail server, marks the recipient currently being 
			processed as 'undelivered', and continues to inform the mail server of the remaining recipients.

			Error 501 usually means that the recipient's mail address is badly formed.

			Previously, a 501 error would cause the message to be aborted (i.e. no recipient would receive it).

			Methods cantDeliver (V2) and doRCPTandDATA (V2) have had 'updating' removed from their signatures.

Version 8

21.07.99	New property loggingRequired; new method setLoggingRequired.
			create now reads ini file looking for Logging parameter in [SMTPClient] section, and sets loggingRequired accordingly.
			Default is now loggingRequired = false.
			User can set logging programmatically by calling setLoggingRequired(true).
			cnRead now checks to see if logging is required and only calls cnWriteLog if it is.
			Ditto cnWrite, cnWriteNotify and cnReadNotify, which have all been reimplemented to check for logging.	

Version 7

12.05.99	Change CnSmtpStateDATA::sendFileAttachments (V2) to send only last node of filename.
			New method CnSmtpStateDATA::getLastFilenameNode (V1) to find last node.


Version 6

11.05.99    raiseValidationException (V2) sets mySmtpConnection in the CnSmtpConnectionException (V2) object.

Version 5

26.04.99 	Method setCompleted (V2) in CnSmtpState deletes all file objects that were used while sending a message.
			setCompleted calls new method deleteFileObjects (V1) in CnSmtpConnection.
			delete method (V2) for CnSmtpConnection also calls deleteFileObjects to reduce code.	

Version 4 (Adoption by CardSchema):

Change properties 'from' and 'to' to 'sendFrom' and 'sendTo', as 'to' will become a JADE reserved word in the future.

Change property 'reply_to' to 'replyTo' to conform with the above.

Change delimiter for recipients from "," to ";".

Version 3 (Beta):

Changes to 'create' method: more robust checks on existence of state objects.

Optimisation of base64Encode and validateMessage.

Versions 1 and 2(Alpha):

Various optimisations, bug fixes and enhancements.`
		Charset_ISO_8859_1_only:       String = "ISO-8859-1" number = 1073;
		Charset_ISO_8859_1:            String = "charset=" & Charset_ISO_8859_1_only number = 1068;

		Charset_US_ASCII:              String = "charset=US-ASCII" number = 1006;
		Charset_UTF_8_only:            String = "UTF-8" number = 1072;
		Charset_UTF_8:                 String = "charset=" & Charset_UTF_8_only number = 1067;

		Completion_Event_Type:         Integer = 20 number = 1007;
		Content_Location:              String = "Content-Location: " number = 1008;
		Content_Transfer_Encoding:     String = "Content-transfer-encoding: " number = 1009;
		Content_Type:                  String = "Content-Type: " number = 1010;
		Content_Type_Multipart_Mixed:  String = "Content-Type: multipart/mixed;" number = 1011;
		Content_Type_Multipart_Related:String = "Content-Type: multipart/related;" number = 1012;
		ErrorBase:                     Integer = 100000 number = 1035;
		Err_Cant_Delete_State_Objects: Integer = ErrorBase + 22 number = 1013;
		Err_Cant_Find_Attachment:      Integer = ErrorBase + 17 number = 1014;
		Err_Cant_Find_Message_File:    Integer = ErrorBase + 10 number = 1015;
		Err_Double_Message_Definition: Integer = ErrorBase + 2 number = 1016;
		Err_Encoding_Error:            Integer = ErrorBase + 27 number = 1071;
		Err_Invalid_Address_Format:    Integer = ErrorBase + 19 number = 1017;
		Err_Invalid_AttachmentEncoding:Integer = ErrorBase + 18 number = 1018;
		Err_Invalid_CharacterSet:      Integer = ErrorBase + 25 number = 1069;
		Err_Invalid_Content_Type:      Integer = ErrorBase + 9 number = 1019;
		Err_Invalid_Encoding_For_ANSI: Integer = ErrorBase + 26 number = 1070;
		Err_Invalid_InlineEncoding:    Integer = ErrorBase + 20 number = 1020;
		Err_Invalid_Phys_File_Location:Integer = ErrorBase + 23 number = 1021;
		Err_Invalid_Recipient:         Integer = ErrorBase + 12 number = 1022;
		Err_Invalid_ReplyTo:           Integer = ErrorBase + 14 number = 1023;
		Err_Invalid_SendFrom:          Integer = ErrorBase + 11 number = 1024;
		Err_Invalid_Sender:            Integer = ErrorBase + 16 number = 1025;
		Err_Line_Exceeds_1000:         Integer = ErrorBase + 7 number = 1026;
		Err_Missing_State_Object:      Integer = ErrorBase + 21 number = 1027;
		Err_No_Control_Object:         Integer = ErrorBase + 0 number = 1028;
		Err_No_Mail_Server:            Integer = ErrorBase + 1 number = 1029;
		Err_No_SendFrom:               Integer = ErrorBase + 4 number = 1030;
		Err_No_SendTo:                 Integer = ErrorBase + 5 number = 1031;
		Err_Non_ASCII_Character:       Integer = ErrorBase + 8 number = 1032;
		Err_Sv_Xtensions_End_With_CrLf:Integer = ErrorBase + 24 number = 1033;
		Err_Too_Many_Recipients:       Integer = ErrorBase + 13 number = 1034;

		Error_And_Undelivered:         Integer = 3 number = 1036;
		Error_Occurred:                Integer = 1 number = 1037;
		Gif:                           String = "image/gif" number = 1038;
		HComments:                     String = "Comments: " number = 1039;
		HDate:                         String = "Date: " number = 1040;
		HFrom:                         String = "From: " number = 1041;
		HPrecedence:                   String = "Precedence: " number = 1042;
		HReplyTo:                      String = "Reply-To: " number = 1043;
		HSender:                       String = "Sender: " number = 1044;
		HSubject:                      String = "Subject: " number = 1045;
		HTo:                           String = "To: " number = 1046;
		Hcc:                           String = "cc: " number = 1047;
		Html:                          String = "html" number = 1048;
		Image:                         String = "Image" number = 1049;
		Jpeg:                          String = "image/jpeg" number = 1050;
		MIMEShareModeFlag:             Integer = 16 number = 1051;
		documentationText
`If the user specifies a shareMode for a CnMIME entity, this value must be ORd into the
CnMIME::shareMode property before doing the send. Otherwise, it is not possible to tell
whether the user wants to set a shareMode of 0 (Share_ReadWrite), or default to the standard
Share_Read shareMode.

Example:

create att;
att.mySmtpConnection	:=	smtp;
att.fileName			:=	"C:\dns\subnetExtract.txt";
att.shareMode			:=	File.Share_Write.bitOr(smtp.MIMEShareModeFlag);`
		MIME_Version:                  String = "MIME-Version: 1.0" number = 1052;
		Mpeg:                          String = "video/mpeg" number = 1053;
		No_Errors:                     Integer = 0 number = 1054;
		None:                          String = "none" number = 1055;
		OctetStream:                   String = "application/octet-stream" number = 1056;
		Plain:                         String = "plain" number = 1057;
		Quoted_Printable:              String = "quoted-printable" number = 1058;
		Seven_Bit:                     String = "7Bit" number = 1059;
		Subject_Encoded_Base64:        Character = "B" number = 1075;
		Subject_Encoded_Quoted_Printab:Character = "Q" number = 1074;
		Text:                          String = "text" number = 1060;
		Text_Html:                     String = "text/html" number = 1061;
		Text_Plain:                    String = "text/plain" number = 1062;
		Type_Equals:                   String = "type=" number = 1063;
		Undelivered_Recipients:        Integer = 2 number = 1064;
		Wav:                           String = "audio/x-wav" number = 1065;
		Zip:                           String = "application/x-zip" number = 1066;
	attributeDefinitions
		allowUnqualifiedNames:         Boolean number = 54, ordinal = 2;
		atLeastOneValidRecipient:      Boolean readonly, number = 1, ordinal = 3;
		authenticate:                  Boolean number = 66, ordinal = 66;
		bcc:                           String subId = 22, number = 2, ordinal = 4;
		bccAddresses:                  HugeStringArray readonly, subId = 10, number = 29, ordinal = 5;
		documentationText
		`Added in version 13.`
		bccNames:                      CnStringArray readonly, subId = 11, number = 34, ordinal = 6;
		documentationText
		`Added in version 13.`
		blockSize:                     Integer number = 3, ordinal = 7;
		boundary:                      String readonly, subId = 26, number = 4, ordinal = 8;
		cc:                            String subId = 21, number = 5, ordinal = 9;
		ccAddresses:                   HugeStringArray readonly, subId = 8, number = 35, ordinal = 10;
		documentationText
		`Added in version 13.`
		ccNames:                       CnStringArray readonly, subId = 9, number = 36, ordinal = 11;
		documentationText
		`Added in version 13.`
		charset:                       String[31] number = 67, ordinal = 67;
		clientName:                    String subId = 2, number = 6, ordinal = 12;
		comments:                      String subId = 23, number = 7, ordinal = 13;
		completed:                     Boolean readonly, number = 37, ordinal = 14;
		documentationText
`Added in Version 13.

Set to true at same time as completion notification is sent.`
		connectionIsOpen:              Boolean protected, number = 38, ordinal = 15;
		contentLocationBase:           String subId = 11, number = 39, ordinal = 16;
		documentationText
`Added in version 13, 21.06.00.

The contentLocationBase is added to relative contentLocations to produce absolute contentLocations.`
		contentType:                   String subId = 3, number = 8, ordinal = 17;
		d1Message:                     Decimal[20] protected, number = 59, ordinal = 59;
		d1Open:                        Decimal[20] protected, number = 57, ordinal = 57;
		d2Message:                     Decimal[20] protected, number = 60, ordinal = 60;
		d2Open:                        Decimal[20] protected, number = 58, ordinal = 58;
		disconnectOnValidationError:   Boolean number = 56, ordinal = 56;
		editedMessage:                 String readonly, subId = 4, number = 9, ordinal = 18;
		encodingType:                  String[31] number = 10, ordinal = 19;
		errorCode:                     Integer number = 11, ordinal = 20;
		errorItem:                     String subId = 28, number = 12, ordinal = 21;
		extendedErrorText:             String subId = 1, number = 13, ordinal = 22;
		fileBase:                      String subId = 20, number = 40, ordinal = 23;
		documentationText
`Added in version 13, 21.06.00.

The fileBase is added to relative filenames to produce absolute filenames.`
		inlineBoundary:                String readonly, subId = 5, number = 41, ordinal = 24;
		isUserEncoded:                 Boolean number = 42, ordinal = 25;
		documentationText
`Added in version 13.

Not used at present, but is a preparation for future encodings such as quoted-printable.

The encodingType property has been used, historically, to indicate that the CnSmtpConnection
object should take the message text and either perform some encoding on it (base64) or perform
no encoding (none).

In future we may add quoted-printable encoding.

It is possible that the user has already performed some encoding on the message before invoking the
CnSmtpConnection::send method: this is quite likely if quoted-printable HTML text is being sent.

This Boolean will allow the user to say 'I want to send a MIME Content-Transfer-Encoding of (for example)
"quoted-printable", but I don't want you to perform the encode: I've already done it'.

The default is false, meaning that encoding will be performed, as now, according to the value of the
encodingType property. This ensures upwards-compatibility.

Note: RFC 2045 refers to 'no encoding' as 'the identity coding transformation' (!). Clearly, to use the phrase 'no encoding' would
be far too simple.`
		keepConnectionOpen:            Boolean number = 43, ordinal = 26;
		documentationText
`If the 'keepConnectionOpen' attribute is true, then it is expected that user-logic
handling the SMTP completion event will executed the CnSmtpConnection::resetConnectionObject`
		loggingIniDefault:             Boolean readonly, number = 63, ordinal = 63;
		loggingRequired:               Boolean number = 14, ordinal = 27;
		loggingResponse:               Boolean readonly, number = 68, ordinal = 68;
		documentationText
		`Added for PAR 1044.`
		mailServer:                    String subId = 7, number = 15, ordinal = 28;
		message:                       String subId = 8, number = 16, ordinal = 29;
		documentationText
`String containing the message to be sent. The message can also be placed in a flat file, in which case
the name of the file should be assigned to "messageFile".

"message" and "messageFile" are mutually exclusive.`
		messageFileName:               String subId = 9, number = 17, ordinal = 30;
		messageHeader:                 String readonly, subId = 10, number = 18, ordinal = 32;
		password:                      String subId = 27, number = 65, ordinal = 65;
		documentationText
		`Required when using authentication`
		precedence:                    String subId = 24, number = 61, ordinal = 61;
		recipientArray:                HugeStringArray readonly, subId = 1, number = 19, ordinal = 36;
		recipientArrayIndex:           Integer readonly, number = 20, ordinal = 37;
		removeStatesOnDeletion:        Boolean number = 55, ordinal = 38;
		documentationText
`The SMTP state objects are retained and re-used by the process until
the attribute 'removeStatesOnDeletion' is set to true and the SMTP connection
object is deleted.

The default value is 'false'.`
		replyTo:                       String subId = 13, number = 21, ordinal = 39;
		replyToAddress:                String[2050] protected, subId = 19, number = 44, ordinal = 40;
		documentationText
`Added in version 13.

The max size is the same as the HugeStringArray element size.`
		replyToName:                   String[261] protected, number = 45, ordinal = 41;
		documentationText
`Added in version 13.

The max size is the same as the CnStringArray element size.`
		result:                        Integer number = 22, ordinal = 42;
		sendAttachmentsSync:           Boolean readonly, number = 62, ordinal = 62;
		sendFrom:                      String subId = 6, number = 23, ordinal = 43;
		sendFromAddress:               String[2050] readonly, subId = 12, number = 46, ordinal = 44;
		documentationText
`Added in version 13.

The max size is the same as the HugeStringArray element size.`
		sendFromArray:                 CnStringArray readonly, subId = 4, number = 32, ordinal = 45;
		documentationText
		`Redundant from version 13 onwards.`
		sendFromName:                  String[261] readonly, number = 47, ordinal = 46;
		documentationText
`Added in version 13.

The max size is the same as the CnStringArray element size.`
		sendTo:                        String subId = 17, number = 24, ordinal = 47;
		sendToAddresses:               HugeStringArray readonly, subId = 7, number = 48, ordinal = 48;
		sendToNames:                   CnStringArray readonly, subId = 5, number = 49, ordinal = 49;
		documentationText
		`Added in version 13.`
		sender:                        String subId = 14, number = 25, ordinal = 50;
		senderAddress:                 String[2050] protected, subId = 18, number = 50, ordinal = 51;
		documentationText
`Added in version 13.

The max size is the same as the HugeStringArray element size.`
		senderName:                    String[261] protected, number = 51, ordinal = 52;
		documentationText
`Added in version 13.

The max size is the same as the CnStringArray element size.`
		serverMessage:                 String readonly, subId = 15, number = 26, ordinal = 53;
		subject:                       String subId = 16, number = 27, ordinal = 54;
		undelivered:                   HugeStringArray subId = 6, number = 33, ordinal = 55;
		username:                      String subId = 25, number = 64, ordinal = 64;
		documentationText
		`Required when using authentication`
	referenceDefinitions
		allInlines:                    CnSmtpInlineArray   explicitInverse, readonly, subId = 3, number = 52, ordinal = 1;
		messageFileObject:             File  readonly, number = 28, ordinal = 31;
		myAttachments:                 CnAttachmentArray   explicitInverse, subId = 2, number = 53, ordinal = 33;
		myCnKarmaCntrl:                CnKarmaCntrl  number = 30, ordinal = 34;
		myMailState:                   CnSmtpState  readonly, number = 31, ordinal = 35;
	jadeMethodDefinitions
		adjustFileLocationBase(pFileLocationBase: String): String number = 1047;
		base64Decode(
			pMessage: String input; 
			pDecodedMessage: Binary output): Integer updating, number = 1001;
		base64Encode(pMessage: Binary input): String updating, number = 1002;
		buildMessageHeader() updating, number = 1003;
		changeState(pStateClass: Class input) updating, number = 1004;
		checkNameLength(pName: String): Boolean number = 1005;
		clearServerMessageAndRead(receiver: Object) updating, number = 1061;
		cnClose(receiver: Object) updating, number = 1048;
		cnCloseNotify(tcp: CnTcpConnection input) updating, number = 1062;
		cnOpenNotify(tcp: CnSmtpConnection input) updating, number = 1006;
		cnRead(receiver: Object) updating, number = 1007;
		cnReadNotify(
			tcp: CnSmtpConnection input; 
			buf: Binary) updating, number = 1008;
		cnWrite(
			body: Binary; 
			receiver: Object) updating, number = 1009;
		cnWriteNotify(tcp: CnTcpConnection input) updating, number = 1010;
		create() updating, number = 1011;
		currentTimeInMilliseconds(): Integer number = 1012;
		delete() updating, number = 1013;
		deleteFileObjects() updating, number = 1014;
		deleteStateObjects() protected, number = 1063;
		findContentType(pExtension: String): String number = 1015;
		genDate(): String number = 1016;
		genUniqueCID(pImageIndex: Integer): String number = 1049;
		generateBoundary(): String number = 1017;
		generateInlineBoundary(): String number = 1050;
		documentationText
		`Added in version 13 20.06.00.`
		getAtLeastOneValidRecipient(): Boolean number = 1018;
		getBoundary(): String number = 1019;
		getEditedMessage(): String number = 1020;
		getMessageFileName(): String number = 1021;
		getMessageFileObject(): File number = 1022;
		getMessageHeader(): String number = 1023;
		getMyAttachments(): CnAttachmentArray number = 1024;
		getRecipientArray(): HugeStringArray number = 1025;
		getRecipientArrayIndex(): Integer number = 1026;
		getServerMessage(): String number = 1027;
		initializeMIMEEntity(pMIMEEntity: CnMIME input) updating, number = 1051;
		isRelative(pFileName: String): Boolean number = 1052;
		openMessageFile(pMessageFileName: String) updating, number = 1053;
		parseRecipients(
			pRecipientList: String; 
			pNames: CnStringArray input; 
			pAddresses: HugeStringArray input) updating, number = 1054;
		raiseValidationException(
			pErrorCode: Integer; 
			pErrorText: String) updating, number = 1028;
		reset() updating, number = 1029;
		resetConnectionObject() updating, number = 1055;
		send() updating, number = 1030;
		separateNameAndAddress(
			pNameAndAddress: String; 
			pName: String output; 
			pAddress: String output) updating, number = 1056;
		separateNameAndEmail(
			pString: String; 
			pNameArray: CnStringArray input) updating, number = 1031;
		setAtLeastOneValidRecipient(pValue: Boolean) updating, number = 1032;
		setCompleted(pCompleted: Boolean) updating, number = 1057;
		setEditedMessage(pMessage: String) updating, number = 1033;
		setLoggingIniDefault(pValue: Boolean) updating, number = 1064;
		setLoggingReponse(pValue: Boolean) updating, number = 1065;
		setLoggingRequired(pFlag: Boolean) updating, number = 1034;
		setMessageFileObject(pFile: File) updating, number = 1035;
		setRecipientArrayIndex(pIndex: Integer) updating, number = 1036;
		setServerMessage(pMessage: String) updating, number = 1037;
		stripBlanks(pString: String input): String updating, number = 1038;
		userNotification(
			eventType: Integer; 
			theObject: Object; 
			eventTag: Integer; 
			userInfo: Any) updating, number = 1039;
		user_cnBuildHeader(body: Binary): Binary updating, number = 1040;
		user_cnGetPreambleDefinition(): Binary number = 1041;
		user_cnTcpExceptionHandler(exObj: Exception): Integer updating, number = 1042;
		validate() updating, number = 1043;
		validateASCIIMessage(
			pInMessage: String; 
			pOutMessage: String output; 
			pWasPreviousLineTruncated: Boolean io) updating, number = 1044;
		validateInlineContentType(pInline: CnSmtpInline input) updating, number = 1058;
		validateMessage(
			pInMessage: Binary input; 
			pOutMessage: String output; 
			pEncodingType: String; 
			pIsTruncatedLine: Boolean io; 
			pIsUserEncoded: Boolean) updating, number = 1045;
		validationExceptionHandler(exObj: Exception): Integer updating, number = 1046;
	externalMethodDefinitions
		emBase64Decode(
			pMessage: String input; 
			pDecodedMessage: Binary output): Integer is "emBase64Decode" in "karma" updating, number = 1059;
		emBase64Encode(pMessage: Binary input): String is "emBase64Encode" in "karma" updating, number = 1060;
	)
	Exception completeDefinition
	(
	)
	NormalException completeDefinition
	(
	)
	CnLdapException completeDefinition
	(
		documentationText
		`Generated for any LDAP exception.`
	constantDefinitions
		CN_VERSION:                    Integer = 1 number = 1001;
	jadeMethodDefinitions
		cnSetErrorCode(pValue: Integer) updating, number = 1001;
		cnSetErrorItem(pValue: String) updating, number = 1002;
		cnSetExtendedErrorText(pValue: String) updating, number = 1003;
	)
	CnSmtpConnectionException completeDefinition
	(
		documentationText
`This material is proprietary to Cardinal Group Limited (Cardinal) and is not to be reproduced, used or 
disclosed except upon written permission of Cardinal.                                                                     

  		 COPYRIGHT (C) CARDINAL GROUP LIMITED 1999 - ALL RIGHTS RESERVED
-------------------------------------------------------------------------------------------------------`
	constantDefinitions
		CN_VERSION:                    Integer = 2 number = 1001;
		documentationText
`Version 2 11.5.99

Added reference mySmtpConnection. This is set by CnSmtpConnection::raiseValidationException.
Added method setMySmtpConnection.`
	referenceDefinitions
		mySmtpConnection:              CnSmtpConnection  readonly, number = 1, ordinal = 1;
	jadeMethodDefinitions
		setMySmtpConnection(pSmtp: CnSmtpConnection) updating, number = 1001;
	)
	ConnectionException completeDefinition
	(
	jadeMethodDefinitions
		cnSetConnection(tcp: Connection) updating, number = 1001;
	)
	ExternalDatabase completeDefinition
	(
	)
	ExternalObject completeDefinition
	(
	)
	FileNode completeDefinition
	(
	constantDefinitions
		CN_FILE_ATTR_ARCHIVE:          Integer = #0020 number = 1001;
		CN_FILE_ATTR_COMPRESSED:       Integer = #0800 number = 1002;
		CN_FILE_ATTR_DEVICE:           Integer = #0040 number = 1003;
		CN_FILE_ATTR_DIRECTORY:        Integer = #0010 number = 1004;
		CN_FILE_ATTR_ENCRYPTED:        Integer = #4000 number = 1005;
		CN_FILE_ATTR_HIDDEN:           Integer = #02 number = 1006;
		CN_FILE_ATTR_NORMAL:           Integer = #0080 number = 1007;
		CN_FILE_ATTR_NOTCONTENTINDEXED:Integer = #2000 number = 1008;
		CN_FILE_ATTR_OFFLINE:          Integer = #1000 number = 1009;
		CN_FILE_ATTR_READONLY:         Integer = #01 number = 1010;
		CN_FILE_ATTR_REPARSE_POINT:    Integer = #0400 number = 1011;
		CN_FILE_ATTR_SPARSE_FILE:      Integer = #0200 number = 1012;
		CN_FILE_ATTR_SYSTEM:           Integer = #04 number = 1013;
		CN_FILE_ATTR_TEMPORARY:        Integer = #0100 number = 1014;
	jadeMethodDefinitions
		cnGetFileAttribute(attr: Integer): Boolean number = 1007;
		cnGetSimpleFileName(): String number = 1001;
		cnSetFileAttribute(
			attr: Integer; 
			setting: Boolean) number = 1008;
	externalMethodDefinitions
		emGetFileAttributes(
			fileName: String; 
			attributes: Integer output): Integer is "emGetFileAttributes" in "karma" number = 1009;
		emSetFileAttributes(
			fileName: String; 
			attributes: Integer): Integer is "emSetFileAttributes" in "karma" number = 1010;
	)
	File completeDefinition
	(
	jadeMethodDefinitions
		cnCopyFile(
			pDestFile: String; 
			pFailIfExists: Boolean; 
			pErrText: String output): Boolean number = 1033;
		cnCopyFilePlus(
			pDestFile: String; 
			pVerifyIntegrity: Boolean; 
			pFailIfFileExists: Boolean; 
			pErrText: String output): Boolean updating, number = 1052;
		cnCopyLoadLog(file: File input) updating, protected, number = 1018;
		cnGetFileDescription(): String number = 1015;
		cnGetFileInfo(type: String): String number = 1013;
		cnGetFileInfoAppServer(type: String): String number = 1014;
		cnGetFileLength(): Integer updating, number = 1025;
		cnGetFileLength64(): Integer64 updating, number = 1053;
		cnGetFileVersion(): String number = 1001;
		cnGetFileVersionAppServer(): String number = 1002;
		cnGetMD5Hash(pMD5Hash: String output): String number = 1008;
		cnGetSuffix(): String number = 1003;
		cnLastModifiedGMT(): TimeStamp number = 1004;
		cnRemoveFile(
			pRetryLimit: Integer; 
			pRetryWaitInterval: Integer): String number = 1048;
		cnRenameFile(
			pFileName: String; 
			pRetryLimit: Integer; 
			pRetryWaitInterval: Integer): String number = 1049;
		cnSetFileRetryDefaults() number = 1079;
		cnSetLastModified(ts: TimeStamp): String updating, number = 1005;
	externalMethodDefinitions
		cnGetGMTBias(bias: Integer output): Integer is "emGetGMTBias" in "karma" number = 1006;
		emCopyFile(
			sourceFile: String; 
			destFile: String; 
			failIfExists: Boolean): Integer is "emCopyFile" in "karma" number = 1039;
		emCopyFileWithTimeStamps(
			sourceFile: String; 
			targetFile: String; 
			failIfExists: Boolean): Integer is "emCopyFileWithTimeStamps" in "karma" number = 1074;
		emDeleteFile(fileName: String): Integer is "emDeleteFile" in "karma" number = 1055;
		emFileVersionInfo(
			fileName: String; 
			infoType: String; 
			infoValue: String output): String is "emFileVersionInfo" in "karma" number = 1007;
		emGetFileHash(
			pFileName: String; 
			pHashValue: String output): String is "emGetFileHash" in "karma" number = 1038;
		emMoveFileEx(
			sourceFile: String; 
			destFile: String; 
			flags: Integer): Integer is "emMoveFileEx" in "karma" number = 1040;
		emSetAccessTime(
			pFilename: String; 
			pDate: Integer; 
			pTime: Integer): Integer is "emSetAccessTime" in "karma" protected, number = 1026;
		documentationText
		`This method was added in CardSchema 3.4 for use by JSM.`
		emSetAccessTimeEx(
			pFilename: String; 
			pDate: Integer; 
			pTime: Integer): Integer is "emSetAccessTimeEx" in "karma" protected, number = 1075;
		emSetCreateTime(
			pFilename: String; 
			pDate: Integer; 
			pTime: Integer): Integer is "emSetCreateTime" in "karma" protected, number = 1036;
		documentationText
		`This method was added in CardSchema 3.4 for use by JSM.`
		emSetCreateTimeEx(
			pFilename: String; 
			pDate: Integer; 
			pTime: Integer): Integer is "emSetCreateTimeEx" in "karma" protected, number = 1077;
		emSetModifyTime(
			pFilename: String; 
			pDate: Integer; 
			pTime: Integer): Integer is "emSetModifyTime" in "karma" number = 1009;
		emSetModifyTimeEx(
			pFilename: String; 
			pDate: Integer; 
			pTime: Integer): Integer is "emSetModifyTimeEx" in "karma" number = 1076;
	)
	CnFile completeDefinition
	(
	attributeDefinitions
		currentDate:                   Date number = 1, ordinal = 1;
	)
	FileFolder completeDefinition
	(
	jadeMethodDefinitions
		cnCopyFilesFromDirectory(
			pDestDir: String; 
			pCreateDirectoryIfNotFound: Boolean; 
			pIncludeSubDirectories: Boolean; 
			pVerifyIntegrity: Boolean; 
			pErrText: String output): Boolean updating, number = 1045;
		cnGetMaskedFileLengths(
			pLocations: CnStringArray; 
			pFolderMask: String; 
			pFileMask: String; 
			pStructureNames: CnStringArray input; 
			pStructureLengths: Integer64Array input; 
			pUdrStructureLengths: Integer64Array input; 
			pUdrNumberStructures: Integer64Array input) updating, number = 1050;
		cnRenameDirectory(newName: String): String number = 1006;
		cnZCopyFilesFromDirectory(
			pDestDir: String; 
			pCreateDirectoryIfNotFound: Boolean; 
			pIncludeSubDirectories: Boolean; 
			pVerifyIntegrity: Boolean; 
			pErrText: String output): Boolean updating, protected, number = 1046;
	externalMethodDefinitions
		emRenameDirectory(
			sourceDir: String; 
			destDir: String): Integer is "emRenameDirectory" in "karma" number = 1005;
	)
	Global completeDefinition
	(
	)
	RootSchemaGlobal completeDefinition
	(
	)
	GCardSchema completeDefinition
	(
	jadeMethodDefinitions
		cnGetProfileStringServer(
			section: String; 
			keyName: String; 
			default: String): String serverExecution, number = 1001;
		cnGetServerComputerName(): String serverExecution, number = 1002;
		cnGetServerHostFQDN(): String serverExecution, number = 1003;
		cnGetServerInstallDir(): String serverExecution, number = 1004;
		cnGetServerLogArchiveDir(): String serverExecution, number = 1015;
		cnGetServerLogFileName(): String serverExecution, number = 1005;
		cnGetServerLogPath(): String serverExecution, number = 1006;
		cnGetServerLogRootDir(): String serverExecution, number = 1007;
		cnGetServerName(): String number = 1008;
		cnGetServerNode(): Node serverExecution, number = 1009;
		cnGetUserProcess(
			appName: String; 
			excludeOwnProcess: Boolean): Process updating, serverExecution, number = 1010;
		cnGetUserProcessForNode(
			procid: String; 
			excludeOwnProcess: Boolean; 
			nod: Node): Process updating, serverExecution, number = 1014;
		cnSetProfileStringServer(
			section: String; 
			keyName: String; 
			string: String) serverExecution, number = 1011;
		cnStartBackgroundClient(): String updating, serverExecution, number = 1012;
	externalMethodDefinitions
		cnGetServerIniFileName(): String is "getIniFileNameWithPath" in "jomsupp" serverExecution, number = 1013;
	)
	JadeDatabaseAdmin completeDefinition
	(
	constantDefinitions
		Backup_Completed_OK_Event:     Integer = 3002 number = 1001;
		Backup_Failed_Event:           Integer = 3001 number = 1002;
		Backup_Worker_Completed_Event: Integer = 3005 number = 1003;
		Compact_Completed_OK_Event:    Integer = 4002 number = 1004;
		Compact_Failed_Event:          Integer = 4001 number = 1005;
		Compact_Worker_Completed_Event:Integer = 4005 number = 1006;
		File_Backup_Complete_Event:    Integer = 3004 number = 1007;
		File_Backup_Start_Event:       Integer = 3003 number = 1008;
		File_Compact_Complete_Event:   Integer = 4004 number = 1009;
		File_Compact_Start_Event:      Integer = 4003 number = 1010;
	jadeMethodDefinitions
		cn3004ExceptionHandler(
			exObj: Exception; 
			error: Boolean output): Integer number = 1002;
		cn3074ExceptionHandler(
			exObj: Exception; 
			error: Boolean output): Integer number = 1005;
		cn3116ExceptionHandler(
			exObj: Exception; 
			error: Boolean output): Integer number = 1007;
		cnGetDatabaseSubrole(): Integer number = 1004;
		cnGetMapFileInfo(
			pMapFileNames: CnSmallStringArray input; 
			pMapFileSizes: CnDecimalArray input) number = 1001;
		cnRpsStartDataPump() number = 1006;
	)
	CnJadeDatabaseAdmin completeDefinition
	(
		documentationText
		`Used during database backups.`
	attributeDefinitions
		abortRequested:                Boolean readonly, number = 6, ordinal = 1;
		backupDir:                     String[129] readonly, number = 3, ordinal = 2;
		compress:                      Boolean readonly, number = 4, ordinal = 3;
		quiesce:                       Boolean readonly, number = 2, ordinal = 5;
	referenceDefinitions
		dbFiles:                       DbFileArray  implicitMemberInverse, readonly, subId = 1, number = 1, ordinal = 4;
		documentationText
		`Array of files to be backed up.`
	jadeMethodDefinitions
		ehHandleAnyException(
			pExObj: Exception; 
			pErrorCode: Integer output): Integer number = 1007;
		getAllDatabaseStructureInfo(
			pDbFileNames: CnStringArray input; 
			pPartitionNames: CnStringArray input; 
			pDbFiles: DbFileArray input; 
			pStatii: IntegerArray input; 
			pPartitionIds: Integer64Array input; 
			pKinds: IntegerArray input; 
			pLocations: CnStringArray input; 
			pExcludeFromBackup: BooleanArray input; 
			pLengths: Integer64Array input; 
			pUDRFileLengths: Integer64Array input; 
			pUDRNumberStructures: Integer64Array input; 
			pEncryptionStatus: IntegerArray input; 
			pIsPartitioned: BooleanArray input; 
			pPartitionCounts: Integer64Array input; 
			pModifiedTimeStamps: TimeStampArray input; 
			pBackupTimeStamps: TimeStampArray input; 
			pFullBackupTimeStamps: TimeStampArray input; 
			pFrozenArray: BooleanArray input; 
			pOfflineArray: BooleanArray input): String number = 1010;
		getAllDbFileInfo(
			pDbFileNames: CnStringArray input; 
			pDbFiles: DbFileArray input; 
			pDbFileStatus: IntegerArray input; 
			pDbFileKind: IntegerArray input; 
			pDbFileLocations: CnStringArray input; 
			pDbFileExcludeFromBackup: BooleanArray input; 
			pDbFileLengths: Integer64Array input; 
			pDbFileUDRFileLengths: Integer64Array input; 
			pDbFileIsPartitioned: BooleanArray input; 
			pDbFilePartitionCounts: Integer64Array input; 
			pDbFileModifiedTimeStamps: TimeStampArray input; 
			pDbFileBackupTimeStamps: TimeStampArray input; 
			pDbFileFullBackupTimeStamps: TimeStampArray input): String updating, number = 1008;
		getAllPartitionInfoForDbFile(
			pDbFile: DbFile; 
			pGetUDRLengths: Boolean; 
			pGetUDRStructures: Boolean; 
			pPartitionNames: CnStringArray input; 
			pStatii: IntegerArray input; 
			pPartitionIds: Integer64Array input; 
			pPartitionLocations: CnStringArray input; 
			pLengths: Integer64Array input; 
			pUDRFileLengths: Integer64Array input; 
			pUDRFileStructures: Integer64Array input; 
			pModifiedTimeStamps: TimeStampArray input; 
			pBackupTimeStamps: TimeStampArray input; 
			pFullBackupTimeStamps: TimeStampArray input; 
			pFrozenArray: BooleanArray input; 
			pOfflineArray: BooleanArray input): String number = 1009;
		getDatabaseDetailsSendAdvice() number = 1011;
		sendDatabaseDetailsAdvice(
			pDbFileNames: CnStringArray; 
			pPartitionNames: CnStringArray; 
			pFileStatus: IntegerArray; 
			pEncryptionStatus: IntegerArray; 
			pPartitionIds: Integer64Array; 
			pFileLengths: Integer64Array; 
			pUDRLengths: Integer64Array; 
			pUDRStructures: Integer64Array; 
			pLocationArray: CnStringArray; 
			pFrozenArray: BooleanArray; 
			pOfflineArray: BooleanArray; 
			pExcludeFromBackup: BooleanArray) number = 1012;
		setAbortRequested(set: Boolean) updating, number = 1005;
		setBackupDir(dir: String) updating, number = 1002;
		setCompress(set: Boolean) updating, number = 1003;
		setQuiesce(set: Boolean) updating, number = 1001;
	)
	CnJadeDatabaseAdminExternal completeDefinition
	(
		documentationText
`This class is only used as a container for methods executed during deployment via JADLOADB.
If this class is ever versioned as part of a CardSchema upgrade, a manual deployment of the
class may be necessary if the environment includes SDS nodes.`
	jadeMethodDefinitions
		getConnectionState() number = 1003;
		getTrackingStatus(param: String) updating, number = 1002;
		getVersionedOrReorgState() number = 1006;
		handleSystemExceptions(
			pExObj: Exception; 
			pErrorCode: Integer output): Integer number = 1004;
		restartRpsDataPump() updating, number = 1001;
	)
	CnSDSDatabaseAdmin completeDefinition
	(
		documentationText
`Used by KCCMgr for database administration and deployment control, especially for SDS systems.
Instantiated in CnKarmaCntrl::create.`
	constantDefinitions
		Connecting:                    Integer = 1 number = 1001;
		Disconnecting:                 Integer = 2 number = 1002;
		Disconnecting_Timer:           Integer = 2 number = 1003;
		Interval_To_Check_Check_Interval:Integer = 5 * 60 * 1000 number = 1012;
		Max_Retries:                   Integer = 60 number = 1004;
		RPS_DATAPUMP_START_EVENT:      Integer = 211 number = 1005;
		documentationText
		`System-only constant in RootSchema. `
		Reconnecting_Timer:            Integer = 3 number = 1006;
		SDS_Check_Timer:               Integer = 101 number = 1007;
		Start_Tracking:                Integer = 1 number = 1008;
		Start_Tracking_Timer:          Integer = 4 number = 1009;
		Stop_Tracking:                 Integer = 2 number = 1010;
		Stop_Tracking_Timer:           Integer = 1 number = 1011;
	attributeDefinitions
		alertTimeStampArray:           TimeStampArray protected, subId = 2, number = 7, ordinal = 27;
		alertTimeStampCatchUpArray:    TimeStampArray protected, subId = 4, number = 22, ordinal = 32;
		checkInterval:                 Integer protected, number = 8, ordinal = 10;
		connectionAlertTimestamp:      TimeStamp protected, number = 9, ordinal = 11;
		connectionCheckInterval:       Integer readonly, number = 18, ordinal = 22;
		connectionNameArray:           StringArray protected, subId = 1, number = 6, ordinal = 26;
		connectionOperation:           Integer protected, number = 3, ordinal = 6;
		dataPumpAlertTimestamp:        TimeStamp protected, number = 5, ordinal = 25;
		hostileTakeover:               Boolean readonly, number = 21, ordinal = 31;
		inTakeoverState:               Boolean readonly, number = 19, ordinal = 30;
		lagTimeAlertTimestamp:         TimeStamp protected, number = 10, ordinal = 12;
		myName:                        String[65] readonly, number = 17, ordinal = 21;
		prevCommittedTimeStamp:        TimeStamp protected, number = 20, ordinal = 29;
		prevReplayedTimeStampArray:    TimeStampArray protected, subId = 3, number = 15, ordinal = 28;
		replayJournalAlertTimestamp:   TimeStamp protected, number = 12, ordinal = 14;
		replayStructFreq:              Integer protected, number = 23, ordinal = 33;
		replayStructState:             Boolean protected, number = 24, ordinal = 34;
		retryNo:                       Integer protected, number = 4, ordinal = 4;
		sdsEnvironmentId:              String[31] readonly, number = 14, ordinal = 16;
		documentationText
`
This is a memo value, used for a key in Joss class SDSEnvironment.  The value is
derived from ini file item [AppEnvironment] SDSEnvironmentId.`
		syncMode:                      Integer readonly, number = 16, ordinal = 20;
		trackingAlertTimestamp:        TimeStamp protected, number = 13, ordinal = 15;
		trackingOperation:             Integer protected, number = 2, ordinal = 5;
	referenceDefinitions
		myJdo:                         JadeDynamicObject  protected, number = 1, ordinal = 1;
	jadeMethodDefinitions
		cnSDSStructureState_Check() number = 1049;
		create() updating, number = 1041;
		delete() updating, number = 1042;
		doCommand(pCommand: String) updating, number = 1012;
		getConnectionState(): Integer updating, number = 1008;
		getConnectionStateString(pConnectionState: Integer): String number = 1001;
		getDatabaseRoleString(pDatabaseRole: Integer): String number = 1045;
		getDatabaseSubroleString(pDatabaseSubrole: Integer): String number = 1046;
		getLastErrorCode(): Integer updating, number = 1026;
		getMapFileInfo(
			pMapFileNameArray: CnStringArray input; 
			pMapFileSizeArray: Integer64Array input) number = 1029;
		getRPSParameters(
			pSchemaName: String output; 
			pRPSMappingName: String output; 
			pRPSStorageMode: Integer output) number = 1038;
		getRPSStorageModeString(
			pSchemaName: String output; 
			pRPSMappingName: String output; 
			pRPSStorageMode: Integer io): String number = 1039;
		getRpsTransitionHaltCodeStr(reason: Integer): String number = 1034;
		getRpsWorkers(): Integer updating, number = 1032;
		getTracking(
			pTrackingStoppedReason: Integer output; 
			pRpsTransitionHaltCode: Integer output): Boolean updating, number = 1018;
		getTrackingDisabled(): Boolean updating, number = 1005;
		getTrackingStoppedReasonStr(reason: Integer): String number = 1031;
		initializeKCCMgr() updating, number = 1021;
		initializeKCSDSChecks() updating, number = 1055;
		sdsExceptionHandler(exObj: SystemException): Integer subschemaHidden, number = 1024;
		sendSDSAdviceMsg(
			pAdviceType: String; 
			pTracking: Boolean; 
			pTrackingStoppedReason: Integer; 
			pRpsTransitionHaltCode: Integer; 
			pText: String; 
			pRaiseAlert: Boolean) updating, number = 1037;
		sysNotification(
			eventType: Integer; 
			theObject: Object; 
			eventTag: Integer) updating, number = 1048;
		timerEvent(eventTag: Integer) updating, number = 1006;
		updateSelf() updating, number = 1027;
		userNotification(
			eventType: Integer; 
			theObject: Object; 
			eventTag: Integer; 
			userInfo: Any) updating, number = 1010;
		zCheckConnection(
			pTracking: Boolean; 
			pConnected: Boolean) updating, protected, subschemaHidden, number = 1013;
		zCheckLagTime(
			pLagSeconds: Integer; 
			pStableTs: TimeStamp; 
			pReplayTs: TimeStamp) updating, protected, subschemaHidden, number = 1014;
		zCheckReadyJournalNo(jdo: JadeDynamicObject) updating, protected, subschemaHidden, number = 1015;
		zCheckRetryCount(msg: String): Boolean updating, protected, number = 1009;
		zCheckSynchronicity(state: Integer) updating, protected, subschemaHidden, number = 1033;
		zCheckTracking(
			pTracking: Boolean; 
			pTrackingDisabled: Boolean; 
			pConnected: Boolean; 
			pTrackingStoppedReason: Integer; 
			pRpsTransitionHaltCode: Integer) updating, protected, subschemaHidden, number = 1016;
		zCheckTracking_SDSChecks() updating, protected, subschemaHidden, number = 1043;
		zCnSDSConnectionTrackingChecks(pEventTag: Integer) updating, protected, number = 1052;
		zCnSDSStructureState_Change(pObject: Object) protected, number = 1050;
		zCnSDSStructureState_Online(pUserInfo: String) protected, number = 1051;
		zCnSDSStructureState_Setup() updating, protected, number = 1047;
		zDoChecks() updating, protected, subschemaHidden, number = 1017;
		zDoPrimaryChecks() updating, protected, subschemaHidden, number = 1040;
		zDoSecondaryChecks() updating, protected, subschemaHidden, number = 1019;
		zGetIniFileCheckInterval() updating, protected, subschemaHidden, number = 1053;
		zGetIniFileMaxLagTime(
			pConnName: String; 
			pSdsMaxLagTime: Integer output) updating, protected, subschemaHidden, number = 1054;
		zGetIniFileSettings() updating, protected, subschemaHidden, number = 1023;
		zGetPrimaryHostFQDN(): String protected, number = 1025;
		zGetReadyJournalNo(jdo: JadeDynamicObject): Integer protected, subschemaHidden, number = 1022;
		zHandleConnectionStateChange(userInfo: Any) updating, protected, number = 1028;
		zHandleConnectionStateChange_SDSChecks(userInfo: Any) updating, protected, number = 1035;
		zHandleRoleChangeEvent(userInfo: Any) updating, protected, number = 1020;
		zHandleTrackingStateChange(
			eventType: Integer; 
			userInfo: Any) updating, protected, number = 1030;
		zRaiseAlert(msg: String) updating, protected, number = 1011;
		zSDSConnect() updating, protected, number = 1002;
		zSDSDisconnect() updating, protected, number = 1007;
		zSDSStartTracking() updating, protected, number = 1004;
		zSDSStopTracking() updating, protected, number = 1003;
		zStopKCCMgr() protected, number = 1036;
	)
	JadeDynamicObject completeDefinition
	(
	jadeMethodDefinitions
		cnGetDeltaInteger64(
			pPropertyName: String; 
			pPreviousJDO: JadeDynamicObject input): Integer64 number = 1001;
	)
	CnJadeDynamicObject completeDefinition
	(
	jadeMethodDefinitions
		create() updating, number = 1001;
		delete() updating, number = 1002;
	)
	JadeJWTModel completeDefinition
	(
	)
	JadeJWTParser completeDefinition
	(
	)
	JadeLog completeDefinition
	(
	)
	JadeReportWriterSecurity completeDefinition
	(
	)
	JadeRestService completeDefinition
	(
	)
	JadeScript completeDefinition
	(
	jadeMethodDefinitions
		cnA__MergeGlobalConstants() number = 1486;
		cnAnalyzeQueuedLocks() number = 1487;
		cnBenchMarkPSArray() number = 1133;
		cnCheckDbFiles() number = 1185;
		cnConsolidateHotFixes() number = 1254;
		documentationText
`Consolidating Hot Fixes
-----------------------

This script accesses the JADECare Systems Manager's master product repository for JADE for the nominated release and consolidates all hot fixes.

Prerequisite : This requires access to file share \\cnwchcm1\JSMJadeReleases.

Assumptions: The JADE environment is expected to be named :
<drive>:\<JADE environment name>\server\c_bin	binaries
<drive>:\<JADE environment name>\server\c_misc	miscellaneous
<drive>:\<JADE environment name>\server\c_system	system files

All binaries are consolidated into one directory (WinAnsi).

All schema files, forms files, class files and method files are placed under another directory (SchemaFiles) and each of these has an entry added into a batch file (_schemaLoad.bat) such that it may be executed to load all the RootSchema, JadeSchema, etc patches. 

To use:
1.	Load the enclosed JadeScript::consolidateHotFixes using the Advanced button in the load dialog to rename the target schema.
2.	Execute the JadeScript::consolidateHotFixes
When prompted 'Enter destination directory of consolidated hot fixes' 
enter a local directory name such as c:\temp\hotfixes_6_0_18. Note that this is the directory that the _schemaLoad.bat will use when executing jadloadb to load schema patches.
3.	When prompted 'Enter location of hot fixes to consolidate' enter the map drive and directory of the hot fix location.

For example: I have J drive mapped to \\cnwchcm1\JSMJadeReleases so to consolidate the 6.0.18 hot fixes, the name supplied here is J:\6.0.18\HotFixes.  Alternatively you can simply enter \\cnwchcm1\JSMJadeReleases\6.0.18\HotFixes as the source location for hot fixes.
4.	When prompted 'Enter drive letter of JADE environment to be upgraded', enter the drive letter of your target JADE environment.
5.	When prompted 'Enter name of JADE environment to be upgraded', enter the name of the JADE environment.
6.	The script will now scan the hot fix directory and consolidate the hot fixes into your named directory.
7.	Copy all binaries from the WinAnsi directory into your binaries directory.
8.	Execute the _schemaLoad file from the subdirectory SchemaFiles under your named directory to load all schema patches.

The _schemaLoad.bat file can be easily modified by the user as required.`
		cnConvertRGB() number = 1001;
		cnDbFileDetails() number = 1026;
		cnExceptionHandler(
			pExObj: Exception; 
			pHadError: Boolean output): Integer number = 1489;
		cnExtractDatabaseStructureInfo() number = 1670;
		cnExtractDbFileInfExtra() number = 1671;
		cnExtractDbFileInfoSimple() number = 1672;
		cnExtractGlobalConstants() number = 1473;
		cnExtractSchemasAndAllClasses() number = 1694;
		cnGetTopOfLockStack(
			pLock: Lock; 
			pLockArray: LockArray; 
			pRequestorArray: ObjectArray; 
			pDepth: Integer io; 
			pTerminate: Boolean output; 
			pDebug: Boolean): Process number = 1490;
		cnIssueShutdownCommandEvent() number = 1659;
		cnJC24CheckCommandLine() number = 1583;
		cnJadeSkinsReload() updating, number = 1175;
		cnJadeSkinsUnload() updating, number = 1187;
		cnListApplications() number = 1044;
		cnListDbFiles() number = 1554;
		cnMakeCommandFile() number = 1423;
		cnMethodInError() number = 1666;
		cnSDSListMyServerInfo() number = 1391;
		cnSchemaAnalyserDemo() updating, number = 1059;
		cnSchemaComparator() updating, number = 1077;
		cnServerStatsDisplay(
			pBin: Binary; 
			pLength: Integer) protected, number = 1538;
		cnServerStatsTest() number = 1539;
		cnSetScaleForm() number = 1658;
		cnSetupApplicationVersions() number = 1070;
		cnStartKCCMgr() serverExecution, number = 1416;
		cnTest2(val: Integer) number = 1131;
		cnTestAlert() number = 1194;
		cnTestBinary() number = 1016;
		cnTestBinary2(bin: Binary) number = 1017;
		cnTestBinaryTooLong() updating, number = 1195;
		cnTestCheckForTransients() updating, number = 1003;
		cnTestCnGetToken() number = 1004;
		cnTestDeployControl() updating, number = 1469;
		cnTestException1() updating, number = 1005;
		cnTestException2(
			str1: String; 
			str2: String; 
			mach: CnMachine input; 
			ia: IntegerArray) updating, number = 1006;
		cnTestExceptionStackDump() number = 1491;
		cnTestFTP_create2GBFile() number = 1771;
		cnTestFtp32Delete() updating, number = 1772;
		cnTestFtp32FindFile() updating, number = 1773;
		cnTestFtp32GetInfo() updating, number = 1774;
		cnTestFtp32GetInfo_2GB() updating, number = 1775;
		cnTestFtp32Limits2() updating, number = 1776;
		cnTestFtp32PutFile() updating, number = 1777;
		cnTestFtp32PutFile_2GB() updating, number = 1778;
		cnTestFtp64Delete() updating, number = 1779;
		cnTestFtp64FindFile() updating, number = 1780;
		cnTestFtp64GetInfo() updating, number = 1781;
		cnTestFtp64GetInfo_2GB() updating, number = 1782;
		cnTestFtp64PutFile() updating, number = 1783;
		cnTestFtp64PutFile_2GB() updating, number = 1784;
		cnTestGetCacheSizes() serverExecution, number = 1008;
		cnTestGetHostByAddress() number = 1157;
		cnTestGetHostByName() number = 1674;
		cnTestGetTimeZoneStuff() number = 1009;
		cnTestGetTokens() updating, number = 1010;
		cnTestHttp() updating, number = 1540;
		cnTestHttpGetFile() updating, number = 1541;
		cnTestHttpWithGoogle() number = 1675;
		cnTestInstrumentation() serverExecution, number = 1439;
		cnTestJadeRecompleAllMethodsApplication() number = 1701;
		cnTestManagedBackup() updating, number = 1020;
		cnTestOSPlatform() number = 1555;
		cnTestPerf() updating, number = 1011;
		cnTestSamplingProblem() number = 1401;
		cnTestSchemaAnalyser() updating, number = 1198;
		cnTestSecondsDifference() number = 1012;
		cnTestServerApp() serverExecution, number = 1126;
		cnTestStartTransaction() number = 1132;
		cnTestTimeStuff() updating, number = 1014;
		cnTestUnicode() number = 1018;
		cnTestValidateMethodApplication() number = 1700;
		cnTestVerifyJournal() number = 1428;
		cnTestWriteLog() number = 1125;
		cnUnloadSkins() number = 1174;
		cnUpdatePersistentAppVersion() updating, number = 1343;
		cnVerifyKarmaExternalFunctions() number = 1556;
		cnZGetDriveInfo(): Boolean protected, number = 1558;
		cnZGetDriveMapping(): Boolean protected, number = 1559;
		cnZGetEnvironmentVariable(): Boolean protected, number = 1560;
		cnZGetFileVersionInfo(): Boolean protected, number = 1561;
		cnZGetLogicalDrives(): Boolean protected, number = 1562;
		cnZGetSubDirectories(): Boolean protected, number = 1563;
		cnZHasSubdirectories(): Boolean protected, number = 1564;
		zCnGetFTPRequiredInfo(
			pUserId: String output; 
			pPassWord: String output; 
			pServerName: String output): Boolean protected, number = 1069;
		zExtractSchemaAndClasses_getSubClasses(
			pClass: Class; 
			pObjArray: ObjectArray input) protected, number = 1695;
	)
	JadeTestCase completeDefinition
	(
	)
	JadeWebService completeDefinition
	(
	webServicesClassProperties
	(
		wsdl = ``;
	)
	)
	JadeWebServiceConsumer completeDefinition
	(
	webServicesClassProperties
	(
		additionalInfo = ``;
		wsdl = ``;
		endPointURL = "";
		wsdlName = "";
		_useSOAP12 = false;
		useAsyncCalls = false;
		useNewPrimTypes = false;
	)
	)
	JadeWebServiceProvider completeDefinition
	(
	webServicesClassProperties
	(
		additionalInfo = ``;
		wsdl = ``;
		secureService = default;
	)
	)
	JadeXMLNode completeDefinition
	(
	)
	JadeXMLAttribute completeDefinition
	(
	)
	JadeXMLCharacterData completeDefinition
	(
	)
	JadeXMLCDATA completeDefinition
	(
	)
	JadeXMLComment completeDefinition
	(
	)
	JadeXMLText completeDefinition
	(
	)
	JadeXMLDocument completeDefinition
	(
	)
	JadeXMLDocumentType completeDefinition
	(
	)
	JadeXMLElement completeDefinition
	(
	)
	JadeXMLProcessingInstruction completeDefinition
	(
	)
	Lock completeDefinition
	(
	jadeMethodDefinitions
		getLockType(): String number = 1001;
	)
	MenuItemData completeDefinition
	(
	)
	MenuItem completeDefinition
	(
	)
	MultiMediaType completeDefinition
	(
	)
	Sound completeDefinition
	(
	)
	Node completeDefinition
	(
	jadeMethodDefinitions
		cnCheckApplicationAlreadyRunningInNode(pClass: Class): Boolean number = 1004;
		cnCheckDuplNodeApplication(pClass: Class) number = 1002;
		cnGetComputerName(): String number = 1001;
		cnGetNameFromCommandLine(): String number = 1005;
		cnGetServerCacheSizes(
			pc: Integer64 output; 
			tc: Integer64 output; 
			rc: Integer64 output; 
			pdb: Integer64 output) serverExecution, number = 1003;
		cnIsApplicationRunningInNode(
			pApplicationName: String; 
			pExcludeSelf: Boolean): Boolean number = 1009;
	)
	Notification completeDefinition
	(
	)
	Process completeDefinition
	(
	jadeMethodDefinitions
		cnGetTransactionStartTime(pMilliseconds: Integer output): TimeStamp number = 1004;
		cnSetThreadPriority(priority: String): String number = 1007;
	externalMethodDefinitions
		emSetThreadPriority(priority: String): Integer is "emSetThreadPriority" in "karma" protected, number = 1008;
	)
	Schema completeDefinition
	(
	jadeMethodDefinitions
		cnGetApplications(): AppNameDict number = 1001;
		cnGetGlobalConstants(): ConstantNDict number = 1002;
	)
	SchemaEntity completeDefinition
	(
	jadeMethodDefinitions
		cnGetModifiedTimeStamp(): TimeStamp number = 1003;
		cnGetModifierName(): String number = 1004;
		cnGetPatchNumber(): Integer number = 1010;
	)
	DbFile completeDefinition
	(
	jadeMethodDefinitions
		cnGetKind(): String number = 1001;
		cnGetStatus(): String number = 1002;
		cnGetStatusFromInput(pFileStatus: Integer): String number = 1003;
	)
	Feature completeDefinition
	(
	)
	Script completeDefinition
	(
	)
	Routine completeDefinition
	(
	)
	Method completeDefinition
	(
	jadeMethodDefinitions
		cnGetExecutionLocation(): Character number = 1001;
		cnGetMethodName(): String number = 1006;
		cnGetParameters(): ParameterColl number = 1002;
		cnGetPriorMethod(
			offset: Integer; 
			codePosition: Integer output): Method number = 1004;
		cnGetSourceLine(position: Integer): String abstract, number = 1005;
		resetSubAccess() updating, number = 1003;
	)
	ExternalMethod completeDefinition
	(
	jadeMethodDefinitions
		cnGetSourceLine(position: Integer): String number = 1001;
	)
	JadeMethod completeDefinition
	(
	jadeMethodDefinitions
		cnGetLocalVars(): JadeLocalVarColl number = 1001;
		cnGetSourceLine(pPosition: Integer): String number = 1002;
	)
	Type completeDefinition
	(
	jadeMethodDefinitions
		cnGetMethods(): MethodNDict number = 1001;
	)
	Class completeDefinition
	(
	jadeMethodDefinitions
		cnDeleteTransientInstances() updating, number = 1001;
		cnGetProperties(): PropertyNDict number = 1004;
		cnGetSubClasses(): ClassNDict number = 1005;
	)
	System completeDefinition
	(
	jadeMethodDefinitions
		cnGetDeltaDatabaseStatusString(pDeltaDatabaseStatus: Integer): String number = 1001;
		cnIsApplicationRunning(
			pApplicationName: String; 
			pExcludeSelf: Boolean): Boolean number = 1016;
		cnIsApplicationRunningInNode(
			pNode: Node; 
			pApplicationName: String; 
			pExcludeSelf: Boolean): Boolean number = 1017;
	)
	WebSession completeDefinition
	(
	)
	RootSchemaSession completeDefinition
	(
	)
	CnSchemaSession completeDefinition
	(
	)
	Window completeDefinition
	(
	)
	Control completeDefinition
	(
	)
	BaseControl completeDefinition
	(
	)
	BrowseButtons completeDefinition
	(
	)
	Button completeDefinition
	(
	)
	CheckBox completeDefinition
	(
	)
	ComboBox completeDefinition
	(
	)
	Folder completeDefinition
	(
	)
	Frame completeDefinition
	(
	)
	GroupBox completeDefinition
	(
	)
	Sheet completeDefinition
	(
	)
	JadeDockBase completeDefinition
	(
	)
	JadeDockBar completeDefinition
	(
	)
	JadeDockContainer completeDefinition
	(
	)
	JadeDotNetVisualComponent completeDefinition
	(
	)
	JadeEditMask completeDefinition
	(
	)
	JadeRichText completeDefinition
	(
	)
	Label completeDefinition
	(
	)
	ProgressBar completeDefinition
	(
	)
	ListBox completeDefinition
	(
	)
	MultiMedia completeDefinition
	(
	)
	OleControl completeDefinition
	(
	)
	OptionButton completeDefinition
	(
	)
	Picture completeDefinition
	(
	)
	CnToolBarPicture completeDefinition
	(
	attributeDefinitions
		mouseOver:                     Boolean protected, number = 1, ordinal = 1;
	jadeMethodDefinitions
		click(pict: Picture input) updating, number = 1001;
		create() updating, number = 1002;
		mouseLeave(pict: Picture input) updating, number = 1003;
		mouseMove(
			pict: Picture input; 
			button: Integer; 
			shift: Integer; 
			x: Real; 
			y: Real) updating, number = 1004;
		paint(pict: Picture input) updating, number = 1005;
	)
	JadeMask completeDefinition
	(
	)
	ScrollBar completeDefinition
	(
	)
	HScroll completeDefinition
	(
	)
	VScroll completeDefinition
	(
	)
	StatusLine completeDefinition
	(
	)
	Table completeDefinition
	(
	jadeMethodDefinitions
		cnAdjustColumnWidth(pColumn: Integer) updating, number = 1013;
		cnAdjustColumnWidths() updating, number = 1014;
		cnAdjustLastColumn() updating, number = 1012;
		cnSetHeading(
			pColumn: Integer; 
			pHeading: String; 
			pAlignment: Integer) updating, number = 1011;
	)
	TextBox completeDefinition
	(
	)
	Form completeDefinition
	(
	jadeMethodDefinitions
		cnSetScaleForm(set: Boolean) updating, number = 1028;
	)
	CnConnectionForm completeDefinition
	(
	constantDefinitions
		Close_Down:                    Integer = 1001 number = 1001;
		Reminder:                      Integer = 1002 number = 1002;
	attributeDefinitions
		delay:                         Integer number = 5, ordinal = 1;
		denyStartup:                   Boolean number = 6, ordinal = 2;
		dontTerminate:                 Boolean number = 7, ordinal = 3;
		message:                       String[501] number = 8, ordinal = 4;
		sourceComputer:                String[31] number = 9, ordinal = 5;
	referenceDefinitions
		btnClose:                      Button  number = 3, ordinal = 9;
		frame1:                        Frame  number = 2, ordinal = 10;
		frmShutdown:                   Frame  number = 10, ordinal = 8;
		tbxDetails:                    TextBox  number = 11, ordinal = 11;
	jadeMethodDefinitions
		btnClose_click(btn: Button input) updating, number = 1004;
		btnClose_windowCreated(
			cntrl: Control input; 
			persistCntrl: Control) updating, number = 1005;
		load() updating, number = 1001;
		timerEvent(eventTag: Integer) updating, number = 1002;
		unload() updating, number = 1003;
	eventMethodMappings
		btnClose_click = click of Button;
		btnClose_windowCreated = windowCreated of Control;
		load = load of Form;
		unload = unload of Form;
	)
	CnDumpForm completeDefinition
	(
	attributeDefinitions
		userPicture:                   Binary subId = 1, number = 12, ordinal = 12;
	referenceDefinitions
		exObj:                         Exception  number = 1, ordinal = 1;
		frame2:                        Frame  number = 2, ordinal = 2;
		frame3:                        Frame  number = 3, ordinal = 3;
		laHelp:                        Label  number = 4, ordinal = 4;
		laText:                        Label  number = 5, ordinal = 5;
		pgBar:                         ProgressBar  number = 6, ordinal = 6;
		picFrogPhoto:                  Picture  number = 11, ordinal = 7;
		picGreenFrog:                  Picture  number = 9, ordinal = 8;
		picOriginalFrog:               Picture  number = 8, ordinal = 9;
		picRainbowFrog:                Picture  number = 10, ordinal = 10;
		picRoadSign:                   Picture  number = 7, ordinal = 11;
	jadeMethodDefinitions
		load() updating, number = 1001;
		positionPicture(pic: Picture input) updating, number = 1003;
		setupPicture() updating, number = 1002;
	eventMethodMappings
		load = load of Form;
	)
	CnExceptionForm completeDefinition
	(
	attributeDefinitions
		displayTime:                   Integer number = 1, ordinal = 4;
		remainingTime:                 Integer readonly, number = 2, ordinal = 14;
	referenceDefinitions
		bAbort:                        Button  number = 3, ordinal = 1;
		bClose:                        Button  number = 4, ordinal = 2;
		bTerminate:                    Button  number = 5, ordinal = 3;
		laAction:                      Label  number = 10, ordinal = 9;
		laHelp:                        Label  number = 11, ordinal = 10;
		laText:                        Label  number = 12, ordinal = 11;
		laType:                        Label  number = 13, ordinal = 12;
		myException:                   Exception  number = 14, ordinal = 13;
		tbxExceptionStack:             TextBox  number = 16, ordinal = 15;
	jadeMethodDefinitions
		bAbort_click(btn: Button input) updating, number = 1001;
		bClose_click(btn: Button input) updating, number = 1002;
		bClose_windowCreated(
			cntrl: Control input; 
			persistCntrl: Control) updating, number = 1007;
		bTerminate_click(btn: Button input) updating, number = 1003;
		load() updating, number = 1004;
		timerEvent(eventTag: Integer) updating, number = 1005;
		unload() updating, number = 1006;
	eventMethodMappings
		bAbort_click = click of Button;
		bClose_click = click of Button;
		bClose_windowCreated = windowCreated of Control;
		bTerminate_click = click of Button;
		load = load of Form;
		unload = unload of Form;
	)
	CnForm completeDefinition
	(
	)
	CnKCGui completeDefinition
	(
	referenceDefinitions
		btnTerminate:                  Button  number = 2, ordinal = 2;
		label1:                        Label  number = 1, ordinal = 1;
	jadeMethodDefinitions
		btnTerminate_click(btn: Button input) updating, number = 1001;
		load() updating, number = 1002;
	eventMethodMappings
		btnTerminate_click = click of Button;
		load = load of Form;
	)
	CnKCGuiTimer completeDefinition
	(
	referenceDefinitions
		btnTerminate:                  Button  number = 1, ordinal = 1;
		label1:                        Label  number = 2, ordinal = 2;
	jadeMethodDefinitions
		btnTerminate_click(btn: Button input) updating, number = 1001;
		load() updating, number = 1002;
		timerEvent(eventTag: Integer) updating, number = 1003;
		zTerminate() protected, number = 1004;
	eventMethodMappings
		btnTerminate_click = click of Button;
		load = load of Form;
	)
	CnTransferProgress completeDefinition
	(
	attributeDefinitions
		startTime:                     TimeStamp number = 1, ordinal = 11;
		totalBytesToBeTransferred:     Integer number = 2, ordinal = 12;
	referenceDefinitions
		bCancel:                       Button  number = 3, ordinal = 1;
		frame1:                        Frame  number = 4, ordinal = 2;
		laFile:                        Label  number = 5, ordinal = 3;
		laRemaining:                   Label  number = 6, ordinal = 4;
		label2:                        Label  number = 7, ordinal = 5;
		label3:                        Label  number = 8, ordinal = 6;
		myFTO:                         CnInternet  number = 9, ordinal = 7;
		pbAllFiles:                    ProgressBar  number = 10, ordinal = 8;
		pbCurrentFile:                 ProgressBar  number = 11, ordinal = 9;
		picture1:                      Picture  number = 12, ordinal = 10;
	jadeMethodDefinitions
		bCancel_click(btn: Button input) updating, number = 1001;
		getDivisionFactor(filesize: Integer): Integer number = 1002;
		getTimeDifference(
			timeSt1: TimeStamp; 
			timeSt2: TimeStamp): Real updating, number = 1003;
		load() updating, number = 1004;
		unload() updating, number = 1005;
		userNotify(
			eventType: Integer; 
			theObject: Object; 
			eventTag: Integer; 
			userInfo: Any) updating, number = 1006;
	eventMethodMappings
		bCancel_click = click of Button;
		load = load of Form;
		unload = unload of Form;
		userNotify = userNotify of Form;
	)
	KCMLoading completeDefinition
	(
	attributeDefinitions
		retry:                         Integer number = 1, ordinal = 7;
	referenceDefinitions
		frame1:                        Frame  number = 2, ordinal = 1;
		laClientName:                  Label  number = 3, ordinal = 2;
		label1:                        Label  number = 4, ordinal = 3;
		label2:                        Label  number = 5, ordinal = 4;
		pgBar:                         ProgressBar  number = 6, ordinal = 5;
		picture1:                      Picture  number = 7, ordinal = 6;
	)
	CnLogOptions completeDefinition
	(
	referenceDefinitions
		bCancel:                       Button  number = 1, ordinal = 1;
		bOK:                           Button  number = 2, ordinal = 2;
		cbxImmediateCommit:            CheckBox  number = 3, ordinal = 3;
		cbxLogCommsBuffers:            CheckBox  number = 4, ordinal = 4;
		cbxLogConnect:                 CheckBox  number = 5, ordinal = 5;
		cbxLogDiagnostics:             CheckBox  number = 6, ordinal = 6;
		cbxLogToScreen:                CheckBox  number = 7, ordinal = 7;
		cbxLogging:                    CheckBox  number = 8, ordinal = 8;
		frame1:                        Frame  number = 9, ordinal = 9;
		groupBox1:                     GroupBox  number = 10, ordinal = 10;
		groupBox2:                     GroupBox  number = 11, ordinal = 11;
		groupBox3:                     GroupBox  number = 12, ordinal = 12;
		label1:                        Label  number = 13, ordinal = 13;
		label2:                        Label  number = 14, ordinal = 14;
		optAllHosts:                   OptionButton  number = 15, ordinal = 15;
		optSelHost:                    OptionButton  number = 16, ordinal = 16;
		tbHostFQDN:                    TextBox  number = 17, ordinal = 17;
		tbLogFileName:                 TextBox  number = 18, ordinal = 18;
		tbLogFilePath:                 TextBox  number = 19, ordinal = 19;
	jadeMethodDefinitions
		bCancel_click(btn: Button input) updating, number = 1001;
		bOK_click(btn: Button input) updating, number = 1002;
		cbxLogging_click(checkbox: CheckBox input) updating, number = 1003;
		enableOptions(set: Boolean) updating, number = 1004;
		load() updating, number = 1005;
	eventMethodMappings
		bCancel_click = click of Button;
		bOK_click = click of Button;
		cbxLogging_click = click of CheckBox;
		load = load of Form;
	)
	CnMsgForm completeDefinition
	(
	attributeDefinitions
		delay:                         Integer number = 1, ordinal = 2;
		denyStartup:                   Boolean number = 2, ordinal = 3;
		dontTerminate:                 Boolean number = 3, ordinal = 4;
		message:                       String[501] number = 4, ordinal = 7;
		sourceComputer:                String[31] number = 5, ordinal = 8;
	referenceDefinitions
		bClose:                        Button  number = 6, ordinal = 1;
		bFocusGrabber:                 Button  number = 9, ordinal = 9;
		frame1:                        Frame  number = 7, ordinal = 5;
		frame2:                        Frame  number = 8, ordinal = 6;
	jadeMethodDefinitions
		bClose_click(btn: Button input) updating, number = 1004;
		load() updating, number = 1001;
		timerEvent(eventTag: Integer) updating, number = 1002;
		unload() updating, number = 1003;
	eventMethodMappings
		bClose_click = click of Button;
		load = load of Form;
		unload = unload of Form;
	)
	CnPrinterForm completeDefinition
	(
	)
	CnSchemaAnalysisOutputForm completeDefinition
	(
	referenceDefinitions
		frData:                        Frame  number = 7, ordinal = 1;
		frFooter:                      Frame  number = 8, ordinal = 2;
		frHead1:                       Frame  number = 2, ordinal = 3;
		frHead2:                       Frame  number = 3, ordinal = 4;
		frHead3:                       Frame  number = 4, ordinal = 5;
		frHead4:                       Frame  number = 5, ordinal = 6;
		frHeader:                      Frame  number = 1, ordinal = 7;
		frMidFooter:                   Frame  number = 6, ordinal = 8;
		frPage:                        Frame  number = 9, ordinal = 9;
		tbPageNo:                      TextBox  number = 10, ordinal = 10;
	)
	CnProgressDialog completeDefinition
	(
	attributeDefinitions
		cancelled:                     Integer number = 7, ordinal = 2;
		lockTarget:                    String[181] number = 5, ordinal = 6;
	referenceDefinitions
		bCancel:                       Button  number = 1, ordinal = 1;
		frMsg1:                        Frame  number = 2, ordinal = 3;
		frMsg2:                        Frame  number = 3, ordinal = 4;
		frMsg3:                        Frame  number = 4, ordinal = 5;
	jadeMethodDefinitions
		bCancel_click(btn: Button input) updating, number = 1002;
		showProgress(
			msg1: String; 
			msg2: String; 
			msg3: String): Integer number = 1001;
	eventMethodMappings
		bCancel_click = click of Button;
	)
	CnWebAppError completeDefinition
	(
	attributeDefinitions
		errorCode:                     Integer number = 1, ordinal = 2;
		errorItem:                     String[541] subId = 1, number = 2, ordinal = 3;
		errorText:                     String subId = 2, number = 3, ordinal = 4;
		lockTargetClassAndOid:         String subId = 3, number = 10, ordinal = 11;
		documentationText
`PAR 979.
Replaces reference 'lockTarget' type Object as only wanting to report the
class and oid of the lock target.`
		lockedBy:                      String[31] number = 4, ordinal = 8;
	referenceDefinitions
		bOK:                           Button  number = 5, ordinal = 1;
		laDumpFile:                    Label  number = 9, ordinal = 9;
		laError:                       Label  number = 6, ordinal = 5;
		label1:                        Label  number = 7, ordinal = 6;
	jadeMethodDefinitions
		bOK_click(btn: Button input) updating, number = 1001;
		load() updating, number = 1002;
	eventMethodMappings
		bOK_click = click of Button;
		load = load of Form;
	)
	ProgressDialog completeDefinition
	(
	)
	Collection completeDefinition
	(
	)
	Btree completeDefinition
	(
	)
	Dictionary completeDefinition
	(
	)
	ExtKeyDictionary completeDefinition
	(
	)
	MemberKeyDictionary completeDefinition
	(
	)
	CnAppDict completeDefinition
	(
	)
	CnDatabaseStructureByNameDict completeDefinition
	(
	)
	CnDatabaseStructureBySizeDict completeDefinition
	(
	)
	CnJadeApplicationDict completeDefinition
	(
	)
	CnJadeNodeDict completeDefinition
	(
	)
	CnJadeProcessDict completeDefinition
	(
	)
	CnLdapAttributeDict completeDefinition
	(
		documentationText
`Note that duplicates are allowed on this dictionary. This is for the Modify feature: it allows us to build an entry with
several different modify requests for the same attribute. We might be adding a value to the attribute, but also deleting
a value from the same attribute in a single modify request. Each CnLdapAttribute object maps onto one MOD
structure in the dll.

When a Search is performed, however, no duplicates are created in this dictionary. This means that the entry::cnFindAttribute
method will always return the one and only instance of a particular attribute, if the CnLdapEntry object has been built
as a result of a Search.`
	constantDefinitions
		CN_VERSION:                    Integer = 1 number = 1001;
	)
	CnLockTargetDict completeDefinition
	(
	)
	CnMachineDict completeDefinition
	(
	)
	CnNameSizeInfoByNameDict completeDefinition
	(
	jadeMethodDefinitions
		loadInstance(
			pName: String; 
			pDec: Decimal) updating, lockReceiver, number = 1001;
	)
	CnNameSizeInfoBySizeDict completeDefinition
	(
	jadeMethodDefinitions
		loadInstance(
			pName: String; 
			pDec: Decimal) updating, lockReceiver, number = 1001;
	)
	CnProcessDict completeDefinition
	(
	)
	CnSDSStructureStateDict completeDefinition
	(
	)
	CnSchemaElementDict completeDefinition
	(
	)
	CnTcpClientDict completeDefinition
	(
	)
	CnTcpConnectionDict completeDefinition
	(
	)
	Set completeDefinition
	(
	)
	CnProcessSet completeDefinition
	(
	)
	ObjectSet completeDefinition
	(
	)
	ExternalCollection completeDefinition
	(
	)
	ExternalDictionary completeDefinition
	(
	)
	ExternalSet completeDefinition
	(
	)
	JadeBytes completeDefinition
	(
	)
	List completeDefinition
	(
	)
	Array completeDefinition
	(
	)
	BinaryArray completeDefinition
	(
	)
	CnBinaryArray completeDefinition
	(
	)
	CnStatisticsSampleBinaryArray completeDefinition
	(
	)
	CnStatsBinaryArray completeDefinition
	(
	)
	BooleanArray completeDefinition
	(
	)
	CharacterArray completeDefinition
	(
	)
	CnHugeStringArray2D completeDefinition
	(
	)
	CnLdapBinaryArray completeDefinition
	(
		documentationText
		`Array of CnLdapBinary objects.`
	constantDefinitions
		CN_VERSION:                    Integer = 1 number = 1001;
	)
	CnLdapEntryArray completeDefinition
	(
		documentationText
		`Array of CnLdapEntry objects.`
	constantDefinitions
		CN_VERSION:                    Integer = 1 number = 1001;
	)
	CnSmallStringArray2D completeDefinition
	(
	)
	CnStringArray2D completeDefinition
	(
	)
	DateArray completeDefinition
	(
	)
	DecimalArray completeDefinition
	(
	)
	CnDecimalArray completeDefinition
	(
	)
	HugeStringArray completeDefinition
	(
	jadeMethodDefinitions
		cnGetAsParameterString(): String number = 1007;
		cnGetNextTokenPos(
			str: String; 
			delimiter: String; 
			dlen: Integer; 
			spos: Integer io; 
			addNullTokens: Boolean) updating, protected, lockReceiver, number = 1002;
		cnGetTokens(
			inputStr: String; 
			delimiter: String; 
			addNullTokens: Boolean) updating, lockReceiver, number = 1001;
	)
	IntegerArray completeDefinition
	(
	)
	ObjectArray completeDefinition
	(
	)
	CnAttachmentArray completeDefinition
	(
	)
	CnBooleanArrayArray completeDefinition
	(
	)
	CnClassArray completeDefinition
	(
	)
	CnDatabaseStructureArray completeDefinition
	(
	)
	CnJadeDynamicObjectArray completeDefinition
	(
	)
	CnNameSizeInfoArray completeDefinition
	(
	jadeMethodDefinitions
		loadInstance(
			pName: String; 
			pDec: Decimal) updating, lockReceiver, number = 1002;
	)
	CnNodeControlCnCntrlArray completeDefinition
	(
	)
	CnSmtpInlineArray completeDefinition
	(
	)
	CnStringArrayArray completeDefinition
	(
	)
	CnVariantArray completeDefinition
	(
	)
	JadeDynamicObjectArray completeDefinition
	(
	)
	StringArray completeDefinition
	(
	jadeMethodDefinitions
		cnFind(str: String): Integer number = 1001;
		cnGetNextTokenPos(
			str: String; 
			delimiter: String; 
			dlen: Integer; 
			spos: Integer io; 
			addNullTokens: Boolean) updating, protected, lockReceiver, number = 1003;
		cnGetTokens(
			inputStr: String; 
			delimiter: String; 
			addNullTokens: Boolean) updating, lockReceiver, number = 1002;
		cnGetTokensUsingTruthSet(
			pInputStr: String; 
			pTruthSet: String; 
			pAddNullTokens: Boolean) updating, lockReceiver, number = 1006;
	)
	CnLargeStringArray completeDefinition
	(
	)
	CnSmallStringArray completeDefinition
	(
	)
	CnStringArray completeDefinition
	(
		documentationText
`This was added primarily to hold an array of file path names.  In NT, MAX_PATH has value of 260.`
	)
	CnTransactionIdArray completeDefinition
	(
	)
	TimeArray completeDefinition
	(
	)
	Any completeDefinition
	(
	jadeMethodDefinitions
		cnGetType(): Type number = 1001;
	)
	Binary completeDefinition
	(
	jadeMethodDefinitions
		cnAnsiToString(length: Integer): String number = 1002;
		cnAsType(type: Type): Any number = 1004;
		cnConvertNullsToQueries(): Binary updating, number = 1003;
	externalMethodDefinitions
		pmAnsiToUnicode(
			bin: Binary; 
			length: Integer): Binary is "pmAnsiToUnicode" in "karma" protected, number = 1001;
	)
	Boolean completeDefinition
	(
	jadeMethodDefinitions
		cnReturnTickDisplayValue(): String number = 1002;
	)
	Date completeDefinition
	(
	jadeMethodDefinitions
		cnFormat_MMMYY(): String number = 1015;
		cnFormat_MonthName_Year(): String number = 1016;
		cnUserFormat(fmt: DateFormat): String number = 1043;
	)
	Decimal completeDefinition
	(
	jadeMethodDefinitions
		cnConvertToByteString(): String number = 1013;
		cnElapsedTimeInMilliSeconds(): Integer number = 1001;
		cnElapsedTimeInSeconds(): Integer number = 1005;
		cnGetElapsedTime(): String number = 1006;
		cnGetElapsedTimeMicrosString(): String number = 1002;
		cnGetElapsedTimeString(): String number = 1014;
		cnGetElapsedTime_ns(): String number = 1018;
		cnNullStringWhenZero(): String number = 1022;
	)
	Integer completeDefinition
	(
	jadeMethodDefinitions
		cnAsDayName(): String number = 1031;
		cnAsDayNameShort(): String number = 1010;
		cnAsMonthName(): String number = 1012;
		cnAsMonthNameShort(): String number = 1013;
		cnAsOrdinalName(): String number = 1011;
		cnConvertToByteString(): String number = 1042;
		cnDifference(pInteger: Integer): Integer number = 1050;
		cnMarkReleaseCutPatchString(): String number = 1003;
		cnMarkReleaseCutString(): String number = 1044;
		cnMarkReleaseString(): String number = 1017;
		cnNullStringWhenZero(): String number = 1045;
		cnToHex(): String number = 1040;
	)
	Integer64 completeDefinition
	(
	jadeMethodDefinitions
		cnConvertToByteString(): String number = 1003;
		cnNullStringWhenZero(): String number = 1004;
		cnToHex(): String number = 1002;
	)
	MemoryAddress completeDefinition
	(
	jadeMethodDefinitions
		cnToHex(): String number = 1001;
	)
	Real completeDefinition
	(
	jadeMethodDefinitions
		cnConvertToByteString(): String number = 1018;
		cnNullStringWhenZero(): String number = 1019;
	)
	String completeDefinition
	(
	jadeMethodDefinitions
		cnAsDate(): Date number = 1106;
		cnAsDayNumber(): Integer number = 1079;
		cnContains(str: String): Boolean number = 1001;
		cnConvertStringToTimeStamp(): TimeStamp number = 1002;
		cnConvertZuluStringToTimeStamp(): TimeStamp number = 1058;
		cnCountCharOccurences(pSearchCharacter: Character): Integer number = 1083;
		cnCountLiteralOccurences(pSearchLiteral: String): Integer number = 1093;
		cnDecimalToHex(length: Integer): String number = 1073;
		cnEncrypt(key: Integer): String number = 1003;
		cnEncryptV2(key: Integer): String number = 1004;
		cnFormatForCSVFile(_appendComma: Boolean): String number = 1170;
		cnFormatVersion(
			pMark: Integer output; 
			pRelease: Integer output; 
			pCut: Integer output; 
			pPatch: Integer output): String number = 1171;
		cnGetDbFileName(): String number = 1238;
		cnGetDbFilePartitionID(): Integer64 number = 1239;
		cnGetNextTokenPos(
			delimiter: String; 
			dlen: Integer; 
			spos: Integer io) protected, number = 1005;
		cnGetPatchId(pPatchId: Integer output): String number = 1084;
		cnGetServerMiscPathFromAppDbpath(): String number = 1092;
		cnGetToken(
			pStartPos: Integer io; 
			pDelimiter: String): String number = 1006;
		cnGetTokens(delimiter: String): CnStringArray number = 1007;
		cnGetTokensUsingTruthSet(truthSet: String): CnStringArray number = 1008;
		cnHHMMTime(): Time number = 1009;
		cnHasSuffix(
			pSuffix: String; 
			pCaseSensitive: Boolean): Boolean number = 1086;
		cnHexToDecimal(length: Integer): String number = 1074;
		cnHexToInteger(): Integer number = 1075;
		cnIsAlpha(): Boolean number = 1050;
		cnIsBoolean(): Boolean number = 1130;
		cnIsDecimal(pMustHaveDecimalPoint: Boolean): Boolean number = 1090;
		cnIsDecimalAndNotNegative(pMustHaveDecimalPoint: Boolean): Boolean number = 1091;
		cnIsHex(): Boolean number = 1076;
		cnIsNumeric(): Boolean number = 1203;
		cnIsNumericAndNotNegative(): Boolean number = 1085;
		cnIsTrueOrFalse(pBoolean: Boolean output): String number = 1279;
		cnMark(): Integer number = 1185;
		cnMarkRelease(): Integer number = 1197;
		cnMarkReleaseCut(): Integer number = 1240;
		cnMarkReleaseCutPatch(): Integer number = 1241;
		cnMarkReleaseCutPatchString(): String number = 1243;
		cnMarkReleaseCutPatchString_AppVersion(): String number = 1273;
		cnMarkReleaseCutString(): String number = 1242;
		cnMarkReleaseString(): String number = 1200;
		cnMultipleLines(
			pLineArray: HugeStringArray input; 
			pLineSize: Integer) number = 1077;
		cnObfuscator(pCypherText: String): String number = 1010;
		cnPadLeadingBlanks(pNum: Integer): String number = 1253;
		cnRemoveChars(pCharsToRemove: String): String number = 1254;
		cnRemoveInvalidFileNameChars(): String number = 1255;
		cnReplaceChar(
			pChar: Character; 
			pWithChar: Character) updating, number = 1011;
		cnReplaceString(
			os: String; 
			ns: String): Integer updating, number = 1172;
		cnStartsWithJoss(): Boolean number = 1276;
		cnStartsWithKarma(): Boolean number = 1277;
		cnStripLeadingAndTrailingCharacters(pCharacter: Character): String number = 1026;
		cnStripTrailingCharacters(pCharacter: Character): String number = 1094;
		cnStripTrailingSlash(): String number = 1023;
		cnToLowerFirst(): String number = 1081;
		cnToUpperFirst(): String number = 1201;
		cnTrimLeadingZeros(): String number = 1078;
		cnTrimToMaxLength(str: String) updating, number = 1173;
		cnUnbust(
			pDelimiters: String; 
			pStringArray: CnStringArray io; 
			pStripSpaces: Boolean): Integer updating, number = 1012;
		cnUnicodeToAnsi(): Binary number = 1014;
	externalMethodDefinitions
		pmUnicodeToAnsi(str: String): Binary is "pmUnicodeToAnsi" in "karma" protected, number = 1013;
	)
	Time completeDefinition
	(
	jadeMethodDefinitions
		cnMinutesDifference(time: Time): Integer number = 1001;
		cnToMinutes(): Integer number = 1002;
		cnUserFormat(fmt: TimeFormat): String number = 1006;
	)
	TimeStamp completeDefinition
	(
	constantDefinitions
		Milliseconds_In_Day:           Integer = 86400000 number = 1001;
		Minutes_In_Day:                Integer = 1440 number = 1002;
		Seconds_In_Day:                Integer = 86400 number = 1003;
	jadeMethodDefinitions
		cnConvertToGMT(bias: Integer): TimeStamp number = 1001;
		cnFormat_CCYYMMDD_hhmmss(): String number = 1023;
		cnFormat_CCYYMMDD_hhmmsscc(): String number = 1040;
		cnFormat_DDMMYY_hhmm(): String number = 1011;
		cnFormat_DDMMYY_hhmmss(): String number = 1014;
		cnFormat_DDMMYY_hhmmsscc(): String number = 1053;
		cnGMT(): TimeStamp number = 1002;
		cnGMTAppServer(): TimeStamp number = 1003;
		cnGetElapsedTimeString(): String number = 1013;
		cnGetGMTBias(bias: Integer output): Integer number = 1004;
		cnGetGMTBiasAppServer(bias: Integer output): Integer number = 1010;
		cnLocalTime(): TimeStamp number = 1005;
		cnLocalTimeAppServer(): TimeStamp number = 1006;
		cnMinutesDifference(ts: TimeStamp): Integer number = 1012;
		cnSecondsDifference(ts: TimeStamp): Integer number = 1007;
		cnZeroMilliseconds(): TimeStamp number = 1008;
		cnZeroSeconds(): TimeStamp updating, number = 1009;
	)
	TimeStampInterval completeDefinition
	(
	jadeMethodDefinitions
		cnDays(): Integer number = 1006;
		cnFormatShort(): String number = 1001;
		cnFormatted(): String number = 1002;
		cnFormattedAbsolute(): String number = 1003;
		cnFormatted_DaysHoursMins(): String number = 1004;
		cnFormatted_DaysHoursMinsSecs(): String number = 1005;
		cnHours(): Integer number = 1007;
		cnMilliseconds(): Integer number = 1008;
		cnMinutes(): Integer number = 1009;
		cnSeconds(): Integer number = 1010;
	)
memberKeyDefinitions
	CnAppDict completeDefinition
	(
		appSchemaName caseInsensitive Latin1;
		appName caseInsensitive Latin1;
	)
	CnDatabaseStructureByNameDict completeDefinition
	(
		name caseInsensitive Latin1;
	)
	CnDatabaseStructureBySizeDict completeDefinition
	(
		size descending;
		name caseInsensitive Latin1;
	)
	CnJadeApplicationDict completeDefinition
	(
		schemaName caseInsensitive Latin1;
		applicationName caseInsensitive Latin1;
	)
	CnJadeNodeDict completeDefinition
	(
		nodeId;
	)
	CnJadeProcessDict completeDefinition
	(
		processId;
	)
	CnLdapAttributeDict completeDefinition
	(
		name caseInsensitive;
	)
	CnLockTargetDict completeDefinition
	(
		schemaName;
		appName;
	)
	CnMachineDict completeDefinition
	(
		clientFQDN caseInsensitive;
	)
	CnNameSizeInfoByNameDict completeDefinition
	(
		name caseInsensitive Latin1;
	)
	CnNameSizeInfoBySizeDict completeDefinition
	(
		size descending;
		name;
	)
	CnProcessDict completeDefinition
	(
		processId caseInsensitive;
	)
	CnSDSStructureStateDict completeDefinition
	(
		name;
		partitionId;
	)
	CnSchemaElementDict completeDefinition
	(
		lastModified descending;
	)
	CnTcpClientDict completeDefinition
	(
		connectionNo caseInsensitive;
		remoteId caseInsensitive;
	)
	CnTcpConnectionDict completeDefinition
	(
		cnPort;
		connectionNo;
	)
inverseDefinitions
	allCnDatabaseStructuresBySize of CnDatabaseAdmin automatic parentOf myCnDatabaseAdmin of CnDatabaseStructure manual;
	allCnProcesses of CnApp automatic peerOf myCnApp of CnProcess manual;
	allApps of CnMachine automatic peerOf myCnMachine of CnApp manual;
	allCnTcpClients of CnCntrl automatic parentOf myCnCntrl of CnTcpConnection manual;
	allCnTcpConnections of CnCntrl automatic parentOf myCnCntrl of CnTcpConnection manual;
	allCnJadeApplications of CnKarmaCntrl automatic parentOf myCnKarmaCntrl of CnJadeSystemClasses manual;
	allCnJadeNodes of CnKarmaCntrl automatic parentOf myCnKarmaCntrl of CnJadeSystemClasses manual;
	allCnJadeProcesses of CnKarmaCntrl automatic parentOf myCnKarmaCntrl of CnJadeSystemClasses manual;
	allCnProcesses of CnKarmaCntrl automatic peerOf myCnKarmaCntrl of CnProcess manual;
	allMachines of CnKarmaCntrl automatic peerOf myKarmaCntrl of CnMachine manual;
	allBinaryValues of CnLdapAttribute automatic parentOf myAttribute of CnLdapBinary manual;
	allAttributes of CnLdapEntry automatic parentOf myEntry of CnLdapAttribute manual;
	mySearchConstraints of CnLdapConnection parentOf myLdapConnection of CnLdapConstraints;
	mySearchConstraints of CnLdapSearch parentOf mySearchObject of CnLdapConstraints;
	allEntries of CnLdapSearch automatic parentOf mySearchObject of CnLdapEntry manual;
	myAttachments of CnSmtpConnection peerOf mySmtpConnection of CnAttachment;
	mySmtpConnection of CnSmtpInline peerOf allInlines of CnSmtpConnection;
	allProcesses of CnMachine automatic peerOf myMachine of CnProcess manual;
	allLockTargets of CnRoot automatic parentOf myCnRoot of CnLockTarget manual;
	allSDSStructureState of CnRoot automatic parentOf myCnRoot of CnSDSStructureState manual;
	allCnJadeProcesses of CnJadeApplication automatic peerOf myCnJadeApplication of CnJadeProcess manual;
	allCnJadeProcesses of CnJadeNode automatic parentOf myCnJadeNode of CnJadeProcess manual;

databaseDefinitions
	CardSchemaDb
	(
	databaseFileDefinitions
		"innoc" number = 137;
		"K_Joss" number = 51;
		"K_LDAP" number = 79;
		"K_LockTarget" number = 552;
		"K_Procs" number = 52;
		"K_SMTP" number = 53;
		"ominous" number = 54;
		"CardMap" number = 55;
	defaultFileDefinition "CardMap";
	classMapDefinitions
		A_VersionClass in "CardMap";
		CardSchema in "_usergui";
		CnAdmin in "CardMap";
		CnAdvice in "CardMap";
		CnAgents in "CardMap";
		CnApp in "CardMap";
		CnAppDict in "CardMap";
		CnApplicationLauncher in "CardMap";
		CnAttachment in "K_SMTP";
		CnAttachmentArray in "K_SMTP";
		CnBackup in "CardMap";
		CnBackupAdvice in "CardMap";
		CnBackupCmd in "CardMap";
		CnBatchMgr in "CardMap";
		CnBinaryArray in "CardMap";
		CnBooleanArrayArray in "CardMap";
		CnClassArray in "CardMap";
		CnClusterInfo in "CardMap";
		CnCntrl in "CardMap";
		CnCommand in "CardMap";
		CnCompactAdvice in "CardMap";
		CnCompactCmd in "CardMap";
		CnControlAdvice in "CardMap";
		CnControlCmd in "CardMap";
		CnDatabaseAdmin in "CardMap";
		CnDatabaseStructure in "CardMap";
		CnDatabaseStructureArray in "CardMap";
		CnDatabaseStructureByNameDict in "CardMap";
		CnDatabaseStructureBySizeDict in "CardMap";
		CnDeadlockHandler in "CardMap";
		CnDecimalArray in "CardMap";
		CnDeployMgrTcpConnection in "CardMap";
		CnExceptionAdvice in "CardMap";
		CnExecuteAdvice in "CardMap";
		CnExecuteCmd in "CardMap";
		CnExternalMethods in "CardMap";
		CnFile in "CardMap";
		CnFileDetailsAdvice in "CardMap";
		CnFtp in "CardMap";
		CnFtp64 in "CardMap";
		CnFunctionAgent in "CardMap";
		CnHttp in "CardMap";
		CnHttp64 in "CardMap";
		CnHugeStringArray2D in "CardMap";
		CnIniFileAgent in "CardMap";
		CnInternet in "CardMap";
		CnInternet64 in "CardMap";
		CnIpAddress in "CardMap";
		CnJadeApplication in "K_Joss";
		CnJadeApplicationDict in "K_Joss";
		CnJadeCareExecutor in "CardMap";
		CnJadeDatabaseAdmin in "CardMap";
		CnJadeDatabaseAdminExternal in "CardMap";
		CnJadeDynamicObject in "CardMap";
		CnJadeDynamicObjectArray in "CardMap";
		CnJadeNode in "K_Joss";
		CnJadeNodeDict in "K_Joss";
		CnJadeProcess in "K_Joss";
		CnJadeProcessDict in "K_Joss";
		CnJadeSkinsLoader in "CardMap";
		CnJadeSystemClasses in "CardMap";
		CnJadeTestCaseListenerIf in "CardMap";
		CnKCLockCheck in "CardMap";
		CnKCNodeControl in "CardMap";
		CnKCSDSChecks in "CardMap";
		CnKCStatsCollector in "CardMap";
		CnKCVerifyJournal in "CardMap";
		CnKarmaCntrl in "CardMap";
		CnKarmaTcpConnection in "CardMap";
		CnLargeStringArray in "CardMap";
		CnLdap in "K_LDAP";
		CnLdapAttribute in "K_LDAP";
		CnLdapAttributeDict in "K_LDAP";
		CnLdapBinary in "K_LDAP";
		CnLdapBinaryArray in "K_LDAP";
		CnLdapConnection in "K_LDAP";
		CnLdapConstraints in "K_LDAP";
		CnLdapEntry in "K_LDAP";
		CnLdapEntryArray in "K_LDAP";
		CnLdapException in "K_LDAP";
		CnLdapSearch in "K_LDAP";
		CnLdapSyntax in "K_LDAP";
		CnLdapURL in "K_LDAP";
		CnLockCheck in "CardMap";
		CnLockTarget in "K_LockTarget";
		CnLockTargetDict in "K_LockTarget";
		CnLocks in "CardMap";
		CnMIME in "K_SMTP";
		CnMachine in "CardMap";
		CnMachineDict in "CardMap";
		CnManagerClass in "CardMap";
		CnMessage in "CardMap";
		CnNameSizeInfo in "CardMap";
		CnNameSizeInfoArray in "CardMap";
		CnNameSizeInfoByNameDict in "CardMap";
		CnNameSizeInfoBySizeDict in "CardMap";
		CnNamedPipe in "CardMap";
		CnNodeControl in "CardMap";
		CnNodeControlCnCntrl in "CardMap";
		CnNodeControlCnCntrlArray in "CardMap";
		CnNodeStatsAdvice in "CardMap";
		CnParam in "CardMap";
		CnPersistentDb in "K_Procs";
		CnPingCmd in "CardMap";
		CnPingReplyAdvice in "CardMap";
		CnProcCmd in "ominous";
		CnProcess in "K_Joss";
		CnProcessDict in "K_Joss";
		CnProcessSet in "K_Procs";
		CnProfilingAgent in "CardMap";
		CnQueuedLockDepth in "CardMap";
		CnRoot in "K_Procs";
		CnSDSAdvice in "CardMap";
		CnSDSCmd in "CardMap";
		CnSDSDatabaseAdmin in "CardMap";
		CnSDSStructureState in "CardMap";
		CnSDSStructureStateDict in "CardMap";
		CnSSLAdvice in "CardMap";
		CnSchemaAnalyser in "CardMap";
		CnSchemaCopyCmd in "K_Procs";
		CnSchemaCopyCompleteAdvice in "K_Procs";
		CnSchemaElement in "CardMap";
		CnSchemaElementDict in "CardMap";
		CnSchemaSession in "_environ";
		CnSecurityManager in "CardMap";
		CnServerStatistics in "CardMap";
		CnSessionAdvice in "CardMap";
		CnSessionCloseAdvice in "CardMap";
		CnSessionOpenAdvice in "CardMap";
		CnSmallStringArray in "CardMap";
		CnSmallStringArray2D in "CardMap";
		CnSmtpConnection in "K_SMTP";
		CnSmtpConnectionException in "K_SMTP";
		CnSmtpInline in "K_SMTP";
		CnSmtpInlineArray in "K_SMTP";
		CnSmtpState in "K_SMTP";
		CnSmtpStateAUTH in "K_SMTP";
		CnSmtpStateDATA in "K_SMTP";
		CnSmtpStateDATASent in "K_SMTP";
		CnSmtpStateHELO in "K_SMTP";
		CnSmtpStateMAIL in "K_SMTP";
		CnSmtpStateNOOP in "K_SMTP";
		CnSmtpStateQUIT in "K_SMTP";
		CnSmtpStateRCPT in "K_SMTP";
		CnSmtpStateRSET in "K_SMTP";
		CnSmtpStateTCPConnected in "K_SMTP";
		CnSmtpStateTCPDisconnected in "K_SMTP";
		CnStackDump in "CardMap";
		CnStartManager in "CardMap";
		CnStatisticsAdvice in "CardMap";
		CnStatisticsSampleBinaryArray in "CardMap";
		CnStatsBinaryArray in "CardMap";
		CnStringArray in "CardMap";
		CnStringArray2D in "CardMap";
		CnStringArrayArray in "CardMap";
		CnTcpClientDict in "CardMap";
		CnTcpConnection in "CardMap";
		CnTcpConnectionDict in "CardMap";
		CnThinClientConnBalancing in "CardMap";
		CnThreadAdvice in "ominous";
		CnThreadCmd in "ominous";
		CnToolBarPicture in "_usergui";
		CnTransactionAgent in "CardMap";
		CnTransactionData in "CardMap";
		CnTransactionIdArray in "CardMap";
		CnTransactionStack in "CardMap";
		CnTransactionStatistics in "CardMap";
		CnTransientDb in "CardMap";
		CnTrapAdvice in "CardMap";
		CnUtility in "CardMap";
		CnValidateMethodAgent in "CardMap";
		CnVariant in "CardMap";
		CnVariantArray in "CardMap";
		CnWatchAdvice in "ominous";
		GCardSchema in "CardMap";
	)
schemaViewDefinitions
	RichardsView
	(
	AppNameDict;
	Application;
	Array;
	ArrayBlock;
	ArrayIterator;
	Attribute;
	BinaryArray;
	BooleanArray;
	BrowseButtons;
	Btree;
	BtreeBlock;
	CMDColor;
	CMDFileSave;
	CMDFont;
	CMDPrint;
	CheckBox;
	Class;
	ClassColl;
	ClassNDict;
	CnForm;
	CnTcpConnection;
	CnTcpConnectionDict;
	CollClass;
	CollClassSet;
	Collection;
	CollectionBlock;
	ComboBox;
	CompAttribute;
	Connection;
	ConstCategoryNDict;
	Constant;
	ConstantCategory;
	ConstantNDict;
	ConstantSet;
	ControlLogicSet;
	ControlOrdList;
	ControlPropNameDict;
	CurrencyFormat;
	DataHandler;
	Database;
	DatabaseNDict;
	DateArray;
	DateFormat;
	DbClassMap;
	DbClassMapDict;
	DbClassMapSet;
	DbFile;
	DbFileNDict;
	DbServer;
	DbServerNDict;
	DecimalArray;
	DeltaInfo;
	DeltaInfoArray;
	DevControlClass;
	DevControlLogicTypes;
	DevControlProperties;
	DevControlTypes;
	Development;
	DictBlock;
	DictIterator;
	Dictionary;
	EntryPointDict;
	Exception;
	ExceptionClass;
	ExplicitInverseRef;
	ExternalKey;
	ExternalMethod;
	FatalError;
	Feature;
	FeatureArray;
	FeatureSet;
	FeatureUsage;
	FeatureUsageColl;
	FeatureUsageSet;
	File;
	FileException;
	FileFolder;
	FileNode;
	FileNodeArray;
	Folder;
	Form;
	FormNameDict;
	FormOrdList;
	Frame;
	Function;
	FunctionNDict;
	GCardSchema;
	GUIClass;
	Global;
	GlobalConstant;
	GroupBox;
	HScroll;
	ImplicitInverseRef;
	InlineTypeUsage;
	InlineUsageColl;
	Inspector;
	IntegerArray;
	IntegrityViolation;
	Inverse;
	InverseSet;
	Iterator;
	JadeCompiler;
	JadeLocalVar;
	JadeLocalVarColl;
	JadeMethod;
	JadeScript;
	Key;
	KeyColl;
	Label;
	Library;
	LibraryNDict;
	List;
	ListBlock;
	ListBox;
	Locale;
	LocaleFormat;
	LocaleFullInfo;
	LocaleNDict;
	LocaleNameInfo;
	Lock;
	LockArray;
	LockException;
	MemberKey;
	MemberKeyDictionary;
	MemberKeySet;
	MenuItem;
	MenuItemData;
	MenuOrdList;
	Method;
	MethodCallDesc;
	MethodColl;
	MethodNDict;
	MethodSet;
	Node;
	NodeDict;
	NormalException;
	Notification;
	NotificationArray;
	NumberFormat;
	ObjMethodCallDesc;
	Object;
	ObjectArray;
	ObjectLongNameDict;
	ObjectNameDict;
	Ocx;
	OleArray;
	OleBlock;
	OleInsert;
	OleObject;
	OptionButton;
	Parameter;
	ParameterColl;
	Picture;
	PrimAttribute;
	PrimMethodCallDesc;
	PrimType;
	PrimTypeNDict;
	Printer;
	PrintingDialog;
	Process;
	ProcessDict;
	ProcessStackArray;
	ProgressDialog;
	Property;
	PropertyColl;
	PropertyNDict;
	PropertySet;
	PseudoType;
	PseudoTypeNDict;
	RACollectionValue;
	RAMethod;
	RAOid;
	RAProperty;
	RARelationIndex;
	RARelationKey;
	RARelationOid;
	RealArray;
	Rectangle;
	RectangleArray;
	Reference;
	ReferenceSet;
	RelationalAttribute;
	RelationalAttributeDict;
	RelationalTable;
	RelationalTableClass;
	RelationalTableCollection;
	RelationalTableDict;
	RelationalTableRelationship;
	RelationalTableXRelationship;
	RelationalView;
	RelationalViewDict;
	Relationship;
	RelationshipNDict;
	ReturnType;
	RootSchemaApp;
	RootSchemaGlobal;
	Routine;
	RoutineSet;
	Schema;
	SchemaColl;
	SchemaEntity;
	SchemaEntityNDict;
	SchemaNDict;
	SchemaView;
	SchemaViewNDict;
	SchemaViewSet;
	Script;
	ScriptElement;
	ScriptSet;
	SetBlock;
	SetIterator;
	Sheet;
	SortActor;
	SortActorArray;
	StringArray;
	System;
	SystemException;
	TcpIpConnection;
	TextBox;
	TimeArray;
	TimeFormat;
	TimeStampArray;
	TranslatableString;
	Type;
	TypeColl;
	TypeNDict;
	TypeSet;
	TypeUsage;
	TypeUsageSet;
	UserInterfaceException;
	UserProfile;
	UserProfileNDict;
	VCollIterator;
	VirtualColl;
	Window;
	)
externalFunctionSources
cnCopyToClipboard
{
cnCopyToClipboard( s : String ) : Integer is "cnCopyToClipboard" in karma;
}
cnFileVersionInfo
{
cnFileVersionInfo(fileName 	: String;
				  infoType	: String;
				  infoBuff	: String[50] output;
				  maxLength : Integer;
				  errText	: String[200] output) : Integer is "cnFileVersionInfo" in karma;
}
cnGetCommandLine
{
cnGetCommandLine(value : String [1024] output;
				 maxLength : Integer io) : Integer is "cnGetCommandLine" in karma;
}
cnGetCurrentProcessId
{
cnGetCurrentProcessId() : Integer is "GetCurrentProcessId" in kernel32;
}
cnGetCurrentThreadId
{
cnGetCurrentThreadId() : Integer is "GetCurrentThreadId" in kernel32;
}
cnGetDriveInfo
{
//   This method returns 	0 = Unknown drive type
//						 	1 = Invalid, as the drive has no root directory
//						  	2 = Removeable
//							3 = Fixed
//							4 = Remote (i.e. mapped drive)
//							5 = CD ROM
//							6 = RAM Disk

cnGetDriveInfo(driveName   	: String;
			   volumeName	: String[32] output;
			   pcName		: String[128] output) : Integer is "cnGetDriveInfo" in karma;
}
cnGetDriveInfoEx
{
cnGetDriveInfoEx(driveName   	: String;
			   volumeName	: String[260] output;
			   pcName		: String[260] output;
			   iType		: Integer output) : Integer is "cnGetDriveInfoEx" in karma;
//   iType values:
//	 	0 = Unknown drive type
//	 	1 = Invalid, as the drive has no root directory
//	  	2 = Removeable
//		3 = Fixed
//		4 = Remote (i.e. mapped drive)
//		5 = CD ROM
//		6 = RAM Disk

//	Return value
//		0	Success
//		-1	Volume name exceeds 256 characters
//		-2	PC name exceeds 256 characters
//		-3	Volume name and PC name both exceed maximum lengths
}
cnGetDriveMapping
{
cnGetDriveMapping(driveName : String; mapName : String[260] output; maxLength : Integer) : Integer is "cnGetDriveMapping" in karma;
}
cnGetEnvironmentVariable
{
cnGetEnvironmentVariable(variable : String; value : String[256] output; maxLength : Integer) : Integer is "cnGetEnvironmentVariable" in karma;
}
cnGetLogicalDrives
{
cnGetLogicalDrives(drives : String[30] output) : Integer is "cnGetLogicalDrives" in karma;
}
cnGetSubDirectories
{
cnGetSubDirectories(parentDirectory : String; subDirList : String[8192] output; maxListLength : Integer) : Integer is "cnGetSubDirectories" in karma;
}
cnHasSubDirectories
{
cnHasSubDirectories(dirName : String) : Boolean is "cnHasSubDirectories" in karma;
}
cnIsProcessRunning
{
cnIsProcessRunning(pProcessName : String) : Boolean is "cnIsProcessRunning" in karma;
}
cnSetModifyTime
{
cnSetModifyTime(fileName : String; newDate, newTime : Integer) : Integer is "cnSetModifyTime" in karma;
}
getFileVersionInfoANSI
{
getFileVersionInfoANSI(pPath 		: String;
					   pParam1		: String;
					   pLength 	 	: String;
					   pInfoblock	: Binary[3000] output) : Boolean is "GetFileVersionInfoA" in version presentationClientExecution;
}
getFileVersionInfoUnicode
{
getFileVersionInfoUnicode(	pPath 		: String;
							pParam1		: String;
							pLength  	: String;
							pInfoblock	: Binary[3000] output):Boolean is "GetFileVersionInfoW" in version presentationClientExecution;
}
verQueryValueANSI
{
verQueryValueANSI(pInfoblock 	: Binary;
				  pSubblock		: String;
				  pTxtMemAddr 	: MemoryAddress output; 
				  pTxtLen		:Integer output) : Boolean is "VerQueryValueA" in version applicationServerExecution;
}
verQueryValueUnicode
{
verQueryValueUnicode(pInfoblock 	: Binary;
				  pSubblock		: String;
				  pTxtMemAddr 	: MemoryAddress output; 
				  pTxtLen		:Integer output) : Boolean is "VerQueryValueW" in version applicationServerExecution;
}
typeSources
	Object (
	jadeMethodSources
cnAnsiBinary
{
cnAnsiBinary(str : String) : Binary;

vars
	// Accepts a unicode or ANSI string, and returns a binary containing
	// an ANSI string.
begin
	if app.isUnicode and
	   str <> null 	 then				// PAR 212 : handle empty string correctly		
		return emUnicodeToAnsi(str);		
	else
		return str.Binary;
	endif;
end;
}
cnCheckEdition
{
cnCheckEdition();

vars

begin
	resynch();				//  used to be conditional on edition - this is historical. 
	//  					//  Don't use this method in new systems : resynchObject(obj) is better.
end;
}
cnCheckTransactionStack
{
cnCheckTransactionStack(inTag : Integer; callingMethodName : String; checkLast : Boolean) : Integer protected;

	//  The checkLast parameter, if false, allows the calling method to specify a tag other than the
	//  expected last tag in the stack, without returning an exception.

vars
	kc		: CnKarmaCntrl;
	tag		: Integer;
	offset	: Integer;
	codePos	: Integer;
	stack	: CnTransactionStack;
	meth	: Method;
	tranId	: String;
begin
	kc		:= app.myCnKarmaCntrl;
	tag		:= inTag;
	
	if tag = CN_TRAN_STATS_DISCARD_ALL then			// 9999
		return tag;
	endif;
	
	if inTag = -2 then								// cnEndTransaction was called
		tag		:= kc.getCallStackPosition() - 3;
		offset	:= 3;
	else											// One of the cnXxxxEx methods was called with a tag
		tag		:= inTag;
		offset	:= 2;
	endif;
	
    stack	:= app.myCnTransactionStack;

	if stack.tags.isEmpty then
		meth	:= method.cnGetPriorMethod(offset, codePos);
		app.cnRaiseNormalException(Cn_Transaction_Error, callingMethodName, 
								   "Encountered cnEndTransaction in " & meth.qualifiedName & " but there was " &
								   "no current logical transaction.", false);

	elseif checkLast and stack.tags.last <> tag then
		meth	:= method.cnGetPriorMethod(offset, codePos);
		tranId	:= stack.transactionIds.last();
		app.cnClearLogicalTransactionStack();
		app.cnRaiseNormalException(Cn_Transaction_Error, callingMethodName, 
								   "Encountered cnEndTransaction in " & meth.qualifiedName & " but last cnStartTransaction " &
								   "had id=" & tranId & " : indicates missing cnEndTransaction.", false);
	endif;
	
	return tag;
end;
}
cnDiscardTransaction
{
cnDiscardTransaction(tag : Integer);

vars
	cc		: CnCntrl;
	stack	: CnTransactionStack;
	index	: Integer;
	i		: Integer;
begin
	if app.myCnKarmaCntrl = null then
		return;
	endif;
	
	cc		:= app.myCnCntrl;

	if not cc.clientTranStats then
		return;
	endif;
	
	cnCheckTransactionStack(tag, method.cnGetMethodName(), false);
	
	stack	:= app.myCnTransactionStack;
	index	:= stack.startTimes.size;
	
	if tag <> CN_TRAN_STATS_DISCARD_ALL then
		stack.startTimes.replace(index, -1);		// this gets detected in cnEndTransactionEx
	else
		foreach i in 1 to index do
			stack.startTimes.replace(i, -1);		
		endforeach;
	endif;  
end;
}
cnEndTransaction
{
cnEndTransaction();

vars

begin
	if app.myCnKarmaCntrl = null then
		return;
	endif;
	
	self.cnEndTransactionEx(-2);
epilog

end;
}
cnEndTransactionEx
{
cnEndTransactionEx(inTag : Integer);

vars
	cc				: CnCntrl;
	
	kc				: CnKarmaCntrl;
	
	cnproc			: CnProcess;
	
	stack			: CnTransactionStack;
	
	jdo,
	jdo2			: CnJadeDynamicObject;

	nodeSampleStats,
	tranError		: Boolean;

	bin,
	bin2,								// rpc
	bin3			: Binary;			// local

	error,
	tranState		: Character;

	dbTranId,
	elapsedDec,
	now,
	startTime		: Decimal[23];
	
	elapsed,
	index,
	len,
	level,
	locLen,							// local stats length
	procInstance,
	pos,
	rpcLen,							// rpc stats length
	tag				: Integer;
	
	str,
	tranId			: String;
	
	ts				: TimeStamp;
begin
	cc		:= app.myCnCntrl;
	if not cc.clientTranStats then
		return;
	endif;

	kc		:= app.myCnKarmaCntrl;
	stack	:= app.myCnTransactionStack;
	tag 	:= self.cnCheckTransactionStack(inTag, method.cnGetMethodName(), true);	// this will raise an exception if there is a start-end pair mismatch
	tranId	:= stack.transactionIds.last;
	index	:= stack.tags.size();
	level	:= index;
	
	startTime := stack.startTimes.last;
	if startTime = -1 then								// discarded entry
	 	return;											// we cut the stack back in the epilog
	endif;
	
	tranState := stack.transactionStates.last;
	if tranState = "S" then								// suspended, never resumed, so it has an elapsed time, not
		elapsedDec	:= startTime;						// a relative machine time value.
		
	else
		now			:= app.cnGetClientRelativeMachineTime;
		if now < startTime then
			//
			//  See PAR 205.  Current investigation indicates that the wraparound value for the relativeMachineTime
			//  counter will vary according to CPU speed.  However the basic hardware tick counter is a 64-bit
			//  counter, and wraparound is thought to normally take years after reboot.
			//
			cc.cnWriteLog(cc.CnLogComment, "Transaction statistic discarded for tran id '" & tranId & "' : relativeMachineTime counter has wrapped.", null);
			return;
		else
			elapsedDec	:= now - startTime;
		endif;
	endif;
		
	if elapsedDec >= Max_Integer then
		elapsed	:= Max_Integer;
	else
		elapsed	:= elapsedDec.Integer;
	endif;

	if self.TranStats_Debug then
		self.zCnLogTransactionEntry(method, tranId, " [" & index.String & "] endTransaction, now=" & now.String & ", startTime=" & startTime.String & ", elapsedDec=" & elapsedDec.String & ", elapsed=" & elapsed.String);
	endif;

    if stack.transactionErrors.last then
    	error 	:= "E";
    else
    	error 	:= " ";
    endif;
    
	nodeSampleStats := (cc.myNodeControl <> null	and		
						cc.myNodeControl.sampleProcessStats);							// get process statistics
   	if nodeSampleStats															and
   	   stack.processPersistentStatsObjects.size = stack.transactionIds.size 	then	// can be out of sync if stats were switched on during
 		bin2			:= stack.getProcessStats;										// a transaction (could even be nested transactions)
		rpcLen			:= bin2.length;
		bin3			:= stack.getThinClientProcessStats;
		locLen			:= bin3.length;
	endif;
    
   	ts	:= app.actualTimeAppServer;
    if cc.logLogicalTransactions then
    	str	:= ts.date.cnUserFormat($CnCCYYMMDD_ns) & CN_COMMA &
			   ts.time.cnUserFormat($CnHHMMSS_ns) & CN_COMMA &
			   tranId & CN_COMMA &
			   elapsed.String & CN_COMMA &
			   error;
		if rpcLen > 0 then
			pos	:= 5;
			while pos < rpcLen do
				str		:= str & CN_COMMA & bin2[pos:8].Real.String;
				pos		:= pos + 8;
			endwhile;
			
			if locLen > 0 then
				pos	:= 6;
				while pos < locLen do
					str		:= str & CN_COMMA & bin3[pos:8].Real.String;
					pos		:= pos + 8;
				endwhile;
			endif;
		endif;

		str := str & CN_COMMA & level.String;
		stack.writeLog(str); 							// writes to flat file on node's host (e.g. app server)
    endif;
    
  	cnproc 		:= kc.myCnProcess;
  	if cnproc = null then								// KarmaControl=false in .ini file (not managed), 
  		return;											// so delete stack entry (in epilog) & return
  	endif;
  	
	tranError := stack.transactionErrors.last;
	procInstance := cnGetInstanceId(process);
  	bin[1:4]	:= 0.Binary;							// placeholder for length
 	bin[5:8]	:= ts.Binary;
  	bin[13:4]	:= elapsed.Binary;
  	bin[17:1]	:= cnAnsiBinary(tranError.Character);
  	len			:= tranId.length;
  	bin[18:4]	:= len.Binary;
  	bin[22:len]	:= cnAnsiBinary(tranId);
  	pos			:= len + 22;
	dbTranId	:= process.getTransactionId64();		// TWL enhanced cn_tranlog diagnostics patch
	bin[pos:12]	:= dbTranId.Binary;						//
	pos			:= pos + 12;							//
	bin[pos:4]	:= procInstance.Binary;		//
	pos			:= pos + 4;								//
	bin[pos:4]	:= level.Binary;						// nested level at end of file
	pos			:= pos + 4;
  	if nodeSampleStats then			// get process statistics
		bin[pos : rpcLen]	:= bin2;
		pos					:= pos + rpcLen;
		bin[pos : locLen]	:= bin3;
		pos					:= pos + locLen;
	endif; 

	len 		:= bin.length();
	bin[1:4]	:= len;

	cnproc.tranStats.add(bin);
	cnproc.incrementTransStatsLength(len);																						// PAR 855
/*	cc.cnWriteLog(cc.CnLogDiag, method.qualifiedName & " transaction stats length=" & len.String & 
														", rpcLe=" & rpcLen.String & 
														", locLen=" & locLen.String &
														" accum length=" & cnproc.tranStatsLength.String, null);
*/	// we prefer to NOT do this action as part of the logical transaction														// PAR 855
	// but may need to to avoid large growth in transients and in the transient map file.										// PAR 855
	if cc.appName <> CN_KCCMGR 									and																// PAR 855
	   cnproc.tranStatsLength > (kc.Max_TranStats_Length * 3) 	then															// PAR 855
		// if the size grows to 3 times the user info size, then force a send to KCCMgr											// PAR 855
		// as one of the following could be true:																				// PAR 855
		//	- the tran stats interval has not been set																			// PAR 855
		//	- doing lots of instrumented transactions before the Tran_Stats_Timer timer fires									// PAR 855
		// 	- processing without going into idle to allow the timer to action													// PAR 855
		kc.handleTranStatsRequestEvent();																						// PAR 855
	endif;																														// PAR 855
epilog
	if cc.clientTranStats 		and
	   stack.tags.size() > null	and 
	   stack.tags.last = tag 	then			// may have already been removed if we're in exception state
	   	//
		stack.tags.removeAt(index);
		stack.transactionIds.removeAt(index);
		stack.transactionErrors.removeAt(index);
		stack.startTimes.removeAt(index);
		stack.transactionStates.removeAt(index);
		
		if cc.myNodeControl <> null 			and		
		   cc.myNodeControl.sampleProcessStats 	then
		   	//
			if stack.processPersistentStatsObjects.size = index then		// could be out of sync if process stats switched on during transaction.
				jdo	:= stack.processPersistentStatsObjects[index];
				stack.processPersistentStatsObjects.removeAt(index);
				delete jdo;
				jdo2	:= stack.processThinClientStatsObjects[index];
				stack.processThinClientStatsObjects.removeAt(index);
				delete jdo2;
			endif;
		endif;	
	endif;						
end;
}
cnGetInstanceId
{
cnGetInstanceId(obj : Object) : Integer;

vars
	str, s		: String;
	posn, t, i 	: Integer;
begin
	posn := 1;
	str := self.getOidStringForObject(obj);
	posn := str.reversePos(".") + 1;
	return str[posn : end].Integer;
end;
}
cnGetInstanceId64
{
cnGetInstanceId64(pObject : Object) : Integer64;

vars
	posn 	: Integer;
	
	str		: String;
begin
	str := self.getOidStringForObject(pObject);
	posn := str.reversePos(CN_PERIOD) + 1;
	return str[posn : end].Integer64;
end;
}
cnGetIntegerConstantName
{
cnGetIntegerConstantName(category : String; value : Integer; isEventType : Boolean) : String;

vars
    gc			: Constant;
    ccat		: ConstantCategory;
    cd			: ConstantNDict;
    superschema	: Schema;
    schema		: Schema;
    i			: Integer;
begin
	//  This method written for JADE Systems Manager and CardSchema, and may not 
	//  necessarily meet generic requirements for all subschemas. 
	//
	//  Note that this method should be used sparingly : it is expensive for deep
	//  schema hierarchies.
	//
	if isEventType then
		if value = Any_System_Event then
			return "Any_System_Event";
			
		elseif value = Object_Create_Event then
			return "Object_Create_Event";
			
		elseif value = Object_Update_Event then
			return "Object_Update_Event";
			
		elseif value = Object_Delete_Event then
			return "Object_Delete_Event";
		endif;
	endif;
	
	schema	:= currentSchema;
	ccat	:= schema.getConstantCategory(category);
	
	if ccat = null then							// search for category in superschemas
		foreach i in 1 to 20 do										
			schema		:= schema.superschema;
			if schema = null then 
				break;
			endif;
			
			ccat	:= schema.getConstantCategory(category);
			if ccat <> null then
				break;
			endif;	
		endforeach;	
	endif;
	
	if ccat <> null then
   		cd 		:= ccat.getConstants();
	   	foreach gc in cd do
	   		if gc.type = Integer and gc.valueAsInteger = value then 		
	   			return gc.name;
	   		endif;
   		endforeach;
   	endif;

	return value.String;			// if constant not found in specified category
end;
}
cnResumeTransaction
{
cnResumeTransaction() clientExecution;

vars
	cc		: CnCntrl;
	stack	: CnTransactionStack;
	index	: Integer;
	i		: Integer;
	now		: Decimal[23];
	start	: Decimal[23];
	oldstart: Decimal[23];
begin
	if app.myCnKarmaCntrl = null then
		return;
	endif;
	
	cc		:= app.myCnCntrl;

	if not cc.clientTranStats then
		return;
	endif;
	
	stack	:= app.myCnTransactionStack;
	now		:= app.cnGetClientRelativeMachineTime();
	index	:= stack.startTimes.size();
	
	foreach i in 1 to index do
		if stack.transactionStates[i] = " " then							// PAR 479 - don't resume transaction unless suspended
			if self.TranStats_Debug then									// PAR 479
				self.zCnLogTransactionEntry(method, 						// PAR 479
										  stack.transactionIds[i], 			// PAR 479
										  " already active, ignored");		// PAR 479
			endif;															// PAR 479
																			// PAR 479
			continue;														// PAR 479
		endif;																// PAR 479

		start	:= stack.startTimes[i];
		oldstart := start;
		if start <> -1 then								// PAR 205 (already discarded transaction statistic)
			if now < start then							// PAR 205
				start	:= -1;							// wraparound : discard
				
			else
				start	:= now - stack.startTimes[i];	// current time minus time elapsed so far
			endif;
			
			stack.startTimes.replace(i, start);
		endif;	
		
		stack.transactionStates.replace(i, " ");		// indicates that the item has been resumed
		if self.TranStats_Debug then
			self.zCnLogTransactionEntry(method, stack.transactionIds[i], " [" & i.String & "] resumed, now=" & now.String & ", old start=" & oldstart.String & ", new start=" & start.String);
		endif;
	endforeach;
end;
}
cnSetTransactionError
{
cnSetTransactionError(currentTransactionOnly : Boolean);

vars
	//  Used to indicate that the current transaction had an error.  If
	//  parameter is false all transactions in the nest are marked as in error.

	kc		: CnKarmaCntrl;
	stack	: CnTransactionStack;
	bool	: Boolean;
	i		: Integer;
	size	: Integer;	

begin
	if app.myCnKarmaCntrl = null then
		return;
	endif;
	
	if not app.myCnCntrl.clientTranStats then
		return;
	endif;

 	kc		:= app.myCnKarmaCntrl;
 	stack	:= app.myCnTransactionStack;
	if stack.tags.isEmpty then
		app.cnRaiseNormalException(Cn_Transaction_Error, null, "cnSetTransactionError called when no transaction in progress.", false);
		return;
	endif; 	

 	if currentTransactionOnly then
 		stack.transactionErrors[stack.transactionErrors.size] := true;

	else
		size	:= stack.tags.size;
		i		:= 1;
		while i <= size do
			stack.transactionErrors[i]	:= true;
			i := i + 1;
		endwhile;
	endif;
end;
}
cnStartTransaction
{
cnStartTransaction(id : String) : Integer;

vars
 	cc			: CnCntrl;

 	kc			: CnKarmaCntrl;				// This method is used with cnEndTransaction to capture performance data
 	
	stack		: CnTransactionStack;

 	jdo1,
 	jdo2		: CnJadeDynamicObject;
	
	tranState	: Character;
	
 	statsType,
 	tag			: Integer;					// Use of returned tag is optional, used with cnEndTransactionEx.
	
 	tranId		: String;
begin
	if app.myCnKarmaCntrl = null then
		return -1;
	endif;
	
	if not app.myCnCntrl.clientTranStats then
		return -1;
	endif;

	if id = "" then
		app.cnRaiseNormalException(Cn_Transaction_Error, id,
 		                           "cnStartTransaction called with null transaction identifier.", false);
 		return -1; 	
	endif;
		
	if id.length > CN_TRANSACTION_ID_MAXLENGTH then
		app.cnRaiseNormalException(Cn_Transaction_Error, id,
 		                           "cnStartTransaction called with overlength transaction identifier - max=" & CN_TRANSACTION_ID_MAXLENGTH.String & ".", false);
 		return -1; 	
	endif;

 	kc 		:= app.myCnKarmaCntrl;
	cc		:= app.myCnCntrl;
	stack	:= app.myCnTransactionStack;
	tag		:= kc.getCallStackPosition - 1;
	if self.TranStats_Debug then
		self.zCnLogTransactionEntry(method, id, "stack tags size = " & stack.tags.size.String);
	endif;
	
	if stack.tags.size > null then
		if stack.tags.last = tag then			// condition was changed from '>=' for 3.0
			tranId	:= stack.transactionIds.last;
			app.cnClearLogicalTransactionStack();
			app.cnRaiseNormalException(Cn_Transaction_Error, id,
									   "cnStartTransaction called twice in same method, or called again at same level in " &
									   "call stack with no matching cnEndTransaction : dangling transaction id=" &
									   tranId & ".", false);
			return -1;	
		endif;
		
		if self.TranStats_Debug then
			self.zCnDumpTransactionStack();
		endif;
		
		tranState := stack.transactionStates.last;
		if tranState = "S" then
			if self.TranStats_Debug then
				self.zCnLogTransactionEntry(method, id, "resuming suspended transactions");
			endif;
			
			self.cnResumeTransaction();								// PAR 397
		
		elseif self.TranStats_Debug then
			self.zCnLogTransactionEntry(method, id, "no suspended transactions");
		endif;
 	endif;	

	stack.tags.add(tag);
	stack.transactionIds.add(id);
	stack.transactionErrors.add(false);
	stack.startTimes.add(app.cnGetClientRelativeMachineTime);	// 3.0
	stack.transactionStates.add(" ");
	if self.TranStats_Debug then
		self.zCnLogTransactionEntry(method, id, "added to stack tags [" & stack.tags.size.String & "], starttime=" & stack.startTimes[stack.tags.size].String);
	endif;
	
	if cc.myNodeControl <> null and cc.myNodeControl.sampleProcessStats then					// node sampling
		if node.isServerNode 	or
		   not app.isMultiUser	then
			statsType	:= Cn_Stats_Type_Local;
		else
			statsType	:= Cn_Stats_Type_Remote;
		endif;	
	
		create jdo1 transient;
		process.getRequestStatistics(jdo1, statsType);
		stack.processPersistentStatsObjects.add(jdo1);
		create jdo2 transient;
		process.getRequestStatistics(jdo2, 1);
		stack.processThinClientStatsObjects.add(jdo2);
	endif;
	 
	return tag;
end;
}
cnSuspendTransaction
{
cnSuspendTransaction() clientExecution;

vars
	cc		: CnCntrl;
	stack	: CnTransactionStack;
	index	: Integer;
	i		: Integer;
	now		: Decimal[23];
	elapsed	: Decimal[23];
	start	: Decimal[23];
begin
	if app.myCnKarmaCntrl = null then
		return;
	endif;
	
	cc		:= app.myCnCntrl;

	if not cc.clientTranStats then
		return;
	endif;
	
	stack	:= app.myCnTransactionStack;
	now		:= app.cnGetClientRelativeMachineTime;
	index	:= stack.startTimes.size;
	
	foreach i in 1 to index do							// stop all transaction timers
		if stack.transactionStates[i] = "S" then							// PAR 479 - don't suspend transaction unless active
			if self.TranStats_Debug then									// PAR 479
				self.zCnLogTransactionEntry(method, 						// PAR 479
										  stack.transactionIds[i], 			// PAR 479
										  " already suspended, ignored");	// PAR 479
			endif;															// PAR 479
																			// PAR 479
			continue;														// PAR 479
		endif;																// PAR 479
		
		start	:= stack.startTimes[i];
		if start = -1 then								// already discarded
			elapsed	:= -1;
			
		elseif now < start then
			elapsed := -1;								// PAR 205 : wrapped around : discard
			cc.cnWriteLog(cc.CnLogComment, "Transaction statistic discarded for tran id '" & stack.transactionIds[i] &
										   "' : relativeMachineTime counter has wrapped.", null);
		else
			elapsed	:= now - start;
		endif;
		
		stack.startTimes.replace(i, elapsed);	
		stack.transactionStates.replace(i, "S");
		if self.TranStats_Debug then
			self.zCnLogTransactionEntry(method, stack.transactionIds[i], " [" & i.String & "] suspended, now=" & now.String & ", old start=" & start.String & ", new start=" & elapsed.String);
		endif;
	endforeach;
end;
}
zCnDeimplementationWarning
{
zCnDeimplementationWarning(pMethod : Method; pRelease : String) protected;

vars
	cc			: CnCntrl;
	badObject	: Boolean;
begin
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_AttemptedAccessViaNullRef, cc, badObject);
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogProgramError, "Warning! " & pMethod.qualifiedName & " is to be deimplemented in release " & pRelease, null);
end;
}
zCnDumpTransactionStack
{
zCnDumpTransactionStack() protected;

vars
	stack	: CnTransactionStack;
	
	state	: Character;

	start	: Decimal[23];
	
	index,
	sz		: Integer;

	str,
	tranId	: String;
begin
	if not self.TranStats_Debug then
		return;
	endif;
		
	stack := app.myCnTransactionStack;
	sz := stack.tags.size();
	if sz = null then
		self.zCnLogTransactionEntry(method, null, "------------ No entries in transaction stack --------------");
		return;
	endif;
	
	self.zCnLogTransactionEntry(method, null, "------------ " & sz.String & " entries in transaction stack --------------");
	foreach index in 1 to sz do
		tranId  := stack.transactionIds[index];
		start	:= stack.startTimes[index];
		state   := stack.transactionStates[index];
		str := "[" & index.String & "] ";
		if start = -1 then								// already discarded
			str := str & "discarded";
		
		else
			str := str & start.String;
		endif;
		
		if state = "S" then
			str := str & " suspended";
		
		else
			str := str & " active";
		endif;
			
		self.zCnLogTransactionEntry(method, tranId, str);
	endforeach;
	self.zCnLogTransactionEntry(method, null, "----------------------------- End of transaction stack --------------------------");
end;
}
zCnLogTransactionEntry
{
zCnLogTransactionEntry(pMethod : Method; pTran, pMsg : String) protected;

vars
	cc	: CnCntrl;
begin
	if not self.TranStats_Debug then
		return;
	endif;
	
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, pMethod.qualifiedName & " " & pTran & " : " & pMsg, null);
end;
}
zCnReimplementationRequired
{
zCnReimplementationRequired(pMethod : Method) protected;

vars
	className,
	methodName	: String;
begin
	className := self.class().name;
	methodName := pMethod.cnGetMethodName();
	app.cnRaiseNormalException(Cn_Edit_Error,
								"Logic error, method must be re-implemented",
								"Method " & methodName & " must be re-implemented for class " & className,
								true);
end;
}
zCnToBeCoded
{
zCnToBeCoded(pMethod : Method) protected;

vars
	className,
	methodName	: String;
begin
	className := self.class().name;
	methodName := pMethod.cnGetMethodName();
	app.cnRaiseNormalException(Cn_Edit_Error,
								"Logic error, method to be coded",
								"Method " & methodName & " yet to be coded for class " & className,
								false);
end;
}
	externalMethodSources
emUnicodeToAnsi
{
emUnicodeToAnsi(str: String): Binary is "emUnicodeToAnsi" in "karma" number = 1008;
}
	)
	CardSchema (
	jadeMethodSources
cnActivateKarmaControl
{
cnActivateKarmaControl(pClientType 					: Integer; 			// Cn_Fat_Client, Cn_Java_Thin_Client, or Cn_JADE_Thin_Client
					   pThinClientComputerIpAddress	: String;
					   pThinClientComputerName		: String) clientExecution, updating;

vars
	kc					: CnKarmaCntrl;
	cc					: CnCntrl;
	cnApp				: CardSchema;
	processApp			: Application;
	str					: String;
	processCardSchemaOK	: Boolean;
	hadDuplicate		: Boolean;
	sz					: Integer;
begin
	// Note : don't use this method for JOSS or KARMA - they need to instantiate subclass CnJossCntrl  //
	
	// PAR 391. If we are in a package context, bail out now.
	processApp := process.getProcessApp();
	processCardSchemaOK := processApp.isKindOf(CardSchema);
	if processCardSchemaOK then
		cnApp := processApp.CardSchema;
		
	else
		cnApp := app.cnGetCardSchemaApp(false);
	endif;

	// PAR 546 - don't activate CnKarmaCntrl if data pump as deploy issues when datapump
	// PAR 546 - activates but KCCMgr not running and CnRoot shared transient doesn't exist.
	if process.isUserDataPump then
		create app.myCnCntrl transient;
		cc := app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogComment, "-----------------  Application Start Up ---------------------------", null);
		
		str :=  "CardSchema Class Library Version " & app.cnGetCardSchemaVersion() & ", JADE version " & processApp.getSystemVersion();
		if not processApp.isKindOf(CardSchema) then
			cc.cnWriteLog(cc.CnLogComment, "Process executing from schema " & processApp.class().schema.name & " which is not a subschema of CardSchema.", null);
		endif;
		
		if processApp.isUnicode() then
			str := str & " (Unicode)";
			
		else
			str := str & " (ANSI)";
		endif;
		
		cc.cnWriteLog(cc.CnLogComment, str & ", process usercode=" & process.userCode & ", app.userName=" & processApp.userName & ".", null);
		cc.cnWriteLog(cc.CnLogComment, "KarmaControl not activated for RPS datapump application, exiting method " & method.name, null);
		return;
	endif;
	
	// We need to cater here for packages as well as non-package applications. And just to add to the fun, we also need to cater
	// for scenarios where:
	//	- 	the importing schema is not a subschema of CardSchema yet one or more of the imported packages are from schemas that
	//		are subschemas of CardSchema (eg package exports SMTP functionality and therefore requires CnKarmaCntrl singleton).
	//	-	the importing schema is a subschema of CardSchema but one or more of the packages imported are from schemas that are
	//		not subschemas of CardSchema.
	//	-	the importing schema is a subschema of CardSchema and the packages being imported are from schemas which are also all
	//		subschemas of CardSchema (the ideal).
	
	// As the Application objects need to be created for each package context and we can't influence the initialize method order,
	// we need to ensure that the first application initialize method instantiates CnKarmaCntrl and associated singletons. As
	// subsequenct application initialize methods activate Karma Control, we need to setup their Application object properties 
	// appropriately for their own context use and for them all to point to the same singletons.
	
	// The application type, used by exception handlers and stack dump, assumes the value for the application process, as the 
	// application context values are incorrect.
	
	// we need to remember which applications have instantiated Karma so we close down (finalize) for the correct applications
	
	if cnApp.myCnKarmaCntrl = null then
		cnApp.cnUsedActivateMethod := true;			// provide compatability with old schemas that create CnKarmaCntrl directly
		create kc;
		kc.appsActivatedKarma.add(app);
		cc := cnApp.myCnCntrl;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " Karma Control has now been instantiated for this process.", null);
		if pClientType = Cn_Java_Thin_Client then
            cc.setJavaThinClient(true);
            cc.setSuppressManagementDialogs(true);
			kc.setThinClientComputerIpAddress(pThinClientComputerIpAddress);
            kc.setThinClientComputerName(pThinClientComputerName);
            cc.cnWriteLog(cc.CnLogComment, "This process initiated by Java thin client at " & pThinClientComputerName &
            			  " (" & pThinClientComputerIpAddress & ").", null);
        endif;

		if cc.karmaControl 			and
		   kc.isMultiUserCapable() 	then																						// PAR 6732
			kc.issueSessionOpenAdvice();
			if node.isApplicationServer() then
				kc.getAndSendSSLDetails();
			endif;
		endif;
		
		if node.isApplicationServer then
			self.zCnThinClientConnBalancing();		// thin-client connection balancing introduced in JADE 6.2.15
		endif;
		
	else
		kc := cnApp.myCnKarmaCntrl;
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectAlreadyInCollection, kc.appsActivatedKarma, hadDuplicate);	// PAR 482
		kc.appsActivatedKarma.add(app);
		cc := cnApp.myCnCntrl;
		if hadDuplicate then																												// PAR 482							
			cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() &																			// PAR 482 
											" Karma Control has already been activated for this application instance, ignoring activation.", // PAR 482
											null);																							// PAR 482
			return;																															// PAR 482
		endif;
		
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " Karma Control has previously been instantiated for this process, invocation #" & kc.appsActivatedKarma.size64().String & ".", null);
	endif;

	if cnApp <> self then
		self.cnSetPackageAppProperties(cnApp);
		cc := cnApp.myCnCntrl;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " package application " & app.name & " id " & self.cnGetInstanceId64(app).String & " CnKarmaCntrl references have now been defined.", null);
	endif;
end;
}
cnAppIsRunning
{
cnAppIsRunning(schemaName : String; appName : String; computer : String; procc : Process output) : Boolean;

vars
	proc		: Process;

	badObject	: Boolean;
begin
	//  If computer is null then if the specified application is running ANYWHERE this returns
	//  true, else only returns true if the specified application is running on the specified
	//  computer.................RWM 28/10/99
	
	on SystemException do cnHandleInvalidObjectReference(exception, badObject);

	// ensure that we single thread through here

	// rewritten to avoid locking nodes etc
	foreach proc in Process.instances do
		badObject := false;
   		if proc.persistentApp.name <> appName then
			continue;
		endif;
		
		if badObject then
			continue;
		endif;

		if proc.schema.name.toLower() <> schemaName.toLower() then
			continue;
		endif;

		if computer = null or 
		   computer.toUpper() = proc.node.cnGetComputerName.toUpper() then
       	   	procc := proc;
       		return true;
       	endif;
	endforeach;

	return false;
end;
}
cnArmServerDeadlockExHandler
{
cnArmServerDeadlockExHandler() serverExecution, updating;

vars

begin
	on DeadlockException do cnGlobalDeadlockExHandler(exception) global;
end;
}
cnArmServerGlobalExceptHandler
{
cnArmServerGlobalExceptHandler() serverExecution, updating;

vars

begin
	on Exception do cnGlobalExceptionHandler(exception) global;
end;
}
cnArmServerLockExceptHandler
{
cnArmServerLockExceptHandler() serverExecution, updating;

vars

begin
	on LockException do cnGlobalLockExceptionHandler(exception) global;
end;
}
cnBuildFQDN
{
cnBuildFQDN(netBiosName : String) : String;

vars
	//  This is reimplemented in Joss subschema
begin
	return netBiosName;
end;
}
cnCheckForTransients
{
cnCheckForTransients() updating;

vars
	cc				: CnCntrl;
	
	countIter		: Iterator;

	obj				: Object;
	
	iArray			: IntegerArray;
	
	oa,
	oa2,oa3			: ObjectArray;
	
	sArray			: StringArray;
	
	t1				: Decimal[23];
	
	cnt,
	ix,
	pos				: Integer;
	
	sz				: Integer64;
		
	appClassName,
	str, 
	s2				: String;
	
	ts				: TimeStamp;
begin
	cc		:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogComment, "Starting check for undeleted process transients ....", null);
	t1		:= app.relativeMachineTime;
	
	ts		:= process.creationTime();
	cc.cnWriteLog(cc.CnLogComment, "Process " & cc.appName & " (" & process.getOidStringForObject(process) & ") was started on " & 
									ts.date().cnUserFormat($CnDDMMYY) & " " & ts.time().cnUserFormat($CnHHMMSS), null);
	appClassName := app.class().name;
	create oa transient;
	create oa2 transient;
	create sArray transient;
	create iArray transient;
	
	// load with expected transients
	oa2.add(oa);
	oa2.add(oa2);
	oa2.add(sArray);
	oa2.add(iArray);
	if app.myCnKarmaCntrl <> null then
		app.myCnKarmaCntrl.allCnProcesses.copy(oa2);
		if app.myCnKarmaCntrl.myCnServerStatistics <> null then
			app.myCnKarmaCntrl.myCnServerStatistics.copyTransientsToArray(oa2);
		endif;
		
		app.myCnKarmaCntrl.allCnProcesses.copy(oa2);
	endif;
	
	self.zCnUser_TransientsToIgnore(oa2);
	
/*	sz := oa2.size64();
	if sz > null then
		cc.cnWriteLog(cc.CnLogComment, sz.userNumberFormat($CnWholeNumbers) & " transient objects defined to be ignored", null);
	endif;
*/	
	process.allTransientInstances(oa, 50000);
	create oa3 transient;					// this object array will contain only those transients that we are interested in
	foreach obj in oa do
		if oa2.includes(obj) then			// ignore transients created by this method
			continue;
		endif;
		
		str		:= obj.String;
		pos		:= 1;
		str		:= str.scanUntil("/", pos);
		if str = CnCntrl.name				or			// these CardSchema classes normally have singletons existing at closedown time
		   str = CnKarmaCntrl.name 			or
		   str = appClassName				or
		   str = GCardSchema.name			or
		   str = CnTransactionStack.name 	or
		   str = CnTransactionData.name		or
		   str = CnProcessSet.name			or
		   str = CnDeadlockHandler.name 	or
		   str = CnVariantArray.name		or 
		   str = CnClusterInfo.name			or
		   str = CnKarmaTcpConnection.name	or
		   str = CnProcess.name				or
		   str[1:6] = "CnSmtp"			or			// more than one of these indicates that the user app failed to clean up
		   
		   str = Printer.name				or			// JADE class singletons
		   str = ApplicationContext.name	or
		   str = LocaleFullInfo.name		or
		   str = DateFormat.name		    or
		   str = TimeFormat.name			or
		   str = NumberFormat.name			or
		   str = CurrencyFormat.name		or
		   str = JadeLog.name				then		// app.myCnLog
			continue;
		endif;
	
		oa3.add(obj);
	endforeach;
	
	self.zCnUser_ViewTransientObjects(oa3);
	
	foreach obj in oa3 do
		str		:= obj.String;
		pos		:= 1;
		str		:= str.scanUntil(CN_SLASH, pos);
		ix		:= sArray.indexOf(str);
		if ix = null then
			sArray.add(str);
			iArray.add(1);
			
		else
			iArray.replace(ix, iArray[ix] + 1);
		endif;
	endforeach;
	
	countIter := iArray.createIterator();
	foreach str in sArray do
		countIter.next(cnt);
		s2	:= "Class " & str & " had " & cnt.String & " process transients remaining.";
		cc.cnWriteLog(cc.CnLogComment, s2, null);
	endforeach;
	
	if sArray.isEmpty() then
		cc.cnWriteLog(cc.CnLogComment, "Check for undeleted process transients found none, other than normal (expected) singletons.", null);
	endif;
epilog
	cc.cnWriteLog(cc.CnLogComment, "Transient checks completed, " & t1.cnGetElapsedTimeString(), null);
	delete oa;
	delete oa2;
	delete oa3;
	delete iArray;
	delete sArray;
	delete countIter;
end;
}
cnCheckLaunchSentinelFile
{
cnCheckLaunchSentinelFile(action : Integer) subschemaHidden, protected, final, updating;

vars
	cc		: CnCntrl;	
	
	file	: File;						// File transient is created and assigned to app.cnMyLaunchSentinelFile, and deleted as part of KCCMgr finalize
	
	cem		: CnExternalMethods;
begin
	cc	:= self.myCnCntrl;
	if self.myCnKarmaCntrl = null then	// can happen if we end early (e.g. SDS errors in initialize).
		return;
	endif;
	
	self.cnUseLaunchSentinelFile	:= self.getProfileString(self.getIniFileName, "AppEnvironment", "UseLaunchSentinelFile", null).toLower = "true";
	
	create cem transient;
	if not cem.emIsService then
		cc.cnWriteLog(cc.CnLogComment, "Ini file option [AppEnvironment] UseLaunchSentinelFile=true but app not running as " &
									   "service, so won't create or remove any PreventSystemLaunch.htm file.", null);
		return;
	endif;	

	if action = CN_CREATE_FILE then
		if not cnUseLaunchSentinelFile then
			cc.cnWriteLog(cc.CnLogComment, "Ini file option [AppEnvironment] UseLaunchSentinelFile=false : won't create file.", null);
			return;
		endif;
		if not app.isMultiUser then
			cc.cnWriteLog(cc.CnLogComment, "Ini file option [AppEnvironment] UseLaunchSentinelFile=true but app is running singleuser : " &
										   "won't create file.", null);	
			return;
		endif;
		
		create file transient;
		file.fileName	:= cnGetServerMiscPath & "/PreventSystemLaunch.htm";
		file.writeLine("System launched at " & app.actualTime.String);
		file.close;
		file.shareMode	:= file.Share_Exclusive;
		file.open();
		self.cnMyLaunchSentinelFile	:= file;
		cc.cnWriteLog(cc.CnLogComment, "Ini file option [AppEnvironment] UseLaunchSentinelFile=true : PreventSystemLaunch.htm has been created.", null);
		return;
	
	elseif action = CN_REMOVE_FILE then
		file	:= self.cnMyLaunchSentinelFile;
		if file = null then
			cc.cnWriteLog(cc.CnLogComment, "Ini file option [AppEnvironment] UseLaunchSentinelFile=false : file object not found.", null);
			return;
		endif;
		
		if file.isAvailable then
			file.purge;
			self.cnMyLaunchSentinelFile := null;
			cc.cnWriteLog(cc.CnLogComment, file.fileName & " sentinel file has been removed.", null);
			delete file;
		else
			cc.cnWriteLog(cc.CnLogComment, file.fileName & " sentinel file not found : not removed.", null);
			delete file;
		endif;
		
	else
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " was called with invalid action=" & action.String, null);
	endif;		 
epilog
	delete cem;
end;
}
cnClearLogicalTransactionStack
{
cnClearLogicalTransactionStack();

vars
	stack	: CnTransactionStack;
begin
	stack	:= self.myCnTransactionStack;
	stack.tags.clear();
	stack.transactionIds.clear();
	stack.startTimes.clear();
	stack.transactionErrors.clear();
	stack.transactionStates.clear();																							// PAR 637
end;
}
cnClientOSPlatformIsWindows
{
cnClientOSPlatformIsWindows() : Boolean;

vars
	version			: String;
	architecture	: Integer;
	osPlatform		: Integer;
begin
	//  This method returns true if the THIN client OS platform is Windows.
	//  Use ::cnOSPlatformIsWindows for fat client or server nodes.
	//  
	osPlatform	:= process.getOSPlatform(version, architecture);
	if osPlatform = Node.OSWindowsEnterprise 	or
	   osPlatform = Node.OSWindowsHome			or
	   osPlatform = Node.OSWindows				then
		return true;
	endif;			
end;
}
cnComputerName
{
cnComputerName() : String;

vars
	str			: String;
	
	pos			: Integer;
	
	kc			: CnKarmaCntrl;
	
	processApp	: Application;
begin
	//  Strips off domain part of computer name (for Unix hosts)

	str		:= app.computerName;
	if str = null then
		return "NO_COMPUTERNAME";
	endif;
	
	if str = "<unavailable>" then
		kc := app.myCnKarmaCntrl;
		if process.isUsingThinClient then
			if kc = null then
				str := app.cnGetNetworkAddressProcess();																		// NFS 777
			
			else
				str := kc.networkAddressProcess;
			endif;
		
		else
		
			if kc = null then
				str := app.cnGetNetworkAddressNode();																			// NFS 777
			
			else
				str := kc.networkAddressNode;
			endif;
		endif;
		
		return str;
	endif;
	
	pos		:= 1;
	return str.scanUntil(".", pos);
end;
}
cnComputerNameAppServer
{
cnComputerNameAppServer() : String;

vars
	str		: String;
	pos		: Integer;
begin
	//  Strips off domain part of computer name (for Unix hosts)
	
	str	:= app.computerNameAppServer;

	if str <> null then
		str		:= app.computerNameAppServer;
		pos		:= 1;
		return str.scanUntil(".", pos);
	else
		return "NO_COMPUTERNAME";
	endif;
end;
}
cnContainsKarma
{
cnContainsKarma(str : String) : Boolean;

vars
	len,
	pos : Integer;
	
	s	: String;
begin
	s	:= str.toLower();

	pos := s.pos("karma", 1);
	if pos > null then
		return true;
	endif;
	
	pos := s.pos("krma", 1);			// Unix form e.g. cnwkrma
	if pos > null then
		return true;
	endif;

	return false;
end;
}
cnConvertPathNameToBackSlashes
{
cnConvertPathNameToBackSlashes(pathname : String) : String updating;

vars
 	fname	: String;
begin
	///    Changes path names with forward slashes to backslashes   ////
	fname := pathname;
	fname.replaceChar(CN_SLASH, CN_BACK_SLASH);
	return fname;
end;
}
cnConvertPathNameToFwdSlashes
{
cnConvertPathNameToFwdSlashes(pathname : String) : String updating;

vars
 	fname	: String;
begin
	///    Changes path names with back slashes to forward slashes   ////

	fname := pathname;
	fname.replaceChar(CN_BACK_SLASH, CN_SLASH);
	return fname;
end;
}
cnDisableLockChecks
{
cnDisableLockChecks();

vars

begin
	process.causeEvent(CN_LOCK_CHECKS_EVENT_DISABLE, true, null);
end;
}
cnEnableLockChecks
{
cnEnableLockChecks();

vars

begin
	process.causeEvent(CN_LOCK_CHECKS_EVENT_ENABLE, true, null);
end;
}
cnFileInUseExceptionHandler
{
cnFileInUseExceptionHandler(exObj : FileException) : Integer updating;

vars
	cc 	: CnCntrl;
	kc	: CnKarmaCntrl;
begin
 	if exObj.errorCode = 5030 then						// file in use
 		kc	:= app.myCnKarmaCntrl;
 		kc.setHadFileException(true);
 		cnFileRetryCount 	:= cnFileRetryCount - 1;
 		if cnFileRetryCount = 0 then
 			cc := app.myCnCntrl;
 			cc.cnWriteLog(cc.CnLogErrors, "ERROR: Retry limit exceeded for file operation on " &
 					      exObj.file.fileName, null);
 			return Ex_Pass_Back;

		else
			process.sleep(250);
			return Ex_Resume_Next;
		endif;

	else
		return Ex_Pass_Back;
	endif;
end;
}
cnFileLastModified
{
cnFileLastModified(file : File) : TimeStamp updating;

vars
	ts : TimeStamp;
begin
	on FileException do cnFileInUseExceptionHandler(exception);
	cnFileRetryCount := 10;

	while true do
		ts := null;
		ts := file.lastModified;
		if ts <> null then				// if null then the exception handler will have
			return ts;					// been invoked.
		endif;
	endwhile;
end;
}
cnFinalizeKCBatch
{
cnFinalizeKCBatch();

vars
	bm		: CnBatchMgr;
begin
	bm		:= self.myCnManagerClass.CnBatchMgr;
	bm.log("--------------  Application close down  -------------------");
	
	if bm <> null then
		delete bm.myLog;
	endif;
end;
}
cnFinalizeKCCMgr
{
cnFinalizeKCCMgr() updating;

vars
	cc			: CnCntrl;
	
	jp			: CnJadeProcess;
	
	kc			: CnKarmaCntrl;
	
	tcp			: CnTcpConnection;
	
	obj			: Object;
	
	objArray	: ObjectArray;				// created as transient and deleted in-line, not in epilog!
begin
	cc	:= app.myCnCntrl;
	kc  := app.myCnKarmaCntrl;
	if kc <> null then
		foreach jp in kc.allCnJadeProcesses do
			if jp.type = 1 then
				cc.logDevelopmentActivity(jp);
			endif;
		endforeach;
	
		create objArray transient;
		CnTcpConnection.allProcessTransientInstances(objArray, 1000, true);
		
		foreach obj in objArray do	
			tcp	:= obj.CnTcpConnection;
			if tcp.state = 1 or tcp.state = 2 then
				tcp.close();								// synchronous close
			endif;
			
			delete tcp;
		endforeach;
		
		delete objArray; 
		cnCheckLaunchSentinelFile(CN_REMOVE_FILE);
		CnMachine.cnDeleteTransientInstances;
		CnApp.cnDeleteTransientInstances;
		delete self.myDba;
	endif;
	
	self.finalize();
end;
}
cnFinalizeKCNodeControl
{
cnFinalizeKCNodeControl() updating;

vars
	cc	: CnCntrl;
begin
	cc	:= app.myCnCntrl;

	if cc.myNodeControl <> null then
		delete cc.myNodeCacheStatsFile;
	endif;
	
	finalize();
end;
}
cnFinalizeKCOnLineBackup
{
cnFinalizeKCOnLineBackup() updating;

vars
	msg		: CnBackupAdvice;
	
	cc		: CnCntrl;
	
	dba		: CnDatabaseAdmin;
	
	errText	: String;
begin
	cc := app.myCnCntrl;
	dba := self.myCnDba;
	if dba.getBackupCompletionType() = null then		
		// backup still in progress and not yet completed
		// so we must be executing a WM_QUIT request
		errText	:= "BACKUP FAILED : Backup termination (WM_QUIT) requested before backup has completed";
		app.cnManagerLog(errText);
		cc.cnWriteLog(cc.CnLogErrors, errText, null);
    	msg	:= dba.createBackupAdviceMessage(msg.Advice_Type_Backup_Failed);
    	msg.setErrorText(errText); 
    	msg.sendMessage(null);
	endif;
	
	if self.cnMyBackupLog <> null then
		self.cnMyBackupLog.commitLog();
		delete cnMyBackupLog;
	endif;
	
	delete dba;
	self.finalize();
epilog
	delete msg;
end;
}
cnFinalizeKCOnLineBackupM
{
cnFinalizeKCOnLineBackupM() updating;

vars

begin
	if self.cnMyBackupLog <> null then
		self.cnMyBackupLog.commitLog();
		delete self.cnMyBackupLog;
	endif;
	
	if self.myCnBackup <> null then
		delete self.myCnBackup;
	endif;
	
	finalize();
end;
}
cnFinalizeKCOnLineBackupWorker
{
cnFinalizeKCOnLineBackupWorker() updating;

vars

begin
	if cnMyBackupLog <> null then
		cnMyBackupLog.commitLog();
		delete cnMyBackupLog;
	endif;
	
	finalize();
end;
}
cnFinalizeKCOnLineCmpactWorker
{
cnFinalizeKCOnLineCmpactWorker() updating;

vars

begin
	if self.cnMyCompactLog <> null then
		self.cnMyCompactLog.commitLog();
		delete self.cnMyCompactLog;
	endif;
	
	self.finalize();
end;
}
cnFinalizeKCOnLineCompact
{
cnFinalizeKCOnLineCompact() updating;

vars

begin
	if self.cnMyCompactLog <> null then
		self.cnMyCompactLog.commitLog();
		delete self.cnMyCompactLog;
	endif;
	
	self.finalize();
end;
}
cnFinalizeKCOnLinePartitionWorker
{
cnFinalizeKCOnLinePartitionWorker() updating;

vars

begin
	if cnMyBackupLog <> null then
		cnMyBackupLog.commitLog();
		delete cnMyBackupLog;
	endif;
	
	finalize();
end;
}
cnFinalizeKCSDSChecks
{
cnFinalizeKCSDSChecks() updating;

vars

begin
	delete app.myCnSDSDbAdmin;
	self.finalize();
end;
}
cnGenericExceptionHandler
{
cnGenericExceptionHandler(pExObj 				: Exception; 				// the exception object
						  pExpectedErrorCode 	: Integer; 					// the exception error code for which handler is armed
						  pArmedForObject 		: Object; 					// optional object, if provided the exception is to have occurred on this object
						  pHadException 		: Boolean output			// if resumable, and items match then this is set to true
						  ) : Integer;

/*
	Note: if the exception matches expected error code and, optionally, the error object
			then if the exception is NOT resumable this handler will pass the exception 
			to the next armed exception handler.
*/						  
vars
	cc	: CnCntrl;
	
	str	: String;
begin
	cc := app.myCnCntrl;
	if cc <> null then
		str := " resumable=" & pExObj.resumable.String & 
				", exception expected=" & pExpectedErrorCode.String &
				", actual=" & pExObj.errorCode.String;
		if app.isValidObject(pExObj.errorObject) then
			str := str & ", errorObject=" & pExObj.errorObject.String;
		
		else																													// PAR 987
			str := str & ", errorObject is invalid";																			// PAR 987
		endif;
		
		if pArmedForObject = null then
			str := str & ", no object check";
		
		else
			str := str & ", check for " & pArmedForObject.String;
		endif;
	endif;
	
	if not pExObj.errorCode = pExpectedErrorCode then
		str := str & ", return Ex_Pass_Back";
		return Ex_Pass_Back;
	endif;
	
	if pArmedForObject = null then
		if not pExObj.resumable then
			str := str & ", return Ex_Pass_Back";
			return Ex_Pass_Back;
		endif;
		
		pHadException := true;
		str := str & ", return Ex_Resume_Next";
		return Ex_Resume_Next;
	endif;
	
	if pExObj.errorObject <> pArmedForObject then
		str := str & ", return Ex_Pass_Back";
		return Ex_Pass_Back;
	endif;
	
	if not pExObj.resumable then
		str := str & ", return Ex_Pass_Back";
		return Ex_Pass_Back;
	endif;

	str := str & ", return Ex_Resume_Next";
	pHadException := true;
	return Ex_Resume_Next;
epilog
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & str & ", pHadException=" & pHadException.String, null);
end;
}
cnGetApplicationType
{
cnGetApplicationType() : String;

vars

begin
	if self.cnApplicationType = self.ApplicationType_GUI then
		return "GUI";
		
	elseif self.cnApplicationType = self.ApplicationType_GUI_No_Forms then
		return "GUI_No_Forms";
		
	elseif self.cnApplicationType = self.ApplicationType_Non_GUI then
		return "Non_GUI";
		
	elseif self.cnApplicationType = self.ApplicationType_Web_Enabled then
		return "Web_Enabled";
		
	elseif self.cnApplicationType = self.ApplicationType_Non_GUI_Web then
		return "Non_GUI_Web";
		
	elseif self.cnApplicationType = self.ApplicationType_Non_GUI_Rest then
		return "Non_GUI_REST";
	
	elseif self.cnApplicationType = self.ApplicationType_Rest_Services then
		return "REST_Services";

	else
		return self.cnApplicationType;
	endif;
end;
}
cnGetApplicationVersion
{
cnGetApplicationVersion() : String;

vars
	
begin
	//   This method can be re-implemented in your subschema, if required.
	//   Note that length of the string returned should not exceed 30 bytes.
	//   Typically used to get app version for documentation in stack dumps, 
	//   and to record application version for display on JSM's SystemView form.
	//
	if currentSchema.name = CN_CARDSCHEMA then
		return app.cnGetCardSchemaVersion();
	endif;
	
	return process.getProcessApp().appVersion;
end;
}
cnGetBackupPathDatabase
{
cnGetBackupPathDatabase(pBackupDir,
						pEnvId,
						pSystemNode,
						pBackupSystemNode	: String) : String;

vars

begin
	return pBackupDir & CN_SLASH & pEnvId & pBackupSystemNode; 
end;
}
cnGetCardSchemaApp
{
cnGetCardSchemaApp(pRequireKarmaControl : Boolean) : CardSchema;

vars
	appArray	: ApplicationArray;
	
	csAppl		: CardSchema;
	
	appl		: Application;
begin
	create appArray transient;
	process.getAllApps(appArray);
					// process application's schema may not be a subschema of CardSchema but 
					// may have imported a package from a schema that is a subschema of CardSchema
	csAppl := app;
	foreach appl in appArray do	// we're looking for the first application that is subschema of CardSchema and if it has instantiated CnKarmaCntrl
		if not appl.isKindOf(CardSchema) then
			continue;
		endif;
		
		if pRequireKarmaControl and appl.CardSchema.myCnKarmaCntrl = null then
			continue;
		endif;
		
		csAppl := appl.CardSchema;
		break;
	endforeach;
	
	return csAppl;
epilog
	delete appArray;
end;
}
cnGetCardSchemaVersion
{
cnGetCardSchemaVersion() : String;

vars

begin
	return A_VersionClass.CardSchema_Version;
end;
}
cnGetClassAndOid
{
cnGetClassAndOid(obj : Object) : String;

vars
	class		: Class;

	error		: Boolean;
	
	className,
	oid,
	oidStr		: String;
begin
	if obj = null then
		return "<null>";
	endif;
	
	on Exception do cnObjNotFoundExceptionHandler(exception, error);
	
	// Prior to CarsSchema 2.7.17 (16Jan2002) the oid string was returned using 'oidStr	:= getOidStringForObject(obj);'
	
	// In the 2.7.17 CardSchema release this was reworked to use 'oidStr := obj.String;' to fix 1046 exceptions due to use 
	// of transient classes by JadeReportWriterSchema.
	
	// As at JADE 7.1 and CardSchema 3.7.05 (6Jul2015) the use of 'oidStr := obj.String;' gave rise to JADE PAR #62742 as an internal
	// string too long error caused an assert and the node to crash. While this 'assert' problem is being resolved in JADE 
	// 7.1.06 and 7.2.00, we are also modifying CardSchema to resolve the underlying JADE issue as a CardSchema patch is
	// less intrusive than a JADE patch.
	
	class	:= self.getClassForObject(obj);
	if error then
		return "<unknown object>";
	endif;

	className := class.name;
	if error then
		oid		:= self.getOidStringForObject(obj);
		return "<Unknown class, oid=" & oid & ">";
	endif;
	
	oid		:= self.getOidStringForObject(obj);
	oidStr	:= className & "/" & oid;
	return oidStr;
end;
}
cnGetClassForObject
{
cnGetClassForObject(obj : Object) : Class;

vars
 	classNo		: Integer;
	oidStr		: String;
	class		: Class;
begin
	if obj <> null then
		return getClassForObject(obj);					// handles invalid object references
	endif;

	return null;
end;
}
cnGetClientMiscPath
{
cnGetClientMiscPath(thinClient : Boolean) : String clientExecution;

vars
	lastNode,
	newNode,
	path		: String;
	
	pos			: Integer;
begin
	if app.myCnKarmaCntrl = null then
		app.cnRaiseNormalException(Cn_Unhandled_Exception, 
									method.cnGetMethodName(), 
									"CnKarmaCntrl must be instantiated before this method can be used.", 
									false);
	endif;
	
	if thinClient then
		path := app.getJadeInstallDir;
	else
		path := app.getJadeInstallDirAppServer;
	endif;

	path := path.toLower();
	path.replaceChar("\", "/");
	if self.cnGetCardSchemaApp(false).cnOSPlatformIsWindows then
		lastNode := "/c_bin";
		newNode  := "c_misc";
	
	else
		lastNode := "/bin";
		newNode	 := "misc";
	endif;
	
	pos		:= path.reversePos(lastNode);				// we expect c_bin to be last node
	if pos = null then
		app.cnRaiseNormalException(Cn_Unhandled_Exception, 
									method.cnGetMethodName(), 
									"Unexpected path name '" & path & "', should end in " & lastNode, 
									false);
	endif;
	
	return path[1:pos] & newNode;
end;
}
cnGetClientRelativeMachineTime
{
cnGetClientRelativeMachineTime() : Decimal clientExecution;

vars

begin
	return relativeMachineTime();
end;
}
cnGetClientTime
{
cnGetClientTime() : TimeStamp clientExecution;

vars

begin
	return app.actualTime;
end;
}
cnGetDriveMapping
{
cnGetDriveMapping(driveName : String; mapName : String output; errorText : String output) : Integer updating;

vars
 	result,
 	result2	: Integer;
	
 	errText	: String;
	
	cem		: CnExternalMethods;
begin
	result := call cnGetDriveMapping(driveName, mapName, 260);

	if result <> 0 then
	 	//  1200 = Invalid drive letter
	 	//  1201 = Connection not available
	 	//  1203 = No network available
	 	//  1208 = Extended error, possibly from server
	 	//  1222 = PC not networked
	 	//  2250 = Drive not mapped (could be a local drive)
	 	//   234 = Mapped path name > 1000 bytes

		create cem transient;
    	result2 := cem.emGetErrorText(result, errText, 127);
    	if result2 = 0 then
    		errorText := "CardSchema::cnGetDriveMapping error : driveName='" & driveName & "', result=" & result.String & " : " & errText;
    	else
        	errorText := "CardSchema::cnGetDriveMapping unknown error, code=" & result.String;
        endif;
    endif;

    return result;
epilog
	delete cem;
end;
}
cnGetEnvVariableAppServer
{
cnGetEnvVariableAppServer(variable : String) : String;

vars
	// Executes on app server if thin client, only use this if that's what you really want !
	cem		: CnExternalMethods;
begin
	create cem transient;
	return cem.emGetEnvironmentVariable(variable);
epilog
	delete cem;
end;
}
cnGetEnvironmentId
{
cnGetEnvironmentId() : String;

vars
	posn	: Integer;
	
	env_id,
	str		: String;
begin
	posn 	:= 1;
	str 	:= app.dbPath();
	posn	:= 1;
	str.scanUntil(CN_BACK_SLASH, posn);					// get past drive letter part
	posn	:= posn + 1;
	env_id 	:= str.scanUntil(CN_BACK_SLASH, posn);		
	return env_id;
end;
}
cnGetEnvironmentVariable
{
cnGetEnvironmentVariable(variable : String) : String;

vars
	result 	: Integer;
	value	: String;
	cem		: CnExternalMethods;
	cc		: CnCntrl;
begin
	if node.isServerNode then
		create cem transient;
		return cem.emGetEnvironmentVariable(variable);					// must be external method on RS6000
	endif;

	result := call cnGetEnvironmentVariable(variable, value, 256);
	if result = 0 then
		return value;
	else
		cc := app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogErrors, "Problem in app.cnGetEnvironmentVariable for '" & variable & "', result=" & result.String, null);
		return null;
	endif;	
epilog
	delete cem;
end;
}
cnGetErrorText
{
cnGetErrorText(error : Integer) : String;

vars
	ex		: Exception;
	path	: String;
begin
	//
	//  This method returns a string describing a JADE error code
	//
	create ex transient;
	ex.errorCode	:= error;
	return ex.text();
	
epilog
	delete ex;
end;
}
cnGetExceptionDisplayPicture
{
cnGetExceptionDisplayPicture() : Binary;

vars

begin
	return null;
end;
}
cnGetIniFileSectionName
{
cnGetIniFileSectionName(section : String) : String;

vars
	// Gets name attribute from command line if used and builds section name
	
	cname	: String;
begin
	cname	:= node.cnGetNameFromCommandLine();
	if cname <> null then
		return cname & "." & section;
	else
		return section;
	endif;		
end;
}
cnGetJadeVersion
{
cnGetJadeVersion() : String;

vars
	jadeVersion : String;
begin
	jadeVersion := self.getSystemVersion();
	return jadeVersion;
end;
}
cnGetNetworkAddressNode
{
cnGetNetworkAddressNode() : String;

vars
	pos				: Integer;
	
	networkAddress	: String;
begin
	networkAddress := node.networkAddress;
	self.zNetworkAddressConvert(networkAddress); 
	
	return networkAddress;
end;
}
cnGetNetworkAddressProcess
{
cnGetNetworkAddressProcess() : String;

vars
	pos				: Integer;
	
	networkAddress	: String;
begin
	networkAddress := process.networkAddress;
	self.zNetworkAddressConvert(networkAddress); 
	
	return networkAddress;
end;
}
cnGetPath
{
cnGetPath(pRoot, pEnvId, pNode, pPathType : String; pFormatStd : Boolean) : String updating;

vars
	//  pRoot can be :
	//
	//			a single drive letter			(Windows)
	//			a partly-formed path			(Windows or Unix)
	//			null							(Unix)

begin
	if self.cnOSPlatformIsWindows then
		return cnGetPathWindows(pRoot, pEnvId, pNode, pPathType, pFormatStd);
	else
		return cnGetPathUnix(pRoot, pEnvId, pNode, pPathType, pFormatStd);
	endif;
end;
}
cnGetPathPartUnix
{
cnGetPathPartUnix(pPathType : String) : String updating, protected;

vars
	pt			: String;
	errorText	: String;
begin
	//  Returns partial path for node level defined in pPathType
	
	if pPathType 	 = CN_C_BIN then
		pt	:= "bin";
	elseif pPathType = CN_C_BIN_DOWNLOAD then
		pt	:= "bin/download";
	elseif pPathType = CN_DOWNLOAD then
		pt 	:= "download";
	elseif pPathType = CN_DOWNLOAD_C_BIN then
		pt	:= "download/bin";
	elseif pPathType = CN_N_BIN then
		pt	:= "new/bin";
	elseif pPathType = CN_O_BIN then
		pt	:= "old/bin";
	elseif pPathType = CN_RUNTIME then
		pt	:= CN_RUNTIME;
	elseif pPathType = CN_C_SYSTEM then
		pt	:= "system";
	elseif pPathType = CN_N_SYSTEM then
		pt	:= "new/system";
	elseif pPathType = CN_O_SYSTEM then
		pt	:= "old/system";
	elseif pPathType = CN_C_SCHEMA then
		pt	:= "schema";
	elseif pPathType = CN_N_SCHEMA then
		pt	:= "new/schema";
	elseif pPathType = CN_O_SCHEMA then
		pt	:= "old/schema";
	elseif pPathType = CN_C_MISC then
		pt	:= "misc";
	elseif pPathType = CN_DOWNLOAD_C_MISC then
		pt	:= "download/misc";
	elseif pPathType = CN_C_MISC_C_MISC then
		pt  := "misc/misc";
	elseif pPathType = CN_N_MISC then
		pt	:= "new/misc";
	elseif pPathType = CN_O_MISC then
		pt	:= "old/misc"; 
	elseif pPathType = CN_C_LIB then
		pt	:= "lib";
	elseif pPathType = CN_DOWNLOAD_C_LIB then
		pt	:= "download/lib";
	elseif pPathType = CN_N_LIB then
		pt	:= "new/lib";
	elseif pPathType = CN_O_LIB then
		pt	:= "old/lib";
	elseif pPathType = CN_LOGS then
		pt	:= CN_LOGS;
	else
		errorText := "Invalid sub-path type : '" & pPathType & "'";
		cnRaiseNormalException(Cn_General_Error, method.cnGetMethodName(), errorText, false);
	endif;
	
	return pt;
end;
}
cnGetPathUnix
{
cnGetPathUnix(pRoot, pEnvId, pNode, pPathType : String; pFormatStd : Boolean) : String updating;

vars
	//  pRoot can be :
	//
	//			a single drive letter			(Windows)
	//			a partly-formed path			(Windows or Unix)
	//			null							(Unix)

	path		: String;
	slash		: Character;
	nod			: String;
	pt			: String;
	errorText	: String;
	cc			: CnCntrl;
begin
	slash	:= "/";
	
	cc	:= app.myCnCntrl;
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() &
//				  " : pRoot=" & pRoot & ", pEnvId=" & pEnvId & ", pNode=" &  pNode & ", pPathType=" & pPathType, null);	// debug
	
	if pRoot = CN_ROOT then
		return app.cnApplicationRootDir & pEnvId;
	endif;
	
	if pRoot = CN_ALTOS then
		return app.cnApplicationRootDir & pEnvId & slash & CN_ALTOS;	
	elseif pNode = null or 
	   pNode = CN_SERVER then
		nod		:= null;
	elseif pNode = CN_CLIENT then
		nod		:= "client";
	elseif pNode = CN_THINCLIENT then
		nod		:= "client/thinclient";
	else
		errorText := "Invalid node type : '" & pNode & "', pathType=" & pPathType;
		cnRaiseNormalException(Cn_General_Error, pNode, errorText, false);
	endif;
			
	if pPathType <> null then
		pt	:= cnGetPathPartUnix(pPathType);			// handle c_bin, c_system etc
	endif;
	
	if pRoot <> null then
		path	:= pRoot & slash & pEnvId;
	else
		path	:= app.cnApplicationRootDir & pEnvId;
	endif;
	
	if nod <> null then
		path := path & slash & nod;
	endif;
	
	if pt <> null then
		path	:= path & slash & pt;
	endif;
	
	return path; 
end;
}
cnGetPathWindows
{
cnGetPathWindows(pRoot, pEnvId, pNode, pPathType : String; pFormatStd : Boolean) : String updating;

vars
	//  pRoot can be :
	//
	//			a single drive letter			(Windows)
	//			a partly-formed path			(Windows or Unix)
	//			null							(Unix)

	path		: String;
	slash		: Character;
	nod			: String;
	pt			: String;
	errorText	: String;
	cc			: CnCntrl;
begin
	slash	:= "/";
	cc	:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() &
				  " : pRoot=" & pRoot & ", pEnvId=" & pEnvId & ", pNode=" &  pNode & ", pPathType=" & pPathType, null);	// debug
	
	if not pFormatStd then
		slash	:= "\";
	endif;
	
	if pRoot = null then
		errorText	:= "Root for path not defined : node type=" & pNode & ", path type=" & pPathType & ".";
		cnRaiseNormalException(Cn_General_Error, pNode, errorText, false);
		
	elseif pRoot.length = 1 or (pRoot.length = 2 and pRoot[2] = ":") then
		path	:= pRoot[1] & ":" & slash & pEnvId & slash;
	else
		path	:= pRoot & slash & pEnvId & slash;
	endif;
	
	if pNode = null then
		if pPathType = CN_C_BIN 	or
		   pPathType = CN_C_MISC 	or
		   pPathType = CN_C_SCHEMA 	or
		   pPathType = CN_N_BIN		or
		   pPathType = CN_N_MISC	or
		   pPathType = CN_N_SCHEMA	or
		   pPathType = CN_O_BIN		or
		   pPathType = CN_O_MISC	or
		   pPathType = CN_O_SCHEMA	or
		   pPathType = CN_LOGS 		then
			return path & slash & pPathType;
		else
			errorText	:= "Path type '" & pPathType & "' not handled for node type'" & pNode & "'.";
			cnRaiseNormalException(Cn_General_Error, pNode, errorText, false);
		endif;
		
	elseif pNode = CN_ROOT then
		return pRoot;
	endif;
	
	if pNode = CN_SERVER then
		path := path & pNode;
		if pPathType = null then
			return path;
		endif;
		
		path := path & slash;
		
		if 	pPathType = CN_C_BIN 			or
			pPathType = CN_C_BIN_DOWNLOAD	or
			pPathType = CN_DOWNLOAD			or
			pPathType = CN_DOWNLOAD_C_BIN	or
			pPathType = CN_C_MISC 			or
			pPathType = CN_C_MISC_C_MISC	or
			pPathType = CN_DOWNLOAD_C_MISC	or
			pPathType = CN_C_SYSTEM			or
			pPathType = CN_N_BIN			or
			pPathType = CN_N_MISC			or
			pPathType = CN_N_SYSTEM			or
			pPathType = CN_O_BIN			or
			pPathType = CN_O_MISC			or
			pPathType = CN_O_SYSTEM			then
			path := path & pPathType;
			return path;
		endif;
				
		errorText := "Invalid path type for directory node '" & pNode & "' : '" & pPathType & "'";
		cnRaiseNormalException(Cn_General_Error, pNode, errorText, false);
	endif;		
	
	if 	pNode = CN_CLIENT then
		path := path & pNode;
		if pPathType = null then
			return path;
		endif;
		
		path := path & slash;
		
		if 	pPathType = CN_C_BIN 		or
			pPathType = CN_C_MISC 		or
			pPathType = CN_C_SCHEMA		or
			pPathType = CN_N_BIN		or
			pPathType = CN_N_MISC		or
			pPathType = CN_N_SCHEMA		or
			pPathType = CN_O_BIN		or
			pPathType = CN_O_MISC		or
			pPathType = CN_O_SCHEMA		then
			path := path & pPathType;
			return path;
		endif;
		
		errorText := "Invalid path type for directory node '" & pNode & "' : '" & pPathType & "'";
		cnRaiseNormalException(Cn_General_Error, pNode, errorText, false);
	endif;

	if pNode = CN_THINCLIENT then
		path := path & "client" & slash & pNode;
		if pPathType = null then
			return path;
		endif;
		
		path := path & slash;
		
		// note that C_BIN_DOWNLOAD and C_MISC_C_MISC are peculiar to THINCLIENT node only
			
		if 	pPathType = CN_C_BIN 			or
			pPathType = CN_DOWNLOAD_C_BIN	or
			pPathType = CN_C_MISC 			or
			pPathType = CN_DOWNLOAD_C_MISC	or
			pPathType = CN_N_BIN			or
			pPathType = CN_N_MISC			or
			pPathType = CN_O_BIN			or
			pPathType = CN_O_MISC			then
			path := path & pPathType;
			return path;
		endif;
		
		errorText := "Invalid path type for directory node '" & pNode & "' : '" & pPathType & "'";
		cnRaiseNormalException(Cn_General_Error, pNode, errorText, false);
	endif;

	if pNode <> null then
		errorText := "Invalid directory node : '" & pNode & "'";
		cnRaiseNormalException(Cn_General_Error, pNode, errorText, false);
	endif;
	
	errorText := "Invalid path type : '" & pPathType & "'";
	cnRaiseNormalException(Cn_General_Error, pNode, errorText, false);
end;
}
cnGetProfileStringServer
{
cnGetProfileStringServer(section, key, default : String) : String serverExecution;

vars
	//  Handles JADE 6.0 named sections : tries named section first then default section
	
	result	: String;
	name	: String;
	iniFile	: String;
begin
	name	:= node.cnGetNameFromCommandLine();
	iniFile	:= getIniFileName;
	
	if name <> null then
		result := app.getProfileString(iniFile, name & "." & section, key, null);
		if result <> null then
			return result;
		endif;
	endif;
	
	return app.getProfileString(iniFile, section, key, default);		
end;
}
cnGetRootDirectory
{
cnGetRootDirectory(pEnvironmentId : String) : String;

vars

begin
	return self.myCnKarmaCntrl.driveLetter & ":/" & pEnvironmentId; 
end;
}
cnGetServerFileLastModified
{
cnGetServerFileLastModified(filename : String) : TimeStamp serverExecution, updating;

vars
	file : File;
begin
	create file transient;
	file.fileName := filename;
	if not file.isAvailable then
	 	return null;
	else
		return app.cnFileLastModified(file).cnGMT;
	endif;
epilog
	delete file;	
end;
}
cnGetServerIniFileName
{
cnGetServerIniFileName() : String serverExecution;

vars

begin
	return self.getIniFileName();
end;
}
cnGetServerMiscPath
{
cnGetServerMiscPath() : String;
/*
	Revised:
	MFJ - 10Jan20 - Remove requirement to have CnKarmaCntl instantiated.
					Remove use of method cnGetToken
					Remove check for Windows vs Linux
	
	Purpose:
	
	Derive the server MISC path from the database path.
	Expectation is that the environment conforms to JADECare Managed Service directory naming standards.
*/
vars
	pos		: Integer;
	
	path	: String;
begin
	path 	:= app.dbPath.toLower();
	pos		:= path.reversePos("c_system");
	if pos = null then
		app.cnRaiseNormalException(Cn_Unhandled_Exception,
									method.cnGetMethodName(),
									"Unable to derive misc path as expected JADECare Managed Service system directory to be \server\c_system.", false);
		return null;
	endif;
	
	pos := pos - 1;
	return path[1:pos] & "c_misc";
end; 
}
cnGetServerTime
{
cnGetServerTime() : TimeStamp;

vars

begin
	return app.actualTimeServer();
end;
}
cnGetSharedTransient
{
cnGetSharedTransient(pClass : Class; pMaxAttempts : Integer) : Object;

/*
	This method is used to obtain or create the first shared transient defined by pClass. 
	
	If unable to get the shared transient for any reason after pMaxAttempts times, the
	object returned is null.
	
	If we have been able to get or create the shared transient, then the object returned
	is the shared transient.
*/
vars
	root			: CnRoot;
	
	obj				: Object;
	
	hadError,
	lockAcquired	: Boolean;
	
	d1				: Decimal[19];
	
	lockAttempts,
	retryTimeMs		: Integer;
	
	cc				: CnCntrl;
begin
	cc		:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " attempting to obtain first shared transient of class " & pClass.name, null);
	retryTimeMs := cc.lockRetryTime;
	if retryTimeMs = null then
		retryTimeMs := 60 * 1000;
	endif;
	
	root	:= app.myCnRoot;
	
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, null, hadError);
	obj	:= pClass.firstSharedTransientInstance();

	if obj = null then
		// single thread by locking CnRoot singleton while setting up node control shared transient (node singleton)
		// We could lock Node here instead of CnRoot, but JADE gets a bit sniffy if we do this
		lockAcquired := false;
		lockAttempts := null;
		while not lockAcquired and lockAttempts < pMaxAttempts do
			lockAttempts := lockAttempts + 1;
			lockAcquired := self.tryLock(root, Exclusive_Lock, Transaction_Duration, retryTimeMs);
			if lockAcquired then
				break;
			endif;
			
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " attempt #" & lockAttempts.String & " to exclusiveLock root object failed after " & (retryTimeMs div 1000).String & "secs", null); 
		endwhile;
		
		if not lockAcquired then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " attempts to lock CnRoot singleton failed, terminating....", null);
			return null;
		endif;
		
		obj	:= pClass.firstSharedTransientInstance();
		if obj = null then
			beginTransientTransaction;
			create obj as pClass sharedTransient;
			commitTransientTransaction;
		endif;
		
		unlock(root);
	endif;
	
	d1 := app.relativeMachineTime();																							// PAR 775
	lockAcquired := self.tryLock(obj, Exclusive_Lock, Session_Duration, LockTimeout_Immediate);									// PAR 775
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " tryLock LockTimeout_Immediate " & d1.cnGetElapsedTimeString() &		// PAR 775
														", lockAcquired=" & lockAcquired.String, null);							// PAR 775
	if lockAcquired then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " acquired lock on shared transient " & obj.String, null);	
		return obj;
	endif;
	
	return null;
epilog
	unlock(root);
end;
}
cnGlobalDeadlockExHandler
{
cnGlobalDeadlockExHandler(exObj : DeadlockException) : Integer updating;

vars
	cls			: Class;																										// PAR 1078
	
 	cc			: CnCntrl;

 	kc			: CnKarmaCntrl;
 	
 	deadHandler	: CnDeadlockHandler;

 	variant		: CnVariant;

 	meth		: Method;

 	methdesc	: MethodCallDesc;
	
 	obj			: Object;

 	param		: Parameter;

 	heldBy		: Process;

	ps			: ProcessStackArray;

 	array		: StringArray;

 	value		: Any;
 	
	bool,
	invObj		: Boolean;

 	stackPos	: Integer;
	
	clsName,																													// PAR 1078
	deadlockMsg,
	ipAddressStr,
 	obtained,
 	str,
 	target,
	usercode	: String;
begin
 	kc 			:= app.myCnKarmaCntrl;
 	cc			:= app.myCnCntrl;

 	deadHandler	:= kc.myDeadlockHandler; 

 	target		:= app.cnGetClassAndOid(exObj.lockTarget);
 	obtained	:= app.cnGetClassAndOid(exObj.obtainedLock);
 	heldBy		:= exObj.targetLockedBy;
	
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, heldBy, invObj);											// PAR 695
	usercode := heldBy.userCode;																								// PAR 695
	on SystemException do null;																									// PAR 695
	
 	if invObj then													// JADE can't always report all the details
		deadlockMsg := "Deadlock exception : no targetLockedBy information available from JADE, " &
					   ", locktype=" & exObj.lockType.String &
					   ", target=" & target &
					   ", other user is trying to lock " & obtained & " (which this process has locked).";
	
	else
		if app.getSystemVersion().cnMarkReleaseCut() >= 6217 then																// PAR 536
			ipAddressStr :=	"ipAddress=" & heldBy.networkAddress & ", ";														// PAR 536
		endif;																													// PAR 536
		
		deadlockMsg := "Deadlock Exception : locktype=" & exObj.lockType.String &
						", locktarget=" & target & ", " &
						"currently held by " &  heldBy.String & " " &
						"(app=" & heldBy.persistentApp.name & ", " &
						ipAddressStr &																							// PAR 536
						"usercode=" & usercode & ")  " &
						"who is trying to lock " & obtained & " (which this process has locked).";
	endif;

	cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " " & deadlockMsg, null);
	self.cnUserLockReport(deadlockMsg);

 	if cc.deadlockRetryLimit = 0 then
		deadlockMsg := "CnCntrl::deadlockRetryLimit for this app is zero : won't retry deadlock.";
 		cc.cnWriteLog(cc.CnLogComment, deadlockMsg, null);
		self.cnUserLockReport(deadlockMsg);
 		deadHandler.setDeadlockRetryCount(0);
		deadHandler.myParameterArray.purge;
 		return Ex_Pass_Back;
 	endif;

	cls := exObj.currentMethodDesc.getReceiver().class();																		// PAR 1078
	if cls = null then																											// PAR 1078
		cc.cnWriteLog(cc.CnLogComment, "GetReceiver.class returned null, receiverAsString=" &									// PAR 1078	
										exObj.currentMethodDesc.receiverAsString(), null);										// PAR 1078
	
	else																														// PAR 1078
		clsName := cls.name;																									// PAR 1078
		if clsName = "WebSessionManager" or																						// PAR 1078
		   clsName = "JadeWebAppExtension" then																					// PAR 1078
			deadlockMsg := "Deadlock incurred in " & clsName & " : won't retry deadlock.";										// PAR 1078
			cc.cnWriteLog(cc.CnLogComment, deadlockMsg, null);																	// PAR 1078
			self.cnUserLockReport(deadlockMsg);																					// PAR 1078
			deadHandler.setDeadlockRetryCount(0);																				// PAR 1078
			deadHandler.myParameterArray.purge;																					// PAR 1078
			return Ex_Pass_Back;																								// PAR 1078
		endif;
		
		cc.cnWriteLog(cc.CnLogComment, "GetReceiver.class=" & cls.name, null);													// PAR 1078
	endif;																														// PAR 1078
		
	if deadHandler.deadlockRetryCount > cc.deadlockRetryLimit then		// retry limit exceeded
		deadlockMsg := "ERROR : Deadlock retry limit (" & cc.deadlockRetryLimit.String &
					   ") has been exceeded : won't retry this deadlock.";
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " " & deadlockMsg, null); 
		self.cnUserLockReport(deadlockMsg);
		deadHandler.setDeadlockRetryCount(0);
		deadHandler.myParameterArray.purge;
   		return Ex_Pass_Back;
   	endif;
		
	// set up for retry
	create ps transient;
	process.currentStack(ps);
	stackPos	:= ps.size;											// point to bottom of stack
	
	while stackPos > 0 do
		methdesc	:= ps[stackPos];								// get stack entry
	
		if methdesc.getReceiver.isKindOf(CnDeadlockHandler)	or		// bottom of stack will be CnDeadlockhandler for retries	
		   not methdesc.method.isKindOf(JadeMethod) then			// if it's an external method we need to
			stackPos := stackPos - 1;								// go up one (getValue only available on JadeMetho
		else
			break;
		endif;	
	endwhile;
	
	if stackPos = 0 then
		deadlockMsg := "Global deadlock exception handler had stackPos=0 after trawl through stack : " &
						"unexpected error : will pass back to global handler.";
		cc.cnWriteLog(cc.CnLogErrors, deadlockMsg, null);
		self.cnUserLockReport(deadlockMsg);	
		deadHandler.setDeadlockRetryCount(0);
		deadHandler.myParameterArray.purge;
		return Ex_Pass_Back;
	endif;			
	
	obj			:= methdesc.getReceiver;
	meth		:= methdesc.method;			
	str			:= methdesc.getName;
	deadHandler.myParameterArray.purge;
			
	foreach param in meth.cnGetParameters do			// should only be one parameter anyway
		value 	:= null;
		bool 	:= meth.getValue(param.name, value);
		create variant transient;						// 'variant' transient is cleaned up when 'CnDeadlockHandler' singleton is deleted.
		variant.setValue(value);
		deadHandler.myParameterArray.add(variant);
	endforeach;
	
//	  	write "meth=" & meth.qualifiedName & ". params size=" & deadHandler.myParameterArray.size.String &
//	  		  ", paramArray=" & deadHandler.myParameterArray.String;
	
	if deadHandler.myParameterArray.size > 12 then
		deadlockMsg := "Method to be retried for deadlock (" & meth.qualifiedName & 
					  ") has more than 12 parameters : can't retry deadlock.";
		cc.cnWriteLog(cc.CnLogComment, deadlockMsg, null);
		self.cnUserLockReport(deadlockMsg);
		deadHandler.setDeadlockRetryCount(0);
		deadHandler.myParameterArray.purge;
		return Ex_Pass_Back;
	endif;
	
	array := methdesc.getName.cnGetTokens("::");
	deadHandler.setMethodName(array[2]);				// unqualified method name
	deadHandler.setMyReceiver(obj);
	deadHandler.setDeadlockRetryCount(deadHandler.deadlockRetryCount + 1);
	abortTransientTransaction;
	abortTransaction;
	self.cnUserLockReport("initiating deadlock retry #" & deadHandler.deadlockRetryCount.String);
	self.cnUserCleanUp(exObj);
	kc.causeEvent(Cn_Deadlock_Retry_Event, true, 0);		// userNotification does the replay
	return Ex_Abort_Action;		

epilog
	delete array;
	if ps <> null then
		ps.purge();
		delete ps;
	endif;
end;
}
cnGlobalExceptionHandler
{
cnGlobalExceptionHandler(exObj : Exception) : Integer updating;

vars
	cc			: CnCntrl;

	kc			: CnKarmaCntrl;
	
	stackdump 	: CnStackDump;

	meth		: Method;

	md			: MethodCallDesc;
	
	obj			: Object;
	
	pc			: ProcessStackArray;

	abort,
	badObject,
	noDump,
	passBack	: Boolean;
	
	cnt,
	ix,
	remoteCode	: Integer;
	
	exceptionDetails,																												// PAR 969
	str			: String;
begin
	cc 	:= app.myCnCntrl;
	if cc = null then		// we're in some strange state so rather than get a 1090 exception and risk getting nested exceptions, we bail.
		if exObj.isKindOf(ConnectionException) then		// refer to JADE PAR 47262. If Web Services connection then JADE itself provides
			return Ex_Pass_Back;						// a default exception handler which needs to handle these.
		endif;											// If application is activating KarmaCntrl then ConnectionException would normally
														// be caught by the CnTcpExceptionHandler and app.myCnCntrl would not be null.
														
		abortTransaction;
		abortTransientTransaction;
		cnUserCleanUp(exObj);
		return Ex_Abort_Action;										 
	endif;
	
	// following moved up, was located at approx at what is now line 155
	// basically if we get a connection exception then either the connection was not of type CnTcpConnection (or a sub-class) or the
	// cnTcpExceptionHandler was somehow not armed or was disarmed. If the connection was of type CnTcpConnection (or a subclass), 
	// we force usage of the correct handler otherwise we bail out and let the JADE default exception handlers take over. 
	// In the case of a WebServices exception JADE arms a special global handler. 
	// RWM advises (on 11/4/08) that a longer term solution is to be implemented within RootSchema that will negate the need for 
	// these changes, but changes below won't hurt existing systems.
	if exObj.isKindOf(ConnectionException)  then		// these shouldn't get to here, but we DO get 1205 exceptions sometimes as a 
		//												// result of aborting a callback method
		cc.cnWriteLog(cc.CnLogErrors, "cnGlobalExceptionHandler detected ConnectionException, error Code = " & exObj.errorCode.String, null);
		if exObj.errorObject.isKindOf(CnTcpConnection) and
		   exObj.errorCode <> 1205 then
			cc.cnWriteLog(cc.CnLogErrors, "cnGlobalExceptionHandler invoking cnTcpExceptionHandler....", null);
			return cnTcpExceptionHandler(exObj.ConnectionException);
		endif;

		return Ex_Pass_Back;								// 1205 exceptions get passed back to default handler, don't need dump
	endif;
	
	kc 	:= app.myCnKarmaCntrl;
	self.setCnStackDumpFileName(null);
	str	:= "Exception " & exObj.errorCode.String & "  (" & exObj.text & ")  in application " & cc.appName &
		   " (application type = " & app.cnGetApplicationType & "), extendedErrorText=" & exObj.extendedErrorText;
	if node.isServerNode then
		app.cnSetServerGlobalExHandlerDone(true);
	
	elseif exObj.errorCode = 1242 then
		if app.cnServerGlobalExHandlerDone then
			str := str & "; server global exception handler was invoked.";
			self.cnSetServerGlobalExHandlerDone(false);
		
		else
			str := str & "; server global exception handler was NOT invoked!";
		endif;
	endif;

    cc.cnWriteLog(cc.CnLogErrors, str, null);
	self.cnUserLockReport(str);

	if node.isServerNode and cc.appName = "KCDbBackupWorker" and exObj.errorCode = 3036 then		// db file not found
		cc.cnWriteLog(cc.CnLogErrors, "3036 error during on-line backup, passing back to JadeDatabaseAdmin's client exception handler.", null);
		return Ex_Pass_Back;
	endif; 

	if cc.exceptionHandlerType = cc.Exception_Handler_Jade_Debug then
		exObj.showDialog;											// show standard dialog, even if I'm a server app :
		abortTransaction;											// normally only use this option during application debug.
		abortTransientTransaction;
		cnUserCleanUp(exObj);
		return Ex_Abort_Action;										 
	endif;
	
	//  Now check for recursion.  If we find this handler has already been called
	//  further down the stack, we give up immediately.  This helps to avoid
	//  overflowing the exception stack. 
	
	create pc transient;
	process.currentStack(pc);
	foreach ix in 3 to pc.size do			// ignore process.stackArray call + myself
		md		:= pc[ix];
		meth	:= md.method;
		if meth = method then
			cnt	:= cnt + 1;
		endif;
		
		if cnt > 1 then
			if cc.karmaControl and cc.reportExceptions then
				app.cnRaiseAlert("Recursive exception in application " & cc.appName &  " of " & kc.environmentId.toUpper & " on " & app.cnComputerName,
								 "Application " & cc.appName & " in environment " & kc.environmentId.toUpper & " had recursive exception : " &
								 "transaction aborted without successful stack dump.  See cn_log.log for exception details.",
								 "N",
								 app.actualTimeServer,
								 cc.appName,
								 kc.localFQDN,
								 kc.networkAddressNode);		// PAR 441 node.networkAddress);
    			cc.cnWriteLog(cc.CnLogErrors, "Alert issued to JADECare Systems Manager.", null);
			endif;		
		
			if cc.exceptionHandlerType = cc.Exception_Handler_CardSchema then
				cc.cnWriteLog(cc.CnLogErrors, ">>>>>>>>>>>  !!    Recursive call of global exception handler detected : can't take dump " &
											  " : aborting now.   !!  <<<<<<<<<", null);
				abortTransaction;											
				abortTransientTransaction;
				cnUserCleanUp(exObj);
				if app.cnApplicationType = app.ApplicationType_GUI then
					app.msgBox("Recursive exception encountered : your transaction has been aborted." & CrLf &
							   "Please re-submit your transaction, or refer to CardSchema log (cn_log.log) for details.", "Error", 48);
				endif;
				return Ex_Pass_Back;	
			else							// exception handler is 'Jade' or 'Both'				
				cc.cnWriteLog(cc.CnLogErrors, ">>>>>>>>    Recursive call of global exception handler detected : won't take dump " &
										  " : returning Ex_Pass_Back...   <<<<<<<<<", null);
				return Ex_Pass_Back;
			endif;				
		endif;
	endforeach;	

	if exObj.isKindOf(FileException) then
		obj	:= exObj.FileException.file;
		on SystemException do app.cnHandleNullOrInvObjectRef(exception, obj, badObject);
		if obj.isKindOf(File) then
			str	:= "file in error is '" & obj.File.fileName & "'.";

		elseif obj.isKindOf(JadeLog) then
			str	:= "file in error is '" & obj.JadeLog.filePath & "/" & obj.JadeLog.fileName & "'.";
			
		else
			str		:= "object returned from FileException::file = " & obj.String;		// other classes may throw file exceptions
		endif;
		
		on SystemException do null;
		if badObject then 
			str := "file in error not known - valid reference not available.";
		endif;

		cc.cnWriteLog(cc.CnLogErrors, "File Exception " & exObj.errorCode.String & " (" & exObj.text & ") : " & str, null);
	
	elseif exObj.isKindOf(LockException) then
		if exObj.LockException.lockTarget = global		  or
		   exObj.LockException.lockTarget = node		  then
			return Ex_Pass_Back;
		endif;

	elseif exObj.isKindOf(ODBCException) then
		cc.cnWriteLog(cc.CnLogErrors, "ODBC Exception : errorCode=" & exObj.errorCode.String & ", state=" & exObj.ODBCException.state &
					  ", nativeError=" & exObj.ODBCException.nativeError.String, null);

	endif;

	////////    Now exclude certain specific exceptions that we really don't want dumps for   ///////
	
	if exObj.isKindOf(NotificationException) then
		str		:= "Notification Exception : errorCode=" & exObj.errorCode.String &  
					  ", notification subscriber=" & app.cnGetClassAndOid(exObj.errorObject) &
					  ", notificationTarget=" & app.cnGetClassAndOid(exObj.NotificationException.notificationTarget) &
					  " : will skip stack dump.";
		cc.cnWriteLog(cc.CnLogErrors, str, null);
		noDump := true;
		
	elseif exObj.errorCode = 1200 or				// reorganisation required
		   exObj.errorCode = 1209 then				// application terminate request - Jade internal error
		noDump := true;

	elseif exObj.errorCode = 1242 then
		remoteCode	:= exObj.remoteErrorCode;
		str			:= "Error 1242 (Method executing on another node aborted) : remote error code = " & remoteCode.String;
		
		if cc.exceptionHandlerType = cc.Exception_Handler_CardSchema and not cc.javaThinClient then
			if (remoteCode = 5503 or remoteCode = 5504)					 and 
			   (self.cnApplicationType = ApplicationType_Web_Enabled or
			    self.cnApplicationType = ApplicationType_Non_GUI_Web) 	 then	
				// need to let JADE provide an output to the browser in this case, otherwise web session locks up		
				cc.cnWriteLog(cc.CnLogErrors, str & " : licence breach in web app : passing back to JADE default exception handler.", null);
				return Ex_Pass_Back;
			endif;
							
			if self.cnApplicationType = ApplicationType_Web_Enabled then														// PAR 1080
				self.cnShowExceptionWebForm(exObj);
			endif;
			
			cc.cnWriteLog(cc.CnLogErrors, str & " : aborting transaction and discarding exception.", null);
			abortTransientTransaction;
			abortTransaction;
			cnUserCleanUp(exObj);
			return Ex_Abort_Action;
			
		elseif cc.exceptionHandlerType = cc.Exception_Handler_Both_NotSvce and cc.isService and not process.isUsingThinClient then  
			cc.cnWriteLog(cc.CnLogErrors, str & " : ExceptionHandler=BothIfNotService and node running as service and not a thin-client process : " &
											    "aborting transaction and discarding exception.", null);
			abortTransientTransaction;
			abortTransaction;
			cnUserCleanUp(exObj);
			return Ex_Abort_Action;
		endif;
		
		cc.cnWriteLog(cc.CnLogErrors, str & " : returning Ex_Pass_Back.", null);
		return Ex_Pass_Back;
	endif;
	
	if exObj.errorCode = 3059 then											// db locked for reorg
		if not cc.suppressManagementDialogs and app.cnApplicationType = app.ApplicationType_GUI then
			abortTransaction;
			abortTransientTransaction;
			cnUserCleanUp(exObj);
			app.msgBox(exObj.text & CrLf & "Please try again later", "Error", 48);
			return Ex_Abort_Action;
			
		else
			noDump	:= true;
		endif;
	endif;	  

	if process.isUsingThinClient then											
		if exObj.errorCode > 14134 and exObj.errorCode < 14150 then			// thin client-to-app-server errors
			//
			//  This is tricky, because JADE starts destroying things if thin client disconnections occur,
			//  and there is no guarantee that my objects will still exist.  Try to log, otherwise just pass back.
			// 
			str	:= "Thin client encountered error " & exObj.errorCode.String & " (" & exObj.text &
				   ") - fatal error for thin client : aborting transaction ";
				   
			if (exObj.errorCode = 14143 or exObj.errorCode = 14144 or exObj.errorCode = 14147) and 		// read & TCP errors : the most common errors
			   cc.exceptionHandlerType = cc.Exception_Handler_CardSchema then   			
				cc.cnWriteLog(cc.CnLogErrors, str & "(no dump taken)", null);
			else
				cc.cnWriteLog(cc.CnLogErrors, str & ". See " & cc.appName & ".log file for history.", null);
				passBack	:= true;
			endif;
	   	   	
			abortTransientTransaction;
	   		abortTransaction;
	   		cnUserCleanUp(exObj);
	   		
	   		if passBack then			
	   			return Ex_Pass_Back;			// JADE has the best chance of logging this
	   		else	
	   			return Ex_Abort_Action;				
	   		endif;
	   	endif;
	endif;	

	//////////    Now invoke call stack dumper, which will decide whether to take a dump,    /////////
	//////////    and whether to report the exception (all changed for CardSchema 3.0)       /////////

	create stackdump as self.zStackDumpClass() transient;
	stackdump.noDump	:= noDump;
	stackdump.dumpStackPlus(exObj, exceptionDetails);																			// PAR 969

    /////////////////////////////////////  Release all locks and abort transaction  //////////////////////////////////////////////

    if cc.exceptionHandlerType = cc.Exception_Handler_CardSchema then
	    cc.cnWriteLog(cc.CnLogErrors, "Exception handler type is CardSchema only : now doing abortTransaction and release locks", null);
		abort	:= true;

	elseif cc.exceptionHandlerType = cc.Exception_Handler_Both_NotSvce and cc.isService and not process.isUsingThinClient then
		cc.cnWriteLog(cc.CnLogErrors, str & " : ExceptionHandler=BothIfNotService and node running as service and not a thin-client process : " &
											"aborting transaction and releasing locks...", null);
		abort	:= true;
	endif;
	
	if abort then
	   	abortTransientTransaction;
		abortTransaction;
		cnUserCleanUp(exObj);
		cc.cnWriteLog(cc.CnLogErrors, "Transaction aborted and locks released : now displaying exception form, if appropriate...", null);
	endif;
    //
    //////////////////////////////////////////////  User friendly dialog now  ///////////////////////////////////////////////////
    //
    if cnApplicationType = ApplicationType_GUI 	and 
       exObj.errorCode <> 14063 				and		// 14063 is 'Unable to create window'
       not app.cnIsServerApp  					then	// unlikely		
    	self.cnShowExceptionFormPlus(exObj, exceptionDetails);	// clientExecution												// PAR 969
    endif;
	
	if abort then
		cc.cnWriteLog(cc.CnLogErrors, "cnGlobalExceptionHandler is finished, now returning Ex_Abort_Action", null);
		self.cnUserLockReport(method.name & " finished, transaction aborted and locks released, return Ex_Abort_Action");
		return Ex_Abort_Action;
	endif;
	
	cc.cnWriteLog(cc.CnLogErrors, "cnGlobalExceptionHandler is finished, now returning Ex_Pass_Back", null);
	self.cnUserLockReport(method.name & " finished, returning Ex_Pass_Back");
	return Ex_Pass_Back;
epilog
	if pc <> null then
		pc.purge();
		delete pc;
	endif;
	
	delete stackdump;
end;
}
cnGlobalLockExceptionHandler
{
cnGlobalLockExceptionHandler(pExObj : LockException) : Integer updating;
	// Generic lock handling routine by JDC, unsupported by them, modified by 
	// R.W.Mitchell, JADE Software Corporation Limited.
vars
	cc					: CnCntrl;

	progressDialog		: CnProgressDialog;
	
	stackdump			: CnStackDump;

	form				: Form;
	
	meth				: Method;

	lockTarget			: Object;

	lockedByProcess		: Process;
	
	lockItems			: CnStringArray;

	badObject,
	hadLockException,
	noDisplay			: Boolean;
	
	date				: Date;
	
	d1					: Decimal [23];

	codePos,
	errorCode,
	lastRetryCount,
	lockDuration,
	lockTimeout,
	lockType,
	retryCount,
	retryLimit,
	retryTime			: Integer;

	errorText,
	exceptionText,
	lockDetails,
	lockedByApp,
	lockedByInfo,
	lockedByNodeName,
	lockedByProcId,
	lockedByUserCode,
	logText,
	lockAppDetails,
	lockItem,
	lockTypeStr,
	methodDetails,
	sourceLine,
	str					: String;
	
	time				: Time;
begin
	cc 				:= app.myCnCntrl;
	create stackdump as self.zStackDumpClass() transient;
	d1				:= app.relativeMachineTime();
	self.setCnStackDumpFileName(null);
	retryCount 		:= 1;
	lockTarget		:= pExObj.lockTarget;
	lockType		:= pExObj.lockType;
	lockDuration	:= pExObj.lockDuration;
	errorCode		:= pExObj.errorCode;
	errorText		:= pExObj.text();
	
	if lockTarget = node				or					// detour to JADE issue : Form::create references node in 5.0.15
	   lockTarget = global				or					//   "        "     "   : ProgressDialog::enableWindows references global	
	   cnApplicationType = ApplicationType_Web_Enabled or		// web session
	   cnApplicationType = ApplicationType_Non_GUI_Web or
	   cnApplicationType = ApplicationType_Non_GUI	 or		// could be non gui in JADE.EXE in 5.1
	   cnIsServerApp					then				// server application
		noDisplay	:= true;
	endif;	

	if not noDisplay then										// not a web or server app
		progressDialog := app.cnShowProgressDialog(app.cnGetClassAndOid(lockTarget));	// this method is clientExecution
	endif;

	self.zGetLockedByDetails(pExObj,
							lockedByApp,
							lockedByInfo,
							lockedByNodeName,
							lockedByProcId,
							lockedByUserCode);

	if lockType = Share_Lock then
		lockTypeStr := "Share";
	
	elseif lockType = Exclusive_Lock then
		lockTypeStr := "Exclusive";
	
	elseif lockType = Reserve_Lock then
		lockTypeStr := "Reserve";

	elseif lockType = Update_Lock then
		lockTypeStr := "Update";

	else
		lockTypeStr := "<unknown : " & lockType.String & ">";
	endif;
	
	meth			:= method.cnGetPriorMethod(2, codePos);
	sourceLine		:= meth.cnGetSourceLine(codePos);
	sourceLine 		:= stackdump.removeSensitiveDataFromArgs(sourceLine);
	
	sourceLine.replaceChar(Tab, CN_SPACE);
	methodDetails	:= "method=" & meth.qualifiedName & ", source=" & sourceLine & " (" & codePos.String & ")";
	create lockItems transient;
	lockItem		:= "user=" & lockedByUserCode & "; node=" & lockedByNodeName &
						"; app=" & lockedByApp & "; procid=" & lockedByProcId;
	lockItems.add(lockItem);
	exceptionText 	:= date.cnUserFormat($CnDDMMYY) 																& CN_COMMA & 
						CN_TILDE & time.cnUserFormat($CnHHMMSS) & "." & time.milliSecond.String. padLeadingZeros(3)	& CN_COMMA &		// add tilde to avoid Excel stuffing up time
						cc.appSchemaName & "::" & cc.appName 														& CN_COMMA &
						self.cnGetInstanceId64(process).String 														& CN_COMMA &
						process.userCode																			& CN_COMMA &
						node.name																					& CN_COMMA &
						lockTarget.String 																			& CN_COMMA &
						lockTypeStr 																				& CN_COMMA &
						meth.qualifiedName																			& CN_COMMA &
						CN_DOUBLE_QUOTE & sourceLine & CN_DOUBLE_QUOTE												& CN_COMMA &
						codePos.String;
	
	lockDetails		:= "lockTarget=" & lockTarget.String & ", locked by " & lockedByUserCode & " on node " & lockedByNodeName;
	lockAppDetails	:= "Application holding lock=" & lockedByApp & ", JadeProcId=" & lockedByProcId;
	methodDetails	:= "method=" & meth.qualifiedName & ", source=" & sourceLine & " (" & codePos.String & ")";
	logText			:= "Lock Exception : " &
						lockDetails & " : " & lockAppDetails & ", " &
						methodDetails;
	cc.cnWriteLog(cc.CnLogDiag, str, null);	// used for dev debug only
	self.cnUserLockReport(str);
	
	if not noDisplay and not cc.javaThinClient then
		app.cnShowProgress(progressDialog, 'Object ' & lockTarget.String,
										   'Locked by ' & lockedByUserCode & " @ " & lockedByNodeName,							// PAR 959
										   lockedByApp & "/" & lockedByProcId & ");  retrying (" & retryCount.String);			// PAR 959
	endif;

	//  Assuming 'normal' lock timeout values of around 1000 - 10000 milliseconds we now retry the lock for maximum of 60 seconds. 
	//  If this time is exceeded without securing the lock, the handler will return Ex_Pass_Back.  If CardSchema's globalExceptionHandler
	//	has been armed, this should result in a dump and release of any locks held by the current transaction, thus releasing
	//  the application database for use by other processes. 

	lockTimeout	:= pExObj.lockTimeout;
	if lockTimeout = 0 then									// using server-defined value
		lockTimeout := cc.lockTimeOut;
	endif;

	retryTime := cc.lockRetryTime;

	if retryTime = 0 then
		retryLimit := Max_Integer - 1;						// retry almost forever

	elseif retryTime < lockTimeout then
		retryLimit := 1;									// retry once only

	else
		retryLimit := retryTime div lockTimeout;			// retry as many times as will fit into lockRetryTime
	endif;

	self.cnUserLockReport("lockTimeout=" & lockTimeout.String & ", retryTime=" & retryTime.String & ", retryLimit=" & retryLimit.String);
	
	// when we retry the lock below, we may get another lock exception.
	// we need to handle this locally rather than go back through the global lock exception handler
	// and, further, we need to get the new details of this lock exception as the lock owner may have
	// changed from the original lock exception.
	on LockException do app.cnLocalLockExceptionHandler(exception, 
														hadLockException,
														lockedByApp,
														lockedByInfo,
														lockedByNodeName,
														lockedByProcId,
														lockedByUserCode);
	while true do
		hadLockException := false;
		self.cnUserLockReport("starting lock retry #" & retryCount.String);
		lock(lockTarget, lockType, lockDuration, lockTimeout);
		if hadLockException then
			str := "retry #" & retryCount.String & " failed";
			
		else
			str := "retry #" & retryCount.String & " succeeded";
		endif;
		
		self.cnUserLockReport(str);
		if not hadLockException then		// lock successful, bail out
			str := lockItems.size.String & CN_COMMA;
			foreach lockItem in lockItems do
				str := str & lockItem & CN_COMMA;
			endforeach;
			
			process.causeEvent(CN_REPORT_LOCKEXCEPTION, true, exceptionText & CN_COMMA & 
																(retryCount+1).String & CN_COMMA &
																(d1-lockTimeout).cnGetElapsedTime_ns() & CN_COMMA &
																str);
			break;
		endif;

		if  not noDisplay		 	and 
			not cc.javaThinClient 	and 
			app.cnShowProgress(progressDialog, 
							   'Object ' & lockTarget.String,
							   'Locked by ' & lockedByUserCode & " @ " & lockedByNodeName, 
			   				   lockedByApp & "/" & lockedByProcId & 															// PAR 959
			   				   '  retrying ( ' & retryCount.String & ' )') = 1 then
			abortTransientTransaction;
			abortTransaction;
			app.cnShowProgressUnload(progressDialog);
			cc.cnWriteLog(cc.CnLogDiag, "Transaction aborted after user pressed cancel on lock retry dialog.", null);
			app.cnMsgBoxClient("Transaction has been aborted (you pressed 'Cancel' on the lock retry dialog)." & CrLf &
					   		   "Resubmit your transaction if required.", cc.appName, 48);
			cnUserCleanUp(pExObj);
			return Ex_Abort_Action;
		endif;

		meth			:= method.cnGetPriorMethod(2, codePos);
		sourceLine		:= meth.cnGetSourceLine(codePos);
		sourceLine 		:= stackdump.removeSensitiveDataFromArgs(sourceLine);
		lockDetails		:= "lockTarget=" & lockTarget.String & ", locked by " & lockedByUserCode & " on node " & lockedByNodeName;
		lockAppDetails	:= "Application holding lock=" & lockedByApp & ", JadeProcId=" & lockedByProcId;
		methodDetails	:= "method=" & meth.qualifiedName & ", source=" & sourceLine & " (" & codePos.String & ")";
		logText			:= "Exception=" & errorCode.String & " : " & errorText & ", " &
							lockDetails & " : " & lockAppDetails & ", " &
							methodDetails;
		// lock may be contended for by more than one process so the owning process may change
		// so keep a list of unique owing processes that prevent us from obtaining the lock
		lockItem		:= "user=" & lockedByUserCode & "; node=" & lockedByNodeName &
							"; app=" & lockedByApp & "; procid=" & lockedByProcId;
		if not lockItems.includes(lockItem) then
			lockItems.add(lockItem);
		endif;
		
		retryCount := retryCount + 1;
		if retryCount > retryLimit then
			if app.cnApplicationType = app.ApplicationType_Web_Enabled then		// web app
				cc.cnWriteLog(cc.CnLogErrors, logText & " : aborted after " & 
							  retryLimit.String & " retries.", null);
	
				app.cnShowExceptionWebForm(pExObj);
	
				if cc.logCallStackDump and lockTarget <> node then
					cc.cnWriteLog(cc.CnLogComment, "CardSchema::cnGlobalLockExceptionHandler is initiating stack dump ...", null);
					stackdump.dumpStack(pExObj);
				endif;
	
				abortTransientTransaction;
				abortTransaction;				// releases all locks
				cnUserCleanUp(pExObj);
				return Ex_Abort_Action;
			endif;

			// not web-app
			str := logText & " : aborted after " & retryLimit.String & 
							 " retries, contended for " & (d1-lockTimeout).cnGetElapsedTime() & ".";
			self.cnUserLockReport(str);
			cc.cnWriteLog(cc.CnLogErrors, str, null);

			if not cc.javaThinClient and not noDisplay then
				app.cnShowProgressUnload(progressDialog);
				
				if self.cnIsForegroundClient and not cc.suppressManagementDialogs then
					abortTransientTransaction;
					abortTransaction;				// releases all locks
					cnUserCleanUp(pExObj);
					self.cnShowLockErrorMessage(lockDetails, lockAppDetails, methodDetails);
					return Ex_Abort_Action;
				endif;						
			endif;
			
			return Ex_Pass_Back;						// otherwise let global exception handler take dump
		endif;
		
//		str := logText & " : retry #" & retryCount.String;
		self.cnUserLockReport(logText);
		cc.cnWriteLog(cc.CnLogErrors, logText, null);
	endwhile;

	// we only get to here if the lock retry is successful
	if not noDisplay and not cc.javaThinClient then
		app.cnShowProgressUnload(progressDialog);
	endif;

	return Ex_Continue;
epilog
	delete lockItems;
	//if progress dialog still up, then unload it
	if not noDisplay then
		form := getForm(CnProgressDialog.name);
		if form <> null then
			form.unloadForm;
		endif;
	endif;
	
	delete stackdump;
end;
}
cnHandleAndBypassAnyException
{
cnHandleAndBypassAnyException(pExObj : Exception; pAppServerGroupName : String; pHadError : Boolean output) : Integer;

vars
	str		: String;
	
	cc		: CnCntrl;
begin
	pHadError := true;
	str := pExObj.errorCode.String & 
		   " Error Item : " & pExObj.errorItem &
		   " Error Text : " & pExObj.text();
	
	if pExObj.extendedErrorText <> null then
		str := str & " (" & pExObj.extendedErrorText & ")";
	endif;

	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogErrors, str, null);
	if pExObj.resumable then
		return Ex_Resume_Next;
	endif;
	
	return Ex_Abort_Action;
end;
}
cnHandleInvalidObjectReference
{
cnHandleInvalidObjectReference(exObj : Exception; badObject : Boolean output) : Integer;

vars

begin
	if exObj.errorCode = 4 then
		badObject	:= true;
		return Ex_Resume_Next;
	else
		return Ex_Pass_Back;
	endif;
end;
}
cnHandleNullOrInvObjectRef
{
cnHandleNullOrInvObjectRef(pExObj : Exception; pObj : Object; pError : Boolean output) : Integer;

vars

begin
	if pObj = null then
		if pExObj.errorCode = Cn_ObjectNotFound or							// 4
		   pExObj.errorCode = Cn_AttemptedAccessViaNullRef  then			// value 1090
			pError := true;
			return Ex_Resume_Next;
		endif;
	
		return Ex_Pass_Back;
	endif;
	
	// if pObj specified, we're only interested if we've got a 4 or 1090 on the specified object
	if (pExObj.errorCode = Cn_ObjectNotFound  or pExObj.errorCode = Cn_AttemptedAccessViaNullRef) and	// 4 or 1090
		pExObj.errorObject() = pObj then
		pError := true;
		return Ex_Resume_Next;
	endif;

	return Ex_Pass_Back;
end;
}
cnHandleReorgException
{
cnHandleReorgException(pExObj 		: SystemException; 
					  pErrorCode 	: Integer output; 
					  pErrorText 	: String output) : Integer;

vars
	cc	: CnCntrl;
begin
	cc	:= app.myCnCntrl;
	pErrorCode := pExObj.errorCode;
	pErrorText := pExObj.text;
	cc.cnWriteLog(cc.CnLogErrors, "Exception " & pErrorCode.String & " (" & pErrorText & ") encountered.", null);

	if pErrorCode = Cn_DatabaseLockedForReorganize 	or				// 3059
	   pErrorCode = Cn_DatabaseFileLockedForReorg 	or				// 3116
	   pErrorCode = Cn_SDSBackupTerminatedReorg 	then			// 3213
		return Ex_Resume_Next;
	endif;
	
	pErrorCode	:= null;
	pErrorText	:= null;
	return Ex_Pass_Back;
end;
}
cnHandleSpecifiedInvalidObjRef
{
cnHandleSpecifiedInvalidObjRef(exObj : SystemException; obj : Object; badObject : Boolean output) : Integer;

vars

begin
	if exObj.errorCode = 4 		and
	   exObj.errorObject = obj 	then
		badObject	:= true;
		return Ex_Resume_Next;
	else
		return Ex_Pass_Back;
	endif;
end;
}
cnHandleStartupException
{
cnHandleStartupException(exObj : Exception) : Integer;

vars
	log		: JadeLog;
	callStack	: String;
	sd			: CnStackDump;
begin
	log		:= app.myCnLog;
	log.log(">>> Exception " & exObj.errorCode.String & " (" & exObj.text & ") <<<");
	create sd transient;
	callStack := sd.dumpCallStack(false, false);	// false means we don't log into app.myCnCntrl which doesn't exist yet
	log.log(callStack);
	log.log("Returning Ex_Pass_Back ...");
	return Ex_Pass_Back;
epilog
	delete sd;	
end;
}
cnHandleSystemShutDownEvent
{
cnHandleSystemShutDownEvent() updating;

vars
	cc		: CnCntrl;
	proc	: Process;
begin
	//  This method is called when a system shut down event is caused by JADCLIENT (5.1.10.38 minimum).
	//  If you want to change the way shut down requests are handled you can re-implement this method.
	//  You may wish to inherit this method in your re-implementation.
	//
	//	Please refer to the current CardSchema User Guide for information about structuring applications
	//  for predictable system shut down in the JADE Direct managed environment. 

	proc	:= Process.firstInstance;							// serverBackground
	resynchObject(proc);
	beginTransaction;
	proc.adminInfo	:= CnKarmaCntrl.System_Stopping;			// CardSchema will now stop any additional clients	
	commitTransaction;											// from starting while the shut down is in process.
	//
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogComment, "System shut down requested by system event : terminating normally now...", null);
	app.cnTerminate();
end;
}
cnInitializeAppServerMonitor
{
cnInitializeAppServerMonitor();

vars
	cc					: CnCntrl;
	
	alias,
	appServerGroup,
	iniFile,
	jadeVer				: String;
	
	hadError			: Boolean;
	
	pid					: Integer;
begin
	//
	//  AppServerMonitor can be started by JAWS and used by JSM as a ping target to detect non-functioning app server.
	//
	
	// allow the AppServerMonitor to be aliased with something meaningful
	iniFile := app.getIniFileName();
	alias := app.getProfileStringAppServer(iniFile, "Karma", process.getProcessApp().name & "Alias", null);		// PAR 555
	if alias <> null then
		app.setCnAppAlias("AppServerMonitor_" & alias);
	endif;
	
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);			// always activate rather than instantiate CnKarmaCntrl.
	pid := node.osID;
	cc	:= app.myCnCntrl;
								   
	if node.isApplicationServer() then
		cc.cnWriteLog(cc.CnLogComment, app.cnAppAlias & " Application Server Monitor started for Application Server (PID=" & pid.String & ").", null);
	
	else
		cc.cnWriteLog(cc.CnLogComment, app.cnAppAlias & " Application Server Monitor started for node (PID=" & pid.String & ") which is NOT an Application Server", null);
	endif;
	
	if app.getProfileStringAppServer(iniFile, "Karma", "AppServerMonitorTerminate", false.String).Boolean then		// NFS 581
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " [Karma] AppServerMonitorTerminate was set, terminating", null);
		terminate;
	endif;
	
	if cc.isInTestMode() then
		cc.beginNotification(process, CN_QUAL_APPSERVERMONITOR_SUSPEND, Response_Continuous, null);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " in test mode, armed 'suspend' notification", null);
	endif;
end;
}
cnInitializeKCBatch
{
cnInitializeKCBatch(initParam : Object);

vars
	bm				: CnBatchMgr;

	osPlatform,
	osArchitecture	: Integer;

	osVersion		: String;
begin
	osPlatform	:= node.getOSPlatform(osVersion, osArchitecture);
	app.cnSetOSPlatform(osPlatform);
	create app.myCnCntrl transient;																								// PAR 1092
	create bm transient;
	bm.initParams := initParam.HugeStringArray;
	bm.initialize();																					// PAR 1072
	bm.beginTimer(250, Timer_OneShot, 1);
end;
}
cnInitializeKCCMgr
{
cnInitializeKCCMgr() updating;

constants
	Max_Attempts		: Integer		= 5;
	Launch				: Boolean		= true;
vars
 	cc 					: CnCntrl;

	cem					: CnExternalMethods;
	
	lockCheck			: CnLockCheck;																							// PAR 1003

 	sdsDba				: CnSDSDatabaseAdmin;

	kc 					: CnKarmaCntrl;

 	tcp 				: CnKarmaTcpConnection;
 	
 	target				: CnLockTarget;

 	root				: CnRoot;
 	
 	jdba				: JadeDatabaseAdmin;

	deltaDatabaseStatus,
	lockCheckInterval,
	maxTries,
	role,
	rpsStorageMode,
	subRole,
	tries				: Integer;
	
	appName,
	iniFileName,
	rpsMappingName,
	schemaName,
	str					: String;
begin
	create cc;
   	on Exception do cnHandleStartupException(exception);

	cc.cnWriteLog(cc.CnLogComment, "KCCMgr is starting ....", null);
    iniFileName			:= app.getIniFileName();

	role	:= system.getDatabaseRole();
	if role <> SDS_RoleSecondary then
		self.zCheckLockTargets();
	endif;
	
	if role <> SDS_RoleUndefined then	
		if role = SDS_RolePrimary then
			str		:= "SDS primary ";

		elseif role = SDS_RoleSecondary then
			subRole := system.getDatabaseSubrole();
			if subRole = SDS_SubroleRelational then
				str	:= "RPS server ";
				
			else
				str	:= "SDS secondary ";
			endif;
		endif;
	
		cc.cnWriteLog(cc.CnLogComment, "KCCMgr is running in an " & str  & ": checking that SDS is running and read access is available...", null);
		create jdba transient;
		while true do
			if not jdba.sdsIsRunning then						
				cc.cnWriteLog(cc.CnLogComment, "SDS not yet running : process will wait & retry ...", null);
			endif;
			
			if role = SDS_RoleSecondary then
				if app.cnSdsReadAccessEnabled() then
					cc.cnWriteLog(cc.CnLogComment, "SDS read access is available : continuing with application initialisation...", null);
					break;
				else			
					cc.cnWriteLog(cc.CnLogComment, "SDS read access not yet enabled : process will wait " &
												   "(you may need to close one or more journals at primary).", null);
				endif;								   
			else
				break;
			endif;
			
			process.sleep(5000);
		endwhile;
	endif;
	
	root	:= CnRoot.firstInstance;
	if role = SDS_RoleSecondary then		
		app.cnDatabaseSubrole	:= jdba.cnGetDatabaseSubrole();
		if root = null then
			if app.cnDatabaseSubrole = SDS_SubroleRelational then
				create jdba transient;
				jdba.rpsGetDatabaseParameters(schemaName, rpsMappingName, rpsStorageMode);
				if rpsStorageMode = jdba.RpsStorageMode_WorkingSet then
					cc.cnWriteLog(cc.CnLogErrors, ">>>> RPS node using Working Set, JADECare managed applications are not supported in this mode!", null);
					terminate;
				endif;
				
				if rpsStorageMode = jdba.RpsStorageMode_Full then
					cc.cnWriteLog(cc.CnLogErrors, ">>>> RPS node can't find CnRoot persistent instance in Full Extent", null);
					cc.cnWriteLog(cc.CnLogErrors, ">>>> Ensure that KCCMgr has executed on SDS Primary, close current journal, start up datapump and then restart database", null);
					terminate;
				endif;

				if rpsStorageMode = jdba.RpsStorageMode_MappedExtent then
					cc.cnWriteLog(cc.CnLogErrors, ">>>> RPS node can't find CnRoot persistent instance in Mapped Extent", null);
					root := CnRoot.firstSharedTransientInstance();
					if root <> null then
						cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " KCCMgr is already running, terminating...", null);
						terminate;
					endif;

					beginTransientTransaction;			
					create root sharedTransient;		
					root.setMyKCCMgrProcess(process);
					commitTransientTransaction;
					cc.cnWriteLog(cc.CnLogErrors, ">>>> Created CnRoot shared transient.", null);

				else
					cc.cnWriteLog(cc.CnLogErrors, ">>>> RPS node can't find CnRoot instance in unknown extent (" & rpsStorageMode.String & ")", null);
					terminate;
				endif;

			else
				cc.cnWriteLog(cc.CnLogErrors, ">>>> SDS secondary cannot start KCCMgr until KCCMgr has been run on primary.", null);
				cc.cnWriteLog(cc.CnLogErrors, ">>>> Start KCCMgr on SDS primary then close current journal, before restarting this secondary.", null);
				terminate;
			endif;
			
		endif;
		
		if app.cnDatabaseSubrole = SDS_SubroleRelational then
			self.zCnDataPumpIniFileSettings();						// sets up CnDefaultDataPumpApplication and may replace value of DataPumpApplication
		endif;
	endif;
	
	if app.cnDatabaseSubrole <> SDS_SubroleRelational then
		// before we acquire the session lock, we check that we are not in a pending delta database state.
		maxTries := 3;
		while tries < maxTries do
			tries := tries + 1;
			deltaDatabaseStatus := system.getDeltaDatabaseStatus();
			if deltaDatabaseStatus < 3 then  // must be disabled, inactive or active
				break;
			endif;
			
			if deltaDatabaseStatus = 3 then
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " delta database " & system.cnGetDeltaDatabaseStatusString(deltaDatabaseStatus).toLower() & ", waiting....", null);
			
			else
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " delta database " & system.cnGetDeltaDatabaseStatusString(deltaDatabaseStatus).toLower() & ", waiting....", null);
			endif;
			
			process.sleep(3000);
		endwhile;
		
		// we're still pending delta database state change, then restart KCCMgr and terminate current copy
		if deltaDatabaseStatus > 2 then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " still waiting for delta database change to become effective, restarting KCCMgr", null);
			app.startApplication(CN_CARDSCHEMA, CN_KCCMGR);
			app.cnTerminate();
			return;
		endif;
	endif;
	
	if root <> null and not root.isSharedTransient() then
		schemaName := currentSchema.name;
		appName    := process.getProcessApp().name;
		target	:= root.allLockTargets[schemaName, appName];
		if target = null and role = SDS_RoleSecondary then
			cc.cnWriteLog(cc.CnLogErrors, ">>>> Unable to locate CnLockTarget persistent instance for schema=" & schemaName & ", application=" & appName, null);
			cc.cnWriteLog(cc.CnLogErrors, ">>>> SDS secondary cannot start KCCMgr until KCCMgr has been run on primary.", null);
			cc.cnWriteLog(cc.CnLogErrors, ">>>> Start KCCMgr on SDS primary then close current journal, before restarting this secondary.", null);
			terminate;
		endif;

		cc.doLockControlSetup(schemaName, appName, false);		// Passing 'false' to this routine ensures that we are the only copy of KCCMgr running
	endif;

	delete cc;
	
	on Exception do null;

	///////////  Now activate Karma Control //////////

	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	kc := app.myCnKarmaCntrl;
	cc := app.myCnCntrl;
	self.cnCheckLaunchSentinelFile(CN_CREATE_FILE);
	if cc.karmaControl and
	   app.cnDatabaseSubrole = SDS_SubroleRelational then		// RPS node, can't use persistent data
		self.zCnDataPumpIniFileSettings();						// sets up CnDefaultDataPumpApplication and may replace value of DataPumpApplication
	endif;
	
	str	:= null;
	
	if role <> SDS_RoleUndefined then
		sdsDba		:= app.myCnSDSDbAdmin;									// created and set up in CnKarmaCntrl::create
		if sdsDba.sdsEnvironmentId = null then
			str		:= "[AppEnvironment] SDSEnvironmentId not declared in ini file : REQUIRED for SDS system";
		
		elseif sdsDba.sdsEnvironmentId[1:3].toUpper <> kc.environmentId[1:3].toUpper then
			str		:= "[AppEnvironment] SDSEnvironmentId=" & sdsDba.sdsEnvironmentId & " but actual environment id=" & kc.environmentId &
					   " : first three characters (customer id) must match";
		endif;			   
	endif;
	
	if kc.masterEnvironmentId[1:3].toUpper <> kc.environmentId[1:3].toUpper then
		str		:= "[AppEnvironment] MasterEnvironmentId=" & kc.masterEnvironmentId & " but actual environment id=" & kc.environmentId &
				   " : first three characters (customer id) must match";
	endif;
	
	if str <> null then
		cc.cnWriteLog(cc.CnLogErrors, ">>>>> " & str & " : KCCMgr will now terminate.", null);
		app.cnTerminate();
	endif;
	
		// only start KCVerifyJournal other than RPS node and if ini file options stipulate
	if cc.archivalRecoveryEnabled 	and 
	   cc.verifyDatabaseJournals 	and
	   (role <> SDS_RoleSecondary or (role = SDS_RoleSecondary and app.cnDatabaseSubrole <> SDS_SubroleRelational)) then		// verify journals when released
		create self.myCnDba transient;
		self.myCnDba.beginNotification(system, JadeDatabaseAdmin.JournalTransferEvent, 0, Cn_JDB_Managed_Tag);
		cc.cnWriteLog(cc.CnLogComment, "This process has now subscribed to journal transfer events, and will verify journals " &
									   "when they are released. KCVerifyJournal will be started on first journal transfer event.", null);
	endif;
		
	self.beginClassNotification(Process, false, Cn_Message_From_Client, Response_Continuous, null);		// app receives notifications
	
   	
	kc.beginClassNotification(Process, 					false, CN_HEARTBEAT, 					Response_Continuous, null);				// event caused by user app
	kc.beginClassNotification(Process, 					false, CN_REPORT_LOCKEXCEPTION, 		Response_Continuous, null);
   	kc.beginClassNotification(Node, 					false, Cn_Launch_Application_Node, 		Response_Continuous, null);
	// PAR 977. As from 3.8.09 we've moved transaction collection to application KCStatsCollector								// PAR 977
	//			to avoid the overheads of handling this in KCCMgr. However as the transaction									// PAR 977
	//			stats advice can be larger than 48KB (the notification userInfo limit) we have to								// PAR 977
	//			use shared transients to the information from KCStatsCollector to KCCMgr to get the								// PAR 977
	//			information back to JSA and JSM.																				// PAR 977
	kc.beginClassNotification(CnTransactionStatistics, 	true,  CN_SEND_TRANSACTIONSTATISTICS,	Response_Continuous, null);		// PAR 977
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " armed class subscription CN_SEND_TRANSACTIONSTATISTICS on CnTransactionStatistics", null);	// PAR 977
	
	kc.beginNotification(system, CN_WRITE_SERVER_LOG, Response_Continuous, null);
	kc.beginNotification(system, Cn_SOA_UserPatches_Alert, Response_Continuous, null);
   	self.beginNotification(system, Cn_Process_Shutdown_Command, Response_Continuous, null);

	//////  Now open connection to Karma  ///////
	
   	if cc.karmaControl then
		cc.cnWriteLog(cc.CnLogConnect, "KCCMgr opening connection to JSA ...", tcp);
		create tcp;
		tcp.cnSetMyCnCntrl(cc);
		kc.setMyParentTcp(tcp);
		tcp.cnOpen("localhost", APP_TO_JSA_PORT, tcp);							// open connection to Karma on this server
	else
		cc.cnWriteLog(cc.CnLogConnect, "KCCMgr won't attempt to connect to JSA : KarmaControl=false.", null);
	endif;

    ///  Now KCCMgr prods all processes running on the server to submit their Session_Open_Advices ///

	create cem transient;
    if not cem.emIsService and role = SDS_RoleSecondary then
    	cc.cnWriteLog(cc.CnLogErrors, "SDS secondary or RPS node not running as service - won't send SessionOpenAdvice", null);
    	//
    	//  To avoid unravelling cluster info in JSA / JSM, we don't send SessionOpenAdvices when we
    	//  are an SDS secondary not running as a service.
    	//    	
    else
		cc.initializeProcesses();
	endif;
   	
    if node.isServerNode then
		create lockCheck transient;																									// PAR 1003
		lockCheck.startLockCheckIfRequired();																						// PAR 1003
    	if app.isMultiUser then
    		cc.startUserServerApplications(app.getIniFileName(), role, Launch);
    	else
    		cc.cnWriteLog(cc.CnLogComment, "Single user mode : any user defined server apps will NOT be started.", null);
    	endif;
    endif;
	
	if role = SDS_RoleSecondary then
		if system.getDatabaseSubrole = SDS_SubroleNative then
			self.cnReportDeploymentStatus();
		endif;
	endif;
		
	self.zCheckUnbufferedIniSettings();
epilog
	delete lockCheck;																												// PAR 1003
	delete jdba;
	delete cem;
end;
}
cnInitializeKCDatabaseBackup
{
cnInitializeKCDatabaseBackup() updating;

vars
	cc				: CnCntrl;
	backupDir		: String;
	includeSysFiles	: Boolean;
	verifyFiles		: Boolean;
	compressFiles	: Boolean;
	allowOverwrite	: Boolean;
	quiesce			: Boolean;
	droppedFiles	: DbFileArray;
	ff				: FileFolder;
	cnDbAdmin		: CnDatabaseAdmin;
	proc			: Process;

begin
	if not app.isMultiUser then				// not allowed to run as single user							// PAR 544
		create cc transient;																				// PAR 544
		cc.cnWriteLog(cc.CnLogErrors, "This application can only be run in multi-user mode.", null);		// PAR 544
		beginTransaction;																					// PAR 544
		node.userExitCode := 1;																				// PAR 544
		commitTransaction;																					// PAR 544
		delete cc;																							// PAR 544
		terminate;																							// PAR 544
	endif;																									// PAR 544

	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogComment, "Simple database backup application version starting....", null);
	
	if app.cnComputerNameAppServer <> cc.myTransientGlobal.cnGetServerComputerName then
		cc.cnWriteLog(cc.CnLogErrors, "This application can only be run on the same computer as the server.", null);
		beginTransaction;																					// PAR 544
		node.userExitCode := 1;																				// PAR 544
		commitTransaction;																					// PAR 544
		app.cnTerminate();
	endif;

	cc.doLockControlSetup(currentSchema.name, cc.appName, false);		// Passing 'false' to this routine ensures that we are the only copy running

	beginTransaction;
	process.userInfo := cc.appName;
	commitTransaction;

	beginTransientTransaction;
	create cnDbAdmin sharedTransient;

	cnDbAdmin.simpleBackup();							// commitTransientTransaction is in simpleBackup
	//
	//  This thread now sits and processes notifications etc
	//
end;
}
cnInitializeKCDatabaseBackupM
{
cnInitializeKCDatabaseBackupM(pObject : Object) updating;

vars
	strArray			: HugeStringArray;
	
	dba					: CnDatabaseAdmin;

	cc					: CnCntrl;

	backupDirectory,
	dbPath,
	environmentId,
	str,
	backupWorkers		: String;
	
	compressFiles,
	quiesce,
	verifyAllFiles,
	hadError,
	disableBackupNotify	: Boolean;

	exitCode,
	pos,
	role				: Integer;
	
	cnDbAdmin			: CnDatabaseAdmin;
	
	cnBackup			: CnBackup;
begin
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	create app.myCnDba transient;
	dba := app.myCnDba;
	create cnBackup transient;
	self.myCnBackup := cnBackup;
	cc := app.myCnCntrl;

	app.cnSetMyBackupLog(dba.getBackupLog());
	str		:= "----------  Starting Multi Worker Backup on " & app.actualTime.date.String & "  " & app.actualTime.time.String & "  ----------------------";
	cc.cnWriteLog(cc.CnLogComment, str, null);
	app.cnManagerLog(str);
	app.cnManagerLog(" ");
	app.cnManagerLog("CardSchema version is " & app.cnGetCardSchemaVersion());

   	on Exception do cnHandleStartupException(exception);
	role := system.getDatabaseRole();
	
	strArray := pObject.HugeStringArray;
	
	hadError := cnBackup.validateParsedParams(strArray, environmentId, backupDirectory, backupWorkers, compressFiles, quiesce, disableBackupNotify); // validate the parsed backup parameters
	if hadError then
		exitCode := 1;	
		dba.logAndTerminateBackup("The parameters provided to start " & CN_KCDATABASEBACKUPMULTI & " failed validation, please check and resubmit. Backup terminated.");
		return;
	endif;
	dba.setDisableBackupNotify(disableBackupNotify);
	
	cc.doLockControlSetup(currentSchema.name, cc.appName, false); // allow only 1 instance of this application to run
	app.cnManagerLog(CN_KCDATABASEBACKUPMULTI & " application starting..." 	&
					"params parsed : "										&
					CN_ENVIRONMENTID 	& "=" 	& environmentId				& ", "	&
					CN_BACKUPDIRECTORY	& "=" 	& backupDirectory			& ", "	&
					CN_BACKUPWORKERS	& "="	& backupWorkers				& ", "	&
					CN_COMPRESSFILES	& "="	& compressFiles.String		& ", "	&
					CN_QUIESCE			& "="	& quiesce.String			& ", "	&
					"verifyFiles=true");
	
	beginTransientTransaction;
	create cnDbAdmin sharedTransient;
	cnDbAdmin.setEnvironmentId(environmentId);
	cnDbAdmin.setBackupRootDir(backupDirectory);
	cnDbAdmin.setBackupWorkers(backupWorkers.Integer);
	cnDbAdmin.setCompressFiles(compressFiles);
	cnDbAdmin.setQuiesce(quiesce);
	cnDbAdmin.setDisableBackupNotify(disableBackupNotify);
	delete strArray;
	commitTransientTransaction;
	
	cnDbAdmin.nonManagedMultiWorkerBackup(role);
	//
	//  This thread now sits and processes notifications etc
	//
epilog
	if exitCode = 1 and role <> SDS_RoleSecondary then
		beginTransaction;
		node.userExitCode := exitCode;
		commitTransaction;
		app.cnTerminate();
	endif;
	
	if process.isInExceptionState() then
		app.cnTerminate();
	endif;
end;
}
cnInitializeKCDbBackupWorker
{
cnInitializeKCDbBackupWorker(cdb : CnDatabaseAdmin input) updating;

vars
 	
begin
	//  This method used by KCDbBackupWorker (secondary database backup thread),
	//  executed via startApplicationWithParameter 

	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);

	beginTransaction;
	process.userInfo := app.myCnCntrl.appName;
	commitTransaction;

	cdb.backupAllDbFiles();

	app.cnTerminate();
end;
}
cnInitializeKCDummy
{
cnInitializeKCDummy() updating;

vars

begin
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	// set up database role in remote environment's ini file (local ini file)
	// this is to allow JAWS to start up remote environments as appropriate when 'launch=<Primary | Secondary>'
    self.zCnCheckAndUpdateRemoteIniFiles();
	app.cnTerminate();
end;
}
cnInitializeKCLockCheck
{
cnInitializeKCLockCheck() updating;

constants
	Max_Attempts					: Integer		= 5;
vars
	cc								: CnCntrl;
	
	kc								: CnKarmaCntrl;
begin
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	
	cc := app.myCnCntrl;
	kc := app.myCnKarmaCntrl;
	
	// KCLockCheck should only run in the server node
	if not node.isServerNode then
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " application is expected to run in database server node, terminating ....", null);
		app.cnTerminate();
	endif;
	
	// only want one copy running in the server node.
	node.cnCheckDuplNodeApplication(CnKCLockCheck);

	self.myCnLockCheck := self.cnGetSharedTransient(CnLockCheck, Max_Attempts).CnLockCheck;
	if self.myCnLockCheck = null then
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " unable to obtain CnLockCheck shared transient, terminating ....", null);
		app.cnTerminate();
	endif;
	
	self.myCnLockCheck.getIniFileValues(true, false);																			// PAR 1003
    if self.myCnLockCheck.lockCheckInterval = null then
		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " extended lock check interval not specified, terminating ...", null);
		app.cnTerminate();
    endif;
	
	cc.beginClassNotification(Process, false, Object_Delete_Event, Response_Continuous, Cn_Process_Class);
	self.myCnLockCheck.beginNotification(system, 	SDS_RoleChangeEvent, 		Response_Continuous, null);						// PAR 1003					
	self.myCnLockCheck.beginNotification(system, 	SDS_RoleChangeProgress, 	Response_Continuous, null);						// PAR 1003					
	self.myCnLockCheck.beginClassNotification(Process, 	false, CN_LOCK_CHECKS_EVENT_DISABLE, 	Response_Continuous, null);			// both KCCMgr and KCLockCheck arm this so as shared transient
	self.myCnLockCheck.beginClassNotification(Process, 	false, CN_LOCK_CHECKS_EVENT_ENABLE, 	Response_Continuous, null);			// CnLockCheck is maintained by both.
   	self.myCnLockCheck.beginTimer(cnLockCheckInterval, Timer_OneShot, CN_LOCK_CHECK_TIMER);
end;
}
cnInitializeKCNodeControl
{
cnInitializeKCNodeControl() updating;

vars
	cc			: CnCntrl;
	
	nodeControl	: CnNodeControl;
	
	file		: File;
begin
	//  So that we receive notifications issued from KCCMgr as a result of the SessionOpenAdvice that
	//  this process will send when it executes the CnKarmaCntrl constructor, we subscribe to all
	//  notes first.  These subscriptions will have no effect for non-managed apps.
	//
	self.beginNotification(system, Cn_Node_Sampling_Status_Chg, 0, 0);			// broadcast
	self.beginNotification(process, Cn_Node_Sampling_Status_Chg, 0, 0);			// specific
	self.beginNotification(system, Cn_Cache_Stats_Request, 0, 0);
	//
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	cc	:= app.myCnCntrl;
	
	node.cnCheckDuplNodeApplication(CnKCNodeControl);																// 3.5.01 - use shared transient.
/*	// PAR 521. Ensure only single copy of KCNodeControl in case 1253 exception occurs
	if app.cnDatabaseSubrole <> SDS_SubroleRelational then
		cc.doLockControlSetup(currentSchema.name, cc.appName & "_" & app.cnGetInstanceId(node).String, false);		// Passing 'false' to this routine ensures that we are the only copy of KCCMgr running
		//																											// PAR 545 - change from using node name to node instance id as Linux node name uses FQDN host name
	endif;
*/	
	// PAR 445 - moved from app to CnKarmaCntrl to avoid issues where sub-schema's application class
	// implements sysNotification method and doesn't do an inheritMethod
	// Unable to use CnKarmaCntrl as sysNotification has been remimplemented by Joss on CnJossCntrl sub-class
	cc.beginClassNotification(Process, false, Object_Delete_Event, 0, Cn_Process_Class);

	if cc.logLocalCacheStats then						// capturing node stats for non-managed app
		nodeControl	:= cc.myNodeControl;
		if nodeControl.samplingFrequency > 0 then
			nodeControl.beginTimer(nodeControl.samplingFrequency * 1000, Timer_OneShot, 1);
			cc.cnWriteLog(cc.CnLogComment, "Node sampling frequency set to " & nodeControl.samplingFrequency.String & " seconds, timer started.", null);
		else
			cc.cnWriteLog(cc.CnLogComment, "Node sampling frequency is zero : timer not started.", null);
		endif;
			
		create cc.myNodeCacheStatsFile transient;
		file			:= cc.myNodeCacheStatsFile;
		file.fileName	:= cc.logPath & CN_BACK_SLASH & nodeControl.nodeId & "_CacheStats_" & app.actualTimeServer.date.cnUserFormat($CnYYMMDD_ns) & ".csv";
		file.usePresentationFileSystem	:= false;
		file.mode		:= file.Mode_Append;
		
		if not file.isAvailable then
			file.writeLine("Node cache stats for node " & nodeControl.nodeId & " on computer " & app.cnComputerNameAppServer & " for " & app.actualTimeServer.date.String);
			file.writeLine("Timestamp" 	& CN_COMMA &
						   "PC CPUTime" & CN_COMMA &
						   "PC Hits"	& CN_COMMA &
						   "PC Misses"	& CN_COMMA &
						   "PC Creates" & CN_COMMA &
						   "PC Swaps"	& CN_COMMA & 
						   "PC MaxBuff"	& CN_COMMA & 
						   "PC TotBuff" & CN_COMMA &
						   "TC CPUTime" & CN_COMMA &
						   "TC Hits"	& CN_COMMA &
						   "TC Misses"	& CN_COMMA &
						   "TC Creates" & CN_COMMA &
						   "TC Swaps"	& CN_COMMA & 
						   "TC MaxBuff"	& CN_COMMA & 
						   "TC TotBuff");
			file.writeLine(" ");
		endif;
	endif;
	
	cc.cnWriteLog(cc.CnLogComment, "Application initialisation is complete.", null);
end;
}
cnInitializeKCOnLineCompact
{
cnInitializeKCOnLineCompact(cdba : CnDatabaseAdmin io) updating;

vars
	//   Managed On-Line Compaction  //
	
begin
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	
	create self.myCnDba transient;
	app.cnSetMyCompactLog(self.myCnDba.getCompactLog());
	cdba.managedCompact();
end;
}
cnInitializeKCSDSChecks
{
cnInitializeKCSDSChecks();

/*
	Recoded to avoid holding a persistent lock.																					// PAR 1035
*/
vars
	cc								: CnCntrl;
begin
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	
	// KCSDSChecks MUST run in the server node																					// PAR 1035
	if not node.isServerNode then																								// PAR 1035
		cc := app.myCnCntrl;																									// PAR 1035
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " application must run in database server node, terminating ....", null);	// PAR 1035
		app.cnTerminate();																										// PAR 1035
	endif;																														// PAR 1035
	
	// only want one copy running in the server node.																			// PAR 1035
	node.cnCheckDuplNodeApplication(CnKCSDSChecks);																				// PAR 1035
	
////	WARNING: Do not re-instate the following setLockForProcess as this														// PAR 1034
////				causes locking issues for KCSDSChecks when attempting to													// PAR 1034
////				deactivate delta database.																					// PAR 1034
////				Refer to PARs 1034, 1046 and 1065.																			// PAR 1034
////	cc.setLockForProcess(CN_CARDSCHEMA, CN_KCSDSCHECKS, true, true);														// PAR 1034

	// Note : the CnSDSDatabaseAdmin instance has already been created and
	// initialized in the CnKarmaCntrl::create method so no need to create
	// the singleton here.
end;
}
cnInitializeKCStartAppInNode
{
cnInitializeKCStartAppInNode(pObject : Object);
/*
	Expects 3 parameters input
	
	pid=<nnnn>     					- needs to be a valid node PID
	startschema=<schema name>		- must be a valid schema, note that the <schema name> is case-sensitive
	startapp=<application name>		- must be a valid application within named schema, 
									  note that the <application name> is case-sensitive
									  
	exitcodes:
	0 - unexepected early termination
	1 - successful
	2 - error
	3 - timed out
	4 - KCStartInAppNode unhandled exception
	other - JADE execption
*/
vars
	obj			: Object;

	appl		: Application;
	
	schema		: Schema;
	
	schemaColl	: SchemaColl;
	
	xnode		: Node;
	
	objSet		: ObjectSet;

	strArray	: HugeStringArray;
	
	bin			: Binary;
	
	badObj		: Boolean;
	
	exitCode,
	pid,
	pos			: Integer;
	
	key,
	stApplication,
	stSchema,
	str,
	verb		: String;
	
	cc			: CnCntrl;
begin
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	cc := app.myCnCntrl;
	if cc.getProcessForLock(currentSchema.name, CN_KCCMGR, true) = null then
		exitCode := 2;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " KCCMgr application is not running", null);
		return;
	endif;
	
	strArray	:= pObject.HugeStringArray;
	if strArray = null then																										// PAR 963
		exitCode := 2;																											// PAR 963
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " expected some parameter values", null);						// PAR 963
		return;																													// PAR 963
	endif;
	
	if strArray.size() <> 3 then
		exitCode := 2;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " expected 3 parameter values", null);
		return;
	endif;
	
	// get PID
	str := strArray[1];
	pos := 1;
	key := str.scanUntil("=", pos);
	if pos = null or (pos + 1) = str.length() then
		exitCode := 2;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " expected pid string of format 'pid=<nnnn>'", null);
		return;
	endif;
	
	verb := str[pos+1:end];
	if key.toLower() <> "pid" then
		exitCode := 2;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " 'pid' literal not in first parameter", null);
		return;
	endif;

	if not verb.cnIsNumeric() then
		exitCode := 2;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " pid value not numeric '" & verb & "'", null);
		return;
	endif;
	
	pid := verb.Integer;
	
		// get schema
	str := strArray[2];
	pos := 1;
	key := str.scanUntil("=", pos);
	if pos = null or (pos + 1) = str.length() then
		exitCode := 2;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " expected startschema string of format 'startschema=<schema name>'", null);
		return;
	endif;
	
	verb := str[pos+1:end];
	if key.toLower() <> "startschema" then
		exitCode := 2;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " 'startschema' literal not in first parameter", null);
		return;
	endif;

	if verb = null then
		exitCode := 2;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " startschema name expected", null);
		return;
	endif;
	
	stSchema := verb;
	
		// get application
	str := strArray[3];
	pos := 1;
	key := str.scanUntil("=", pos);
	if pos = null or (pos + 1) = str.length() then
		exitCode := 2;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " expected startapp string of format 'startapp=<schema name>'", null);
		return;
	endif;
	
	verb := str[pos+1:end];
	if key.toLower() <> "startapp" then
		exitCode := 2;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " 'startapp' literal not in first parameter", null);
		return;
	endif;

	if verb = null then
		exitCode := 2;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " startapp name expected", null);
		return;
	endif;
	
	stApplication := verb;

	// check schema is valid
	create schemaColl transient;
	rootSchema.allSubschemas(schemaColl);
	foreach obj in schemaColl do
		if obj.Schema.name = stSchema then
			schema := obj.Schema;
			break;
		endif;
	endforeach;
	
	if schema = null then
		exitCode := 2;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " schema '" & stSchema & "' invalid", null);
		return;
	endif;
	
	appl := schema.cnGetApplications[stApplication];
	if appl = null then
		exitCode := 2;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " application '" & stApplication & "' for schema '" & stSchema & "' invalid", null);
		return;
	endif;
	
	create objSet transient;
	Node.instances.copy(objSet);
	
	// arm exception handler as node could disappear and cause UE 4
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, obj, badObj);
	foreach obj in objSet do
		if obj.Node.osID = pid then
			xnode := obj.Node;
			break;
		endif;
	endforeach;
	
	if xnode = null then
		exitCode := 2;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " pid " & pid.String & " not found", null);
		return;
	endif;
	
	beginNotification(xnode, Cn_Launch_Application_Reply, Response_Cancel, null);
	bin	:= (stSchema & CN_COMMA & stApplication).Binary;
	
	xnode.causeEvent(Cn_Launch_Application_Node, true, bin);
	beginTimer(5000, Timer_OneShot, Cn_Launch_Application_Timeout);
epilog
	delete schemaColl;
	delete objSet;
	if exitCode = 2 then
		beginTransaction;
		node.userExitCode := 2;
		commitTransaction;
		app.cnTerminate();
	endif;
	
	if process.isInExceptionState() then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " KCStartInAppNode had unhandled exception, exitcode 4", null);	// PAR 963
		beginTransaction;																										// PAR 963
		node.userExitCode := 4;																									// PAR 963
		commitTransaction;																										// PAR 963
		app.cnTerminate();
	endif;
end;
}
cnInitializeKCStartMonitorBack
{
cnInitializeKCStartMonitorBack();

vars
	csm		: CnStartManager;
	
	result 	: Integer;
begin
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	create csm transient;
	result := csm.startMonitorBackgroundOnServer();
	beginTransaction;
	node.userExitCode := result;
	commitTransaction;
	
	app.cnTerminate();
epilog
	delete csm;
end;
}
cnInitializeKCStatsCollector
{
cnInitializeKCStatsCollector() updating;

vars
	cc								: CnCntrl;
	
	kc								: CnKarmaCntrl;
begin
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	
	// KCStatsCollector MUST run in the server node
	if not node.isServerNode then
		cc := app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " application must run in database server node, terminating ....", null);
		app.cnTerminate();
	endif;
	
	// only want one copy running in the server node.
	node.cnCheckDuplNodeApplication(CnKCStatsCollector);

	// the only purpose for KCStatsCollector is to collect transaction stats and, at specified interval, forward to JSA/JSM.
	kc := app.myCnKarmaCntrl;
	kc.beginClassNotification(Process, false, Cn_Tran_Stats_Submission, Response_Continuous, null);
end;
}
cnInitializeKCValidateMethods
{
cnInitializeKCValidateMethods(initParam : Object);

vars
	cc	: CnCntrl;
	
	vma	: CnValidateMethodAgent;
begin
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	cc := app.myCnCntrl;
	create vma transient;
	vma.parameters := initParam.HugeStringArray;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & "  started timer...", null);
	vma.beginTimer(500, Timer_OneShot, 1);
end;
}
cnInitializeKCVerifyJournal
{
cnInitializeKCVerifyJournal() updating;

vars
	cc		: CnCntrl;
	cdba	: CnDatabaseAdmin;
begin
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	cc	:= app.myCnCntrl;
	
	// KCVerifyJournal MUST run in the server node																				// PAR 1065
	if not node.isServerNode then																								// PAR 1065
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " application must run in database server node, terminating ....", null);	// PAR 1065
		app.cnTerminate();																										// PAR 1065
	endif;																														// PAR 1065
	
	// only want one copy running in the server node.																			// PAR 1065
	node.cnCheckDuplNodeApplication(CnKCVerifyJournal);																			// PAR 1065
	
////	WARNING: Do not re-instate the following setLockForProcess as this														// PAR 1065
////				causes locking issues for KCSDSChecks when attempting to													// PAR 1065
////				deactivate delta database.																					// PAR 1065
///	cc.doLockControlSetup(currentSchema.name, cc.appName, false);																// PAR 1065

	create cdba transient;												// singleton lasts for duration of JADE process
	cdba.beginClassNotification(CnParam, true, Cn_KCCMgr_JournalTransferEvent, 0, Cn_Param_Class);								// PAR 940
	cdba.beginTimer(250, Timer_OneShot, cdba.Verify_Check_Timer);
end;
}
cnInitializeOnLineBackupWorker
{
cnInitializeOnLineBackupWorker(cdba : CnDatabaseAdmin io) updating;

vars
	cc					: CnCntrl;
	
	dba					: CnDatabaseAdmin;
	
	cnDatabaseStructure	: CnDatabaseStructure;
	
	dbFile				: DbFile;
	
	jdba				: JadeDatabaseAdmin;
	
	dbPartition			: JadeDbFilePartition;

	badObject,
	invObject			: Boolean;
	
	ed,
	pid					: Integer;
	
	partitionId			: Integer64;
	
	backupLocation		: String;
begin
	process.sleep(100);				// give KCOnLineBackup a chance to subscribe to notes on Process : PAR 2714
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	cc	:= app.myCnCntrl;
	create dba transient;
	create jdba transient;
	create myCnDba transient;
	app.cnSetMyBackupLog(dba.getBackupLog);
	on Exception do dba.backupExceptionHandler(exception, cdba, dba);
	cdba.armServerExceptionHandler(dba, CN_KCONLINEBACKUPWORKER);
	
	app.cnSetMyBackupLog(cdba.getBackupLog);
	app.cnManagerLog("Worker thread has completed initialisation...");
	
	on SystemException do self.cnHandleInvalidObjectReference(exception, badObject);
	
	while true do
		exclusiveLock(cdba);
		if badObject then
			self.cnManagerLog("Shared CnDatabaseAdmin transient no longer valid .... terminating");
			app.cnTerminate();
		else
			cdba.checkForAbortedBackup();			// will terminate this process immediately
	
			beginTransientTransaction;
			cnDatabaseStructure	:= cdba.allCnDatabaseStructuresForThreading.first();
			if cnDatabaseStructure = null then
				commitTransientTransaction;
				self.cnManagerLog("Worker can't find any more files to back up : will terminate.");
				app.cnTerminate();
			endif;

			dbFile 			:= cnDatabaseStructure.myDbFile;
			backupLocation 	:= cnDatabaseStructure.backupLocation;
			partitionId 	:= cnDatabaseStructure.partitionId;
			if partitionId = null then
				dbPartition := null;
			else
				dbPartition := dbFile.getPartition(partitionId);
			endif;
			
			cdba.allCnDatabaseStructuresForThreading.remove(cnDatabaseStructure);
			commitTransientTransaction;
			
			dba.setMyCurrentDatabaseEntity(dbFile, dbPartition);			// for exception handler
			cdba.backupDbFile(dbFile, dbPartition, jdba, backupLocation);
			cdba.checkForAbortedBackup();								// will terminate this process immediately
		endif;
	endwhile;
	
epilog
	pid	:= cnGetInstanceId(process);
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, cdba, invObject);
	ed := cdba.edition;
	if process.isInExceptionState then
		if invObject then
			self.cnManagerLog(method.cnGetMethodName() & " epilog : " & app.cnGetClassAndOid(cdba) & " shared transient no longer valid.");
		
		else
			if cdba.abortRequested then
				self.cnManagerLog("Database backup abort requested : KCOnLineBackupWorker/" & pid.String & " will now terminate.");
			else
				cdba.causeEvent(jdba.Backup_Failed_Event, true, "Application exception in KCOnLineBackupWorker/" & 
																pid.String & " : " & cdba.failureReason);
			endif;
		endif;
	endif;
	
	if not invObject 				and
	   not cdba.disableBackupNotify then
		cdba.causeEvent(jdba.Backup_Worker_Completed_Event, true, pid);		
	endif;
	
	delete dba;
	delete jdba;
	
	app.cnTerminate();
end;
}
cnInitializeOnLineCmpactWorker
{
cnInitializeOnLineCmpactWorker(cdba : CnDatabaseAdmin io) updating;

vars
	dba					: CnDatabaseAdmin;
	
	jdba				: JadeDatabaseAdmin;
	
	cc					: CnCntrl;
	
	dbFile				: DbFile;
	
	dbPartition			: JadeDbFilePartition;
	
	cnDatabaseStructure	: CnDatabaseStructure;
	
	badObject			: Boolean;
	
	pid					: Integer;
begin
	process.sleep(100);		// give KCOnLineCompact a chance to subscribe to notes on Process : PAR 2714
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	
	cc	:= app.myCnCntrl;
	create dba transient;
	create jdba transient;
	create myCnDba transient;
	app.cnSetMyCompactLog(dba.getCompactLog);
	on Exception do dba.compactExceptionHandler(exception, cdba, dba);
	cdba.armServerExceptionHandler(dba, CN_KCONLINECOMPACTWORKER);
	
	self.cnManagerLog("Worker thread has completed initialisation...");
	
	on SystemException do self.cnHandleInvalidObjectReference(exception, badObject);
	
	while true do
		exclusiveLock(cdba);
		if badObject then
			self.cnManagerLog("Shared CnDatabaseAdmin transient no longer valid... terminating");
			app.cnTerminate();
		else
			cdba.checkForAbortedCompact(); 			// will terminate this process immediately
	
			beginTransientTransaction;
			cnDatabaseStructure	:= cdba.allCnDatabaseStructuresForThreading.first;
			if cnDatabaseStructure <> null then
				cdba.allCnDatabaseStructuresForThreading.remove(cnDatabaseStructure);
				commitTransientTransaction;
				
				dbFile 		:= cnDatabaseStructure.myDbFile;
				dba.setMyCurrentDatabaseEntity(dbFile, null);			// for exception handler
				cdba.compactMapFile(dbFile, jdba);
				
				cdba.checkForAbortedCompact();		// will terminate this process immediately
			else
				commitTransientTransaction;
				self.cnManagerLog("Worker can't find any more files to compact : will terminate.");
				app.cnTerminate();
			endif;
		endif;
	endwhile;
	
epilog
	pid	:= cnGetInstanceId(process);
	
	if process.isInExceptionState then
		if app.isValidObject(cdba) then
			if cdba.abortRequested then
				self.cnManagerLog("Database compaction abort requested : KCOnLineCompactWorker/" & pid.String & " will now terminate.");
			else
				cdba.causeEvent(jdba.Compact_Failed_Event, true, "Application exception in KCOnLineCompactWorker/" & 
																pid.String & " : " & cdba.failureReason);
			endif;
		else
			self.cnManagerLog(method.cnGetMethodName() & " epilog : " & app.cnGetClassAndOid(cdba) & " shared transient no longer valid.");
		endif;
	endif;
	
	if app.isValidObject(cdba) then
		cdba.causeEvent(jdba.Compact_Worker_Completed_Event, true, pid);		
	endif;
	
	delete dba;
	delete jdba;
	
	app.cnTerminate();
end;
}
cnInitializeOnlinePartitionWorker
{
cnInitializeOnlinePartitionWorker(cdba : CnDatabaseAdmin io) updating;

	/* 
		Purpose
		set 'beginPartitionedFileBackup' for all partitioned DbFiles with partitions of file length greater zero.
		The method 'DbFile::beginPartitionedFileBackup' causes the partition control file and index file to be backed up. 
		
		We always back these up to the default backup disk to avoid having all partitions default to other than a specific location.
		For example : if we specified a backup location for the partition control file and
		index files then all partitions by default would be directed to the same backup location.
	*/
	
vars
	msg					: CnBackupAdvice;
	
	cc					: CnCntrl;
	
	dba					: CnDatabaseAdmin;
	
	dbFile				: DbFile;
	
	jdba				: JadeDatabaseAdmin;
	
	dbPartition			: JadeDbFilePartition;

	badObject,
	invObject			: Boolean;
	
	ed,
	pid					: Integer;
begin
	process.sleep(100);				// give KCOnLineBackup a chance to subscribe to notes on Process
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	cc	:= app.myCnCntrl;
	create dba transient;
	create jdba transient;
	create myCnDba transient;
	
	on Exception do dba.backupExceptionHandler(exception, cdba, dba);
	cdba.armServerExceptionHandler(dba, CN_KCONLINEPARTITIONWORKER );
	
	app.cnSetMyBackupLog(cdba.getBackupLog);
	app.cnManagerLog("Partition worker thread has completed initialisation...");
	
	on SystemException do self.cnHandleInvalidObjectReference(exception, badObject);
	msg := dba.createBackupAdviceMessage(CnMessage.Advice_Type_Backup_Progress);
	pid	:= app.cnGetInstanceId(process);
	while true do
		exclusiveLock(cdba);
		if badObject then
			self.cnManagerLog("Shared CnDatabaseAdmin transient no longer valid .... terminating");
			app.cnTerminate();
		else
			cdba.checkForAbortedBackup();			// will terminate this process immediately
	
			beginTransientTransaction;
			dbFile	:= cdba.allPartitionedDbFilesForThreading.first();
			if dbFile = null then
				commitTransientTransaction;
				self.cnManagerLog("Worker can't find any more partitioned files to back up : will terminate.");
				app.cnTerminate();
			endif;
			
			cdba.allPartitionedDbFilesForThreading.remove(dbFile);
			commitTransientTransaction;
			
			dba.setMyCurrentDatabaseEntity(dbFile, null);			// for exception handler
			app.cnManagerLog("begin backup of partition control file and index for " & dbFile.name);
			dbFile.beginPartitionedFileBackup(cdba.backupDir, true, cdba.compressFiles, cdba.overwriteFiles);	// verify checksums always true
			app.cnManagerLog("completed backup of partition control file and index for " & dbFile.name);
			msg.setCurrentFileName(dbFile.name);
			msg.setPercentProgress(0);
			msg.setBackupWorkerId(pid);
			msg.setPhase(Phase_MapFile_Completed);
			msg.sendMessage(null);
			cdba.checkForAbortedBackup();								// will terminate this process immediately
		endif;
	endwhile;
	
epilog
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, cdba, invObject);
	ed := cdba.edition;
	if process.isInExceptionState then
		if invObject then
			self.cnManagerLog(method.cnGetMethodName() & " epilog : " & app.cnGetClassAndOid(cdba) & " shared transient no longer valid.");
		
		else
			if cdba.abortRequested then
				self.cnManagerLog("Database backup abort requested : KCOnLinePartitionWorker/" & pid.String & " will now terminate.");
			else
				cdba.causeEvent(jdba.Backup_Failed_Event, true, "Application exception in KCOnLinePartitionWorker/" & 
																pid.String & " : " & cdba.failureReason);
			endif;
		endif;
	endif;
	
	delete dba;
	delete jdba;
	
	app.cnTerminate();
end;
}
cnInitializeTodaysDate
{
cnInitializeTodaysDate();

vars
	date		: Date;
	
	exitCode	: Integer;
begin
	exitCode := date.year() * 10000 + date.month() * 100 + date.day();
	beginTransaction;
	node.userExitCode := exitCode;
	commitTransaction;
	terminate;
end;
}
cnIntializeKCOnLineBackup
{
cnIntializeKCOnLineBackup(cdba : CnDatabaseAdmin io) updating;

vars
	//   Managed On-Line Backup  //
	
begin
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	create self.myCnDba transient;
	app.cnSetMyBackupLog(myCnDba.getBackupLog);
	cdba.managedBackup();
end;
}
cnIsRPSNode
{
cnIsRPSNode() : Boolean;

vars

begin
	return (system.getDatabaseRole() 	= SDS_RoleSecondary 	and
			system.getDatabaseSubrole() = SDS_SubroleRelational);
end;
}
cnJadeTestCaseDebug
{
cnJadeTestCaseDebug(pMethod 	: Method;
					pLogText	: String);

vars
	hadError : Boolean;
begin
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_AttemptedAccessViaNullRef, null, hadError);
	app.myJadeTestCaseListener.logDebugInfo(pMethod, pLogText, false);
end;
}
cnLocalLockExceptionHandler
{
cnLocalLockExceptionHandler(pExObj 				: LockException; 
							pHadLockException 	: Boolean output;
							pLockedByApp,
							pLockedByInfo,
							pLockedByNodeName,
							pLockedByProcId,
							pLockedByUserCode	: String output) : Integer protected, final;

vars
	errorCode	: Integer;
begin
	errorCode := pExObj.errorCode;
	if errorCode <> Cn_ObjectLocked then
		return Ex_Pass_Back;
	endif;
	
	pHadLockException := true;
	self.zGetLockedByDetails(pExObj,
								pLockedByApp,
								pLockedByInfo,
								pLockedByNodeName,
								pLockedByProcId,
								pLockedByUserCode);
	return Ex_Resume_Next;
end;
}
cnLocalLockExceptionHandler2
{
cnLocalLockExceptionHandler2(pExObj : LockException; 
							pHadLockException : Boolean output) : Integer protected, final;

vars
	errorCode	: Integer;
	cc			: CnCntrl;
begin
	cc := app.myCnCntrl;
	errorCode := pExObj.errorCode;
	if errorCode = 1027 then
		pHadLockException := true;
		return Ex_Resume_Next;
	endif;

	return Ex_Pass_Back;
end;
}
cnManagerLog
{
cnManagerLog(text : String) clientExecution;

vars
 	str : String;
 	ts	: TimeStamp;
 	cc	: CnCntrl;
begin
	cc	:= app.myCnCntrl;
 	str	:= ts.date.userFormat($CnCCYYMMDD) & " " & ts.time.String & "." & ts.time.milliSecond.String.padLeadingZeros(3) & ": " &
 		   cc.appName & "/" & cnGetInstanceId64(process).String & " : " & text;
 		   
	cc.cnWriteLog(cc.CnLogComment, str, null);
 	if app.cnMyBackupLog <> null		then // backup process	
 		app.cnMyBackupLog.info(str);
		return;
	endif;
	
	if app.cnMyCompactLog <> null	then // compact process
		app.cnMyCompactLog.info(str);
		return;
	endif;
	
	cc.cnWriteLog(cc.CnLogComment, str, null);
end;
}
cnMsgBoxClient
{
cnMsgBoxClient(msg : String; title : String; flags : Integer) clientExecution;

vars
	//  Use instead of app.msgBox to display message box on client, from serverExecution methods
begin
	app.msgBox(msg, title, flags);
end;
}
cnOSPlatformIsUnix
{
cnOSPlatformIsUnix() : Boolean;

vars

begin
	//  This method returns true if the FAT client node or server node OS platform is Windows.
	//  Use ::cnClientOSPlatformIsLinux for THIN client OS platform.
	
	if cnOSPlatform = Node.OSUnixLinux 	or
	   cnOSPlatform = Node.OSUnixAIX	then
		return true;
	else
		return false;
	endif;	   	
end;
}
cnOSPlatformIsWindows
{
cnOSPlatformIsWindows() : Boolean;

vars

begin
	//  This method returns true if the FAT client node or server node OS platform is Windows.
	//  Use ::cnClientOSPlatformIsWindows for THIN client OS platform.
	//  
	return (cnOSPlatform = Node.OSWindows 				or
			cnOSPlatform = Node.OSWindowsEnterprise 	or
			cnOSPlatform = Node.OSWindowsHome);
end;
}
cnObjNotFoundExceptionHandler
{
cnObjNotFoundExceptionHandler(exObj : Exception; error : Boolean output) : Integer protected;

vars

begin
	if exObj.errorCode = 4 		or
	   exObj.errorCode = 1046	or				// invalid class number
	   exObj.errorCode = 1072   or
	   exObj.errorCode = 1090 	or
	   exObj.errorCode = 1092	then
	   	error := true;
		return Ex_Resume_Next;
		
	else
		return Ex_Pass_Back;
	endif;
end;
}
cnRaiseAlert
{
cnRaiseAlert (pShortText			: String;				// short description of fault, max length 64
			  pLongText				: String;				// long description or instruction for alert, max length 200
			  pStatus				: Character;			// C=Clear, N=New, R=Repeat
			  pWhenRaised			: TimeStamp;			// you also need to store this in order to clear the alert later

				 //  The following items are optional, i.e. developers can pass 'null' as parameters

			  pAppName				: String;				// application name : optional
			  pClientFQDN			: String;				// fqdn of problem machine
			  pClientIpAddress		: String				// ip address of problem machine
             ) updating;					

vars
	cc		: CnCntrl;
begin
	//  This method allows application developers to raise JOSS alerts. The alert gets sent to
	//  JOSS as a TrapAdvice message using the Cardinal Enterprise, and specific trap number
	//  'Cn_Application_Alert'.

	cc		:= app.myCnCntrl;
	if cc.suppressAlerts then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " alert suppressed : shortText='" & pShortText & "', longText='" & pLongText & "', status=" & pStatus, null);
		return;
	endif;
	
	self.z_RaiseAlertCommon(Cn_Application_Alert, pShortText, pLongText, pAppName, null, pClientFQDN, pClientIpAddress, pStatus, pWhenRaised, null);
end;
}
cnRaiseJossAlert
{
cnRaiseJossAlert(pAlertType         : Integer;      	    // type of alert : must be Cn_Karma_Alert 
				 pShortText			: String;				// short description of fault, max length 64
				 pLongText			: String;				// long description or instruction for alert, max length 200
				 pStatus			: Character;			// C=Clear, N=New, R=Repeat
				 pWhenRaised		: TimeStamp;			// you also need to store this in order to clear the alert later

				 //  The following items are optional, i.e. you can pass 'null' as parameters

				 pAppName			: String;				// application name : optional
				 pEnvironmentName	: String;				// Only KarmaCommsMgr uses this										// JSM PAR 8367
				 pClientFQDN		: String;				// fqdn of problem machine
				 pClientIpAddress	: String;				// ip address of problem machine
				 pTcp				: CnKarmaTcpConnection	// Only Joss/Karma uses this
				   				      input) updating;
				   				      
	//  This is an INTERNAL-USE ONLY method which allows JOSS application developers to raise JOSS alerts. 
	//  The alert gets sent to JOSS as a TrapAdvice message using the Cardinal Enterprise MIB, and specific 
	//  trap number 'Cn_Karma_Alert'.  Subschema (other) application developers please use ::cnRaiseAlert.
vars
	cnApp	: CardSchema;
	
	cc		: CnCntrl;
begin
	cc		:= app.myCnCntrl;
	cnApp	:= self.cnGetCardSchemaApp(false);

	if 	cc.appName.length() < 4 or 
		(cnApp.cnSystemType = CN_SYSTEMTYPE_USER and cc.appName[1:2] <> "KC") then
		self.cnRaiseNormalException(Cn_Edit_Error, method.cnGetMethodName(), "Invalid application called cnRaiseJossAlert.", false);
		return;
	endif;
	
	if pAlertType <> Cn_Karma_Alert then
		self.cnRaiseNormalException(Cn_Edit_Error, method.cnGetMethodName(), "Invalid alert type specified.", false);
		return;
	endif;
	
	self.z_RaiseAlertCommon(pAlertType, pShortText, pLongText, pAppName, pEnvironmentName, pClientFQDN, pClientIpAddress, pStatus, pWhenRaised, pTcp);	// JSM PAR 8367
end;
}
cnRaiseNormalException
{
cnRaiseNormalException(errorcode : Integer; erroritem : String; errortext : String; resumable : Boolean) updating;

vars
	exObj : NormalException;
begin
	create exObj transient;
	exObj.errorCode 		:= errorcode;
	exObj.errorItem			:= erroritem;
	exObj.extendedErrorText	:= errortext;
	exObj.continuable		:= false;
	exObj.resumable			:= resumable;
	raise exObj;
end;
}
cnRemoveDirectory
{
cnRemoveDirectory(dirName : String) : Boolean updating;

vars
	ff 			: FileFolder;
	filenode	: FileNode;
	cc 			: CnCntrl;
    filename	: String;
    oldname		: String;
    pos			: Integer;
    kc			: CnKarmaCntrl;

begin
	//  Removes directory, subdirectories, and contents.  Returns false if there was a problem.
	//  You may, of course, not be interested in the return value, and therefore can ignore it.
	
	cc 	:= app.myCnCntrl;
	kc	:= app.myCnKarmaCntrl;

	on FileException do kc.fileExceptionHandler(exception);
 	create ff transient;
 	ff.fileName := dirName;

 	if ff.isAvailable then
 		foreach filenode in ff.files do
			kc.setFileRetryNo(null);
			kc.setHadFileException(null);
			filename := filenode.cnGetSimpleFileName();

    		if filenode.isKindOf(File) then
    			filenode.File.readOnly := false;
    			filenode.File.purge;
				if kc.hadFileException then
					if cc <> null then
						cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " had exception " & kc.exceptionErrorCode.String &
													" (" & kc.exceptionText & ") on file '" & filenode.fileName & "' : " &
													"file and parent directories not removed.  Use Windows tools to find file user, " &
													"or check file/directory permissions.", null);
					endif;
					
					return false;
				endif;
				
    		else
    			cnRemoveDirectory(dirName & "/" & filename);
    		endif;
    	endforeach;

 		oldname		:= app.cnConvertPathNameToFwdSlashes(ff.fileName);
 		pos			:= oldname.reversePos("/");

 		///  To avoid exceptions when purging the folder (it only needs to be selected in Explorer to cause  	///
 		///  a problem) we rename the file first, then purge it.												///

 		filename := oldname[1 : pos] & "~" & oldname[pos + 1 : end]; 
 		cc.cnWriteLog(cc.CnLogDiag, "Renaming directory " & oldname & " prior to remove .....", null);
 		if not kc.moveFile(oldname, filename) then
 			cc.cnWriteLog(cc.CnLogComment, "Rename of file " & ff.fileName & " failed, file not removed.", null);
 			return false;
 		endif;

 		ff.fileName := filename;
 		ff.purge;
 		cc.cnWriteLog(cc.CnLogComment, "Directory " & dirName & " and subdirectories removed.", null);
 		return true;
 	else
 		cc.cnWriteLog(cc.CnLogComment, "Directory " & dirName & " not removed - not found.", null);
 		return true;
 	endif;

epilog
	delete ff;
end;
}
cnReportDeploymentStatus
{
cnReportDeploymentStatus() protected;

vars
	dba						: CnSDSDatabaseAdmin;
	tracking				: Boolean;
	trackingStoppedReason	: Integer;
	rpsTransitionHaltCode	: Integer;
	cc						: CnCntrl;
	
begin
	// Used for SDS secondaries (native only, not RPS) during deployments.  Called at end of KCCMgr initialize
	// to report deployment status to JSA.
	
	cc			:= self.myCnCntrl;
	dba			:= self.myCnSDSDbAdmin;
	tracking	:= dba.getTracking(trackingStoppedReason, rpsTransitionHaltCode);
	
	if not tracking then
		if trackingStoppedReason = SDS_ReasonEndJadeUpgrade 	or
		   trackingStoppedReason = SDS_ReasonEndUserSchemaLoad 	or
		   trackingStoppedReason = SDS_ReasonDeploymentStart 	or
		   trackingStoppedReason = SDS_ReasonDeploymentEnd 		then
			//
			//  Advise JSA, who will then reply with a resume tracking command.
			//
			dba.sendSDSAdviceMsg(CnMessage.Advice_Type_SDS_Status, tracking, trackingStoppedReason, rpsTransitionHaltCode,
								 "Tracking stopped : reason=" & trackingStoppedReason.String & " (" & 
								 dba.getTrackingStoppedReasonStr(trackingStoppedReason) & ").", false);
		endif;

		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : SDS secondary deployment status check : not tracking, status=" & trackingStoppedReason.String, null);
	else
		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : SDS secondary deployment status check : database is currently tracking.", null);
	endif;
end;
}
cnSdsReadAccessEnabled
{
cnSdsReadAccessEnabled() : Boolean updating;

vars
	dba		: JadeDatabaseAdmin;
	jdo		: JadeDynamicObject;
begin
	create dba transient;
	create jdo transient;
	dba.sdsGetMyServerInfo(jdo);
	return jdo.getPropertyValue("readAccessDisabled").Boolean <> true; 
	
epilog
	delete dba;
	delete jdo;
end;
}
cnSendHeartbeat
{
cnSendHeartbeat();

vars

begin
	//  For use by processes that stay busy for long periods (i.e. they don't go idle and
	//  therefore don't respond to management 'ping' notifications).  If this sort of process
	//  is to be pinged by JSM, then the developer should code in a manner which results in
	//  a call of this method at least every ping interval e.g. every 30 seconds would be a
	//  good interval. Excessive use of this method will flood KCCMgr with notifications !
	
	process.causeEvent(CN_HEARTBEAT, true, null);
end;
}
cnSendSDSTrackingAdviceMsg
{
cnSendSDSTrackingAdviceMsg(	pAdviceType 				: String;
							pTrackingStoppedReason		: Integer;
							pTrackingStoppedSubReason	: Integer;
							pText 						: String); 

vars

begin

end;
}
cnSetCurrentLocaleDefaultCountryCode
{
cnSetCurrentLocaleDefaultCountryCode(pValue : Integer) updating;

vars

begin
	self.cnCurrentLocaleDefaultCountryCode := pValue;
end;
}
cnSetDistributionNode
{
cnSetDistributionNode(pValue : String) updating;

vars

begin
	self.cnDistributionNode := pValue;
end;
}
cnSetDistributionProcess
{
cnSetDistributionProcess(pValue : String) updating;

vars

begin
	self.cnDistributionProcess := pValue;
end;
}
cnSetExceptionHandlerType
{
cnSetExceptionHandlerType(handlerType : Integer) updating;

vars

begin
	if myCnKarmaCntrl <> null then
		cnRaiseNormalException(Cn_General_Error, method.cnGetMethodName(), 
							   "Exception handler type must be set up before CnKarmaCntrl is instantiated.", false);
	endif;
	
	if handlerType < 1 or handlerType > 4 then
		cnRaiseNormalException(Cn_General_Error, method.cnGetMethodName(), 
							   "Exception handler type must be one of Jade, CardSchema, Both or Jade_Debug.", false);
	endif;
	
	cnExceptionHandlerType := handlerType;								   
end;
}
cnSetIsForegroundClient
{
cnSetIsForegroundClient(set : Boolean) updating;

vars

begin
	self.cnIsForegroundClient	:= set;
end;
}
cnSetMyBackupLog
{
cnSetMyBackupLog(log : JadeLog) updating;

vars

begin
	self.cnMyBackupLog := log;
end;
}
cnSetMyCompactLog
{
cnSetMyCompactLog(log : JadeLog) updating;

vars

begin
	self.cnMyCompactLog := log;
end;
}
cnSetOSArchitecture
{
cnSetOSArchitecture(osArch : Integer) updating;

vars

begin
	self.cnOSArchitecture := osArch;
end;
}
cnSetOSPlatform
{
cnSetOSPlatform(osPlatform : Integer) updating;

vars

begin
	self.cnOSPlatform := osPlatform;
end;
}
cnSetOSVersion
{
cnSetOSVersion(version : String) updating;

vars

begin
	self.cnOSVersion := version;
end;
}
cnSetPackageAppProperties
{
cnSetPackageAppProperties(pProcessApp : CardSchema) updating, protected;
/*
	This method is used to propagate the properties from the process application
	into the package application so that values and references can be used by the
	package as though it had instantiated CnKarmaCntrl.
*/
vars
	propNDict	: PropertyNDict;
	
	prop		: Property;
	
//	cc			: CnCntrl;
	
	value		: Any;
	
	propName	: String;
begin
//	cc := pProcessApp.myCnCntrl;
	propNDict := CardSchema.getProperties();
	foreach prop in propNDict do
		propName := prop.name;
		value := pProcessApp.getPropertyValue(propName);
		app.setPropertyValue(propName, value);
//		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " property=" & propName, null);
	endforeach;
end;
}
cnSetProfileStringServer
{
cnSetProfileStringServer(section, key, default : String) serverExecution;

vars
	iniFile	: String;
begin
	iniFile	:= self.getIniFileName();
	app.setProfileString(iniFile, section, key, default);		
end;
}
cnSetServerGlobalExHandlerDone
{
cnSetServerGlobalExHandlerDone(pBool : Boolean) updating;

vars

begin
	self.cnServerGlobalExHandlerDone := pBool;
end;
}
cnSetSystemType
{
cnSetSystemType() updating;

vars
	dbPath,
	type 	: String; 
	
	cc		: CnCntrl;
begin
	cc := app.myCnCntrl;
	type := app.getProfileStringAppServer(app.getIniFileNameAppServer, CN_KARMA, "SystemType", null).toUpper;	// mainly used for dev debug...RWM
	
	if type = null 						or 
	   cc.appName.cnStartsWithJoss() 	or 
	   cc.appName.cnStartsWithKarma() 	then
		dbPath := app.dbPath.toLower();
		if dbPath.cnContains("joss") then
			type := "JSM";
			
		elseif self.cnContainsKarma(dbPath) then
			type := "JSA";
		endif;
	endif;
	
	if type = "JSM" then
		cnSystemType := CN_SYSTEMTYPE_JSM;
	
	elseif type = "JSA" then
		cnSystemType := CN_SYSTEMTYPE_JSA;
	endif;
end;
}
cnSetThinClientOSArchitecture
{
cnSetThinClientOSArchitecture(osArch : Integer) updating;

vars

begin
	self.cnThinClientOSArchitecture := osArch;
end;
}
cnSetThinClientOSPlatform
{
cnSetThinClientOSPlatform(osPlatform : Integer) updating;

vars

begin
	self.cnThinClientOSPlatform := osPlatform;
end;
}
cnSetThinClientOSVersion
{
cnSetThinClientOSVersion(osVersion : String) updating;

vars

begin
	self.cnThinClientOSVersion := osVersion;
end;
}
cnShowExceptionForm
{
cnShowExceptionForm(exObj : Exception) clientExecution, updating;

vars
 	cc 	: CnCntrl;
	
 	frm	: CnExceptionForm;	
begin
   	cc 	:= app.myCnCntrl;
	create frm;
   	frm.myException := exObj;
  	if cc.exceptionDisplayModal then
   		frm.showModal();
		
   	else
   		frm.show();
   	endif;
end;
}
cnShowExceptionFormPlus
{
cnShowExceptionFormPlus(pExObj : Exception; pExceptionStack : String) clientExecution, updating;

vars
 	cc 				: CnCntrl;
	
 	frm				: CnExceptionForm;	
begin
   	cc := app.myCnCntrl;
	create frm;
   	frm.myException := pExObj;
	frm.tbxExceptionStack.text := pExceptionStack;
  	if cc.exceptionDisplayModal then
   		frm.showModal();
		
   	else
   		frm.show();
   	endif;
end;
}
cnShowExceptionWebForm
{
cnShowExceptionWebForm(exObj : Exception) clientExecution;

vars
	webfrm 					: CnWebAppError;
	
	lockObject				: Object;																			// PAR 979
	
	lockedByUserCode		: String;
begin
	create webfrm;									
	webfrm.errorCode 		:= exObj.errorCode;
	webfrm.errorText		:= exObj.text;
	
	if exObj.errorCode = 1242 then
		webfrm.errorText	:= "Method on another node aborted with error " & exObj.remoteErrorCode.String;
	endif;
	webfrm.errorItem		:= exObj.errorItem;

	if exObj.isKindOf(LockException) then
		if exObj.LockException.targetLockedBy.userCode <> null then
			lockedByUserCode	:= exObj.LockException.targetLockedBy.userCode;
			
		else
			lockedByUserCode	:= '<not available>';
		endif;

		webfrm.lockedBy			:= lockedByUserCode;
		lockObject				:= exObj.LockException.lockTarget();											// PAR 979
		webfrm.lockTargetClassAndOid	:= lockObject.class().name & "/" &										// PAR 979
											self.getOidStringForObject(lockObject);								// PAR 979
	endif;	

	webfrm.show;
end;
}
cnShowLockErrorMessage
{
cnShowLockErrorMessage(lockDetails : String; lockingAppDetails : String; methodDetails : String) clientExecution;

vars
	// This method is called from cnGlobalLockExceptionHandler if the JADE application has
	// set boolean cnIsForegroundClient and multiple attempts to acquire a lock fail.
	// You can re-implement this if you don't like the appearance or text.
	//
	//		lockDetails 		: string containing technical info about the lock
	//		lockingAppDetails	: string containing details about the app that has the lock we want
	//		methodDetails		: string containing info about the method that was trying to acquire the lock
begin
	app.msgBox("This application has been unable to secure a required lock.  Please wait a moment then re-submit your transaction." & CrLf & Lf &
			   "Lock details :" & CrLf & Tab & lockDetails & CrLf & Tab & lockingAppDetails & CrLf &			   
			   "Method details : " & CrLf & Tab & methodDetails,
			   "Lock Error in " & app.String, 48);
end;
}
cnShowProgress
{
cnShowProgress(progressDialog : CnProgressDialog input; msg1, msg2, msg3 : String) : Integer clientExecution, updating;

vars
 	// for lock exceptions
begin
 	return progressDialog.showProgress(msg1, msg2, msg3);			// 1= Cancelled
end;
}
cnShowProgressDialog
{
cnShowProgressDialog(lockTarget : String) : CnProgressDialog clientExecution, updating;

vars
	progressDialog : CnProgressDialog;				// for lock exceptions
begin
	create progressDialog transient;
	progressDialog.caption 		:= "Waiting for Lock in " & app.name & "/" & cnGetInstanceId64(process).String;
	progressDialog.lockTarget	:= lockTarget;
	progressDialog.centreWindow();
	progressDialog.show;
	return progressDialog;
end;
}
cnShowProgressUnload
{
cnShowProgressUnload(progressDialog : CnProgressDialog input) clientExecution, updating;

vars
 	// lock exceptions
begin
	progressDialog.unloadForm; 	
end;
}
cnStandardizePathName
{
cnStandardizePathName(pathname : String) : String updating;

vars
 	i 		: Integer;
 	str		: String;
 	len		: Integer;
 	fname	: String;
begin
	///    Changes path names with backslashes to forward slashes   ////

	fname := pathname;

	if fname.length > 1 and fname[1:2] = "\\" then			// retain UNC name
		fname.replaceChar("\", "/");
		fname[1:2]	:= "\\";
	else
		fname.replaceChar("\", "/");
	endif;	

	return fname;
end;
}
cnStartApplicationOnServer
{
cnStartApplicationOnServer(pSchema, pApplication : String) : Process serverExecution;

vars

begin
	return app.startApplication(pSchema, pApplication);
end;
}
cnTcpExceptionHandler
{
cnTcpExceptionHandler(exObj : ConnectionException) : Integer updating;

vars
	cc 					: CnCntrl;
	
	kc					: CnKarmaCntrl;																							// PAR 988
	
	conn	 			: Connection;

	tcp 				: CnTcpConnection;
	
	badObject			: Boolean;
	
	errorCode,
	response,
	restartReturnCode	: Integer;
	
	errorText			: String;																								// PAR 988
begin
	cc 					:= app.myCnCntrl;
	errorCode 			:= exObj.errorCode;
	conn 				:= exObj.connection;
	if errorCode = Cn_Tcp_Header_Error then
		if conn.isKindOf(CnKarmaTcpConnection) then
			kc			:= app.myCnKarmaCntrl;																					// PAR 988
			if app.name = CN_KCCMGR then																						// PAR 988
				errorText	:= "KCCMgr has detected incoming message from JSA with invalid TCP Header. Refer to JSA and " & 	// PAR 988
								kc.environmentId & " cn_logs to identify and rectify.";											// PAR 988
					
			else																												// PAR 988
				errorText	:= "JSM/JSA has detected incoming message with invalid TCP Header. " &								// PAR 988
								"Name=" & conn.CnKarmaTcpConnection.remoteName & " (" &											// PAR 1031
									conn.CnKarmaTcpConnection.remoteIpAddress & ") " &											// PAR 1031
								"Refer to JSA cn_logs to identify JADE environment and rectify.";								// PAR 988
			endif;																												// PAR 988
			
			app.cnRaiseJossAlert(Cn_Karma_Alert,
								"TCP Header Error detected",
								errorText,																						// PAR 988
								"N",
								app.actualTime,
								cc.appName,
								kc.managedEnvironmentName,																		// JSM PAR 8367
								conn.CnKarmaTcpConnection.remoteName,
								conn.CnKarmaTcpConnection.remoteIpAddress,
								kc.myParentTcp);
			kc.setMyParentTcp(null);																							// PAR 988
		endif;

		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " TCP header error detected, deleting connection.", null);
		delete conn;
		return Ex_Abort_Action;
	endif;
	
	// PAR 508 - JadeMultiWorkerTcpTransport will get null connection at times
	if conn = null then																					// PAR 508
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & 											// PAR 508
									" doesn't handle exceptions for null connection object", null);		// PAR 508
		return Ex_Pass_Back;																			// PAR 508
	endif;																								// PAR 508
	
	if not conn.isKindOf(CnTcpConnection) then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " doesn't handle exceptions for class " & conn.class.name, null);
		return Ex_Pass_Back;
	endif;

	if (errorCode < 31000	or errorCode > 31099) 			and											// PAR 508
		not (errorCode >= 10048 and errorCode <= 10061)		then
		return Ex_Pass_Back;													// we discard other ConnectionExceptions
	endif;

    tcp := exObj.connection.CnTcpConnection;
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, tcp, badObject);
	tcp.edition();
 	if badObject then
 		cc.cnWriteLog(cc.CnLogConnect, method.cnGetMethodName() & " got null TCP object reference in exObj" &
 					  " : errorCode=" & errorCode.String , null);
 		return Ex_Abort_Action; 										// throw the exception away
 	endif;

 	if errorCode = 1205 then										// aborted call back method, usually follows a prior exception
 		cc.cnWriteLog(cc.CnLogErrors, "::cnTcpExceptionHandler passing 1205 exception back : last action : " & 
 				      tcp.cnGetLastActionString & ", client host = " & tcp.computerName, null);
 		return Ex_Pass_Back;
 	endif;

	if tcp.isKindOf(CnKarmaTcpConnection) then
		tcp.causeEvent(tcp.CnKarmaTcpConnection.TCP_Disconnected, true, 0);
		tcp.CnKarmaTcpConnection.setManagedEnvironmentName(null);																// PAR 833
	endif;

	cc.cnWriteLog(cc.CnLogErrors, "TCP error on connection #" & tcp.connectionNo.String &
								  " : client host was " & tcp.computerName & 
								  " on port " & tcp.lastPort.String &
								  " error=" & errorCode.String & 
								  " : " & exObj.text &
								  " : last action : " & tcp.cnGetLastActionString(), tcp);
	cc.decrementConnectionCount;
	response := tcp.user_cnTcpExceptionHandler(exObj);							// user exit, for application-specific
    if response <> Ex_Continue then												// handling
    	return response;
    endif; 

	if tcp.cnJossTcpRestart() then												// Joss, Karma and buddies
		return Ex_Abort_Action;													// only if they're Openers
   	endif;

    if response = Ex_Continue then
    	restartReturnCode	:= tcp.user_cnTcpRestart();
    	if restartReturnCode = -1 then											// subschema has not reimplemented the method
	    	tcp.cnBumpRetryNo;
	    	if tcp.connectionType = tcp.Listener and cc.autoReListen then		// we've been connected
	    		tcp.cnListen(tcp.lastPort, tcp.myReceiver);
		
	    	elseif tcp.connectionType = tcp.ContinuousListenerMaster and 										// JSM PAR 3660
				   cc.appName = CN_KARMACOMMSMGR 						 and 										// JSM PAR 3660
				   tcp.lastPort = APP_TO_JSA_PORT 					 then										// JSM PAR 3660
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " listen connection on port " & 				// JSM PAR 3660
											tcp.lastPort.String & " failed, retry in 30 seconds", null);		// JSM PAR 3660
	    		tcp.beginTimer(30000, Timer_OneShot, 100);														// JSM PAR 3660

	    	elseif tcp.connectionType = tcp.Opener then 
	    		if cc.connectionRetryDelay > 0  then
	
	    			if not tcp.cnRetryTimerRunning then
						tcp.beginTimer(cc.connectionRetryDelay * 1000, Timer_OneShot, tcp.Connection_Retry_Timer);
						tcp.cnSetCnRetryTimerRunning(true);
						cc.cnWriteLog(cc.CnLogErrors, "Connection open will be retried in " & cc.connectionRetryDelay.String & " seconds", null);
					else
						cc.cnWriteLog(cc.CnLogErrors, "Connection retry timer already running for connection #" & tcp.connectionNo.String &
													  " : will retry shortly.", null);
					endif;
	
					return Ex_Continue;
	
				elseif cc.autoReOpen then											// we've been connected
	    			tcp.cnOpen(tcp.computerName, tcp.lastPort, tcp.myReceiver);
	    		endif;
	
	    	else
	    		tcp.user_cnIssueErrorMsg(exObj);      		// leaves object disconnected, 
	    		//											// this is another user exit
	    	endif;
	    else
	    	return restartReturnCode;						// this is the value returned from subschema implementation of 							
	    endif;	    										// tcp.user_cnTcpRestart.  Must be valid exception handler return code
   	endif; 

	return Ex_Abort_Action;	
end;
}
cnTerminate
{
cnTerminate() updating;

vars
	sd	: CnStackDump;
	cc	: CnCntrl;
	str	: String;
begin
	//  This method should be used in preference to direct coding of 'terminate' instructions,
	//  because it allows you to determine which method performed the terminate.  For user
	//  systems (e.g. JETed LINC systems, you can re-implement this method in your subschema 
	//  and add your own code to set task values etc, prior to invoking this method via
	//  the inheritMethod instuction.
	
	cc	:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogComment, "Application is now terminating itself.", null);
	
	if cc.logStackDumpOnTerminate then
		cc.cnWriteLog(cc.CnLogComment, "LogStackDumpOnTerminate=true : will mini-dump call stack...", null);
		create sd transient;
		sd.dumpCallStack(true, false);		// log to cn_log, on client machine
		cc.cnWriteLog(cc.CnLogComment, "Call stack has been dumped.", null);
	endif;
	
	if process.isInTransactionState then
		cc.cnWriteLog(cc.CnLogComment, "Aborting current database transaction .....", null);
		abortTransaction;
	endif;
	
	abortTransientTransaction;
	
	cc.cnWriteLog(cc.CnLogComment, "Terminating own process NOW....", null);	
	terminate;
epilog
	delete sd;
end;
}
cnThinClientOSIsWindows
{
cnThinClientOSIsWindows() : Boolean;

vars

begin
	//  This method returns true if the THIN client OS platform is Windows.
	//  Use ::cnOSPlatformIsWindows for fat client or server nodes.
	//  
	return (self.cnThinClientOSPlatform = Node.OSWindowsEnterprise 	or
			self.cnThinClientOSPlatform = Node.OSWindowsHome			or
			self.cnThinClientOSPlatform = Node.OSWindows);
end;
}
cnThinClientOSIsWindowsMobile
{
cnThinClientOSIsWindowsMobile() : Boolean;

vars

begin
	//  This method returns true if the THIN client OS platform is Windows.
	//  Use ::cnOSPlatformIsWindows for fat client or server nodes.
	//  
	return self.cnThinClientOSPlatform = Node.OSWindowsMobile;
end;
}
cnUserCleanUp
{
cnUserCleanUp(exObj : Exception) updating;

vars
	//  This is a placeholder method, and is invoked from CardSchema's exception handlers
	//  when a transaction is aborted.
	//
	//  It is intended to be re-implemented by subschema developers, to perform such
	//  activities as restoring properties to known values.
	//
begin

end;
}
cnUserLockReport
{
cnUserLockReport(pLockMsg : String) protected;
/*
	May be re-implemented if desired.
	This is to allow the user application to log or send information during a lock exception and its retry
*/
vars

begin

end;
}
cnValidateBackupPath
{
cnValidateBackupPath(pBackupDir 	: String;
					 pDatabaseRole 	: Integer) : Boolean updating;

vars
	ff : FileFolder;
begin
	create ff transient;
	ff.fileName := pBackupDir;
	return ff.isAvailable();
epilog
	delete ff;
end;
}
cnWriteServerLog
{
cnWriteServerLog(text : String);

vars
	//  For LOW VOLUME logging into server's CardSchema log (cn_log.log).	
	cc	: CnCntrl;
begin
	cc := app.myCnCntrl;
	system.causeEvent(CN_WRITE_SERVER_LOG, true, "[" & cc.appName & " on " & app.cnComputerName & "]  " & text);
			
	// The above notification is subscribed to by KCCMgr, JossCommsMgr, KarmaCommsMgr
end;
}
dbPath
{
dbPath() : String;

vars
 	////   This method added to cater for VB apps that use CardSchema.  Such VB apps    ////
 	////   set cnDbPath prior to instantiating CnKarmaCntrl.    RWM.					////
 	
	str		: String;
begin
	str := self.cnGetCardSchemaApp(false).cnDbPath;
	if str <> null then
		return str;
	endif;
	
	return inheritMethod().cnStripTrailingSlash();
end;
}
finalize
{
finalize() updating;

vars
	cc 				: CnCntrl;
	kc				: CnKarmaCntrl;
	stack			: CnTransactionStack;
	numApps			: Integer64;				
	processApp		: Application;
	cnApp			: CardSchema;
begin
	cc := app.myCnCntrl;
 	if cc = null then
 		return;								// CnCntrl not instantiated
 	endif;
	
	// PAR 391 - this is to handle normal and package applications
	// PAR 391 - when an application executes a method in a package, 
	// PAR 391 - then more than one application exists in the process stack.
	
	// PAR 457 - We only want to execute this finalize method if are the last application to finalize

	kc := app.myCnKarmaCntrl;
	if kc = null then						// CnKarmaCntrl not instantiated
		return;
	endif;
	
	if not kc.appsActivatedKarma.includes(app) then
		cc.cnWriteLog (cc.CnLogDiag, method.cnGetMethodName() & " " & cc.appName & "/" & app.cnGetInstanceId64(app).String & " did not activate CnKarmaCntrl, bypassing finalize method.", null);
		return;
	endif;
	
	processApp := process.getProcessApp();
	if processApp.isKindOf(CardSchema) then
		cnApp := processApp.CardSchema;
		
	else
		cnApp := app.cnGetCardSchemaApp(false);
	endif;
	
	numApps := kc.appsActivatedKarma.size64();
	if numApps > 1 then
		cc.cnWriteLog (cc.CnLogDiag, method.cnGetMethodName() & " bypass finalize for " & cc.appName & "/" & app.cnGetInstanceId64(app).String & " #" & numApps.String & " as not last application.", null);
		kc.appsActivatedKarma.remove(app);
		return;
	endif;
	
 	cc.cnWriteLog(cc.CnLogComment, "------------------- Starting Application Shut Down  ----------(::finalize)-------------", null);
 	
	stack	:= app.myCnTransactionStack;	
	if cc.logLogicalTransactions and stack <> null and stack.myLog <> null then
		delete stack.myLog;										// close logical tran log, if used
	endif;

 	if cc.checkTransientsOnShutDown then
 		app.cnCheckForTransients();
		
 	else
 		cc.cnWriteLog(cc.CnLogComment, "Check for transients at shut down NOT specified : not done.", null);
 	endif;
 	
 	if kc <> null then
 		endNotificationForSubscriber(kc);
 		kc.handleTranStatsRequestEvent();							// send any tran stats
 	endif;
 	
 	cc.cnWriteLog(cc.CnLogComment, "------------------- Application Shut Down Completed  ----------(finalize)-------------", null);
 	delete cc;
 	self.myCnCntrl := null;
	cnApp.myCnCntrl := null;
 	
 	if kc <> null then					//  Moved here for PAR 221
 		delete kc;
		self.myCnKarmaCntrl := null;
		cnApp.myCnKarmaCntrl := null;
 	endif;
end;
}
isMultiUser
{
isMultiUser() : Boolean;

vars

begin
	if cnForeignApp then 					// VB apps
		return true;
	else
		return inheritMethod;
	endif;
end;
}
setCnAppAlias
{
setCnAppAlias(pAlias : String) updating;
/*
	Purpose :
	
	Used by JSA applications but as from 12Aug08 also by JADE Master Terminal.
	
	Causes the Appication name to be replace with this alias. There is no limit to the
	content of this name except that it must be limited to 100 bytes.
	
	Note: that if this is a Managed JADECare Service then this alias is very likely to be used for
	application monitoring.
	
*/
vars
	cc		: CnCntrl;
	
	kc		: CnKarmaCntrl;
	
	alias	: String;
begin
	alias	:= pAlias[1:100];
	if self.cnAppAlias = alias then
		// no change, so don't need to do anything.
		return;
	endif;
	
	if app.name = alias then
		// alias name matches app.name, so nothing to do
		return;
	endif;
	
	kc := app.myCnKarmaCntrl;
	if kc = null then
		create app.myCnCntrl transient;
	endif;
	
	cc := app.myCnCntrl;
	
	// if app.myCnKarmaCntrl exists then we have executed
	// cnActivateKarmaControl or (for JSM/JSA) instantiated
	// the CnJossCntrl singleton.
	if kc <> null then
		// tell KCCMgr to force a delete of this process and issue SessionCloseAdvice
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " force process delete and send SessionClose", null);
		process.causeEvent(Cn_ForceDeleteOfProcess, true, null);
	endif;
	
	// update the application alias
	self.cnAppAlias := pAlias[1:100];
	
	if kc <> null then
		// tell KCCMgr to create a new Jade Process entity before SessionOpen is issued.
		process.causeEvent(Cn_ForceCreateOfProcess, true, null);
		
		// and now issue a new SessionOpenAdvice using the new alias
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " issue SessionOpenAdvice", null);
		kc.issueSessionOpenAdvice();
	endif;
end;
}
setCnAppServerIsOnServer
{
setCnAppServerIsOnServer(set : Boolean) updating;

vars

begin
 	self.cnAppServerIsOnServer := set;
end;
}
setCnApplicationRootDir
{
setCnApplicationRootDir(dir : String) updating;

vars

begin
	self.cnApplicationRootDir := dir;
end;
}
setCnApplicationType
{
setCnApplicationType(pType : Character) updating;

vars

begin
	self.cnApplicationType := pType;
end;
}
setCnDbPath
{
setCnDbPath(dbPath : String) updating;

vars

begin
   	self.cnDbPath := dbPath;
end;
}
setCnForeignApp
{
setCnForeignApp(set : Boolean) updating;

vars

begin
 	self.cnForeignApp := set;
end;
}
setCnIsServerApp
{
setCnIsServerApp(set : Boolean) updating;

vars

begin
	self.cnIsServerApp := set;
end;
}
setCnStackDumpFileName
{
setCnStackDumpFileName(pStackDumpFileName : String) updating;

vars

begin
	self.cnStackDumpFileName := pStackDumpFileName;
end;
}
setMyCnClusterInfo
{
setMyCnClusterInfo(ci : CnClusterInfo) updating;

vars

begin
	self.myCnClusterInfo := ci;
end;
}
setMyCnLog
{
setMyCnLog(log : JadeLog) updating;

vars

begin
	self.myCnLog := log;
end;
}
setMyCnRoot
{
setMyCnRoot(root : CnRoot) updating;

vars

begin
	self.myCnRoot := root;
end;
}
setMyCnSDSDbAdmin
{
setMyCnSDSDbAdmin(dba : CnSDSDatabaseAdmin) updating;

vars

begin
	self.myCnSDSDbAdmin	:= dba;
end;
}
setMyCnTransactionStack
{
setMyCnTransactionStack(stack : CnTransactionStack) updating;

vars

begin
  	self.myCnTransactionStack := stack;
end;
}
setMyDba
{
setMyDba(dba : JadeDatabaseAdmin) updating;

vars

begin
 	self.myDba := dba;
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;

vars
	cc					: CnCntrl;
begin
	cc := app.myCnCntrl;
	
	if eventTag = Cn_Launch_Application_Timeout then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " Launch application request timedout", null);
		beginTransaction;
		node.userExitCode := 3;
		commitTransaction;

		app.cnTerminate();
	endif;
end;
}
userNotification
{
userNotification(eventType: Integer; theObject: Object; userTag: Integer; userInfo: Any) updating;

vars
	cc 		: CnCntrl;
	
	kc 		: CnKarmaCntrl;
	
	tcp		: CnKarmaTcpConnection;

	msg 	: CnMessage;
	
	cache,
	proc	: Boolean;
	
	msgLen	: Integer;
	
	str		: String;
begin
	cc := app.myCnCntrl;
	kc := app.myCnKarmaCntrl;

	if eventType = Cn_Message_From_Client then
		msgLen	:= userInfo.Binary.length();
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " eventType=Cn_Message_From_Client, userInfo length=" & msgLen.userNumberFormat($CnWholeNumbers) & ", userInfo=" & userInfo.Binary.cnAnsiToString(msgLen), null);
		create msg;
		msg.receiveMsg(userInfo.Binary, theObject.Process, eventType);
		return;
	endif;
		
	if eventType = Cn_Node_Sampling_Status_Chg then					// 55000206
		proc	:= userInfo.Binary[1].Character.Boolean;
		cache	:= userInfo.Binary[2].Character.Boolean;
		beginTransientTransaction;
		cc.myNodeControl.doSamplingStatusChange(proc, cache);
		commitTransientTransaction;
		return;
	endif;
		
	if eventType = Cn_Cache_Stats_Request then						// 55000208
		beginTransientTransaction;
		cc.myNodeControl.doCacheStatsRequest();
		commitTransientTransaction;
		return;
	endif;
		
	if eventType = Cn_Process_Shutdown_Command then
		cc.cnWriteLog(cc.CnLogComment, "Shutdown_Command event received, do shutdown checks...", null);
		if self.zCnPreShutDownChecks() then
			cc.cnWriteLog(cc.CnLogComment, "Shutdown_Command event received, shutdown checks OK : terminating.", null);
			app.cnTerminate();
		endif;
		
		cc.cnWriteLog(cc.CnLogComment, "Shutdown checks returned false, continuing....", null);
		return;
	endif;
	
	if eventType = Cn_Launch_Application_Reply then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " start application response '" & userInfo.String & "'", null); 
		beginTransaction;
		if userInfo.String = CN_OK then
			node.userExitCode := 1;
		
		else
			node.userExitCode := 2;
		endif;
		commitTransaction;

		app.cnTerminate();
	endif;
epilog
	delete msg;
end;
}
zCheckLockTargets
{
zCheckLockTargets() protected;
/*
	This should only execute where database role is other than SDS Secondary.
	
	Check that required CnLockTarget entries exist on SDS Primary as we don't want logic to try
	to create these on the secondary.
*/
vars
	root					: CnRoot;
	
	glob					: GCardSchema;

	lt						: CnLockTarget;
	
	commsMgr1,
	commsMgr2,
	schemaName				: String;
	
	createCommsMgr,
	createCommsMgrStarter,
	createKCVerifyJournal	: Boolean;
begin
	schemaName := currentSchema.name;
	commsMgr1   := app.name;
	commsMgr2   := app.name & " Starter";

	root := CnRoot.firstInstance;
	if root = null then
		glob	:= GCardSchema.firstInstance;			// in a mapped extent, this persistent object won't be available
		exclusiveLock(glob);							// single thread thru this next bit - only want one root object
		root	:= CnRoot.firstInstance;
		if root = null then
			beginTransaction;
			create root;
			app.setMyCnRoot(root);
			create lt persistent;
			lt.loadSelf(schemaName, commsMgr1);
		
			create lt persistent;
			lt.loadSelf(schemaName, commsMgr2);

			create lt persistent;
			lt.loadSelf(schemaName, CN_KCVERIFYJOURNAL);
			commitTransaction;
		endif;

		unlock(glob);
		return;
	endif;
	
	app.setMyCnRoot(root);
	lt := root.allLockTargets[schemaName, commsMgr1];
	createCommsMgr := (lt = null);
	
	lt := root.allLockTargets[schemaName, commsMgr2];
	createCommsMgrStarter := (lt = null);

	lt := root.allLockTargets[schemaName, CN_KCVERIFYJOURNAL];
	createKCVerifyJournal := (lt = null);
	
	if createCommsMgr or
	   createCommsMgrStarter or
	   createKCVerifyJournal then
		beginTransaction;
		if createCommsMgr then
			create lt persistent;
			lt.loadSelf(schemaName, commsMgr1);
		endif;
		
		if createCommsMgrStarter then
			create lt persistent;
			lt.loadSelf(schemaName, commsMgr2);
		endif;

		if createKCVerifyJournal then
			create lt persistent;
			lt.loadSelf(schemaName, CN_KCVERIFYJOURNAL);
		endif;
		commitTransaction;
	endif;
end;
}
zCheckUnbufferedIniSettings
{
zCheckUnbufferedIniSettings() protected;
/*
	ini file settings to allow unbuffered standard output from defined JADE utilities.
	
	refer to PAR 35026 - closure details below:

		There is a new set of undocumented INI file key values defined, that enable unbuffered output in some Jade console/batch applications.
	
		[JadeEnvironment]
		XYZZYStdoutUnbuffered=true
		XYZZYStderrUnbuffered=true
		
		Where XYZZY can be one of jadclient, jadloadb, jadregb, jdbutilb, jddlutlb
		
		i.e.
		[JadeEnvironment]
		jdbutilbStdoutUnbuffered=true
		
		The INI file values are not automatically created and default to false	
*/

constants
	STDOUT_UNBUFFERED		: String 	= "StdoutUnbuffered";
	STDERR_UNBUFFERED		: String 	= "StderrUnbuffered";
vars
	iniFileName,
	utility					: String;
	
begin
	iniFileName := app.getIniFileName();
	if app.getProfileString(iniFileName, CN_JADEENVIRONMENT, "jdbutilb" & STDOUT_UNBUFFERED, false.String).Boolean then
		return;
	endif;

	// jdbutilb
	utility := "jdbutilb";
	app.setProfileString(iniFileName, CN_JADEENVIRONMENT, utility & STDOUT_UNBUFFERED, true.String);
	app.setProfileString(iniFileName, CN_JADEENVIRONMENT, utility & STDERR_UNBUFFERED, true.String);
	
	// jadloadb
	utility := "jadloadb";
	app.setProfileString(iniFileName, CN_JADEENVIRONMENT, utility & STDOUT_UNBUFFERED, true.String);
	app.setProfileString(iniFileName, CN_JADEENVIRONMENT, utility & STDERR_UNBUFFERED, true.String);

	// jadclient
	utility := "jadclient";
	app.setProfileString(iniFileName, CN_JADEENVIRONMENT, utility & STDOUT_UNBUFFERED, true.String);
	app.setProfileString(iniFileName, CN_JADEENVIRONMENT, utility & STDERR_UNBUFFERED, true.String);

	// jadregb
	utility := "jadregbb";
	app.setProfileString(iniFileName, CN_JADEENVIRONMENT, utility & STDOUT_UNBUFFERED, true.String);
	app.setProfileString(iniFileName, CN_JADEENVIRONMENT, utility & STDERR_UNBUFFERED, true.String);

	// jddlutlb
	utility := "jddlutlb";
	app.setProfileString(iniFileName, CN_JADEENVIRONMENT, utility & STDOUT_UNBUFFERED, true.String);
	app.setProfileString(iniFileName, CN_JADEENVIRONMENT, utility & STDERR_UNBUFFERED, true.String);
end;
}
zCnCheckAndUpdateRemoteIniFiles
{
zCnCheckAndUpdateRemoteIniFiles() protected;
/*
	This method updates the remote's ini file(s) with:
	- current database role - used by JAWS when launch attr is database role dependent
	- node distribution - to ensure that jadeadmin uses the correct distribution when updating this remote
*/
constants
    PrimaryRole		: String    = "PrimaryRole";
    SecondaryRole   : String    = "SecondaryRole";

vars
	cc					: CnCntrl;
	
	ff 					: FileFolder;
	
	fn 					: FileNode;
	
	success				: Boolean;
	
	databaseRole,
	pos					: Integer;
	
	databaseRoleStr,
	databaseRoleStrLower,
	dir,
	envId,
	hostName,
	hostNameServer,
	iniAutoUpdateDistribution,
	iniDatabaseRole,
	iniFileName,
	iniFileNameServer	: String;
begin
	cc := app.myCnCntrl;
	// don't do anything if the applications is
	// running in the server node
    if self.cnIsServerApp then
		return;
	endif;
	
	// don't do anymore if :
	// - the node is using the same ini file volume as the database and
	// - the server host is the same name as the application host.
	// This means that the node is running from the same root directory
	// as the database.
	iniFileName := app.getIniFileName().toLower();
	iniFileNameServer := app.cnGetServerIniFileName().toLower();
	hostName := app.cnComputerName().toLower();
	hostNameServer := global.cnGetServerComputerName().toLower();
	if hostName = hostNameServer and
	   iniFileName[1] = iniFileNameServer[1] then
		return;
	endif;

	pos := iniFileName.reversePos(CN_SLASH);
	envId := app.myCnKarmaCntrl.environmentId;
	dir := iniFileName[1:pos-1];
	create ff transient;
	ff.fileName := dir;
	ff.mask := envId & "*.ini";
	// ensure that remote ini files has correct current database role
	// for JAWS to use to decide what to launch where the launch attribute
	// is database role dependent.
	databaseRole := system.getDatabaseRole();
	if databaseRole = SDS_RolePrimary 	or
	   databaseRole = SDS_RoleSecondary then
			// update <env>.ini
			// As the ini file for KCDummy is kcdummy.ini (which is copied from <env>.ini), we need to
			// look for all <env>*.ini files
		if databaseRole = SDS_RolePrimary then
			databaseRoleStr := PrimaryRole;
			
		else
			databaseRoleStr := SecondaryRole;
		endif;
		
		databaseRoleStrLower := databaseRoleStr.toLower();
		foreach fn in ff.files do
			iniFileName := fn.fileName;
			iniDatabaseRole := app.getProfileString(iniFileName, CN_SYNCDBSERVICE, CN_DATABASEROLE, null);
//				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file " & iniFileName & " [" & CN_SYNCDBSERVICE & "] " & CN_DATABASEROLE & " " & iniDatabaseRole, null);
			if databaseRoleStrLower <> iniDatabaseRole.toLower() then
				success := app.setProfileString(iniFileName, CN_SYNCDBSERVICE, CN_DATABASEROLE, databaseRoleStr);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " updated ini file " & iniFileName & " [" & CN_SYNCDBSERVICE & "] " & CN_DATABASEROLE & " " & databaseRoleStr & 
																	" on '" & hostName & "', database hostname '" & hostNameServer & "' : success=" & success.String, null);
			
			else
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " no change to ini file " & iniFileName & 
																	", databaseRole already set to " & databaseRoleStr & 
																	" hostName='" & hostName & 
																	"', hostNameServer='" & hostNameServer, null);
			endif;
		endforeach;
	endif;
	
	// now ensure ini file(s) contain the correct [JadeAutoUpdate] Distrubution
	// to avoid jadeadmin copying incorrect files
	foreach fn in ff.files do
		iniFileName := fn.fileName;
		iniAutoUpdateDistribution := app.getProfileString(iniFileName, CN_JADEAUTOUPDATE, CN_DISTRIBUTION, null);
		if iniAutoUpdateDistribution <> self.cnDistributionNode then
			success := app.setProfileString(iniFileName, CN_JADEAUTOUPDATE, CN_DISTRIBUTION, self.cnDistributionNode);
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " updated ini file " & iniFileName & " [" & CN_JADEAUTOUPDATE & "] " & CN_DISTRIBUTION & " " & self.cnDistributionNode & 
																" on '" & hostName & "', database hostname '" & hostNameServer & "' : success=" & success.String, null);
		
		else
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " no change to ini file " & iniFileName & 
																", [" & CN_JADEAUTOUPDATE & "] " & CN_DISTRIBUTION & " already set to " & self.cnDistributionNode & 
																" hostName='" & hostName & 
																"', hostNameServer='" & hostNameServer, null);
		endif;
	endforeach;
epilog
	delete ff;
end;
}
zCnDataPumpIniFileSettings
{
zCnDataPumpIniFileSettings() protected;
/*
	This logic does the following:
	- sets up the CnDefaultDataPumpApplication if required
	- ensures that the correct datapump application is defined in case the deployment failed and it wasn't reset.

	if [JadeRps] CnDefaultDataPump hasn't been defined yet and [JadeRps} DataPumpApplication exists then
	save DataPumpApplication details as CnDefaultDataPumpApplication
	
	When JADECare deployment occurs, the user datapump is changed to use the RootSchema,JadeRpsDataPump between the 
	'start of deployment' tracking halt (100) and the 'end of JADE upgrade' tracking halt (101) to ensure that
	the JADE reorg stuff is correctly handled as otherwise user-defined logic could be marked in error or requiring
	recompilation if the default or user-defined datapump is executed which could fail with an exception and 
	cause unexpected tracking halt during RPS deployment.
*/
constants
	RootSchema_DataPump	: String	= "RootSchema,JadeRpsDataPump";
vars
	dataPumpStringMatch	: Boolean;
	commandLineName,
	dataPumpString,
	defaultDataPump,

	iniFileName			: String;
	
	cc					: CnCntrl;
begin
	cc := app.myCnCntrl;
	iniFileName := app.getIniFileName();
	commandLineName := node.cnGetNameFromCommandLine();
	
	// first check named section
	if commandLineName <> null then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " commandLineName =" & commandLineName, null);
		dataPumpString := app.getProfileString(iniFileName, commandLineName & "." & CN_JADERPS, CN_DATAPUMPAPPLICATION, null);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file value [" &
															commandLineName & "." & CN_JADERPS &
															"] " & CN_DATAPUMPAPPLICATION & 
															"=" & dataPumpString, null);
		if dataPumpString <> null then
			if dataPumpString <> RootSchema_DataPump then
				// now check if default datapump has already been named
				defaultDataPump := app.getProfileString(iniFileName, commandLineName & "." & CN_JADERPS, CN_DEFAULTDATAPUMPAPPLICATION, null);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file value [" &
																	commandLineName & "." & CN_JADERPS &
																	"] " & CN_DEFAULTDATAPUMPAPPLICATION & 
																	"=" & defaultDataPump, null);
				if defaultDataPump = null then
					// not defined so save original data pump application as JADECare default in named section
					app.setProfileString(iniFileName, commandLineName & "." & CN_JADERPS, CN_DEFAULTDATAPUMPAPPLICATION, dataPumpString);
					cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file update: defined [" &
																		commandLineName & "." & CN_JADERPS &
																		"] " & CN_DEFAULTDATAPUMPAPPLICATION & 
																		"=" & dataPumpString, null);
					dataPumpStringMatch := true;
				else
					cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " defaultDataPump found in named section, no update required", null);
				endif;
			
			else
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " dataPumpString found in named section but matches RootSchema datapump", null);
			endif;
		
		else
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " dataPumpString in named section is null", null);
		endif;
	endif;

	// if we haven't found an entry in the named section then check if defined in un-named section
	if dataPumpString = null then
		dataPumpString := app.getProfileString(iniFileName, CN_JADERPS, CN_DATAPUMPAPPLICATION, null);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file value [" &
															CN_JADERPS &
															"] " & CN_DATAPUMPAPPLICATION & 
															"=" & dataPumpString, null);
		if dataPumpString <> null then
			if dataPumpString <> RootSchema_DataPump then
				// now check if default datapump has already been named
				defaultDataPump := app.getProfileString(iniFileName, CN_JADERPS, CN_DEFAULTDATAPUMPAPPLICATION, null);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file value [" &
																	CN_JADERPS &
																	"] " & CN_DEFAULTDATAPUMPAPPLICATION & 
																	"=" & defaultDataPump, null);
				if defaultDataPump = null then
					// not defined so save original data pump application as JADECare default in un-named section
					app.setProfileString(iniFileName, CN_JADERPS, CN_DEFAULTDATAPUMPAPPLICATION, dataPumpString);
					cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file update: defined [" &
																		CN_JADERPS &
																		"] " & CN_DEFAULTDATAPUMPAPPLICATION & 
																		"=" & dataPumpString, null);
					dataPumpStringMatch := true;
				
				else
					cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " defaultDataPump found in un-named section, no update required", null);
				endif;
			
			else
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " dataPumpString found in un-named section but matches RootSchema datapump", null);
			endif;
		
		else
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " dataPumpString in un-named section is null", null);
		endif;
	endif;
	
	// check if the default datapump application was defined above, and if it was, exit now
	if dataPumpStringMatch then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & CN_DATAPUMPAPPLICATION &
															" and " & CN_DEFAULTDATAPUMPAPPLICATION &
															" match, exiting method...", null);
		return;
	endif;

	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " >>>> completed checks for presence of DataPumpApplication and CnDefaultDataPumpApplication <<<<", null);
	// at this point we know that we haven't had to set up the default data pump application.
	// check named and un-named section for default data pump string value
	if commandLineName <> null then
		defaultDataPump := app.getProfileString(iniFileName, commandLineName & "." & CN_JADERPS, CN_DEFAULTDATAPUMPAPPLICATION, null);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file value [" &
															commandLineName & "." & CN_JADERPS &
															"] " & CN_DEFAULTDATAPUMPAPPLICATION & 
															"=" & defaultDataPump, null);
		dataPumpString := app.getProfileString(iniFileName, commandLineName & "." & CN_JADERPS, CN_DATAPUMPAPPLICATION, null);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file value [" &
															commandLineName & "." & CN_JADERPS &
															"] " & CN_DATAPUMPAPPLICATION & 
															"=" & dataPumpString, null);
		if defaultDataPump = null then
			if dataPumpString = RootSchema_DataPump then
				// we can just remove this entry.
				app.setProfileString(iniFileName, commandLineName & "." & CN_JADERPS, CN_DATAPUMPAPPLICATION, ProfileRemoveKey);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file update: deleted key [" &
													commandLineName & "." & CN_JADERPS &
													"] " & CN_DATAPUMPAPPLICATION & 
													", value was " & dataPumpString, null);
			else
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " named section : defaultDataPump is null, dataPumpString is null or not equal RootSchema", null);
			endif;
		
		elseif dataPumpString = null then
			// so we've got the default datapump value but there is no actual datapump declaration in this named section
			// which means the datapump declaration has been deleted by user. So we need to delete the default setting.
			app.setProfileString(iniFileName, commandLineName & "." & CN_JADERPS, CN_DEFAULTDATAPUMPAPPLICATION, ProfileRemoveKey);
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file update: deleted key [" &
												commandLineName & "." & CN_JADERPS &
												"] " & CN_DEFAULTDATAPUMPAPPLICATION & 
												", value was " & defaultDataPump, null);
			
			// we deliberately fall down to continue to check un-named section
		
		elseif defaultDataPump <> dataPumpString then
			if dataPumpString = RootSchema_DataPump then
				// so we've got a default data pump application and the data pump application definition is the same as RootSchema datapump application
				// then replace it
				app.setProfileString(iniFileName, commandLineName & "." & CN_JADERPS, CN_DATAPUMPAPPLICATION, defaultDataPump);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file update: modified [" &
																	commandLineName & "." & CN_JADERPS &
																	"] " & CN_DATAPUMPAPPLICATION & 
																	", value was " & dataPumpString &
																	", value now " & defaultDataPump, null);
				return;
			endif;

			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " no ini file change but values differ: [" &
																	commandLineName & "." & CN_JADERPS &
																	"] " & CN_DATAPUMPAPPLICATION & 
																	"=" & dataPumpString &
																	", [" &
																	commandLineName & "." & CN_JADERPS &
																	"] " & CN_DEFAULTDATAPUMPAPPLICATION & 
																	"=" & defaultDataPump, null);
		
		else
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " named section : dataPumpApplication and defaultDataPump not null and match", null);
		endif;
	endif;

	// now do same checks for un-named section
	defaultDataPump := app.getProfileString(iniFileName, CN_JADERPS, CN_DEFAULTDATAPUMPAPPLICATION, null);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file value [" &
														CN_JADERPS &
														"] " & CN_DEFAULTDATAPUMPAPPLICATION & 
														"=" & defaultDataPump, null);
	dataPumpString := app.getProfileString(iniFileName, CN_JADERPS, CN_DATAPUMPAPPLICATION, null);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file value [" &
														CN_JADERPS &
														"] " & CN_DATAPUMPAPPLICATION & 
														"=" & dataPumpString, null);
	if defaultDataPump = null then
		if dataPumpString = RootSchema_DataPump then
			// we can just remove this entry.
			app.setProfileString(iniFileName, CN_JADERPS, CN_DATAPUMPAPPLICATION, ProfileRemoveKey);
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file update: deleted key [" &
												CN_JADERPS &
												"] " & CN_DATAPUMPAPPLICATION & 
												", value was " & dataPumpString, null);
		else
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " un-named section : defaultDataPump is null, dataPumpString is null or not equal RootSchema", null);
		endif;
	
	elseif dataPumpString = null then
		// so we've got the default datapump value but there is no actual datapump declaration in this named section
		// which means the datapump declaration has been deleted by user. So we need to delete the default setting.
		app.setProfileString(iniFileName, CN_JADERPS, CN_DEFAULTDATAPUMPAPPLICATION, ProfileRemoveKey);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file update: deleted key [" &
											CN_JADERPS &
											"] " & CN_DEFAULTDATAPUMPAPPLICATION & 
											", value was " & defaultDataPump, null);
		
		// now continue to check un-named section
	
	elseif defaultDataPump <> dataPumpString then
		if dataPumpString = RootSchema_DataPump then
			// so we've got a default data pump application and the data pump application definition is the same as RootSchema datapump application
			// then replace it
			app.setProfileString(iniFileName, CN_JADERPS, CN_DATAPUMPAPPLICATION, defaultDataPump);
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ini file update: modified [" &
																CN_JADERPS &
																"] " & CN_DATAPUMPAPPLICATION & 
																", value was " & dataPumpString &
																", value now " & defaultDataPump, null);
			return;
		endif;
		
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " no ini file change but values differ: [" &
																CN_JADERPS &
																"] " & CN_DATAPUMPAPPLICATION & 
																"=" & dataPumpString &
																", [" &
																CN_JADERPS &
																"] " & CN_DEFAULTDATAPUMPAPPLICATION & 
																"=" & defaultDataPump, null);

	else
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " un-named section : dataPumpApplication and defaultDataPump not null and match", null);
	endif;
end;
}
zCnPreShutDownChecks
{
zCnPreShutDownChecks() : Boolean protected;
/*
	Allows applications to code specific pre-shutdown logic, if required.
	
	Returns true if OK to proceed to terminate.
	
	If false is returned, then it is up to the application to ensure that termination does eventually occur.
*/
vars

begin
	return true;
end;
}
zCnThinClientConnBalancing
{
zCnThinClientConnBalancing() protected;
/*
	JADE's thin-client connection balancing introduced in JADE 6.2.15
*/
constants
	Max_Attempts	: Integer	= 10;
vars
	cc				: CnCntrl;

	obj				: Object;
	
	hadError		: Boolean;
	
	appServerGroup,
	iniFile,
	jadeVer			: String;
begin
	cc := app.myCnCntrl;
	obj := self.cnGetSharedTransient(CnThinClientConnBalancing, Max_Attempts);
	if obj = null then
		cc.cnWriteLog(cc.CnLogComment, "Application server thin-client connection balancing is already registered for this node (" & self.getOidStringForObject(node) & ").", null);
		return;
	endif;
	
	jadeVer := app.getSystemVersion();
	if jadeVer.cnMarkReleaseCut() < 6215 then
		cc.cnWriteLog(cc.CnLogComment, "Application server thin-client connection balancing is not available for this JADE release " & jadeVer & ".", null);
		return;
	endif;
	
	iniFile := app.getIniFileNameAppServer();
	appServerGroup := app.getProfileStringAppServer(iniFile, CN_JADEAPPSERVER, CN_APPSERVERGROUPNAME, null);
	if appServerGroup = null then
		cc.cnWriteLog(cc.CnLogComment, "Application server not using thin-client connection balancing as AppServerGroupName not specified.", null);
		return;
	endif;
	
	on SystemException do self.zHandleAndBypassAnyTCBExcept(exception, appServerGroup, hadError);
	app.sendMsg("enableThinClientConnBalancing");
	if hadError then
		cc.cnWriteLog(cc.CnLogComment, "Application server failed to invoke thin-client connection balancing for this node (" & self.getOidStringForObject(node) & ") : AppServerGroupName '" & appServerGroup & "'.", null);
	
	else
		cc.cnWriteLog(cc.CnLogComment, "Application server has invoked thin-client connection balancing for this node (" & self.getOidStringForObject(node) & ") : AppServerGroupName '" & appServerGroup & "'.", null);
	endif;
end;
}
zCnUser_TransientsToIgnore
{
zCnUser_TransientsToIgnore(pObjectArray : ObjectArray input) protected;

vars
	cc	: CnCntrl;
begin
	cc	:= app.myCnCntrl;
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ......", null);
	if app.isValidObject(myCnManagerClass)  then
		pObjectArray.add(app.myCnManagerClass);
		app.myCnManagerClass.cnDefineTransientsToIgnore(pObjectArray);
	endif;

	//		add user-logic to add those transient instances to input array that are to be ignored when doing transient checks
end;
}
zCnUser_ViewTransientObjects
{
zCnUser_ViewTransientObjects(pObjectArray : ObjectArray input) protected;

vars

begin
//		add user-logic to report or inspect transient objects in input array
end;
}
zGetLockedByDetails
{
zGetLockedByDetails(pExObj : LockException;
					pLockedByApp,
					pLockedByInfo,
					pLockedByNodeName,
					pLockedByProcId,
					pLockedByUserCode : String output) protected;

vars
	appl				: Application;
	
	lockTarget			: Object;
	
	lockedByProcess		: Process;
	
	badObject			: Boolean;
begin
	lockTarget		:= pExObj.lockTarget;
	
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, lockedByProcess, badObject);
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectNotAvailable, lockedByProcess, badObject);	// PAR 469
	lockedByProcess := pExObj.targetLockedBy;
	pLockedByUserCode := lockedByProcess.userCode;						// locking process could have gone away (tiny window)
	if lockTarget = global or badObject then
		pLockedByUserCode		:= 'not available';
		pLockedByNodeName		:= '<not available>';

	else
		pLockedByUserCode		:= lockedByProcess.userCode;
		if lockTarget <> node then												// if locking node we can have problems (see above)
			pLockedByNodeName	:= lockedByProcess.node.name;
			
		else
			pLockedByNodeName	:= app.cnGetClassAndOid(lockedByProcess.node);
		endif;
		
		pLockedByInfo		:= lockedByProcess.userInfo;
		pLockedByProcId		:= cnGetInstanceId64(lockedByProcess).String;
		appl				:= lockedByProcess.persistentApp;
		pLockedByApp		:= lockedByProcess.schema.name & "::" & appl.name;

		if pLockedByUserCode = null then
			pLockedByUserCode	:= '<not available>';
			pLockedByNodeName	:= '<not available>';
		endif;
	endif;
end;
}
zHandleAndBypassAnyTCBExcept
{
zHandleAndBypassAnyTCBExcept(pExObj : Exception; pAppServerGroupName : String; pHadError : Boolean output) : Integer protected;

vars
	str		: String;
	
	cc		: CnCntrl;
begin
	pHadError := true;
	str := pExObj.errorCode.String & 
		   " Error Item : " & pExObj.errorItem &
		   " Error Text : " & pExObj.text();
	
	if pExObj.extendedErrorText <> null then
		str := str & " (" & pExObj.extendedErrorText & ")";
	endif;

	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogErrors, str, null);
	if cc.karmaControl then
		app.cnRaiseAlert(app.myCnKarmaCntrl.environmentId. toUpper() & " Thin-client connection balancing initialization failed",
						 cc.appName & " running in Application Server (PID=" & node.osID.String & 
							") detected AppServerGroupName='" & pAppServerGroupName & 
							"' and failed to initialize thin-client connection balancing : " & CrLf & str,
						 "N",
						 app.actualTime(),
						 cc.appName,
						 null,
						 null);
	endif;
	
	if pExObj.resumable then
		return Ex_Resume_Next;
	endif;
	
	return Ex_Abort_Action;
end;
}
zNetworkAddressConvert
{
zNetworkAddressConvert(pNetworkAddress : String io) protected;

vars
	pos				: Integer;
	
	networkAddress	: String;
begin
	// Shared Memory Transport will return null string
	//
	// NFS 777, 778, refer JADE contacts #58414 and #58503.
	// "On a client node using HPSM, Node.networkAddres returns "procNNNN" where NNNN 
	// is the decimal process number of the process at the other end of the connection.
	//
	// When the transport is TCP/IP, Node.networkAddress is considered the IP address"

	// This method looks to cater for all cases of IPv4, IPv6, Shared Memory (standard) and HPSM
	
	networkAddress := pNetworkAddress;
	pos := networkAddress.reversePos(CN_PERIOD);		// check for IPv4 style of IP Address;
	
	if pos = null then
		pos := networkAddress.reversePos(CN_COLON);		// check for IPv6 style of IP Address;
	endif;

	if pos <> null then									// located either IPv4 or IPv6 address, leave as is
		return;
	endif;
	
	pNetworkAddress := "127.0.0.1";						// for Shared Memory or HPSM, return local host IP address in IPv4 form
end;
}
zStackDumpClass
{
zStackDumpClass() : Class protected;
/*
	Purpose:
	
	Return the class of the Stack Dump class.
	This allows this method to be re-implemented by sub-schemas
	
*/

vars

begin
	return CnStackDump;
end;
}
z_RaiseAlertCommon
{
z_RaiseAlertCommon(	pAlertType			: Integer;
					pShortText,
					pLongText,
					pAppName,
					pEnvironmentName,																							// JSM PAR 8367
					pClientFQDN,
					pClientIpAddress	: String;
					pStatus				: Character;
					pWhenRaised			: TimeStamp;
					pTcp				: CnKarmaTcpConnection) updating, protected;

vars
	cnApp			: CardSchema;

	cc				: CnCntrl;
	
	ipAddr			: CnIpAddress;
	
	kc				: CnKarmaCntrl;
	
	result,
	appname,
	servername,
	hexIpAddr,
	clientfqdn,
	clientIpAddr	: String;
	
	
	ipToken     	: CnStringArray;
	
	now,
	whenRaisedUTC	: TimeStamp;
	
	msg, 
	newmsg 			: CnMessage;
	
	trapAdv	    	: CnTrapAdvice;
	
	tcp				: CnKarmaTcpConnection;
begin
	cc		:= app.myCnCntrl;
	kc		:= app.myCnKarmaCntrl;
	cnApp	:= self.cnGetCardSchemaApp(false);
	if pShortText = null then
		self.cnRaiseNormalException(Cn_Edit_Error, method.cnGetMethodName(), "The short text argument not specified.", false);
		return;
	endif;
	
	if pShortText.length > 200 then
		self.cnRaiseNormalException(Cn_Edit_Error, method.cnGetMethodName(), "The short text argument length > 200.", false);
		return;
	endif;
	
	if pLongText = null then
		self.cnRaiseNormalException(Cn_Edit_Error, method.cnGetMethodName(), "The long text argument must be specified.", false);
		return;
	endif;
	
	if pStatus <> "C" and 
	   pStatus <> "N" and 
	   pStatus <> "R" then
		self.cnRaiseNormalException(Cn_Edit_Error, method.cnGetMethodName(), "The status argument must be C (Clear), R (Repeat) or N (New).", false);
		return;
	endif;
	
	if not pWhenRaised.isValid() then
		self.cnRaiseNormalException(Cn_Edit_Error, method.cnGetMethodName(), "The whenRaised time must be specified.", false);
		return;
	endif;

	////  Set up defaults if optional items not specified  ////

	if pClientIpAddress <> null then
		clientIpAddr 	:= pClientIpAddress;
		
	else
		if process.isUsingThinClient then
			clientIpAddr := kc.thinClientComputerIpAddress;
			
		elseif cnApp.cnIsServerApp then
			clientIpAddr := "127.0.0.1";			// See PAR 14292 - Node::networkAddress returns null in server app
			
		else
			clientIpAddr := kc.networkAddressNode;	// node.networkAddress;
		endif;
		
		if clientIpAddr = null then
			clientIpAddr := "127.0.0.1";			//  catch-all - IP address not usually important here
		endif;
	endif;
	
	if clientIpAddr.toLower() = "localhost" then
		clientIpAddr	:= "127.0.0.1";				// detour problems with shared memory RPC
	endif;

	if pClientFQDN <> null then
		clientfqdn 	:= pClientFQDN;
		
	else
		clientfqdn	:= app.cnComputerName;
	endif;

	if pAppName <> null then
		appname := pAppName;
		
	else
		appname	:= cc.appName;
	endif;
	
	if pEnvironmentName <> null and 																							// JSM PAR 8367
	   cc.appName[1:5] = CN_KARMA then
		servername := pEnvironmentName;																							// JSM PAR 8367
		
	else
		servername	:= kc.managedEnvironmentName;
	endif;

	// convert IP address and send message
	create ipToken transient;
	create ipAddr transient;
	ipToken.cnGetTokens(clientIpAddr, CN_PERIOD, true);
	if ipToken.isEmpty() then					// not IPv4 then
		ipToken.cnGetTokens(clientIpAddr, CN_COLON, true);
		if ipToken.isEmpty() then
			clientIpAddr	:=  "127.0.0.1";	// fall back to IPv4 as we have no match for IPv4 or IPv6
			
		else
			hexIpAddr := ipAddr.v6DisplayToHex(clientIpAddr);
		endif;
		
	elseif ipToken.size() <> 4 then
		clientIpAddr	:= "127.0.0.1";
		
	else
		hexIpAddr := ipAddr.v4DisplayToHex(clientIpAddr);
	endif;
	
	create msg transient;
	result := msg.createNewMsg(msg.Advice, msg.Trap_Advice, clientfqdn, clientIpAddr, cc.Application_Process, cc.JossCommsMgr_Process, newmsg);
	if result <> CN_OK then
		self.cnRaiseNormalException(Cn_Edit_Error, method.cnGetMethodName(), "Problem in createNewMsg : " & result, false);
	endif;
	
	whenRaisedUTC := pWhenRaised.localToUTCTime();
	trapAdv := newmsg.CnTrapAdvice;
	trapAdv.setClientIpAddress(clientIpAddr);
	trapAdv.setEnterprise(Cn_Enterprise);
	trapAdv.setGenericTrapNum(6);
	trapAdv.setSpecificTrapNum(pAlertType);
	trapAdv.setSourceIpAddress(hexIpAddr);
	trapAdv.setDeviceIpAddress(hexIpAddr);
	trapAdv.setManagedEnvironmentName(servername);

	trapAdv.setVarNameAndValue(1, "short", pShortText );
	trapAdv.setVarNameAndValue(2, "long", pLongText.trimRight );
	trapAdv.setVarNameAndValue(3, "status", pStatus );
	trapAdv.setVarNameAndValue(4, "whenraised", whenRaisedUTC.String & "." & whenRaisedUTC.time.milliSecond().String.padLeadingZeros(3));		// changed for 3.0
	trapAdv.setVarNameAndValue(5, "fqdn", clientfqdn ) ;
	trapAdv.setVarNameAndValue(6, "application", appname ) ;
	trapAdv.setVarNameAndValue(7, "servername", servername ) ;
	trapAdv.setVarNameAndValue(8, "servertime", now.String & "." & now.time.milliSecond().String.padLeadingZeros(3));		// Tracker PAR 751
	if pStatus = "N" then
		trapAdv.setTimestamp(whenRaisedUTC);
		
	else
		trapAdv.setTimestamp(app.actualTime.localToUTCTime());
	endif;

	tcp := pTcp;
	trapAdv.sendMessage(tcp);
epilog
	delete msg;
	delete trapAdv;
	delete ipToken;
	delete ipAddr;
end;
}
	externalMethodSources
cnGetDriveMappingEM
{
cnGetDriveMappingEM(
			driveName: String; 
			mapName: String output): Integer is "emGetDriveMapping" in "karma" updating, number = 1051;
}
	)
	CnApplicationLauncher (
	jadeMethodSources
getDetails
{
getDetails(pSchemaName,
		   pApplicationName	: String output;
		   pDatabaseRole,
		   pDelay			: Integer output);

vars

begin
	pSchemaName 		:= self.schemaName;
	pApplicationName	:= self.applicationName;
	pDatabaseRole		:= self.databaseRole;
	pDelay				:= self.delay;
end;
}
loadSelf
{
loadSelf(pSchemaName,
		 pAppName 		: String;
		 pDatabaseRole,
		 pDelay			: Integer) updating;

vars

begin
	self.schemaName			:= pSchemaName;
	self.applicationName	:= pAppName;
	self.databaseRole		:= pDatabaseRole;
	self.delay				:= pDelay;
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;

vars
	cc	: CnCntrl;	
begin
	cc	:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogComment, "Now launching application " & applicationName & " of schema " & schemaName & "...", null);
	app.startApplication(schemaName, applicationName);
epilog
	delete self;	
end;
}
	)
	CnDatabaseAdmin (
	jadeMethodSources
armServerExceptionHandler
{
armServerExceptionHandler(pDba : CnDatabaseAdmin; pApplication: String) updating, serverExecution;

vars

begin
	if 	pApplication = CN_KCONLINEBACKUPWORKER or
		pApplication = CN_KCONLINEPARTITIONWORKER  then
		on Exception do backupExceptionHandler(exception, self, pDba) global;	
		return;
	endif;

	on Exception do compactExceptionHandler(exception, self, pDba) global;	
end;
}
backupAllDbFiles
{
backupAllDbFiles() updating;

vars

begin
	beginTransientTransaction;
	myDba.backupAllDbFiles(self.backupDir, 
							false, 							// includeSystemFiles false
							true, 							// verifyFiles true
							self.compressFiles, 
							self.overwriteFiles, 
							self.quiesce, 
							self.droppedFiles);				// PAR 591
	commitTransientTransaction; 

epilog
	if process.isInExceptionState then
		myDba.causeEvent(myDba.Backup_Failed_Event, true, "Database backup failed due to unhandled exception - see logs.");

	else
		myDba.causeEvent(myDba.Backup_Completed_OK_Event, true, 0);	
	endif;
end;
}
backupDbFile
{
backupDbFile(pDbFile 			: DbFile; 
			 pDbPartition 		: JadeDbFilePartition; 
			 jdba 				: JadeDatabaseAdmin;
			 pBackupLocation	: String) updating;

	//  This method used for managed backups i.e. KCOnLineBackupWorker
vars
	cc				: CnCntrl;
	
	structureName	: String;
	
	len				: Integer64;
	
	notify			: Boolean;
begin
	cc			:= app.myCnCntrl;
	notify		:= not self.disableBackupNotify;
	if pDbPartition = null then
		len				:= pDbFile.getFileLength().Integer64;
		structureName	:= pDbFile.getName();
		
	else
		len				:= pDbPartition.getFileLength();
		structureName	:= pDbFile.getName() & "_" & pDbPartition.getName();
	endif;
	
	if notify then
		self.causeEvent(jdba.File_Backup_Start_Event, true, process.cnGetInstanceId(process).Binary & structureName.Binary);
	endif;
	
	if pBackupLocation = null then
		app.cnManagerLog("Starting backup for structure " & structureName & ", length=" & len.String & ", verify=" & true.String &
							", compress=" & self.compressFiles.String &
							", backupLocation=<default>");
	
	else
		app.cnManagerLog("Starting backup for structure " & structureName & ", length=" & len.String & ", verify=" & true.String &
							", compress=" & self.compressFiles.String &
							", backupLocation=" & pBackupLocation);
	endif;
						
	if pDbPartition = null then	
		pDbFile.backupFile(pBackupLocation, true, self.compressFiles, true);				// if null uses default backup dir from beginBackup		
																							// note that for 6.0 on, we ALWAYS verify (i.e. VerifyCheckSums)
	else
		pDbPartition.backupFilePartition(pBackupLocation, true, self.compressFiles, true);	// if null uses default backup dir from beginBackup
	endif;
	
	if pBackupLocation = null then
		app.cnManagerLog("Completed backup for structure " & structureName & " to default backup location");
		
	else
		app.cnManagerLog("Completed backup for structure " & structureName & " to " & pBackupLocation);
	endif;
	
	if notify then
		self.causeEvent(jdba.File_Backup_Complete_Event, true, process.cnGetInstanceId(process).Binary & structureName.Binary);
	endif;
	process.sleep(150);						// release CPU : allow single NT CPU to process notifications at KCOnLineBackup thread 
end;
}
backupExceptionHandler
{
backupExceptionHandler(exObj : Exception; dba : CnDatabaseAdmin input; localDba : CnDatabaseAdmin) : Integer updating;

vars
	cc			: CnCntrl;

	dbName,
	partName,
	reason,
	str			: String;
	
	dbFile		: DbFile;
	
	partition	: JadeDbFilePartition;
	
	pid			: Integer;
	
	abortedReq,
	badObject	: Boolean;
begin
	//		dba 		is the shared transient instance shared across all workers
	//		localDba	is a process transient specific to this worker
	//
	cc	:= app.myCnCntrl;
	
	if exObj.isKindOf(LockException) then					// PAR 312
		return Ex_Pass_Back;
	endif;
	
	if exObj.errorCode = 3051 then							// user aborted backup
		if not process.isInTransientTransactionState then
			beginTransientTransaction;
			self.abortRequested := true;					// so client node can detect requested abort vs. unexpected one
			commitTransientTransaction;
		else
			self.abortRequested	:= true;
		endif;
		
		app.cnManagerLog("Current file backup has been aborted (3051) ... exception handler returning Ex_Abort_Action");
		return Ex_Abort_Action;
	endif;
		
	if exObj.errorCode = 1242 and abortRequested then				// method on another node aborted
		app.cnManagerLog("Current file backup aborted (1242) ... terminating backup.");
		app.cnTerminate();
	endif;
	
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, null, badObject);
	abortedReq := dba.abortRequested;
	if abortedReq then
		app.cnManagerLog("Backup has been aborted : encountered " & exObj.errorCode.String & " exception - ignoring.");
		return Ex_Resume_Next;										// pass control to method that armed handler
	endif;

	reason		:= "error " & exObj.errorCode.String & " (" & exObj.text & ").";
	dbFile		:= localDba.myCurrentDbFile;
	partition	:= localDba.myCurrentDbPartition;
	dbName  := dbFile.getName();
	if badObject then	
		dbName := "<no current dbFile>";
	endif;

	if partition <> null then
		badObject := false;
		partName := partition.getName();
		if badObject then	
			partName := "<no current partiton>";			
		endif;
	endif;

	reason := reason & " : Current structure " & dbName;
	if partName <> null then
		reason := reason & "_" & partName;
	endif;
	
	if not process.isInTransientTransactionState then
		beginTransientTransaction;
		dba.failureReason	:= reason;					
		commitTransientTransaction;
	else
		dba.failureReason	:= reason;					
	endif;
	
	if exObj.errorCode = 3035 then						// map file certification error
		pid		:= cnGetInstanceId(process);
		raiseAlert("Backup failed : " & reason, true);
		self.causeEvent(JadeDatabaseAdmin.Backup_Failed_Event, true, "Application exception in KCOnLineBackupWorker/" & 
															pid.String & " : backup failed : " & reason);
		app.cnManagerLog("Backup failed : " & reason & " .... worker terminating.");
		app.cnTerminate();
	endif;
	
	return Ex_Pass_Back;
end;
}
backupLogFile
{
backupLogFile(dba 			: JadeDatabaseAdmin; 
			  logNo 		: Integer; 
			  sourcePath	: String;
			  destPath 		: String;
			  verifyLogs	: Boolean;
			  compressLogs	: Boolean;
			  overwriteLog	: Boolean) : Boolean updating;

vars
	kc				: CnKarmaCntrl;
	
	fileNameArray	: CnStringArray;
	
	fileSizeArray	: Integer64Array;
	
	file			: File;
begin
	kc	:= app.myCnKarmaCntrl;
	kc.setFileRetryNo(0);
	
	app.cnManagerLog("Attempting to back up log #" & logNo.String & " from " & sourcePath & " (retry=" & kc.fileRetryNo.String & ")");
	//						// log may be in use by verify, so may need to retry - exception handler increments retryNo
	on FileException do kc.fileExceptionHandler(exception);

	create file			 transient;
	create fileNameArray transient;
	create fileSizeArray transient;
	
	while true do									
		app.cnManagerLog("Start back up of journal #" & logNo.String & " from " & sourcePath & " (retry=" & kc.fileRetryNo.String & ")");
		kc.setHadFileException(false);
		
		if app.name = CN_KCDATABASEBACKUPMULTI	and
		   not self.disableBackupNotify			then  // only send notifications if 'DisableBackupNotifications=false' in the environments .ini file
			fileNameArray.add(logNo.String);
			file.fileName := sourcePath & "/db" & "".padLeadingZeros(10-logNo.String.length) & logNo.String & ".log";
			fileSizeArray.add(file.cnGetFileLength64());
			self.buildUserInfoNonManagedBackup(fileNameArray, fileSizeArray, Cn_Backup_Journal_Start, "Backing up journal #");
			fileNameArray.clear();
			fileSizeArray.clear();
		endif;

		dba.backupJournal(logNo, sourcePath, destPath, verifyLogs, compressLogs, overwriteLog); 
		if not kc.hadFileException then
			kc.setFileRetryNo(0);
			return true;
		endif;
		
		if kc.exceptionErrorCode = Cn_FileDirectoryNotFound then
			app.cnManagerLog("Failed to backup journal #" & logNo.String & ", directory specified not found.");
			return false;
		endif;
		
		if kc.fileRetryNo > 9 then
			app.cnManagerLog("Failed to backup journal #" & logNo.String & ", errorcode=" & kc.exceptionErrorCode.String);
			return false;
		endif;
		
		app.cnManagerLog("Encountered file exception #" & kc.exceptionErrorCode.String & "(" & kc.exceptionText & ") : waiting 10 seconds before retrying....");
		process.sleep(10000);
	endwhile;
	
epilog
	delete file;
	delete fileNameArray;
	delete fileSizeArray;
	if app.name = CN_KCDATABASEBACKUPMULTI 	and
	   kc.hadFileException 					then
		terminateManagedBackup("Errors were encountered when trying to backup the database journals, please review logs. Backup terminated", Backup_Failed);
	endif;
end;
}
backupLogFiles
{
backupLogFiles(dba : JadeDatabaseAdmin; endLogNo : Integer io) : String updating, serverExecution;							// NFS 578

/*
	NFS 578.
	This method MUST be server execution in order to trap and handle the possible 3036 exceptions that
	may occur if database has a JournalCloseAction of Move and the journal doesn't exist in the 
	current journals directory.
*/
vars
	cc				: CnCntrl;
	
	kc				: CnKarmaCntrl;

	fn				: FileNode;
	
	ff				: FileFolder;
	
	jdba			: JadeDatabaseAdmin;

	backupOK,
	compressLogs,
	endJournalBackupFailed,
	foundOne,
	missingJournal,
	noObject,
	overwriteLog,
	verifyLogs		: Boolean;																								// NFS 578

	dbRole,
	logNo			: Integer;
	
	archivePath,
	compressLogStr,
	destPath,
	fname,
	fromArchive,																										// NFS 578	iniFile,
	iniFile,
	overwriteLogStr,
	sourcePath		: String;
begin
	cc			:= app.myCnCntrl;
	kc			:= app.myCnKarmaCntrl;
	destPath 	:= backupRootDir & "/" & kc.environmentId & "/logs/current";
	
	// KC_DatabaseBackupMulti is somewhat different in that kc.environmentId could be different to that of the user specified
	// environmentId. We have to handle this situation, particularly if say the 'system' folder is e:\system yet the rest of
	// the database is in d:\nonStandard. Since 'nonStandard' is the environmentId we would expect all files to end up
	// in the backup destination folder under the 'nonStandard' folder. Failure to execute the code below would result in
	// logs being backed up to <backup dest>\system instead.
	if app.name = CN_KCDATABASEBACKUPMULTI then
		destPath := backupRootDir & "/" & self.environmentId & "/logs/current";
	endif;
	
	app.cnManagerLog(" ");
	app.cnManagerLog("----  Starting log file backup   ----");
	create ff;
	ff.fileName := destPath;
	if not ff.isAvailable then
		ff.make;
	else
		if not removeFilesFromDirectory(destPath) then
			return "Problem removing files from log destination directory " & destPath;
		endif;
	endif;

	iniFile			:= app.getIniFileNameAppServer();
	verifyLogs		:= true;
	compressLogStr  := app.getProfileStringAppServer(iniFile, CN_JSMDATABASEBACKUP, CN_COMPRESSLOGS, null);
	if compressLogStr = null then
		app.setProfileStringAppServer(iniFile, CN_JSMDATABASEBACKUP, CN_COMPRESSLOGS, false.String);
		compressLogs := false;
	
	else
		compressLogs := compressLogStr.Boolean;
	endif;
	
//	compressLogs	:= app.getProfileStringAppServer(iniFile, CN_JSMDATABASEBACKUP, CN_COMPRESSLOGS, false.String).Boolean;
	overwriteLogStr	:= app.getProfileStringAppServer(iniFile, CN_JSMDATABASEBACKUP, CN_ALLOWOVERWRITE, null);
	if overwriteLogStr = null then
		app.setProfileStringAppServer(iniFile, CN_JSMDATABASEBACKUP, CN_ALLOWOVERWRITE, true.String);
		overwriteLog := true;
	
	else
		overwriteLog := overwriteLogStr.Boolean;
	endif;
//	overwriteLog	:= app.getProfileStringAppServer(iniFile, CN_JSMDATABASEBACKUP, CN_ALLOWOVERWRITE, true.String).Boolean;

 	app.cnManagerLog("This database has EnableArchivalRecovery=" & enableArchiveRecovery.String & ".");
	app.cnManagerLog("Log backup options are : VerifyLogs=" & verifyLogs.String & ", CompressLogs=" & compressLogs.String &
			 ", OverWriteLog=" & overwriteLog.String & " : now looking for logs to back up.");

	if not enableArchiveRecovery then	
		//
		//  EnableArchivalRecovery not set, so JadeDatabaseAdmin will have copied the logs to the 
		//  same directory as the rest of the system files.  The logs are a snapshot (JADE doesn't close
		//  the current log) so we determine start and end log numbers by inspecting the files
		//  that were copied by JADE to the backup directory.
		//
		sourcePath	:= backupDir;
		ff.fileName	:= backupDir;
		ff.mask		:= "db*.log";
		on SystemException do app.cnGenericExceptionHandler(exception, 1090, null, noObject);
		fname		:= ff.files.first.fileName;
		on SystemException do null;
		if noObject then
			ff.mask		:= "db*.lo_";
		endif;
		
		fname		:= ff.files.first.fileName;
		logNo		:= getLogNumberFromFileName(fname);
		fname		:= ff.files.last.fileName;
		endLogNo	:= getLogNumberFromFileName(fname);

	else
		//  EnableArchivalRecovery IS on, so the logs will be in the current logs directory.  
		//
		create jdba transient;
		sourcePath	:= jdba.getCurrentJournalDirectory();
		archivePath := cc.myTransientGlobal.cnGetServerLogArchiveDir();														// NFS 578
		logNo		:= self.startLogNo;
	endif;
	
	on SystemException do self.handle3036Exception(exception, missingJournal);												// NFS 578
	if logNo > endLogNo then						// log numbers have rolled over
		while logNo <= Max_Integer do
			backupOK := self.backupLogFile(dba, logNo, sourcePath, destPath, verifyLogs, compressLogs, overwriteLog);		// NFS 578
			fromArchive := null;																							// NFS 578
			if not backupOK and archivePath <> null then																	// NFS 578
				fromArchive := " (from archive path)";																		// NFS 578
				backupOK := self.backupLogFile(dba, logNo, archivePath, destPath, verifyLogs, compressLogs, overwriteLog);	// NFS 578
			endif;																											// NFS 578
			
			if not backupOK then 																							// NFS 578
				return "ERROR : transaction journal #" & logNo.String & " required for backup : not found in " & 			// NFS 578
									sourcePath & " or " & archivePath;														// NFS 578
			endif;
			
			app.cnManagerLog("Log " & logNo.String & " backed up" & fromArchive & ".");
			logNo 		:= logNo + 1;
			foundOne	:= true;
		endwhile;
		
		logNo 	:= 1;		
	endif;

	dbRole := system.getDatabaseRole();																						// PAR 841
	while logNo <= endLogNo do																								// PAR 841
		if logNo = endLogNo 			and																					// PAR 841
		   dbRole = SDS_RoleSecondary 	then																				// PAR 841
			on SystemException do app.cnGenericExceptionHandler(exception, Cn_DatabaseReadPastEndOfFile, null, endJournalBackupFailed);	// PAR 841
			app.cnManagerLog("exception handler armed for " & Cn_DatabaseReadPastEndOfFile.String & 						// PAR 841
							" (Database Read Past End Of File) system exception");											// PAR 841
		endif;																												// PAR 841
		
		backupOK := self.backupLogFile(dba, logNo, sourcePath, destPath, verifyLogs, compressLogs, overwriteLog);			// NFS 578
		if endJournalBackupFailed then																						// PAR 841
			app.cnManagerLog("Attempt to backup journal " & logNo.String & " failed, OK for SDS Secondary, continuing...");	// PAR 841
			break;																											// PAR 841
		endif;																												// PAR 841
		
		fromArchive := null;																								// NFS 578
		if not backupOK and archivePath <> null then																		// NFS 578
			fromArchive := " (from archive path)";																			// NFS 578
			backupOK := self.backupLogFile(dba, logNo, archivePath, destPath, verifyLogs, compressLogs, overwriteLog);		// NFS 578
		endif;																												// NFS 578
			
		if not backupOK then 																								// NFS 578
			return "ERROR : transaction journal #" & logNo.String & " required for backup : not found in " & 				// NFS 578
								sourcePath & " or " & archivePath;															// NFS 578
		endif;
		
		app.cnManagerLog("Log " & logNo.String & " backed up" & fromArchive & ".");
		logNo 		:= logNo + 1;
		foundOne	:= true;
	endwhile;

	kc.setFileRetryNo(0);

	if not foundOne and
	   not endJournalBackupFailed then
		return("ERROR : No database transaction journals found for backup.");
	endif;

	return CN_OK;
epilog
	if process.isInExceptionState then
		app.cnManagerLog("Log file backup failed");
	endif;

	delete fn;
	delete ff;
	delete jdba;
end;
}
backupNonDbFiles
{
backupNonDbFiles() : String updating;

vars

	base,
	path,
	envId,
	logpath,
	str,
	pbase,
	currentLog,
	errText		: String;

	kc			: CnKarmaCntrl;

	cc			: CnCntrl;
begin
	kc 			:= app.myCnKarmaCntrl;
	cc			:= app.myCnCntrl;
	base 		:= self.backupRootDir & "/" & kc.environmentId.toLower();							// set destination backup dir
    pbase 		:= kc.driveLetter.toLower() & ":/" & kc.environmentId.toLower();					// set production system base directory
	
	// KC_DatabaseBackupMulti is somewhat different in that kc.environmentId could be different to that of the user specified
	// environmentId. We have to handle this situation, particularly if say the 'system' folder is e:\system yet the rest of
	// the database is in d:\nonStandard. Since 'nonStandard' is the environmentId we would expect all files to end up
	// in the backup destination folder under the 'nonStandard' folder. Failure to execute the code below would result in
	// logs being backed up to <backup dest>\system instead.
	if app.name = CN_KCDATABASEBACKUPMULTI then
		base 	:= self.backupRootDir & "/" & self.environmentId.toLower();
		pbase 	:= kc.driveLetter.toLower() & ":/" & self.environmentId.toLower();
	endif;
	
    app.cnManagerLog(" ");
    app.cnManagerLog("----   Starting backup of non-database files   ----");

 	logpath := app.cnConvertPathNameToFwdSlashes(cc.myTransientGlobal.cnGetServerLogRootDir.toLower);
 	if not self.directoryExists(logpath) then
 		return "Specified log path '" & logpath & "' not found.";
 	endif;

	if self.copyFilesFromDirectory(pbase, base, logpath, false, errText) then
		app.cnManagerLog("Non-database files successfully backed up.");
		return CN_OK;
	endif;

	return "Problem encountered copying files from " & pbase & "/";
end;
}
buildUserInfoNonManagedBackup
{
buildUserInfoNonManagedBackup(	pFileNameArray		: CnStringArray;
								pFileSizeArray		: Integer64Array;
								pEventTag 			: Integer;
								pStatusText 		: String);

/*								
 	this method is only executed for non-database files. because we don't want a continuous stream of events being
	raised we store each file copy event in an array, wait a period of time then send a chunk of data through.
*/
vars
	timestamp		: TimeStamp;

	backupInfo 		: Binary;
	
	str,
	fileName		: String;
	
	fileSize		: Integer64;
	
	fSize			: Binary;
begin
	backupInfo		:=	timestamp.Binary;
	foreach fileName in pFileNameArray do
		str 		:= str & fileName & "|";
	endforeach;
	backupInfo		:= 	backupInfo & str.length.Binary 		&
					cnAnsiBinary(str)						;
	
	foreach fileSize in pFileSizeArray do				
		fSize 		:= fSize & fileSize.Binary;		
	endforeach;		
	
	backupInfo		:= 	backupInfo & fSize.length.Binary 	&
						fSize								&
						pEventTag.Binary					&
						pStatusText.length.Binary			&
						cnAnsiBinary(pStatusText)			;
					
	system.causeEvent(Cn_Backup_Status_Change, true, backupInfo);
end;
}
calculateStartLogNo
{
calculateStartLogNo(startLogNo, abortLogNo : Integer) : Integer;

//  Determine true start journal number based on abort journal and start journal, 
//  allowing for possible log number wrap-around (at Max_Integer in 6.0.18 or later). 

constants
	Diff	= Max_Integer div 2;
vars
	
begin
	if abortLogNo > startLogNo then
		if abortLogNo - startLogNo > Diff then 		// startLogNo has wrapped since abortLogNo, i.e.
			return abortLogNo;						// abortLogNo is earlier than start log
		else
			return startLogNo;
		endif;
		
	elseif abortLogNo < startLogNo then				 
		if startLogNo - abortLogNo > Diff then		// start log is earlier than abort log, but numbers
			return startLogNo;						// rolled over after start log
		else
			return abortLogNo;
		endif;
	
	else
		return startLogNo;
	endif;		
end;
}
checkDirectories
{
checkDirectories(dir : String input; createIfAbsent : Boolean) : Boolean updating;

vars
  	array 	: StringArray;
  	i		: Integer;
  	path	: String;
  	present	: Boolean;
begin										// Method checks directories on path and creates any that don't exist
	array 	:= dir.cnGetTokens("/");
	path 	:= array[1];

	present := checkDirectory(path, false);
	if not present then
		app.cnManagerLog("Invalid drive letter or mount point specified for directory check : input was '" & dir & "'");
		return false;
	endif; 

	i := 2;
	while i <= array.size do
		path := path & "/" & array[i];
		checkDirectory(path, true);					// create if absent
		i := i +1;
	endwhile;

	return true; 

epilog
	delete array;
end;
}
checkDirectory
{
checkDirectory(dir : String; createIfAbsent : Boolean) : Boolean updating;

vars
	ff	: FileFolder;
begin
	create ff transient;
	ff.fileName := dir;
	if ff.isAvailable then 
		return true;
	elseif createIfAbsent then
		ff.make;
		app.cnManagerLog("New directory " & dir & " has been created.");
		return true;
	else
		return false;
	endif;

epilog
	delete ff;	
end;
}
checkForAbortedBackup
{
checkForAbortedBackup();

vars

begin
	if self.abortRequested then
		app.cnManagerLog("Backup has been aborted by someone .... worker thread terminating.");
		app.cnTerminate();
	endif;
	
	if self.abnormalTermination then
		app.cnManagerLog("Backup has failed or was interrupted (abnormalTermination=true) : worker thread will terminate.");
		app.cnTerminate();
	endif;
end;
}
checkForAbortedCompact
{
checkForAbortedCompact();

vars

begin
	if self.abortRequested then
		app.cnManagerLog("Compaction abort request received .... worker thread terminating.");
		app.cnTerminate();
	endif;
	
	if self.abnormalTermination then
		app.cnManagerLog("Compaction has failed or was interrupted (abnormalTermination=true) : worker thread will terminate.");
		app.cnTerminate();
	endif;
end;
}
closeTranLogAndAdvise
{
closeTranLogAndAdvise() updating;

vars
	jdba		: JadeDatabaseAdmin;
	msg			: CnBackupAdvice;	
	str			: String;
	cc			: CnCntrl;
	logNo		: Integer;
begin
	cc := app.myCnCntrl;

	if not abnormalTermination then
		create jdba transient;
		logNo 	:= jdba.getCurrentLogNumber;
		str 	:= app.getProfileString(app.getIniFileName, "PersistentDb", "MaxWaitForQuietPoint", "-1");
		cc.cnWriteLog(cc.CnLogComment, "Ini file specifies MaxWaitForQuietPoint=" & str, null);
		
		if system.getDatabaseRole <> SDS_RoleSecondary then
			str 	:= "Now closing current transaction journal (" & logNo.String & ").";
			app.cnManagerLog(str);
			cc.cnWriteLog(cc.CnLogComment, str, null);

			// from Hugh McColl 2Feb2011
			// A call to closeCurrentJournal is performed as inline synchronous code, 
			// thus guaranteeing that a journal switch record is written to the current
			// journal before the line of code returns. It is an atomic operation that 
			// preps the new journal and increments the currentJournal number as accessed
			// by getCurrentJournalNumber.
			jdba.closeCurrentJournal();
			logNo 	:= jdba.getCurrentJournalNumber - 1;
			app.cnManagerLog("Database journal #" & logNo.String & " has now been closed.");
			
		else
			logNo	:= jdba.getCurrentJournalNumber();
			app.cnManagerLog("SDS secondary : closeCurrentJournal not required : current journal=" & logNo.String);
		endif;
		
		app.cnManagerLog("Log closed OK, on-line backup completed, start journal=" & self.startLogNo.String & ", final journal=" & logNo.String);
		
		beginTransientTransaction;				
		self.tranLogClosed	:= true;
		commitTransientTransaction;
		app.myCnDba.setBackupCompletionType(msg.Advice_Type_Backup_CompletedOK);			
		msg := createBackupAdviceMessage(msg.Advice_Type_Backup_CompletedOK);
		msg.setStartLogNo(self.startLogNo);		// this is the tran log required before we started the backup
		msg.setEndLogNo(logNo);					// this is the tran log BEFORE we did the commitBackup.
		msg.setCompletedBackupIsCommitCoherent(self.completedBackupIsCommitCoherent); //7055
		msg.sendMessage(null);					

	else
		app.cnManagerLog("Abnormal backup termination - will not close current database journal.");
	endif;		
			
epilog
	delete msg;
	delete jdba;
end;
}
compactExceptionHandler
{
compactExceptionHandler(exObj : Exception; dba : CnDatabaseAdmin input; localDba : CnDatabaseAdmin) : Integer updating;

vars
	cc			: CnCntrl;
	reason		: String;
	dbFile		: DbFile;
	pid			: Integer;
	badObject	: Boolean;
	abortedReq	: Boolean;
	str			: String;
begin
	//		dba 		is the shared transient instance shared across all workers
	//		localDba	is a process transient specific to this worker
	//
	cc	:= app.myCnCntrl;
	
	if exObj.isKindOf(LockException) then					// PAR 312
		return Ex_Pass_Back;
	endif;
	
	if exObj.errorCode = 3051 then							// user aborted compact
		if not process.isInTransientTransactionState() then
			beginTransientTransaction;
			self.abortRequested := true;					// so client node can detect requested abort vs. unexpected one
			commitTransientTransaction;
		else
			self.abortRequested	:= true;
		endif;
		
		app.cnManagerLog("Current file compaction has been aborted (3051) ... exception handler returning Ex_Abort_Action");
		return Ex_Abort_Action;
	endif;
	
	if exObj.errorCode = 1242 and abortRequested then				// method on another node aborted
		app.cnManagerLog("Current file compaction aborted (1242) ... terminating compaction.");
		app.cnTerminate();
	endif;
		
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, null, badObject);
	abortedReq := dba.abortRequested;
	if abortedReq then
		app.cnManagerLog("Compaction has been aborted : encountered " & exObj.errorCode.String & " exception - ignoring.");
		return Ex_Resume_Next;											// pass control to method that armed handler
	endif;

	reason	:= "error " & exObj.errorCode.String & " (" & exObj.text & ").";
	dbFile	:= localDba.myCurrentDbFile;		// compact only needs to deal with DbFile as partitions are always compacted as part of DbFile
	str  := dbFile.getName();
	if badObject then	
		reason	:= reason & " : no current dbFile.";			
	
	else
		reason	:= reason & " Current file=" & str;
	endif;

	if not process.isInTransientTransactionState then
		beginTransientTransaction;
		dba.failureReason	:= reason;					
		commitTransientTransaction;
	else
		dba.failureReason	:= reason;					
	endif;
		
	return Ex_Pass_Back;
end;
}
compactMapFile
{
compactMapFile(pDbFile : DbFile; jdba : JadeDatabaseAdmin) updating;

/*  this method used for online compactions i.e. KCOnLineCompactWorker

*/

vars
	cc		: CnCntrl;
	
	dbName	: String;
	
	len		: Decimal[23];
begin
	cc			:= app.myCnCntrl;
	len			:= pDbFile.getFileLength();
	dbName		:= pDbFile.getName();
	
	self.causeEvent(jdba.File_Compact_Start_Event, true, process.cnGetInstanceId(process).Binary & dbName.Binary);
	app.cnManagerLog("Starting compaction for file " & dbName & ", length=" & len.String);
	
	pDbFile.compactFile();
	
	app.cnManagerLog("Completed compaction for file " & dbName);
	self.causeEvent(jdba.File_Compact_Complete_Event, true, process.cnGetInstanceId(process).Binary & dbName.Binary);
	
	process.sleep(150);	// release CPU : allow single NT CPU to process notifications at KCOnLineCompact thread 
end;
}
copyFile
{
copyFile(sourceFile, destFile : String; failIfExists : Boolean; errText : String output) : Boolean updating;

vars
	int,
	result		: Integer;
	
	kc			: CnKarmaCntrl;	
	
	cc			: CnCntrl;

	errortext 	: String;
	
	cem			: CnExternalMethods;
	
	file		: File;
begin
	cc		:= app.myCnCntrl;
	create file transient;
	result 	:= file.emCopyFile(sourceFile, destFile, failIfExists);

	if result = null then
		app.cnManagerLog(sourceFile & " copied to " & destFile);
 		return true;
	endif;

	create cem transient;
	int	:= cem.emGetErrorText(result, errortext, 127);
	if int <> 0 then
		app.cnManagerLog("In CnDatabaseAdmin::copyFile CnKarmaCntrl::getWindowsErrorText got error result=" & int.String);
	endif;
	
	errText := "Copy of " & sourceFile & " to " & destFile & " failed, result=" & result.String & ":" & errortext;
	app.cnManagerLog(errText);
	return false;
epilog
	delete cem;
	delete file;
end;
}
copyFilesFromDirectory
{
copyFilesFromDirectory(sourceDir, destDir, logPath : String; failIfExists : Boolean; errText : String output) : Boolean updating;

vars
	d1,
	d2				: Decimal[23];
	
	ff,
	ff2				: FileFolder;
	
	filenode 		: FileNode;
	
	file			: File;
	
	notify			: Boolean;
	
	cc				: CnCntrl;
	
	pos				: Integer;
	
	kc				: CnKarmaCntrl;
	
	filename,
	filename_full,
	filepath,
	sourcedir,
	suffix			: String;
	
	fileNameArray	: CnStringArray;
	fileSizeArray	: Integer64Array;
begin
	///// Copies files and subdirectories from sourcedir to destDir : for installation on Karma
   	sourcedir := app.cnStandardizePathName(sourceDir.toLower);

	if sourcedir = logPath 					or
	   sourcedir = stateOverflowDirectory	or
	   sourcedir.cnContains("crashlogs")	then
		app.cnManagerLog(">>>>>>  Directory " & sourcedir & " not backed up : not required/specified.  <<<<<<<");
		return true;
	endif;

	cc 		:= app.myCnCntrl;
	kc 		:= app.myCnKarmaCntrl;
	notify	:= not self.disableBackupNotify;
	create ff transient;
	ff.fileName := sourcedir;

	create fileNameArray transient;
	create fileSizeArray transient;
	
	d1 := app.relativeMachineTime();
	foreach filenode in ff.files do
		filename 	:= filenode.cnGetSimpleFileName();
    	if filenode.isKindOf(File) then
    		file 	:= filenode.File;
    		suffix	:= file.cnGetSuffix().toLower();
    		if suffix ="tmp"									or 
    		   filename.toLower() = "backupinfo"				then
    			app.cnManagerLog(">>>>>>>> " & file.fileName & " not copied : backupinfo or tmp file.  <<<<<<<");
				continue;
			endif;
    			
			if suffix = "dat" then
				filename_full := filenode.fileName.toLower();
				filename_full.replaceChar(CN_BACK_SLASH, CN_SLASH);
				pos := filename_full.reversePos(CN_SLASH);
				filepath := filename_full[1:pos-1];
				if filepath = self.databaseDirectory then
					app.cnManagerLog(">>>>>>>> " & file.fileName & " not copied : database file.  <<<<<<<");
					continue;
				endif;
			endif;
				
			if app.name = CN_KCDATABASEBACKUPMULTI 	and
			   notify								then			// only send notifications if 'DisableBackupNotifications=false' in the environments .ini file
				fileNameArray.add(file.name);
				fileSizeArray.add(file.cnGetFileLength64());
				d2 := app.relativeMachineTime();
				if fileNameArray.size() > 500 	or	
				  (d2 - d1) > 1000 				then				// don't raise an event on every single file as this could be expensive, update periodically
					self.buildUserInfoNonManagedBackup(fileNameArray, fileSizeArray, Cn_Backup_NonDbFile_Start, "Backing up file... ");
					fileNameArray.clear();
					fileSizeArray.clear();
					d1 := d2;
				endif;
			endif;
			
			if not copyFile(file.fileName, destDir & "/" & filename, false, errText) then
				return false;
			endif;

    	else
    		create ff2 transient;
    		ff2.fileName := destDir & "/" & filename;
    		if not ff2.isAvailable then
    			ff2.make;
    		endif;
			
    		delete ff2;

    		if not self.copyFilesFromDirectory(filenode.fileName, destDir & "/" & filename, logPath, failIfExists, errText) then
    			return false;
    		endif;
		endif;
	endforeach;
	
	// send any remaining advices from KCDatabaseBackupMulti through
	if app.name = CN_KCDATABASEBACKUPMULTI	and
	   notify								then						// only send notifications if 'DisableBackupNotifications=false' in the environments .ini file
		self.buildUserInfoNonManagedBackup(fileNameArray, fileSizeArray, Cn_Backup_NonDbFile_Start, "Backing up file... ");
	endif;
	
	return true;
epilog
	delete ff;
	delete fileNameArray;
	delete fileSizeArray;
end;
}
create
{
create() updating;

vars

begin
 	self.startTime := app.actualTime;
end;
}
createBackupAdviceMessage
{
createBackupAdviceMessage(adviceType : String) : CnBackupAdvice updating;

vars
	msg		: CnMessage;
	tmsg	: CnMessage;
	newmsg	: CnBackupAdvice;
	kc		: CnKarmaCntrl;
	cc		: CnCntrl;
begin
	kc		:= app.myCnKarmaCntrl;
	cc		:= app.myCnCntrl;
	create msg;
	msg.createNewMsg(msg.Advice, msg.Backup_Advice, kc.localFQDN, kc.localIpAddress, cc.Application_Process, cc.KarmaCommsMgr_Process, tmsg);
	newmsg	:= tmsg.CnBackupAdvice;
	newmsg.setAdviceType(adviceType);
	newmsg.setStartLogNo(0);
	newmsg.setEndLogNo(0);
	newmsg.setManagedEnvironmentName(kc.managedEnvironmentName);
	newmsg.setTimestamp(app.actualTime);
	return newmsg;
	
epilog
	delete msg;
end;
}
createCompactAdviceMessage
{
createCompactAdviceMessage(pAdviceType : String) : CnCompactAdvice;

vars
	msg		: CnMessage;
	tmsg	: CnMessage;
	newmsg	: CnCompactAdvice;
	kc		: CnKarmaCntrl;
	cc		: CnCntrl;
begin
	kc		:= app.myCnKarmaCntrl;
	cc		:= app.myCnCntrl;
	create msg;
	msg.createNewMsg(msg.Advice, msg.Compact_Advice, kc.localFQDN, kc.localIpAddress, cc.Application_Process, cc.KarmaCommsMgr_Process, tmsg);
	newmsg	:= tmsg.CnCompactAdvice;
	newmsg.setAdviceType(pAdviceType);
	newmsg.setManagedEnvironmentName(kc.managedEnvironmentName);
	newmsg.setTimeStamp(app.actualTime);
	return newmsg;
epilog
	delete msg;
end;
}
directoryExists
{
directoryExists(dirname : String) : Boolean  updating;

vars
	ff : FileFolder;
	cc	: CnCntrl;
begin
	create ff transient;
	ff.fileName := dirname;
	if ff.isAvailable then
		return true;
	endif;

	app.cnManagerLog("Directory existence check failed for " & dirname);
	return false;
epilog
	delete ff;
end;
}
ehGeneralExceptionHandler
{
ehGeneralExceptionHandler(exObj : Exception; errorCode : Integer output; errorText : String output) : Integer;

vars
	cc	: CnCntrl;
begin
	errorCode	:= exObj.errorCode;
	errorText	:= exObj.text;
	cc			:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogErrors, cc.appName & " encountered error " & errorCode.String & " ( " & errorText & ") : aborting.", null);
	abortTransaction;
	abortTransientTransaction;
	
	return Ex_Abort_Action;	
end;
}
finalizeAndTerminate
{
finalizeAndTerminate() updating;

vars
	msg		: CnBackupAdvice;
	
	cdba	: CnDatabaseAdmin;

	dbFile	: DbFile;
	
	obj		: Object;
	
	elapsed	: String;
begin
	endNotificationForSubscriber(self);
    elapsed := self.startTime.cnGetElapsedTimeString();
    app.cnManagerLog("Backup elapsed time was " & elapsed); 
    
    cdba := app.myCnDba;
	if self.abnormalTermination then
    	app.cnManagerLog("Sending abnormal termination backup advice, type=" & cdba.getBackupCompletionType());
    	msg	:= self.createBackupAdviceMessage(cdba.getBackupCompletionType());
    	msg.setErrorText(cdba.getBackupCompletionText()); 
    	msg.sendMessage(null);
    endif;

	app.cnManagerLog("----------------- End of Database Backup Task  ------------------------");
	
	if not process.isInTransientTransactionState then
		beginTransientTransaction;
	endif;
	
	self.allCnDatabaseStructuresBySize.purge();
	delete self;								
	commitTransientTransaction;
	
	delete app.cnMyBackupLog;
	
	app.cnTerminate();
	
epilog
	delete msg;
end;
}
finalizeAndTerminateCompact
{
finalizeAndTerminateCompact() updating;

vars
	msg		: CnCompactAdvice;
	
	elapsed	: String;
begin
	endNotificationForSubscriber(self);
    elapsed := self.startTime.cnGetElapsedTimeString();
    app.cnManagerLog("Compaction elapsed time was " & elapsed); 
    
    if abnormalTermination or self.abortRequested then															//7312
    	if abnormalTermination then
			app.cnManagerLog("Sending abnormal termination compact advice, type=" & self.compactCompletionType);
			
		else
			app.cnManagerLog("Sending abort completion advice compact advice");									//7312
		endif;
    	msg	:= createCompactAdviceMessage(self.compactCompletionType);
    	msg.setErrorText(self.compactCompletionText); 
    	msg.sendMessage(null);
    endif;

	app.cnManagerLog("----------------- End of Database Compaction Task  ------------------------");
	
	if not process.isInTransientTransactionState then
		beginTransientTransaction;
	endif;
	
	self.allCnDatabaseStructuresBySize.purge();
	delete self;								
	commitTransientTransaction;
	
	delete app.cnMyCompactLog;

	app.cnTerminate();
	
epilog
	delete msg;
end;
}
getAbortJournalNumber
{
getAbortJournalNumber(pFileName : String);

/*
	Purpose :
	
	Similar to 'getCurrentJournalNumber' in that a file is output but the file will contain the earliest required journal
	number being the abort journal number. 
	
	This method is used for direct, off-line execution from JADLOADB during deployments, backups etc

	Execution command line:
		jadloadb.exe 
			ini=<ini file> 
			path=<systempath> 
			schema=CardSchema
			app=KCDeployMgr 
			executeSchema=CardSchema
			executeClass=CnDatabaseAdmin
			executeMethod=getAbortJournalNumber
			executeParam=<fileName>
*/

vars
	file	: File;

	dba		: JadeDatabaseAdmin;
begin
	create dba transient;
	create file transient;
	file.mode := file.Mode_Input;
	file.fileName	:= pFileName;
	if file.isAvailable then
		file.readOnly	:= false;
		file.purge();
	endif;
	
	file.mode := file.Mode_Output;
	file.writeLine(dba.getAbortJournalNumber().String.padLeadingZeros(2));
epilog
	delete file;
	delete dba;
end;
}
getBackupCompletionText
{
getBackupCompletionText() : String;

vars

begin
	return self.backupCompletionText;
end;
}
getBackupCompletionType
{
getBackupCompletionType() : String;

vars

begin
	return self.backupCompletionType;
end;
}
getBackupLog
{
getBackupLog() : JadeLog;

vars
	log		: JadeLog;
	ts		: TimeStamp;
	cc		: CnCntrl;
begin
	cc	:= app.myCnCntrl;
	create log transient;
	log.filePath		:= cc.logPath;
	log.fileName		:= "cn_backup_" & ts.date.cnUserFormat($CnCCYYMMDD_ns) & ".log";
	log.versionFile		:= false;
	log.formatOutput	:= false;
	log.bufferOutput	:= true;
    return log;
end;
}
getCommitCoherentBackupMaxTries
{
getCommitCoherentBackupMaxTries(): Integer;

vars
	maxTries	: Integer;
	
 	str			: String;
begin
	str := app.getProfileString(app.getIniFileName, CN_JSMDATABASEBACKUP, CN_COMMITCOHERENTBACKUP_MAX_TRIES, "").toLower();
	
	maxTries := str.Integer;
	
	if 	maxTries < 1 then
		
		maxTries := 3;
		
		app.setProfileString(app.getIniFileName, CN_JSMDATABASEBACKUP, CN_COMMITCOHERENTBACKUP_MAX_TRIES, "3");
	endif;
	
	return maxTries;
end;
}
getCommitCoherentBackupRetryInterval
{
getCommitCoherentBackupRetryInterval(): Integer;

vars
	retryInterval	: Integer; //minutes
	
 	str				: String;
begin
	str 			:= app.getProfileString(app.getIniFileName, CN_JSMDATABASEBACKUP, CN_COMMITCOHERENTBACKUP_RETRY_INTERVAL, "").toLower();
	
	retryInterval := str.Integer;
	
	if 	retryInterval < 1 then
		
		retryInterval := 5;
		
		app.setProfileString(app.getIniFileName, CN_JSMDATABASEBACKUP, CN_COMMITCOHERENTBACKUP_RETRY_INTERVAL, "5");//5 min between retries
	endif;
	
	return retryInterval;
end;
}
getCompactLog
{
getCompactLog() : JadeLog;

vars
	log		: JadeLog;
	ts		: TimeStamp;
	cc		: CnCntrl;
begin
	cc	:= app.myCnCntrl;
	create log transient;
	log.filePath		:= cc.logPath;
	log.fileName		:= "cn_compact_" & ts.date.cnUserFormat($CnCCYYMMDD_ns) & ".log";
	log.versionFile		:= false;
	log.formatOutput	:= false;
	log.bufferOutput	:= true;
    return log;
end;
}
getCurrentJournalNumber
{
getCurrentJournalNumber(pFileName : String);
/*
	Purpose :
	
	Similar to 'getAbortJournalNumber' in that a file is output but the file will contain the current journal being acted on
	
	This method is used for direct, off-line execution from JADLOADB during deployments, backups etc
	
	Execution command line:
		jadloadb.exe 
			ini=<ini file> 
			path=<systempath> 
			schema=CardSchema
			app=KCDeployMgr 
			executeSchema=CardSchema
			executeClass=CnDatabaseAdmin
			executeMethod=getCurrentJournalNumber
			executeParam=<fileName>
*/
vars
	file	: File;
	dba		: JadeDatabaseAdmin;
begin
	create dba transient;
	create file transient;
	file.mode := file.Mode_Input;
	file.fileName	:= pFileName;
	if file.isAvailable then
		file.readOnly	:= false;
		file.purge();
	endif;
	
	file.mode := file.Mode_Output;
	file.writeLine(dba.getCurrentJournalNumber().String.padLeadingZeros(2));
epilog
	delete file;
	delete dba;
end;
}
getElapsedTime
{
getElapsedTime() : String updating;

vars
	ts		: TimeStamp;
	
	tsi		: TimeStampInterval;
begin
	endNotificationForSubscriber(self);

	tsi		:= ts - self.startTime;
	return tsi.cnFormatted();
end;
}
getLogNumberFromFileName
{
getLogNumberFromFileName(str : String) : Integer;

vars
	s	: String;
	pos	: Integer;		
begin
	pos		:= str.pos(".log", 1);
	if pos = null then
		pos		:= str.pos(".lo_", 1);
	endif;
	
	return str[pos - 10 : 10].Integer;
end;
}
globalBackupExceptionHandler
{
globalBackupExceptionHandler(exObj : Exception) : Integer updating;

vars
	msg			: CnBackupAdvice;
	str			: String;
	errorCode	: Integer;
	cc			: CnCntrl;
begin
	cc := app.myCnCntrl;
	errorCode := exObj.errorCode;
	if errorCode = Cn_ObjectLocked then		// PAR 517 - if 1027 (Object Locked) pass back so lock can be 
		return Ex_Pass_Back;				// PAR 517 - retried by globalLockExceptionHandler
	endif;									// PAR 517
	
	str		:= "Unexpected exception in application " & cc.appName & " : UE " & errorCode.String & " (" & exObj.text & ").";
	msg 	:= createBackupAdviceMessage(msg.Advice_Type_Backup_Failed);
	msg.setErrorText(str);
	msg.sendMessage(null);
	delete msg;
	
	self.terminateManagedBackup(str, Backup_Failed);																			// PAR 1016
	return Ex_Pass_Back;
end;
}
globalCompactExceptionHandler
{
globalCompactExceptionHandler(exObj : Exception) : Integer updating;

vars
	msg		: CnCompactAdvice;
	str		: String;
	cc		: CnCntrl;
begin
	cc := app.myCnCntrl;
	str		:= "Unexpected exception in application " & cc.appName & " : UE " & exObj.errorCode.String & " (" & exObj.text & ").";
	msg 	:= createCompactAdviceMessage(msg.Advice_Type_Compact_Failed);
	msg.setErrorText(str);
	msg.sendMessage(null);
	delete msg;

	return Ex_Pass_Back;
end;
}
handle3004Exception
{
handle3004Exception(exObj : Exception; error : Boolean output; errText : String output) : Integer;

vars
	str		: String;
begin
	if exObj.errorCode <> 3004 then
		return Ex_Pass_Back;
	endif;
	
	errText		:= "UE 3004 (internal) : unmapped database : possible cause is that this is a new RPS node and the RPS datapump " &
				   "has not yet been run. Map file list cannot be formed : backup will fail.  Start RPS datapump then try again.";
	app.cnManagerLog(errText);
	error		:= true;
	return Ex_Resume_Next;
end;
}
handle3036Exception
{
handle3036Exception(pExObj : Exception; pHadError : Boolean output) : Integer;

vars

begin
	pHadError := (pExObj.errorCode = Cn_DatabaseFileReqdNotFound);		// 3036			// NFS 578
	if pHadError then																	// NFS 578
		return Ex_Resume_Next;															// NFS 578
	endif;																				// NFS 578
	
	return Ex_Pass_Back;																// NFS 578
end;
}
handleObjectNotFoundException
{
handleObjectNotFoundException(exObj : Exception) : Integer;

vars

begin
	if exObj.errorCode = 4 then
		return Ex_Abort_Action;
	else
		return Ex_Pass_Back;
	endif;
end;
}
handleVerifyJournalException
{
handleVerifyJournalException(pExObj : Exception; pHadError : Boolean output) : Integer updating;

vars

begin
	if pExObj.errorCode > 3000 and pExObj.errorCode < 3399 then	// database engine errors
		errorText	:= pExObj.text;
		errorCode	:= pExObj.errorCode;
		pHadError	:= true;
		abortTransientTransaction;
		abortTransaction;
		return Ex_Resume_Next;
		
	else
		return Ex_Pass_Back;
	endif;
end;
}
locateJournal
{
locateJournal(pFile 			: File input;
			  pJournalNumber	: Integer;
			  pCurrent,
			  pArchive			: String;
			  pPath				: String output) : Boolean;
constants
	Max_Tries		: Integer		= 10;
	Sleep_Period	: Integer		= 15 * 1000; // 15 secs
vars
	cc				: CnCntrl;
	
	try				: Integer;
begin
	cc				:= app.myCnCntrl;
	pFile.mode		:= pFile.Mode_Input;
	foreach try in 1 to Max_Tries do
		pFile.fileName := pCurrent & CN_BACK_SLASH & "db" & pJournalNumber.String.padLeadingZeros(10) & ".log";
		if pFile.isAvailable() then
			pPath := pCurrent;
			return true;
		endif;
		
		if pCurrent <> pArchive then
			pFile.fileName := pArchive & CN_BACK_SLASH & "db" & pJournalNumber.String.padLeadingZeros(10) & ".log";
			if pFile.isAvailable() then
				pPath := pArchive;
				return true;
			endif;
		endif;
		
		pFile.fileName := pCurrent & CN_BACK_SLASH & "db" & pJournalNumber.String.padLeadingZeros(10) & ".lo_";
		if pFile.isAvailable() then
			pPath := pCurrent;
			return true;
		endif;
	
		if pCurrent <> pArchive then
			pFile.fileName := pArchive & CN_BACK_SLASH & "db" & pJournalNumber.String.padLeadingZeros(10) & ".lo_";
			if pFile.isAvailable() then
				pPath := pArchive;
				return true;
			endif;
		endif;
		
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " unable to locate journal " & pJournalNumber.String & " in paths " & pCurrent & " and " & pArchive & ", try #" & try.String, null);
		process.sleep(Sleep_Period);
	endforeach;
	
	return false;
end;
}
logAndTerminateBackup
{
logAndTerminateBackup(errorText : String) updating;

vars
 	cc	: CnCntrl;
begin
	cc	:= app.myCnCntrl;
 	app.cnManagerLog(errorText);
 	app.cnManagerLog("SYSTEM BACKUP FAILED <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
	raiseAlert("System backup failed : " & errorText, true);
	cc.cnWriteLog(cc.CnLogErrors, "ERROR: System backup failed, reason=" & errorText, null);
	finalizeAndTerminate;
end;
}
logAndTerminateCompact
{
logAndTerminateCompact(errorText : String) updating;

vars
 	cc	: CnCntrl;
begin
	cc	:= app.myCnCntrl;
 	app.cnManagerLog(errorText);
 	app.cnManagerLog("SYSTEM COMPACTION FAILED <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");
	raiseAlert("System compaction failed : " & errorText, false);
	cc.cnWriteLog(cc.CnLogErrors, "ERROR: System compaction failed, reason=" & errorText, null);
	finalizeAndTerminateCompact();
end;
}
managedBackup
{
managedBackup() updating;

vars
	cc						: CnCntrl;
	
	jdba					: CnJadeDatabaseAdmin;
	
	kc 						: CnKarmaCntrl;

	dbFile					: DbFile;
	
	ff						: FileFolder;
	
	error,
	lockedForReorg			: Boolean;

	partitionedFileCount,
	partitionThreads,
	pos						: Integer;

	backupType,
	errText,
	rootDir,
	str						: String;
begin
	//	This is executed by the KCOnLineBackup (controlling) thread.  This class was significantly
	//  reworked for CardSchema 2.9, to provide multi-threaded backups.
	//
	kc 		:= app.myCnKarmaCntrl;
	cc 		:= app.myCnCntrl;

	on Exception do self.globalBackupExceptionHandler(exception) global;			// send BackupAdvice message (Backup_Failed)
	on Exception do self.handle3004Exception(exception, error, errText);							// RPS node not unmapped

	beginTransientTransaction;		// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	
	self.isManaged := true;
	
	if quiesce then 
		backupType := "On-Line (quiesced)";
	else
		backupType	:= "On-Line";
	endif;
	
	str		:= "--------------  Starting Managed " & backupType & " Backup for " & app.actualTime.date.String & "  ----------------------";
	cc.cnWriteLog(cc.CnLogComment, str, null);
	app.cnManagerLog(str);
	app.cnManagerLog(" ");
	app.cnManagerLog("CardSchema version is " & app.cnGetCardSchemaVersion());
	app.cnManagerLog("Backup is being taken on " & app.cnComputerName & " for environment " & kc.environmentId.toUpper & ".");
	app.cnManagerLog("Preparing destination directories to receive backup ...");

	if app.cnOSPlatformIsWindows then
		pos := backupRootDir.reversePos("/");
	    if pos = 0 then
	    	pos := backupRootDir.reversePos("\");
	    endif;
	
		if pos > 3 then
			terminateManagedBackup("Backup root directory '" & backupRootDir & "' not valid : cannot be multi-level, must be root.", Backup_Failed);
		endif;

		rootDir	:= kc.driveLetter & ":/" & kc.environmentId;				// Application root directory
	else
		if backupRootDir = null then
			terminateManagedBackup("Backup root directory not specified.", Backup_Failed);
		endif;
			
		rootDir := app.cnApplicationRootDir & kc.environmentId;							// Application root directory
	endif;	

	if app.cnConvertPathNameToFwdSlashes(backupRootDir.toLower) = rootDir.toLower then
		str :=  "Backup root directory '" & backupRootDir & "' not valid : cannot be same as application root directory.";
		terminateManagedBackup(str, Backup_Failed);
	endif;	

	if app.cnOSPlatformIsWindows then
		backupDir			:= backupRootDir & "/" & kc.environmentId & "/server/c_system";
	else
		backupDir			:= backupRootDir & "/system";				// Unix
	endif; 
	
	create ff transient;
	ff.fileName				:= backupDir;			// directory for database backup output	: should have been created by KarmaBackupMgr				
	if not ff.isAvailable then
		str := "Backup destination directory '" & backupDir & "' is not available - backup failed.";
		terminateManagedBackup(str, Backup_Failed);
	endif;
	
	enableArchiveRecovery	:= app.getProfileStringAppServer(app.getIniFileNameAppServer, "PersistentDb", "EnableArchivalRecovery", "false").Boolean;                               
	app.cnManagerLog(" ");
	app.cnManagerLog("----   Starting managed on-line backup of database files : backupDir=" &  backupDir & "   ----");
	app.cnManagerLog("Parameters : CompressFiles=" & self.compressFiles.String &
						", AllowOverwriteFiles=" & self.overwriteFiles.String &
						", Quiesce=" & self.quiesce.String &
						", Workers=" & backupWorkers.String &
						", CommitCoherent=" & self.commitCoherentBackup.String &											// 7055
						", MustBeCommitCoherent=" & self.mustBeCommitCoherentBackup.String);								// 7055
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_DatabaseLockedForReorganize, null, lockedForReorg);
	create jdba transient;						
	self.zBackupCommonSetAbortJournalEnterBackupState(jdba);
	if lockedForReorg then
		terminateManagedBackup("Unable to perform backup as database is locked for reorganization.", Backup_Failed);
		abortTransientTransaction;
		return;
	endif;

	self.zBackupCommonGetStructDetails();
	commitTransientTransaction;
	
	partitionedFileCount := self.allPartitionedDbFiles.size();
	app.cnManagerLog(partitionedFileCount.String & " partition controlfiles and indexes to back up.");						// PAR 1109
	if partitionedFileCount > 0 then
		partitionThreads := partitionedFileCount.min(self.backupWorkers);
		self.zBackupCommonInitiatePartitionWorkers(partitionThreads);
		//execution of database files will be invoked when partition workers complete.
	
	else
		self.zBackupCommonSubscribeNotify(jdba);
		self.zBackupCommonInitiateWorkers();
	endif;		
epilog
	delete ff;
	delete jdba;	
	if process.isInExceptionState and app.cnMyBackupLog <> null then
		terminateManagedBackup("Exception occurred in CnDataseAdmin::managedBackup : see logs and stack dump.", Backup_Failed);
	endif;
end;
}
managedCompact
{
managedCompact() updating;

vars
	msg						: CnCompactAdvice;
	
	cc						: CnCntrl;
	
	cnDatabaseStructure		: CnDatabaseStructure;
	
	cndba,
	jdba					: CnJadeDatabaseAdmin;
	
	kc 						: CnKarmaCntrl;
	
	dbFile					: DbFile;

	ff						: FileFolder;
	
	iterDbFile,
	iterExclude,
	iterStatus,
	iterLength,
	iterUDRLength			: Iterator;

	proc					: Process;
	
	dbFileExcludeFromCompact: BooleanArray;
	
	dbFileNames,
	structureNamesArray		: CnStringArray;
	
	dbFileArray				: DbFileArray;
	
	dbFileStatus 			: IntegerArray;
	
	dbFileLengths,
	dbFileUDRLengths,
	structureLengthsArray	: Integer64Array;
	
	badObject,
	error,
	fileExclude				: Boolean;

	fileStatus,
	i,
	int,
	statusResident,
	x						: Integer;
	
	fileSize,
	totalSize,
	udrFileSize				: Integer64;

	str,
	result,
	rootDir,
	errText,
	dbFileName				: String;

begin
	//	This is executed by the KCOnLineCompact (controlling) thread.
	//
	kc 				:= app.myCnKarmaCntrl;
	cc 				:= app.myCnCntrl;
	statusResident 	:= DbFile.Status_Resident;

	on Exception do self.globalCompactExceptionHandler(exception) global; // send CompactAdvice message (Compact_Failed)
	on Exception do self.handle3004Exception(exception, error, errText);  // RPS node not unmapped
	
	beginTransientTransaction; // <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
		
	str		:= "--------------  Starting Online Compaction for " & app.actualTime.date.String & "  ----------------------";
	cc.cnWriteLog(cc.CnLogComment, str, null);
	app.cnManagerLog(str);
	app.cnManagerLog(" ");
	app.cnManagerLog("CardSchema version is " & app.cnGetCardSchemaVersion());
	app.cnManagerLog("Compaction is being performed on " & app.cnComputerName & " for environment " & kc.environmentId.toUpper & ".");

	if app.cnOSPlatformIsWindows then
		rootDir	:= kc.driveLetter & ":/" & kc.environmentId;				// Application root directory
	else
		rootDir := app.cnApplicationRootDir & kc.environmentId;				// Application root directory
	endif;	
	
	enableArchiveRecovery	:= app.getProfileStringAppServer(app.getIniFileNameAppServer, "PersistentDb", "EnableArchivalRecovery", "false").Boolean;                               
	app.cnManagerLog(" ");
	app.cnManagerLog("----   Starting on-line compaction of database files   ----");
	app.cnManagerLog("Parameters : Workers=" & self.compactWorkers.String);
						
	create jdba transient;
	create structureNamesArray transient;
	create structureLengthsArray transient;

	create cndba transient;
	create dbFileNames 				transient;
	create dbFileArray				transient;
	create dbFileExcludeFromCompact	transient;
	create dbFileStatus 			transient;
	create dbFileLengths 			transient;
	create dbFileUDRLengths 		transient;
	result := cndba.getAllDbFileInfo(	dbFileNames, 						
										dbFileArray,
										dbFileStatus, 
										null, 							// dbfile kind
										null,							// dbfile location
										dbFileExcludeFromCompact, 
										dbFileLengths, 
										dbFileUDRLengths,
										null,							// dbfile ispartitioned
										null,							// dbfile partition count
										null,							// dbfile modified timestamp
										null,							// dbfile backup timeStamp
										null);							// dbfile full backup timeStamp
	if result <> CN_OK then
		terminateCompact(result, Compact_Failed);
	endif;
	
	app.cnManagerLog("Candidate files for compaction are :-");
	iterDbFile		:= dbFileArray.createIterator();
	iterExclude		:= dbFileExcludeFromCompact.createIterator();
	iterStatus		:= dbFileStatus.createIterator();
	iterLength		:= dbFileLengths.createIterator();
	iterUDRLength	:= dbFileUDRLengths.createIterator();
	foreach dbFileName in dbFileNames do
		iterDbFile.next(dbFile);
		iterExclude.next(fileExclude);
		iterStatus.next(fileStatus);
		iterLength.next(fileSize);
		iterUDRLength.next(udrFileSize);
		str := Tab & dbFileName.padBlanks(32);

		if not self.compactStructureNames.includes(dbFileName) then
			continue;
		endif;
				
		if fileExclude then
			str := str & ">>> exclude from compact <<<";
			app.cnManagerLog(str);
			continue;
		endif;
		
		if fileStatus <> statusResident then		// RPS working set
			str := str & ">>> not resident (fileStatus=" & fileStatus.String & ") <<<";
			app.cnManagerLog(str);
			continue;
		endif;
		
		if fileSize = null then
			str := str & ">>> added to dropped files list (file length = 0)  <<<";
			app.cnManagerLog(str);
			continue;
		endif;

		create cnDatabaseStructure sharedTransient;
		cnDatabaseStructure.size				:= fileSize;	// so we can order the files by size
		cnDatabaseStructure.name				:= dbFileName;
		cnDatabaseStructure.myDbFile			:= dbFile;
		cnDatabaseStructure.myCnDatabaseAdmin	:= self;
		str := str & fileSize.cnConvertToByteString();
		if udrFileSize > null then
			str := str & "  (UDR=" & udrFileSize.cnConvertToByteString() & ")";
		endif;
				
		app.cnManagerLog(str);
	endforeach;

	if self.compactWorkers = 0 then
		self.compactWorkers	:= 1;
	endif;

	// compaction of mapfiles includes any paritions.
	// there is no compaction facility for partitions by themselves.
	foreach cnDatabaseStructure in self.allCnDatabaseStructuresBySize do			// collection ordered by decreasing map file size
		self.allCnDatabaseStructuresForThreading.add(cnDatabaseStructure);
		structureNamesArray.add(cnDatabaseStructure.name);					// now these are ordered we can populate our arrays to be sent back to JSA
		structureLengthsArray.add(cnDatabaseStructure.size.Integer64);
		totalSize := totalSize + cnDatabaseStructure.size.Integer64;
	endforeach;

	commitTransientTransaction;		// <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
	
	if structureNamesArray.isEmpty() then
		terminateCompact("None of the mapfiles requested were suitable for compaction. Operation aborted.", Compact_Failed);
		return;
	endif;
	
	self.setupProgressEventInterval(jdba); // 3.0 : set up progress event interval based on largest map file				
	
	beginClassNotification(CnDatabaseAdmin, true, jdba.File_Compact_Start_Event, 0, Cn_JDB_Managed_Tag);
	beginClassNotification(CnDatabaseAdmin, true, jdba.File_Compact_Complete_Event, 0, Cn_JDB_Managed_Tag);
	beginClassNotification(CnDatabaseAdmin, true, jdba.Compact_Failed_Event, 0, Cn_JDB_Managed_Tag);
	beginClassNotification(CnDatabaseAdmin, true, jdba.Compact_Worker_Completed_Event, 0, Cn_JDB_Managed_Tag);
	
	// NOTE: CompactProgressEvent at time of coding does not exist in the RootSchema::DbFile class - See JADE NFS 48308
	// beginClassNotification(DbFile, false, DbFile.CompactProgressEvent,0, Cn_JDB_Managed_Tag); // 1000
	
	beginNotification(system, CN_COMPACTION_STOP_REQUESTED, 0 , Cn_JDB_Managed_Tag); 
	beginNotification(system, CN_COMPACTION_ABORT_REQUESTED, 0 , Cn_JDB_Managed_Tag);

	msg := createCompactAdviceMessage(msg.Advice_Type_Compact_Starting);
	structureNamesArray.copy(msg.mapFileNames);
	app.cnManagerLog("Mapfile names = " & structureNamesArray.size64().String);
	structureLengthsArray.copy(msg.mapFileSizes);
	app.cnManagerLog("Mapfile lengths = " & structureLengthsArray.size64().String);
	msg.sendMessage(null);
	delete msg;

	app.cnManagerLog("Initiating on-line compaction threads (KCOnLineCompactWorker) for " & self.compactWorkers.String & " workers : parsing " & self.String & ".");
	
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_AttemptedAccessViaNullRef, null, badObject);	// handle 1090 which can occur (licence restriction, out of memory etc)
	foreach int in 1 to self.compactWorkers do
		proc := null;			// need to initialize as failure to start the process (eg licence exceeded) causes proc to be left as last found
		proc := app.startApplicationWithParameter(CN_CARDSCHEMA, CN_KCONLINECOMPACTWORKER, self);
		// check if valid object
		x := proc.edition;
		if badObject then
			i := i + 1;
			badObject := false;
			continue;
		endif;
		
		beginNotification(proc, Object_Delete_Event, 0, Cn_Compact_Process_Deleted); 
		beginTransientTransaction;
		processSet.add(proc);
		commitTransientTransaction;
		process.sleep(500);
	endforeach;

	if processSet.isEmpty() then
		self.terminateCompact("No compaction workers were started, possibly exceeded licences allowed, please check logs.", Compact_Failed);
		return;
	endif;

	if i > 1 then	// if we failed to start any compact processes then issue alert
		app.cnRaiseJossAlert(Cn_Karma_Alert,
		 	                 "Detected failure to start compact workers for " & kc.environmentId.toUpper() & " on " & app.cnComputerName & ".",
	 						 i.String & " copies of KCOnlineCompactWorker failed to start for JADE environment " &
							 kc.managedEnvironmentName.toUpper() & " on " & app.cnComputerName & ". Possibly licences allowed has been exceeded. Please check logs for reason.",
	 						 "N",
	 						 app.actualTime,
	 						 app.name,
	 						 kc.managedEnvironmentName,
	 						 app.cnComputerNameAppServer,
	 						 null,
 						 	 null);
	endif;

epilog
	delete ff;
	delete jdba;
	delete dbFileArray;
	delete structureNamesArray;
	delete structureLengthsArray;
	delete cndba;
	delete dbFileNames;
	delete dbFileExcludeFromCompact;
	delete dbFileStatus;
	delete dbFileLengths;
	delete dbFileUDRLengths;
	delete iterDbFile;
	delete iterExclude;
	delete iterStatus;
	delete iterLength;
	delete iterUDRLength;
	delete cndba;
	if process.isInExceptionState and app.cnMyCompactLog <> null then
		terminateCompact("Exception occurred in " & method.cnGetMethodName() & " : see logs and stack dump.", Compact_Failed);
	endif;
end;
}
moveFile
{
moveFile(sourceFile, destFile : String; overWrite : Boolean) : Boolean;

vars
	result		: Integer;
	cc			: CnCntrl;
	int			: Integer;
	str			: String;
	errortext 	: String;
	kc			: CnKarmaCntrl;
	file		: File;
	cem			: CnExternalMethods;
begin
	cc 		:= app.myCnCntrl;
	kc		:= app.myCnKarmaCntrl;
	create file transient;
	result 	:= file.emMoveFileEx(sourceFile, destFile, overWrite.Integer);		// 1 = Overwrite
    str		:= "Move of " & sourceFile & " to " & destFile;

	if result = null then 
 		app.cnManagerLog(str & " was successful"); 	
 		return true;
	endif;
	
	create cem transient;
	int	:= cem.emGetErrorText(result, errortext, 127);
	if int <> null then
		app.cnManagerLog("CnExternalMethods::emGetErrorText got error result=" & int.String);
	endif;
	
	str := str & " not done : result=" & result.String & ":" & errortext;
	app.cnManagerLog(str);
	return false;
epilog
	delete cem;
	delete file;
end;
}
nonManagedMultiWorkerBackup
{
nonManagedMultiWorkerBackup(pDatabaseRole : Integer) updating;

constants
	DatabaseFiles				: String = "/_databasefiles";
vars
	kc							: CnKarmaCntrl;
	
	cc							: CnCntrl;	
	
	jdba						: CnJadeDatabaseAdmin;
	
	ff,
	ffSys						: FileFolder;

    allowMultiLevelBackupDir,
	backupSysFiles,																												// PAR 620
	error,
	enableArchiveRecoveryLocal,
	ignoreEnableArchiveRecovery,
	lockedForReorg				: Boolean;

	partitionedFileCount,
	partitionThreads,
	pos							: Integer;
	
	str,
	envId,
	result,
	errText,
	sys_Dir,
	envNode,
	root_Dir,
	jadeDbPath,
	iniFileName,
	jadeInstallPath,
	stateOverflowDirStr			: String;
	
begin
	cc 		:= app.myCnCntrl;
	kc 		:= app.myCnKarmaCntrl;
	envId	:= self.environmentId;

	on Exception do self.globalBackupExceptionHandler(exception) global;			// send BackupAdvice message (Backup_Failed)
	on Exception do self.handle3004Exception(exception, error, errText);			// RPS node not unmapped
	
	app.cnManagerLog("Backup is being taken on " & app.cnComputerName & " for environment " & envId.toUpper & ".");
	iniFileName := app.getIniFileNameAppServer();
	ignoreEnableArchiveRecovery := app.getProfileStringAppServer(iniFileName, 
																CN_KCDATABASEBACKUP, 
																CN_IGNORENABLEARCHIVALRECOVERY, 
																false.String).Boolean;
	enableArchiveRecoveryLocal	:= app.getProfileStringAppServer(iniFileName, 
																CN_PERSISTENTDB, 
																CN_ENABLEARCHIVALRECOVERY, 
																true.String).Boolean;               							// PAR 878

	if ignoreEnableArchiveRecovery then
		app.cnManagerLog(CN_IGNORENABLEARCHIVALRECOVERY & " is TRUE, " & CN_ENABLEARCHIVALRECOVERY & " restriction will be ignored.");
	
	else
		if enableArchiveRecoveryLocal = false then
			str :=  "EnableArchivalRecovery is set to FALSE in this applications [PersistentDb] section, this is not permitted. Backup terminated.";
			logAndTerminateBackup(str);		
		endif;
	endif;
	
	app.cnManagerLog("----   Preparing destination directories to receive backup   ----");
	if self.backupRootDir = null then				// if params have been parsed by a user this will never be null, if the value is taken
		if pDatabaseRole <> SDS_RoleSecondary then	// from the ini file then it could be, for this reason the logged error below is valid
			beginTransaction;
			node.userExitCode := 1;
			commitTransaction;
		endif;
		logAndTerminateBackup("BackupDirectory not specified in [" & CN_KCDATABASEBACKUP & "] section of .ini file - backup failed.");
	endif;

    allowMultiLevelBackupDir := app.getProfileStringAppServer(iniFileName, CN_KCDATABASEBACKUP, CN_ALLOWMULTILEVELBACKUPDIR, false.String).Boolean;
    if not allowMultiLevelBackupDir then
        pos := self.backupRootDir.reversePos(CN_SLASH);
        if pos = 0 then
            pos := self.backupRootDir.reversePos(CN_BACK_SLASH);
        endif;

		if pos > 3 then
			if pDatabaseRole <> SDS_RoleSecondary then
				beginTransaction;
				node.userExitCode := 1;
				commitTransaction;
			endif;
			
			self.logAndTerminateBackup("Backup root directory '" & self.backupRootDir & "' not valid : cannot be multi-level, must be root.");
		endif;
	endif;

	root_Dir := app.cnGetRootDirectory(envId);
	if app.cnConvertPathNameToFwdSlashes(self.backupRootDir.toLower()) = root_Dir.toLower() then
		if pDatabaseRole <> SDS_RoleSecondary then	
			beginTransaction;
			node.userExitCode := 1;
			commitTransaction;
		endif;
		str :=  "Backup root directory '" & self.backupRootDir & "' not valid : cannot be same as application system directory.";
		logAndTerminateBackup(str);
	endif;	

	sys_Dir		:= app.dbPath().toLower();
	sys_Dir.replaceChar(CN_BACK_SLASH, CN_SLASH);						// for linux compatibility
	jadeDbPath	:= sys_Dir[1 : sys_Dir.reversePos(CN_SLASH)].toLower();
	sys_Dir 	:= sys_Dir[sys_Dir.reversePos(CN_SLASH) : end];
	
	// if the 'system' folder has been placed outside of the environment node structure we need to check that it doesn't still exist
	// under the envirvonment node, failure to do this could be potentially dangerous as we would end up with a 'system' folder in
	// the final backup location containing a mix of files between the real 'system' folder and the 'system' folder left under the
	// environment node
	envNode			:= app.getJadeInstallDir();
	envNode.replaceChar(CN_BACK_SLASH, CN_SLASH);						// for linux compatibility
	jadeInstallPath	:= envNode[1 : envNode.reversePos(CN_SLASH)].toLower();
	jadeInstallPath := jadeInstallPath[1 : jadeInstallPath.length - 1];
	
	create ff transient;
	if jadeDbPath <> jadeInstallPath & CN_SLASH then
		// the 'system' files are not under the environment node like the non-database files, this means we need to execute
		// self.zBackupRemainingFilesInSystem so we will set a boolean on self.backupRemainingFilesInSystem
		backupSysFiles := true;																									// PAR 620
		ff.fileName	:= jadeInstallPath & sys_Dir;
		if ff.isAvailable() then
			str := jadeInstallPath & sys_Dir & " exists yet the actual database files are located in " & app.dbPath() & ", this is dangerous and is not permitted. Backup terminated.";
			logAndTerminateBackup(str);	
		endif;
	endif;
	
	beginTransientTransaction;
	self.backupRemainingFilesInSystem := backupSysFiles;																		// PAR 620
	self.enableArchiveRecovery := enableArchiveRecoveryLocal;
	self.backupRootDir.replaceChar(CN_BACK_SLASH, CN_SLASH);			// for linux compatibility	
 	if not app.cnValidateBackupPath(self.backupRootDir, pDatabaseRole) then
		if pDatabaseRole <> SDS_RoleSecondary then
			beginTransaction;
			node.userExitCode := 1;
			commitTransaction;
		endif;
		
		self.terminateManagedBackup("Backup root directory '" & self.backupRootDir & "' is not available - backup failed." , self.Backup_Failed);
	endif;

	self.backupDir := app.cnGetBackupPathDatabase(backupRootDir, envId, sys_Dir, DatabaseFiles);
	ff.fileName := self.backupDir;
	if ff.isAvailable() then
		result := app.myCnBackup.removeDirectory(self.backupRootDir & CN_SLASH & envId);
		if result <> CN_OK then
	  		terminateManagedBackup(result & ". Please remove files manually." , Backup_Failed);
		endif;
	endif;

	ff.make();
	app.cnManagerLog("New directory " & ff.fileName & " created.");

	overwriteFiles		:= true;
	self.databaseDirectory	:= app.cnStandardizePathName(app.dbPath).toLower();
	self.databaseDirectory	:= self.databaseDirectory.cnStripTrailingSlash();
	app.cnManagerLog("DatabaseDirectory is '" & self.databaseDirectory & "'.");	
	
	stateOverflowDirStr	:= app.getProfileStringAppServer(iniFileName, CN_PERSISTENTDB, CN_STATEOVERFLOWDIRECTORY, null).toLower();
	
	if stateOverflowDirStr = null then
		stateOverflowDirStr := app.dbPath & "/pdb_osm";
		app.cnManagerLog("[" & CN_PERSISTENTDB & "] " & CN_STATEOVERFLOWDIRECTORY & " defaulting to " & stateOverflowDirStr);
	
	else
		app.cnStandardizePathName(stateOverflowDirStr);
		app.cnManagerLog("[" & CN_PERSISTENTDB & "] " & CN_STATEOVERFLOWDIRECTORY	& "=" & stateOverflowDirStr);
		if stateOverflowDirStr.length > 3 and
			stateOverflowDirStr[2:2] = ":/" then					// we appear to have a full path name
			// do nothing
		
		else
			if 	stateOverflowDirStr [1:1] = CN_SLASH or 
				stateOverflowDirStr [1:1] = CN_BACK_SLASH then
				stateOverflowDirStr := stateOverflowDirStr[2:end];
			endif;

			stateOverflowDirStr := app.dbPath & CN_SLASH & stateOverflowDirStr;
			app.cnManagerLog("relative " & CN_STATEOVERFLOWDIRECTORY	& ", derived directory '" & stateOverflowDirStr & "'");
		endif;
	endif;
	
	self.stateOverflowDirectory	:= app.cnStandardizePathName(stateOverflowDirStr).toLower();
	app.cnManagerLog("StateOverflowDirectory is now defined as '" & stateOverflowDirectory & "'.");	

	app.cnManagerLog(" ");
	app.cnManagerLog("----   Starting Multi Worker Backup of database files : backupDir=" &  backupDir & "   ----");
	app.cnManagerLog("Parameters : IncludeSystemFiles=" & false.String & 
						", verifyFiles=" & true.String &
						", CompressFiles=" & self.compressFiles.String &
						", AllowOverwriteFiles=" & self.overwriteFiles.String &
						", Quiesce=" & self.quiesce.String);

	create jdba sharedTransient;
	self.setMyDba(jdba);
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_DatabaseLockedForReorganize, null, lockedForReorg);
	self.zBackupCommonSetAbortJournalEnterBackupState(jdba);
	if lockedForReorg then
		logAndTerminateBackup("Unable to perform backup as database is locked for reorganization.");
		abortTransientTransaction;
		return;
	endif;
	
	self.zBackupCommonGetStructDetails();
	commitTransientTransaction;
	
	partitionedFileCount := self.allPartitionedDbFiles.size();
	
	if partitionedFileCount > 0 then
		partitionThreads := partitionedFileCount.min(self.backupWorkers);
		self.zBackupCommonInitiatePartitionWorkers(partitionThreads);
		//execution of database file workers will be invoked when partition workers complete.
	else
		self.zBackupCommonSubscribeNotify(jdba);
		self.zBackupCommonInitiateWorkers();
	endif;
epilog
	delete ff;
	delete ffSys;
	if process.isInExceptionState and app.cnMyBackupLog <> null then
		if pDatabaseRole <> SDS_RoleSecondary then
			beginTransaction;
			node.userExitCode := 1;
			commitTransaction;
		endif;
		logAndTerminateBackup("Exception occurred in " & method.cnGetMethodName() & " : see logs and stack dump.");
	endif;
end;
}
prepareBackupDirectories
{
prepareBackupDirectories() : String updating;

vars
	base	: String;
	path	: String;
	kc		: CnKarmaCntrl;
	str		: String;
begin
	kc	 := app.myCnKarmaCntrl;
 	base := backupRootDir & "/" & kc.environmentId.toLower;
 	if app.cnOSPlatformIsWindows then
	    path := base & "/server/c_bin";
	    checkDirectories(path, true);									// check/create all directories on this path
	    checkDirectory(base & "/server/c_system", true);				// if not present, we create
	    checkDirectory(base & "/server/c_misc", true);
	    checkDirectory(base & "/client/c_bin", true);
	    checkDirectory(base & "/client/c_schema", true);
	    checkDirectory(base & "/client/c_misc", true);
	    checkDirectory(base & "/server/o_bin", true);
	    checkDirectory(base & "/server/o_system", true);					
	    checkDirectory(base & "/server/o_misc", true);
	    checkDirectory(base & "/client/o_bin", true);
	    checkDirectory(base & "/client/o_schema", true);
	    checkDirectory(base & "/client/o_misc", true);
	    checkDirectory(base & "/server/n_bin", true);
	    checkDirectory(base & "/server/n_system", true);					
	    checkDirectory(base & "/server/n_misc", true);
	    checkDirectory(base & "/client/n_bin", true);
	    checkDirectory(base & "/client/n_schema", true);
	    checkDirectory(base & "/client/n_misc", true);
	    checkDirectory(base & "/journals/current", true);
	else
		path := base & "/bin";
	    checkDirectories(path, true);						// check/create all directories on this path
	    checkDirectory(base & "/system", true);				// if not present, we create
	    checkDirectory(base & "/misc", true);
	    checkDirectory(base & "/lib", true);
	    checkDirectory(base & "/client/bin", true);
	    checkDirectory(base & "/client/schema", true);
	    checkDirectory(base & "/client/misc", true);
	    checkDirectory(base & "/old/bin", true);
	    checkDirectory(base & "/old/system", true);					
	    checkDirectory(base & "/old/misc", true);
	    checkDirectory(base & "/old/lib", true);
	    checkDirectory(base & "/client/old/bin", true);
	    checkDirectory(base & "/client/old/schema", true);
	    checkDirectory(base & "/client/old/misc", true);
	    checkDirectory(base & "/server/new/bin", true);
	    checkDirectory(base & "/server/new/system", true);					
	    checkDirectory(base & "/server/new/misc", true);
	    checkDirectory(base & "/new/lib", true);
	    checkDirectory(base & "/client/new/bin", true);
	    checkDirectory(base & "/client/new/schema", true);
	    checkDirectory(base & "/client/new/misc", true);
	    checkDirectory(base & "/journals/current", true);
	endif;

    str := "Directory checks done : backup root directory will be '" & base & "'";
    app.cnManagerLog(str);

    on FileException do kc.fileExceptionHandler(exception);
    kc.setHadFileException(false);
    kc.setFileRetryNo(0);

    if not removeFilesFromDirectory(base) then
    	return "Unexpected error removing files from directory or sub-directory '" & base & "'.";
    endif;

    if kc.hadFileException then
    	return "Problem removing file from directory : file=" & kc.exceptionFileName & ", error=" & kc.exceptionErrorCode.String;
    endif;

    on FileException do null;

    return CN_OK;
end;
}
raiseAlert
{
raiseAlert(pText : String; pBackupProcess : Boolean) updating;

vars
 	kc 	: CnKarmaCntrl;
 	str	: String;
 	cc	: CnCntrl;
begin
	kc 	:= app.myCnKarmaCntrl;
	cc	:= app.myCnCntrl;
	if pBackupProcess then
		str	:= "System backup problem for ";
		
	else											// other apps that use this class e.g. KCVerifyJournal, KCCMgr
		str	:= "Unexpected error in " & app.name & " for ";
	endif;
	
	str 	:= str & kc.environmentId & " on " & app.cnComputerNameAppServer;

 	if kc.environmentId.toLower.cnContains("joss") then					// communicate with JossCommsMgr
 		cc.cnWriteLog(cc.CnLogDiag, str & " : raising emergency alert now.", null);
 		system.causeEvent(Cn_Joss_Emergency_Alert, true, str & "~" & pText);

	elseif cc.appName[1:5] = "Karma" or
	    cc.appName[1:2] = "KC" then
		cc.cnWriteLog(cc.CnLogDiag, str & " : raising regular (JOSS) alert now.", null);
	 	app.cnRaiseJossAlert( Cn_Karma_Alert
		 	                 ,str
	 						 ,pText
	 						 ,"N"
	 						 ,app.actualTime
	 						 ,cc.appName
	 						 ,kc.managedEnvironmentName
	 						 ,app.cnComputerNameAppServer
	 						 ,null
 						 	 ,null);
	
	else
		cc.cnWriteLog(cc.CnLogDiag, str & " : raising regular alert now.", null);
	 	app.cnRaiseAlert(    str
	 						 ,pText
	 						 ,"N"
	 						 ,app.actualTime
	 						 ,cc.appName
	 						 ,app.cnComputerNameAppServer
	 						 ,null);
	endif;
end;
}
removeFilesFromDirectory
{
removeFilesFromDirectory(dir : String) : Boolean updating;

vars
 	ff 		: FileFolder;
 	file	: FileNode;
begin
	create ff transient;
	ff.fileName := dir;
	if ff.isAvailable then
		foreach file in ff.files do
			if file.isKindOf(File) then
				file.File.readOnly := false;
				file.purge;
			elseif file.cnGetSimpleFileName[1] <> "." then				// detour 5.0.8 bug
				if not removeFilesFromDirectory(file.fileName) then
					return false;
				endif;
			endif;
		endforeach;
	else
		app.cnManagerLog("Invalid directory specified for Server::removeFilesFromDirectory : '" & dir & "'");
		return false;
	endif;

	app.cnManagerLog("All files removed from directory " & dir);

	return true;

epilog
	delete ff;
end;
}
setBackupCompletionText
{
setBackupCompletionText(pValue : String) updating;

vars

begin
	self.backupCompletionText := pValue;
end;
}
setBackupCompletionType
{
setBackupCompletionType(pValue : String) updating;

vars

begin
	self.backupCompletionType := pValue;
end;
}
setBackupRootDir
{
setBackupRootDir(dir : String) updating;

vars

begin
	backupRootDir := dir;
end;
}
setBackupWorkers
{
setBackupWorkers(cnt : Integer) updating;

vars

begin
	self.backupWorkers := cnt;
end;
}
setCancelBackup
{
setCancelBackup(set : Boolean) updating;

vars

begin
	cancelBackup := set;
end;
}
setCommitCoherentBackup
{
setCommitCoherentBackup(pCommitCoherentBackup : Boolean) updating;

vars

begin
	self.commitCoherentBackup := pCommitCoherentBackup;
end;
}
setCompactWorkers
{
setCompactWorkers(pWorkers : Integer) updating;

vars

begin
	self.compactWorkers := pWorkers;
end;
}
setCompressFiles
{
setCompressFiles(set : Boolean) updating;

vars

begin
	self.compressFiles	:= set;
end;
}
setDisableBackupNotify
{
setDisableBackupNotify(pBool : Boolean) updating;
/*
	Only applicable to KCDatabaseBackupMulti. Under most circumstances KCDatabaseBackupMulti will not be updating a
	GUI application yet notifications are still raised to update potential subscribers. If notifications aren't
	required then setting this to TRUE will prevent them being raised during the backup.
	
	NOTE: the default value is:
	
	[KCDatabaseBackup]
	DisableBackupNotifications=false
*/
vars

begin
	self.disableBackupNotify := pBool;
end;
}
setEnvironmentId
{
setEnvironmentId(pValue : String) updating;

vars

begin
	self.environmentId := pValue;
end;
}
setErrorCode
{
setErrorCode(code : Integer) updating;

vars

begin
	self.errorCode := code;
end;
}
setErrorText
{
setErrorText(txt : String) updating;

vars

begin
	self.errorText := txt;
end;
}
setMustBeCommitCoherentBackup
{
setMustBeCommitCoherentBackup(pMustBeCommitCoherentBackup : Boolean) updating;

vars

begin
	self.mustBeCommitCoherentBackup := pMustBeCommitCoherentBackup;
end;
}
setMyCurrentDatabaseEntity
{
setMyCurrentDatabaseEntity(pDbFile : DbFile; pDbPartition : JadeDbFilePartition) updating;

/*
	Only one of these arguments should be provided, the other should always be null.
*/
vars

begin
	self.myCurrentDbFile		:= pDbFile;
	self.myCurrentDbPartition	:= pDbPartition;
end;
}
setMyDba
{
setMyDba(dba : JadeDatabaseAdmin) updating;

vars

begin
 	self.myDba := dba;
end;
}
setQuiesce
{
setQuiesce(set : Boolean) updating;

vars

begin
	self.quiesce	:= set;
end;
}
setScheduleTime
{
setScheduleTime(pScheduleTimeStamp : TimeStamp) updating;

vars

begin
	self.scheduleTimeStamp := pScheduleTimeStamp;
end;
}
setupProgressEventInterval
{
setupProgressEventInterval(jdba : JadeDatabaseAdmin) updating;

	//  This method used for managed compacts
constants
	BYTES_PER_EVENT_UNCOMPRESSED = 2000000;
	BYTES_PER_EVENT_COMPRESSED	= 700000;
vars
	cc			: CnCntrl;
	
	cfile		: String;
	
	len			: Decimal[22];
	
	eventInt	: Integer;
	
	partitionId	: Integer64;
	
	real		: Real;	
	
	obj			: Object;
	
	dbFile		: DbFile;
	
	dbPartition	: JadeDbFilePartition;
begin
	cc			:= app.myCnCntrl;
	
	dbFile 	:= self.allCnDatabaseStructuresBySize.first.myDbFile;
	partitionId := self.allCnDatabaseStructuresBySize.first.partitionId;
	if partitionId = null then
		len		:= dbFile.getFileLength();
		cfile	:= dbFile.getName;
	
	else
		dbPartition := dbFile.getPartition(partitionId);
		len		:= dbPartition.getFileLength();
		cfile	:= dbPartition.getName;
	endif;
	
	if self.compressFiles then
		real	:= len / BYTES_PER_EVENT_COMPRESSED;
	else
		real	:= len / BYTES_PER_EVENT_UNCOMPRESSED;
	endif;
	
	if real > 1 then
		eventInt	:= (100 / real).roundedUp;			// this is the computed progress interval as a percentage of the file
	else
		eventInt	:= 40;
	endif;
	
	if eventInt < 1 then
		eventInt 	:= 1;
	endif;

	jdba.enableProgressEvents(eventInt);				// this is global for the entire backup
	app.cnManagerLog("Progress events enabled based on largest file which is " & cfile & ", length=" & len.String & ", progress increment=" & eventInt.String & "%."); 	
end;
}
simpleBackup
{
simpleBackup() updating;

vars
	kc 					: CnKarmaCntrl;
	cc					: CnCntrl;
	dba					: JadeDatabaseAdmin;
	ff					: FileFolder;
	result				: String;
	str					: String;
	pos					: Integer;
	rootDir				: String;
	iniFileName			: String;
	stateOverflowDirStr	: String;

begin
	kc 		:= app.myCnKarmaCntrl;
	cc 		:= app.myCnCntrl;
	app.cnSetMyBackupLog(getBackupLog());

	str		:= "----------  Starting Simple On-Line Backup for environment " & kc.environmentId & " on " & app.actualTime.date.String & "  " & app.actualTime.time.String & "  ----------------------";
	cc.cnWriteLog(cc.CnLogComment, str, null);
	app.cnManagerLog(str);
	app.cnManagerLog(" ");
	app.cnManagerLog("CardSchema version is " & app.cnGetCardSchemaVersion());

	str := self.zValidationChecks();					// check environment id is valid
	if str <> CN_OK then
		str := str & ", terminating.";
		cc.cnWriteLog(cc.CnLogErrors, str, null);
		app.cnManagerLog(str);
		beginTransaction;																							// PAR 544
		node.userExitCode := 1;																						// PAR 544
		commitTransaction;																							// PAR 544
		app.cnTerminate();
	endif;
	
	app.cnManagerLog("----   Preparing destination directories to receive backup   ----");
	
	iniFileName		:= app.getIniFileNameAppServer();

	backupRootDir 	:= app.getProfileStringAppServer(iniFileName, CN_JSMDATABASEBACKUP, CN_BACKUPDIRECTORY, null);
	if backupRootDir = null then
		beginTransaction;																							// PAR 544
		node.userExitCode := 1;																						// PAR 544
		commitTransaction;																							// PAR 544
		logAndTerminateBackup("BackupDirectory not specified in [JSMDatabaseBackup] section of .ini file - backup failed.");
	endif;

    pos := backupRootDir.reversePos("/");
    if pos = 0 then
    	pos := backupRootDir.reversePos("\");
    endif;

	if pos > 3 then
		beginTransaction;																							// PAR 544
		node.userExitCode := 1;																						// PAR 544
		commitTransaction;																							// PAR 544
		logAndTerminateBackup("Backup root directory '" & backupRootDir & "' not valid : cannot be multi-level, must be root.");
	endif;

	if app.cnOSPlatformIsWindows then
		rootDir		:= kc.driveLetter & ":/" & kc.environmentId; 
	else
		rootDir		:= app.cnApplicationRootDir & kc.environmentId;
	endif;		

	if app.cnConvertPathNameToFwdSlashes(backupRootDir.toLower) = rootDir.toLower then
		beginTransaction;																							// PAR 544
		node.userExitCode := 1;																						// PAR 544
		commitTransaction;																							// PAR 544
		str :=  "Backup root directory '" & backupRootDir & "' not valid : cannot be same as application system directory.";
		logAndTerminateBackup(str);
	endif;	

	create ff;
	ff.fileName := backupRootDir;
	if not ff.isAvailable then
		beginTransaction;																							// PAR 544
		node.userExitCode := 1;																						// PAR 544
		commitTransaction;																							// PAR 544
		str := "Backup root directory '" & backupRootDir & "' is not available - backup failed.";
		logAndTerminateBackup(str);
	endif;

	self.backupDir				:= backupRootDir & "/" & kc.environmentId.toLower & "/server/c_system"; 
	self.databaseDirectory		:= app.cnStandardizePathName(app.dbPath).toLower();
	self.databaseDirectory		:= self.databaseDirectory.cnStripTrailingSlash();
	enableArchiveRecovery	:= app.getProfileStringAppServer(app.getIniFileNameAppServer, 
															CN_PERSISTENTDB, 
															CN_ENABLEARCHIVALRECOVERY, 
															true.String).Boolean;               					// PAR 878
	ff.fileName 			:= backupDir;
	if not ff.isAvailable then 
		ff.make;
		app.cnManagerLog(" New directory " & ff.fileName & " created.");
	endif;

	result := prepareBackupDirectories;
	if result <> CN_OK then
		beginTransaction;																							// PAR 544
		node.userExitCode := 1;																						// PAR 544
		commitTransaction;																							// PAR 544
		logAndTerminateBackup(result);
	endif;

	// IncludeSystemFiles no longer required as database system files now treated as binaries						// PAR 591
	if app.getProfileStringAppServer(iniFileName, CN_JSMDATABASEBACKUP, "IncludeSystemFiles", null) <> null then		// PAR 591
		global.cnSetProfileStringServer(CN_JSMDATABASEBACKUP, "IncludeSystemFiles", ProfileRemoveKey);				// PAR 591
	endif;																											// PAR 591
	
	self.compressFiles		:= app.getProfileStringAppServer(iniFileName, CN_JSMDATABASEBACKUP, CN_COMPRESSFILES, false.String).Boolean;
	self.overwriteFiles		:= app.getProfileStringAppServer(iniFileName, CN_JSMDATABASEBACKUP, CN_ALLOWOVERWRITEFILES, true.String).Boolean;
	self.quiesce			:= app.getProfileStringAppServer(iniFileName, CN_JSMDATABASEBACKUP, CN_QUIESCE, false.String).Boolean;
	stateOverflowDirStr		:= app.getProfileStringAppServer(iniFileName, CN_PERSISTENTDB, CN_STATEOVERFLOWDIRECTORY, null).toLower;
	
	if stateOverflowDirStr = null then
		stateOverflowDirStr := app.dbPath & "/pdb_osm";
		app.cnManagerLog("[PersistentDb] StateOverflowDirectory defaulting to " & stateOverflowDirStr);
	
	else
		app.cnStandardizePathName(stateOverflowDirStr);
		if stateOverflowDirStr.length > 3 and
			stateOverflowDirStr[2:2] = ":/" then					// we appear to have a full path name
			app.cnManagerLog("[" & CN_PERSISTENTDB & "] " & CN_STATEOVERFLOWDIRECTORY	& "=" & stateOverflowDirStr);
		
		else
			if 	stateOverflowDirStr [1:1] = "/" or 
				stateOverflowDirStr [1:1] = "\" then
				stateOverflowDirStr := stateOverflowDirStr[2:end];
			endif;

			stateOverflowDirStr := app.dbPath & "/" & stateOverflowDirStr;
			app.cnManagerLog("    " &	CN_PERSISTENTDB & " " & CN_STATEOVERFLOWDIRECTORY & " " & stateOverflowDirStr);
		endif;
	endif;
	
	
	self.stateOverflowDirectory	:= app.cnStandardizePathName(stateOverflowDirStr).toLower();
	app.cnManagerLog("StateOverflowDirectory is now defined as '" & stateOverflowDirectory & "'.");	

	app.cnManagerLog(" ");
	app.cnManagerLog("----   Starting on-line backup of database files : backupDir=" &  backupDir & "   ----");
	app.cnManagerLog("Parameters : IncludeSystemFiles=" & false.String & 
						", verifyFiles=" & true.String &
						", CompressFiles=" & compressFiles.String &
						", AllowOverwriteFiles=" & overwriteFiles.String &
						", Quiesce=" & quiesce.String);

	create droppedFiles sharedTransient;
	create dba sharedTransient;
  	self.setMyDba(dba);
  	self.zSetStartJournalNumber(dba);

	beginNotification(dba, dba.FileBackupStartEvent, 0, Cn_JDB_Admin_Tag);
	beginNotification(dba, dba.FileBackupCompleteEvent, 0, Cn_JDB_Admin_Tag);
	beginNotification(dba, dba.BackupCompleteEvent, 0, Cn_JDB_Admin_Tag);
	beginNotification(dba, dba.LogTransferEvent, 0, Cn_JDB_Admin_Tag);
	beginNotification(dba, dba.Backup_Failed_Event, 0, Cn_JDB_Admin_Tag);
	beginNotification(dba, dba.Backup_Completed_OK_Event, 0, Cn_JDB_Admin_Tag);
	
	commitTransientTransaction;

	// Now start the backup in another thread.  This current thread receives and processes any notifications.

	app.cnManagerLog("Initiating on-line database file backup thread (KCDbBackupWorker).");
	app.startApplicationWithParameter(CN_CARDSCHEMA, CN_KCDBBACKUPWORKER, self);

epilog
	delete ff;

	if process.isInExceptionState and app.cnMyBackupLog <> null then
		beginTransaction;																							// PAR 544
		node.userExitCode := 1;																						// PAR 544
		commitTransaction;																							// PAR 544
		logAndTerminateBackup("Exception occurred in CnDataseAdmin::simpleBackup : see logs and stack dump.");
	endif;
end;
}
sysNotification
{
sysNotification(eventType: Integer; theObject: Object; eventTag: Integer) updating;

vars
	str		: String;
	cc		: CnCntrl;
	obj		: Object;
	jdba	: JadeDatabaseAdmin;
begin
	cc	:= app.myCnCntrl;
	app.cnManagerLog(method.cnGetMethodName() & " : eventType=" & eventType.String & ", theObject=" & theObject.String &
						", eventTag=" & eventTag.String & ", self=" & self.String);
	
	if eventType = Object_Delete_Event				and
		(eventTag = Cn_Backup_Process_Deleted		or
		 eventTag = Cn_Compact_Process_Deleted) 	or
		 eventTag = Cn_Partition_Process_Deleted	then
			
			if self.processSet.includes(theObject) then
				beginTransientTransaction;
				self.processSet.remove(theObject);
				commitTransientTransaction;
			endif;
		
		if self.processSet.isEmpty() then
			if eventTag = Cn_Compact_Process_Deleted then
				self.zCompactWorkersTerminated();
			
			elseif eventTag = Cn_Partition_Process_Deleted then
				self.zPartitionWorkersTerminated();
			
			else
				self.zBackupWorkersTerminated();
			endif;
			
		endif;
		
		return;
	endif;
epilog
	delete jdba;	
end;
}
terminateCompact
{
terminateCompact(str : String; terminationType : Integer) updating;

vars
	cc		: CnCntrl;
	
	errText	: String;
begin
	cc := app.myCnCntrl;
	if not self.abnormalTermination then
		if not process.isInTransientTransactionState then
			beginTransientTransaction;
		endif;

		if terminationType = self.Compact_Failed then
			compactCompletionType	:= CnMessage.Advice_Type_Compact_Failed;
			abnormalTermination		:= true;
			errText	:= "COMPACTION FAILED : " & str;
			app.cnManagerLog(errText);
			cc.cnWriteLog(cc.CnLogErrors, errText, null);
		
		// 07/06/2012 - JadClient action=abortReorg is now used to immediately interupt a compaction, in this case we will terminate the compaction ourself
		elseif terminationType = self.Compact_Interrupted then
			compactCompletionType	:= CnMessage.Advice_Type_Compact_Interrupt;
			//abnormalTermination		:= true; 																						// PAR 7312
			errText	:= "COMPACTION INTERRUPTED : " & str;
			app.cnManagerLog(errText);
			cc.cnWriteLog(cc.CnLogErrors, errText, null);
			
		elseif terminationType = self.Compact_OK then
			compactCompletionType := CnMessage.Advice_Type_Compact_CompleteOK;		// shouldn't normally be here
			errText := "Compaction completed OK, " & str;
			app.cnManagerLog(errText);
			cc.cnWriteLog(cc.CnLogComment, errText, null);
		endif;
		
		compactCompletionText := errText;
		commitTransientTransaction;
		
	else
		if process.isInTransientTransactionState then
			commitTransientTransaction;
		endif;
	endif;
	
	if self.processSet.isEmpty()					or
	   terminationType = self.Compact_Interrupted	then
		self.finalizeAndTerminateCompact();
		
	else
		app.cnManagerLog(method.cnGetMethodName() & " : waiting for " & self.processSet.size64().String & " workers to stop ....");
	endif;
end;
}
terminateManagedBackup
{
terminateManagedBackup(str : String; terminationType : Integer) updating;

vars
	msg				: CnBackupAdvice;
	
	cc				: CnCntrl;
	
	cdba			: CnDatabaseAdmin;
	
	completionType,
	errText			: String;
begin
	cc := app.myCnCntrl;
	cdba	:= app.myCnDba;			// use local transient rather than shared transient
	if not self.abnormalTermination then
		if not process.isInTransientTransactionState then
			beginTransientTransaction;
		endif;

		if terminationType = Backup_Failed then
			completionType	:= CnMessage.Advice_Type_Backup_Failed;
			self.abnormalTermination 	:= true;
			errText	:= "BACKUP FAILED : " & str;
			app.cnManagerLog(errText);
			cc.cnWriteLog(cc.CnLogErrors, errText, null);
			
		elseif terminationType = Backup_Interrupted then
			completionType	:= CnMessage.Advice_Type_Backup_Interrupted;
			self.abnormalTermination := true;
			errText	:= "BACKUP INTERRUPTED : " & str;
			app.cnManagerLog(errText);
			cc.cnWriteLog(cc.CnLogErrors, errText, null);
					
		elseif terminationType = Backup_OK then
			completionType	:= CnMessage.Advice_Type_Backup_CompletedOK;		// shouldn't normally be here
			errText := "Backup completed OK, " & str;
			app.cnManagerLog(errText);
			cc.cnWriteLog(cc.CnLogComment, errText, null);
		endif;
		commitTransientTransaction;

		cdba.setBackupCompletionType(completionType);
		cdba.setBackupCompletionText(errText);
		
	else
		if process.isInTransientTransactionState then
			commitTransientTransaction;
		endif;
	endif;
	
	if self.processSet.isEmpty then
		self.finalizeAndTerminate();
		
	else
		app.cnManagerLog("CnDatabaseAdmin::terminateManagedBackup : waiting for " & self.processSet.size64().String & " workers to stop....");
	endif;
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;

vars

begin
	if eventTag = Verify_Check_Timer then
		self.verifyJournalCheck();
//		beginTimer(60000, Timer_OneShot, Verify_Check_Timer);
		return;
	endif;
end;
}
userNotification
{
userNotification(eventType : Integer; theObject : Object; eventTag : Integer; userInfo : Any) updating;

vars
	dba				: JadeDatabaseAdmin;

	dbFile			: DbFile;

	fileLength		: Decimal[19];
	
	constName		: String;
	
	compactionTask,
	dbFileOffline	: Boolean;
begin
	if eventType 		= JadeDatabaseAdmin.BackupCompleteEvent then
		constName	:= "BackupCompleteEvent";

	elseif eventType	= JadeDatabaseAdmin.Backup_Completed_OK_Event then
		constName	:= "Backup_Completed_OK_Event";
		
	elseif eventType	= JadeDatabaseAdmin.File_Backup_Start_Event then		// 3003
		constName	:= "File_Backup_Start_Event";
		
	elseif eventType	= JadeDatabaseAdmin.FileBackupCompleteEvent then
		constName	:= "FileBackupCompleteEvent";
		
	elseif eventType	= JadeDatabaseAdmin.File_Backup_Complete_Event then		// 3004
		constName	:= "File_Backup_Complete_Event";
		
	elseif eventType 	= JadeDatabaseAdmin.Backup_Worker_Completed_Event then	// 3005
		constName	:= "Backup_Worker_Completed_Event";
		
	elseif eventType	= JadeDatabaseAdmin.JournalTransferEvent then
		constName	:= "JournalTransferEvent";
		
	elseif eventType	= JadeDatabaseAdmin.BackupFailedEvent then				// RootSchema
		constName	:= "BackupFailedEvent";
		
	elseif eventType	= JadeDatabaseAdmin.Backup_Failed_Event then			// CardSchema
		constName	:= "Backup_Failed_Event";
		
	elseif eventType = CN_BACKUP_ABORT_REQUESTED then
		constName	:= "CN_BACKUP_ABORT_REQUESTED";
		
	elseif eventType = DbFile.BackupBytesDoneEvent then
		constName	:= "BackupBytesDoneEvent";
		
	elseif eventType = DbFile.BackupOperationEvent then
		constName	:= "BackupOperationEvent";
		
	elseif eventType	= JadeDatabaseAdmin.BackupAbortedEvent then
		constName	:= "BackupAbortedEvent";
		
	elseif eventType	= JadeDatabaseAdmin.BackupCancelledEvent then
		constName	:= "BackupCancelledEvent";
		
	elseif eventType	= JadeDatabaseAdmin.Compact_Failed_Event then			// 4001
		constName	:= "Compact_Failed_Event";
		
	elseif eventType 	= JadeDatabaseAdmin.Compact_Completed_OK_Event then		// 4002
		constName	:= "Compact_Completed_OK_Event";
		
	elseif eventType	= JadeDatabaseAdmin.File_Compact_Start_Event then		// 4003
		constName	:= "File_Compact_Start_Event";
		
	elseif eventType	= JadeDatabaseAdmin.File_Compact_Complete_Event then	// 4004
		constName	:= "File_Compact_Complete_Event";
		
	elseif eventType	= JadeDatabaseAdmin.Compact_Worker_Completed_Event then	// 4005
		constName	:= "Compact_Worker_Completed_Event";
		
	elseif eventType = CN_COMPACTION_STOP_REQUESTED then
		constName	:= "CN_COMPACTION_STOP_REQUESTED";
		
	elseif eventType = CN_COMPACTION_ABORT_REQUESTED then
		constName	:= "CN_COMPACTION_ABORT_REQUESTED";
		
	else
		constName	:= "< not decoded >";
	endif;	

	if eventType = Cn_KCCMgr_JournalTransferEvent and 
	   eventTag = Cn_Param_Class then
		self.verifyJournalCheck();
		return;
	endif;
	
	compactionTask := false;
	if eventType = JadeDatabaseAdmin.Compact_Failed_Event				or 
		eventType = JadeDatabaseAdmin.Compact_Completed_OK_Event		or
		eventType = JadeDatabaseAdmin.File_Compact_Start_Event			or
		eventType = JadeDatabaseAdmin.File_Compact_Complete_Event 		or
		eventType = JadeDatabaseAdmin.Compact_Worker_Completed_Event 	or
		eventType = CN_COMPACTION_STOP_REQUESTED 						or
		eventType = CN_COMPACTION_ABORT_REQUESTED 						then
		compactionTask := true;
	endif;
	
	//multi-threaded backup or compact
	if eventTag = Cn_JDB_Managed_Tag then
		if compactionTask then
			self.userNotificationCompact(theObject, eventType, userInfo);
		
		else
			userNotificationBackup(theObject, eventType, userInfo); // if executing this then it must be a backup event
		endif;
		
		return;
	endif;
		
	//simple backup (single-threaded)
	if eventTag = Cn_JDB_Admin_Tag then
		dba := theObject.JadeDatabaseAdmin;
		if eventType = dba.BackupCompleteEvent then					// this event can indicate normal OR abnormal completion
			app.cnManagerLog("On-line database file backup task has ended.");
			return;
		endif;

		if eventType = dba.Backup_Completed_OK_Event then
			self.zBackupJournalsAndNonDbFiles("Database file backup (on-line) backup completed OK");
			return;
		endif;

		if eventType = dba.FileBackupStartEvent then
			app.cnManagerLog("File backup started for " & userInfo.DbFile.name & "....");
			return;
		endif;
			
		if eventType = dba.FileBackupCompleteEvent then
			dbFile := userInfo.DbFile;																							// PAR 594
			on SystemException do app.cnGenericExceptionHandler(exception, JErr_DbFileOffline, dbFile, dbFileOffline);			// PAR 594
			fileLength := dbFile.getFileLength();																				// PAR 594
			if dbFileOffline then																								// PAR 594
				app.cnManagerLog("File backup completed for " & dbFile.name & " (offline)");									// PAR 594
			
			else																												// PAR 594
				app.cnManagerLog("File backup completed for " & userInfo.DbFile.name & ", size=" & fileLength.String);
			endif;																												// PAR 594
			
			return;
		endif;

		if eventType = dba.JournalTransferEvent then
        	app.cnManagerLog("Journal transfer event : log no=" & userInfo.Integer.String);
			return;
		endif;

		if eventType = dba.Backup_Failed_Event then
			beginTransaction;																									// PAR 544
			node.userExitCode := 1;																								// PAR 544
			commitTransaction;																									// PAR 544
			logAndTerminateBackup(userInfo.String);
			return;
		endif;
	endif;

	app.cnManagerLog(method.cnGetMethodName() & " : eventType=" & eventType.String & " (" & constName & "), tag=" & eventTag.String &
					", theObject=" & app.cnGetClassAndOid(theObject) & ", userInfo=" & userInfo.String);

epilog
	if process.isInExceptionState then
		if eventType = JadeDatabaseAdmin.JournalTransferEvent then		// used by KCCMgr, JossCommsMgr
			return;														// stack is being cut back from ::userNotificationManaged
		else
			if compactionTask then		
				logAndTerminateCompact("Exception occurred during compaction : see logs and stackdump for more information.");
			else
				logAndTerminateBackup("Exception occurred during backup : see logs and stackdump for more information.");
			endif;
			
		endif;
	endif;
end;
}
userNotificationBackup
{
userNotificationBackup(theObject : Object; eventType : Integer; userInfo : Any) updating;

vars
	//  Handle user notifications during JSM managed backups. 
	//  Called from ::userNotification method.
	
	msg				: CnBackupAdvice;

	cc				: CnCntrl;

	cdba			: CnDatabaseAdmin;
	
	dbStructure		: CnDatabaseStructure;
	
	kc				: CnKarmaCntrl;

	dbFile			: DbFile;

	jdba			: JadeDatabaseAdmin;

	issueMsg,
	joss			: Boolean;
	
	phase			: Character;

	ix,
	lastProgress,
	len,
	percentDone,
	pos,
	pos2,
	udrPos,
	progress,
	workerId		: Integer;
	
	bytesDone,
	bytesToDo,
	lastBytesDone,
	lastBytesToDo,
	length,
	newBytesDone	: Integer64;
	
	fileName,
	keyword,
	keyValue,
	logText,
	operation,
	phaseStr,
	structure,
	userInfoStr		: String;
begin
	kc 	:= app.myCnKarmaCntrl;
	cc	:= app.myCnCntrl;
	
	if eventType = JadeDatabaseAdmin.JournalTransferEvent then							// used by KCCMgr, JossCommsMgr
		self.zHandleJournalTransferEvent(userInfo);																				// PAR 1066
		return;
	endif;
	
	if eventType = CN_BACKUP_ABORT_REQUESTED then
		if self.abortRequested then
			app.cnManagerLog(method.cnGetMethodName() & " : abort already in process : waiting for " & processSet.size64().String & " workers to stop.");
			return;
		endif;
		
		beginTransientTransaction;
		self.abortRequested := true;
		commitTransientTransaction;		
		
		create jdba transient;
		jdba.abortBackup();							// note that on a fast machine the process deleted notes can arrive before
		delete jdba;								// the BackupAbortedEvent note ... addressed in PAR 167 in ::sysNotification method
		
		app.cnManagerLog(method.cnGetMethodName() & " : abortBackup has been issued, CnDatabaseAdmin.abortRequested now set.");
		return;
	endif;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
/*	beginClassNotification(DbFile, 				false, 	DbFile.BackupProgressEvent,			Response_Continuous, Cn_JDB_Managed_Tag); 							// 1000
	beginClassNotification(DbFile, 				false, 	DbFile.BackupOperationEvent,		Response_Continuous, Cn_JDB_Managed_Tag); 							// 1001
	beginClassNotification(DbFile, 				false, 	DbFile.BackupBytesDoneEvent,		Response_Continuous, Cn_JDB_Managed_Tag); 							// 1002
	beginClassNotification(DbFile, 				false, 	DbFile.BackupOutputEvent,			Response_Continuous, Cn_JDB_Managed_Tag); 							// 1003
	beginClassNotification(DbFile, 				false, 	DbFile.BackupErrorEvent,			Response_Continuous, Cn_JDB_Managed_Tag); 							// 1004	
*/

	cdba	:= app.myCnDba;
	phase	:= " ";																// local process transient
	if theObject.isKindOf(DbFile) then
		dbFile := theObject.DbFile;
		fileName := dbFile.getName();
	endif;
	
	if eventType = DbFile.BackupOperationEvent or
	   eventType = DbFile.BackupBytesDoneEvent 	then

		percentDone := null;
		userInfoStr := userInfo.String;
		len := userInfoStr.length();
		pos := 1;
		
		while pos < len do
			keyword := userInfoStr.scanUntil(CN_EQUAL, pos);				// keyword
			pos := pos + 1;
			keyValue := userInfoStr.scanUntil(CN_SEMICOLON, pos);
			pos := pos + 1;
			if keyword = "operation" then
				pos2 := 1;
				operation := keyValue.scanUntil(CN_SPACE, pos2);
			
			elseif keyword.toLower() = "filename" then
				pos2 := 1;
				structure := keyValue.scanUntil(CN_SEMICOLON, pos2);		// gets whole string including .dat
				pos2 := structure.length() - 4;								// find start of .dat
				// not all responses return with a .dat suffix so check before dropping last 4 bytes
				if structure[pos2+1:4].toLower() = ".dat" then				
					structure := structure[1:pos2];
				endif;
				
				if eventType = DbFile.BackupOperationEvent then				// this is last entry from BackupOperationEvent
					break;
				endif;
				
			elseif keyword.toLower() = "bytesdone" then
				bytesDone := keyValue.Integer64;
								
			elseif keyword.toLower() = "bytestodo" then						// this is last entry from BackupBytesDoneEvent
				bytesToDo := keyValue.Integer64;
				break;										

			else
				app.cnManagerLog(">> unexpected end of bytesdone");
				break;
			endif;
		endwhile;
		
		if eventType = DbFile.BackupBytesDoneEvent 	then
			logText := "BackupBytesDoneEvent (1002) : " & operation & 
							" on " & structure & 
							", bytesDone=" & bytesDone.userNumberFormat($CnWholeNumbers) & 
							", bytesToDo=" & bytesToDo.userNumberFormat($CnWholeNumbers) & 
							", ";
			
		else
			logText := "BackupOperationEvent (1001) : " & operation & " on " & structure & ", ";
		endif;

		udrPos := structure.toLower().pos("_udr", 1);
		if udrPos > null then
			structure := structure[1:udrPos-1];
		endif;
			
		ix := cdba.currentFiles.indexOf(structure.toLower());	// all files held in currentFiles are now in lower case - RCG 20/07/11
		if ix = null then
			app.cnManagerLog(logText & " progress event notification is for file " & structure & " : event discarded : unable to locate current file.");
			return;
		endif;

		workerId := cdba.backupWorkerIds[ix];
				
		if app.cnSystemType = CN_SYSTEMTYPE_JSM then					// reduce event rate for Joss
			joss 		:= true;
		endif;

		if eventType = DbFile.BackupOperationEvent 	then				// BackupOperationEvent is incurred once at start of backup and verify phaces as well as for each UDR and partition
			issueMsg	:= true;
			phase		:= operation[1];
			cdba.currentFilePhases[ix] := phase;
			if phase = Phase_MapFile_Verify then
				cdba.currentFileProgresses[ix]	:= cdba.currentFileSizes[ix] div 2;
				
			elseif not cdba.currentFileInProgress[ix] then
				cdba.currentFileProgresses[ix] := null;					// so we can use this to setup the correct phase.
				cdba.currentFileInProgress[ix] := true;
			endif;
			
		else
			phase			:= cdba.currentFilePhases[ix];
			lastBytesDone 	:= cdba.currentFileProgresses[ix];			// BackupBytesDone allows us to track progress of database structure backup
			lastBytesToDo	:= cdba.currentFileSizes[ix];
			if phase = Phase_MapFile_Verify then
				newBytesDone	:= bytesToDo + bytesDone;
			
			else
				newBytesDone	:= bytesDone;
			endif;
			
			if lastBytesToDo > null then
				percentDone		:= (newBytesDone * 100 div lastBytesToDo).Integer;
				lastProgress	:= (lastBytesDone * 100 div lastBytesToDo).Integer;		// in bytes increment rather than a percentage request. The percentage request
			
			else
				percentDone := null;
				lastProgress := null;
			endif;
			
			cdba.currentFileProgresses[ix]	:= newBytesDone;
			if percentDone > (lastProgress + 10) then					// caused problems on really large structures as minimum was 1%.
				issueMsg						:= true;
			endif;
			
			logText := logText & ", new bytes done=" & newBytesDone.userNumberFormat($CnWholeNumbers) & 
								 ", last bytes done=" & lastBytesDone.userNumberFormat($CnWholeNumbers) &
								 ", last bytes todo=" & lastBytesToDo.userNumberFormat($CnWholeNumbers) &
								 ", percent=" & percentDone.String & "%, ";
		endif;
		
		if not joss or issueMsg then
			msg 	:= createBackupAdviceMessage(CnMessage.Advice_Type_Backup_Progress);
			msg.setCurrentFileName(structure);
			msg.setPercentProgress(percentDone);
			msg.setBackupWorkerId(workerId);
			msg.setPhase(phase);
			msg.sendMessage(null);
		endif;
		
		if phase = Phase_MapFile_BackingUp then
			phaseStr 	:= "backup";
			
		elseif phase = Phase_MapFile_Verify then
			phaseStr	:= "verify";
			
		else
			phaseStr	:= phase;
		endif;
		
		app.cnManagerLog(logText & "Worker=" & workerId.String & ", phase=" & phaseStr);
		return;
	endif;
		
	if eventType = DbFile.BackupOutputEvent 	then
		app.cnManagerLog("BackupOutputEvent (1003) on " & fileName & " : unserInfo='" & userInfo.String & "'");
		return;
	endif;

	if eventType = DbFile.BackupErrorEvent 	then
		app.cnManagerLog("BackupOperationEvent (1004) on " & fileName & " : unserInfo='" & userInfo.String & "'");
		return;
	endif;
	
	if eventType = jdba.File_Backup_Start_Event 		or					// 3003
	   eventType = jdba.File_Backup_Complete_Event 		or					// 3004
	   eventType = jdba.Backup_Worker_Completed_Event 	then				// 3005
		//
		//  These events are caused by worker threads
		//
		workerId	:= userInfo.Binary[1:4].Integer;
		
		if eventType = jdba.File_Backup_Start_Event 	or
		   eventType = jdba.File_Backup_Complete_Event then
			fileName	:= userInfo.Binary[5 : end].String;
		endif;
		
	   if eventType = jdba.File_Backup_Start_Event then
			phase	:= "S";	   	
			cdba.currentFiles.add(fileName.toLower());
			cdba.currentFilePhases.add(phase);
			cdba.backupWorkerIds.add(workerId);
			cdba.currentFileProgresses.add(null);					// mainly for Joss
			cdba.currentFileInProgress.add(false);
			progress	:= null;
			dbStructure := self.allCnDatabaseStructures[fileName];
			length := null;
			if dbStructure = null then
				app.cnManagerLog("Unable to locate file '" & fileName & "'");
			
			else
				length := dbStructure.size * 2;						// x 2 as we need to cater for both backup and verify phases
			endif;
			
			cdba.currentFileSizes.add(length);
			app.cnManagerLog("Worker=" & workerId.String & ", file backup started (3003) for " & fileName & ", expected length=" & length.userNumberFormat($CnWholeNumbers) & " ....");
			
		elseif eventType = jdba.File_Backup_Complete_Event then
			phase	:= Phase_MapFile_Completed;
			app.cnManagerLog("Worker=" & workerId.String & ", file backup complete (3004) for " & fileName & ".");
			ix		:= cdba.currentFiles.indexOf(fileName.toLower());
			cdba.currentFiles.removeAt(ix);
			cdba.currentFilePhases.removeAt(ix);
			cdba.currentFileProgresses.removeAt(ix);
			cdba.backupWorkerIds.removeAt(ix);
			cdba.currentFileInProgress.removeAt(ix);
			cdba.currentFileSizes.removeAt(ix);
			progress	:= 100;
			
		elseif eventType = jdba.Backup_Worker_Completed_Event then
			phase	:= Phase_Worker_Terminated;
			app.cnManagerLog("Backup worker " & workerId.String & " has terminated (3005).");
		endif;

		msg 	:= createBackupAdviceMessage(CnMessage.Advice_Type_Backup_Progress);
		msg.setCurrentFileName(fileName);
		msg.setPercentProgress(progress);
		msg.setBackupWorkerId(workerId);
		msg.setPhase(phase);
		msg.sendMessage(null);
		return;
	endif;

	if eventType = jdba.Backup_Failed_Event or					// CardSchema
	   eventType = jdba.BackupFailedEvent then					// RootSchema
		terminateManagedBackup(userInfo.String, Backup_Failed);
		return;
	endif;

	if eventType = jdba.BackupAbortedEvent or					// 4000
	   eventType = jdba.BackupCancelledEvent then				// 8000
		terminateManagedBackup("Backup cancelled or aborted.", Backup_Interrupted);
		return;
	endif;
epilog
	delete msg;
end;
}
userNotificationCompact
{
userNotificationCompact(theObject : Object; eventType : Integer; userInfo : Any) updating;

	//  Handle user notifications during JSM managed compactions. 
	//  Called from ::userNotification method.

vars
	dbFile					: DbFile;
	
	msg						: CnCompactAdvice;
	
	cc						: CnCntrl;
	
	jdba					: JadeDatabaseAdmin;
	
	cdba					: CnDatabaseAdmin;
	
	issueMsg,
	joss,
	immediateAbortRequested	: Boolean;
	
	ix,
	progress,
	lastProgress,
	workerId				: Integer;
	
	fileName,
	phaseStr				: String;
	
	phase					: Character;
begin
	cc						:= app.myCnCntrl;
	// abort request takes priority over stop request, for this reason we won't prevent the abortRequested from being set
	// multiple times, the reason for this is because the abortRequested flag may have already been set by a CN_COMPACTION_STOP_REQUESTED
	// and now the user has decided they can't wait for the current file to complete so they have now requested an immediate abort instead.
	if eventType = CN_COMPACTION_ABORT_REQUESTED then
		beginTransientTransaction;
		self.abortRequested := true;
		commitTransientTransaction;
		
		app.cnManagerLog(method.cnGetMethodName() & " : CnDatabaseAdmin.abortRequested now set.");
		terminateCompact("aborting this compaction immediately due to user request ....", self.Compact_Interrupted);
		return;
	endif;
	
	if eventType = CN_COMPACTION_STOP_REQUESTED then
		if self.abortRequested then
			app.cnManagerLog(method.cnGetMethodName() & " : abort request already in process : waiting for " & processSet.size64().String & " workers to stop.");
			return;
		endif;
		
		beginTransientTransaction;
		self.abortRequested := true;
		commitTransientTransaction;
		
		app.cnManagerLog(method.cnGetMethodName() & " : CnDatabaseAdmin.abortRequested now set.");
		return;
	endif;
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	cdba	:= app.myCnDba;
	phase	:= " ";													// local process transient

	if theObject.isKindOf(DbFile) then
		dbFile 		:= theObject.DbFile;
		fileName	:= dbFile.getName();
		ix			:= cdba.currentFiles.indexOf(fileName);

		if ix < 1 then												// notifications sometimes come in wrong order
			app.cnManagerLog("Progress event notification is for file " & fileName & " : event discarded : compaction of this file appears to have been completed.");
			return;
		endif;
		
		workerId := cdba.compactWorkerIds[ix];
				
		if app.cnSystemType = CN_SYSTEMTYPE_JSM then				// reduce event rate for Joss
			joss := true;
		endif;
		
		if ix = null then
			cdba.currentFiles.add(fileName);						// shouldn't happen if notes are delivered as issued
			cdba.currentFileProgresses.add(userInfo.Integer);
			phase := Phase_MapFile_Starting;
			cdba.currentFilePhases.add(phase);
			issueMsg		:= true;
		
		else
			lastProgress	:= cdba.currentFileProgresses[ix].Integer;
			
			if userInfo.Integer = 0 or userInfo.Integer > (lastProgress + 25) then
				issueMsg						:= true;
				cdba.currentFileProgresses[ix]	:= userInfo.Integer;
			endif;
		endif;
				
		if issueMsg then
			msg := createCompactAdviceMessage(CnMessage.Advice_Type_Compact_Progress);
			msg.setCurrentFileName(fileName);
			msg.setPercentProgress(userInfo.Integer);
			msg.setCompactWorkerId(workerId);
			msg.setPhase(phase);
			msg.sendMessage(null);
		endif;
		
		if phase = "S" then
			phaseStr := "file compaction";
			
		else
			phaseStr := phase;
		endif;
		
		app.cnManagerLog("Worker=" & workerId.String & ", file=" & fileName & ", phase=" & phaseStr & ", progress=" & userInfo.Integer.String);
	
	else
		if eventType = jdba.File_Compact_Start_Event 		or					// 4003
		   eventType = jdba.File_Compact_Complete_Event 	or					// 4004
		   eventType = jdba.Compact_Worker_Completed_Event 	then				// 4005
			//
			//  These events are caused by worker threads
			//
		   	workerId	:= userInfo.Binary[1:4].Integer;
		   	
		   	if eventType = jdba.File_Compact_Start_Event 	or
		   	   eventType = jdba.File_Compact_Complete_Event then
		   	   	fileName := userInfo.Binary[5 : end].String;
		   	endif;
		   	
		   if eventType = jdba.File_Compact_Start_Event then
				phase := Phase_MapFile_Starting;
		   	   	app.cnManagerLog("Worker=" & workerId.String & ", file compaction started for " & fileName & "....");
				cdba.currentFiles.add(fileName);
		   	   	cdba.currentFilePhases.add("S");
		   	   	cdba.compactWorkerIds.add(workerId);
		   	   	cdba.currentFileProgresses.add(null);					// mainly for Joss
		   	   	progress := 0;
		   	   	
			elseif eventType = jdba.File_Compact_Complete_Event then
				phase := Phase_MapFile_Completed;
				app.cnManagerLog("Worker=" & workerId.String & ", file compaction complete for " & fileName & ".");
				ix	:= cdba.currentFiles.indexOf(fileName);
				cdba.currentFiles.removeAt(ix);
				cdba.currentFilePhases.removeAt(ix);
				cdba.currentFileProgresses.removeAt(ix);
				cdba.compactWorkerIds.removeAt(ix);
				progress	:= 100;
				
			elseif eventType = jdba.Compact_Worker_Completed_Event then
				phase := Phase_Worker_Terminated;
				app.cnManagerLog("Compact worker " & workerId.String & " has terminated.");
			endif;
	
			msg := createCompactAdviceMessage(CnMessage.Advice_Type_Compact_Progress);
			msg.setCurrentFileName(fileName);
			msg.setPercentProgress(progress);
			msg.setCompactWorkerId(workerId);
			msg.setPhase(phase);
			msg.sendMessage(null);			

		elseif eventType = jdba.Compact_Failed_Event then
			terminateCompact(userInfo.String, self.Compact_Failed);
		endif;
		
	endif;
epilog
	delete msg;
end;
}
verifyJournal
{
verifyJournal(param : CnParam io) updating, serverExecution;

vars
	cc			: CnCntrl;
	
	kc			: CnKarmaCntrl;
	
	file		: File;

	jdba		: JadeDatabaseAdmin;
	
	hadError	: Boolean;

	journalNo,
	numErrors,
	pos			: Integer;
	
	scanFileName,
	scanFileDetail,																												// PAR 1111
	iniFileName,
	path,
	pathArchive,
	pathCurrent,
	str			: String;
begin
	kc			:= app.myCnKarmaCntrl;
	cc			:= app.myCnCntrl;
	create jdba transient;
	pathCurrent	:= jdba.getCurrentJournalDirectory();
	pathCurrent	:= pathCurrent.cnStripTrailingSlash();
	pathCurrent.cnReplaceChar(CN_SLASH, CN_BACK_SLASH);
	
	iniFileName	:= app.getIniFileName();
	pathArchive	:= app.getProfileString(iniFileName, CN_PERSISTENTDB, "JournalArchiveDirectory", null);
	if pathArchive = null then
		pos		:= pathCurrent.reversePos(CN_BACK_SLASH);
		pathArchive := pathCurrent[1:pos] & "archive";
	endif;
	
	pathArchive.cnStripTrailingSlash();
	pathArchive.replaceChar(CN_SLASH, CN_BACK_SLASH);
	journalNo	:= param.journalNo;
	create file transient;
	
	if not self.locateJournal(file, journalNo, pathCurrent, pathArchive, path) then
		app.cnRaiseAlert("Verify journal issue", 
						  "Unable to locate journal #" & journalNo.String & " in paths " & pathCurrent & " and " & pathArchive & CrLf &
						  "JADE Environment " & kc.managedEnvironmentName & " on " & app.cnComputerName,
						  "N",
						  app.actualTime(),
						  app.name,
						  kc.localFQDN,
						  kc.localIpAddress);
		return;
	endif;
	
	on Exception do self.handleVerifyJournalException(exception, hadError);
	
	cc.cnWriteLog(cc.CnLogComment, "Verifying database journal #" & param.journalNo.String & " in " & path & " ...", null); 
	scanFileName := path & "\db" & param.journalNo.String.padLeadingZeros(10) & ".scan";										// PAR 1111
	numErrors	:= jdba.verifyJournal(param.journalNo, path);
	if hadError then
		return;
	endif;

	if numErrors <> null then
		return;
	endif;
	
	cc.cnWriteLog(cc.CnLogComment, "Verification of database journal #" & journalNo.String & " completed OK.", null);
	app.cnFileRetryCount	:= 10;
	on FileException do app.cnFileInUseExceptionHandler(exception);
	file.fileName := scanFileName;																								// PAR 1111
	while true do
		kc.setHadFileException(false);	
		file.purge();
		if not kc.hadFileException then
			break;
		endif;
	endwhile;
	
	cc.cnWriteLog(cc.CnLogComment, "Journal scan log '" & file.fileName & "' removed.", null);
epilog
	delete file;
	delete jdba;
	if process.isInExceptionState 	or
	   numErrors <> null			then
		if numErrors <> null then
			str := numErrors.String & " errors detected verifying database journal #" & param.journalNo.String & ", check file " & scanFileName;	// PAR 1111
			if numErrors = 1 then
				scanFileDetail := self.zGetScanFileContents(scanFileName);															// PAR 1111
			endif;
			
		else
			str	:= "Error verifying database journal #" & param.journalNo.String & " : error=" & self.errorCode.String & " (" & self.errorText.String & ")";
		endif;
		
		cc.cnWriteLog(cc.CnLogErrors, str, null);
		app.cnRaiseJossAlert(Cn_Karma_Alert,
						 "EMERGENCY ALERT : Database journal verification failed on " & app.cnComputerName & " for " & kc.environmentId.toUpper,
					     str & ". Note that this can seriously jeopardise the database's integrity and could incur significant data loss if a restore from backup is needed." & CrLf & CrLf &	// PAR 1110
						 "Please escalate immediately to the appropriate Operations staff and with priority for production systems." &	// PAR 1111
						 scanFileDetail,																								// PAR 1111
					     "N",
					     app.actualTime,
					     cc.appName,	
					     kc.managedEnvironmentName,																				// JSM PAR 8367
	  					 kc.localFQDN,
	  					 kc.localIpAddress,
	  					 null);
	endif;
		
	beginTransientTransaction;
	delete param;
	commitTransientTransaction;
end;
}
verifyJournalCheck
{
verifyJournalCheck() updating;

vars
	cc		: CnCntrl;

	param	: CnParam;

	obj		: Object;
	
	array	: ObjectArray;
begin
	cc		:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : starting check for journals awaiting verification...", null);
	create array transient;
	CnParam.allSharedTransientInstances(array, 1000, false);
	foreach obj in array do
		self.verifyJournal(obj.CnParam);
	endforeach;	
	
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : no more journals waiting for verification : thread will idle...", null);
epilog
	delete array;
end;
}
zAlertCouldNotTakeCommitCoherentBackup
{
zAlertCouldNotTakeCommitCoherentBackup(pAlertText : String) updating;

	/*
		Purpose:
		Notify JSM that a commit coherent backup (suitable for restore to RPS) of this SDS Native DB was not able to be achieved.
	*/
vars
	msg	: CnBackupAdvice;
begin
	msg := self.createBackupAdviceMessage(msg.Advice_Type_Backup_Advisory);
	msg.setErrorText(pAlertText);
	msg.sendMessage(null);
epilog
	delete msg;
end;
}
zBackupCommonGetStructDetails
{
zBackupCommonGetStructDetails() updating, protected;

constants
	Status_Resident			: Integer		= DbFile.Status_Resident;
vars
	cc						: CnCntrl;

	kc						: CnKarmaCntrl;
	
	cnDatabaseStructure		: CnDatabaseStructure;

	cndba					: CnJadeDatabaseAdmin;	
	
	dbFile					: DbFile;
	
	iterDbFile,
	iterExclude,
	iterIsPartitioned,
	iterOffline,
	iterPartitionId,
	iterPartitionName,
	iterStatus,
	iterLength,
	iterUDRLength			: Iterator;
	
	dbFileExcludeFromBackup,
	dbFileIsPartitioned,	
	dbFrozenArray,
	dbOfflineArray			: BooleanArray;		
	
	dbLocations,
	partitionNames			: CnStringArray;
	
	dbFileArray				: DbFileArray;
	
	dbFileStatus,
	dbEncryptionStatus		: IntegerArray;																						// JSM PAR 7050
	
	dbFileUDRLengths,
	dbFileUDRStructures,
	partitionIds			: Integer64Array;

	uniqueDbFiles			: ObjectSet;
	
	duplicate,
	fileExclude,
	isPartitioned,
	offline					: Boolean;
	
	pos,
	fileStatus,
	statusUnMapped			: Integer;
	
	index,
	partitionId,
	structureLength,
	totalSize,
	udrFileSize				: Integer64;
	
	str,
	result,
	dbFileName,
	partitionName,
	structureName,
	backupLocation			: String;
	
	fx						: CnFunctionAgent;
begin
	kc := app.myCnKarmaCntrl;
	cc := app.myCnCntrl;
	
	statusUnMapped := DbFile.Status_Unmapped;
	app.cnManagerLog("Get database structure details....");
	create cndba					transient;
	create partitionNames			transient;
	create partitionIds				transient;
	create dbFileArray				transient;
	create dbFileExcludeFromBackup 	transient;
	create dbFileStatus 			transient;
	create dbFileUDRLengths 		transient;
	create dbFileUDRStructures 		transient;
	create dbFileIsPartitioned		transient;
	create dbLocations				transient;			// only required for send details advice
	create dbFrozenArray			transient;			// only required for send details advice
	create dbOfflineArray			transient;
	create dbEncryptionStatus		transient;																					// JSM PAR 7050
	result := cndba.getAllDatabaseStructureInfo(self.dbFileNames,
												partitionNames,
												dbFileArray,
												dbFileStatus,
												partitionIds,
												null, 							// dbfile kind
												dbLocations,
												dbFileExcludeFromBackup, 
												self.dbFileLengths, 
												dbFileUDRLengths,
												dbFileUDRStructures,
												dbEncryptionStatus,				// encryption status							// PAR 1004, JSM PAR 7050
												dbFileIsPartitioned,
												null,							// dbfile partition count
												null,							// dbfile modified timestamp
												null,							// dbfile backup timeStamp
												null,							// dbfile full backup timeStamp
												dbFrozenArray,
												dbOfflineArray);
	if result <> CN_OK then
		terminateManagedBackup(result, Backup_Failed);
	endif;
	
	create fx transient;
	fx.cnSDSStructureStatePrimUpdate(self.dbFileNames, dbFileStatus, partitionIds, dbFileExcludeFromBackup, dbFrozenArray, dbOfflineArray); // update the CnSDSStructureState class
	app.cnManagerLog("Number of database structures located : " & self.dbFileNames.size64().userNumberFormat($CnWholeNumbers));
	
	if self.isManaged then	// only send these details if managed by JadeCare24
		cndba.sendDatabaseDetailsAdvice(self.dbFileNames,
										partitionNames,
										dbFileStatus,
										dbEncryptionStatus,																		// JSM PAR 7050
										partitionIds,
										self.dbFileLengths,
										dbFileUDRLengths,
										dbFileUDRStructures,
										dbLocations,
										dbFrozenArray,
										dbOfflineArray,
										dbFileExcludeFromBackup);
	endif;
	
	app.cnManagerLog("Candidate files for backup (from ::getAllDatabaseStructureInfo) are :-");
	iterDbFile			:= dbFileArray.createIterator();
	iterExclude			:= dbFileExcludeFromBackup.createIterator();
	iterStatus			:= dbFileStatus.createIterator();
	iterLength			:= self.dbFileLengths.createIterator();
	iterUDRLength		:= dbFileUDRLengths.createIterator();
	iterIsPartitioned	:= dbFileIsPartitioned.createIterator();
	iterOffline			:= dbOfflineArray.createIterator();
	iterPartitionName	:= partitionNames.createIterator();
	iterPartitionId		:= partitionIds.createIterator();
	create uniqueDbFiles transient;
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectAlreadyInCollection, uniqueDbFiles, duplicate);
	foreach dbFileName in self.dbFileNames do
		iterDbFile.next(dbFile);
		iterExclude.next(fileExclude);
		iterStatus.next(fileStatus);
		iterLength.next(structureLength);
		iterUDRLength.next(udrFileSize);
		iterIsPartitioned.next(isPartitioned);
		iterOffline.next(offline);
		iterPartitionId.next(partitionId);
		iterPartitionName.next(partitionName);
		structureName := dbFileName;
		if partitionName <> null then
			structureName := structureName & "_" & partitionName;
		endif;
		
		if fileExclude then
			str := ">>> exclude from backup <<<";
		
		elseif fileStatus = statusUnMapped then		// RPS working set
			str := ">>> status unmapped <<<";

		elseif offline then
			str := ">>> structure is offline <<<";
		
		elseif fileStatus = Status_Resident then
			// CardSchema issue if zero length but resident and when no JADE issue alert found
			if structureLength = null then
				str := "Database structure " & structureName & " (oid=" & dbFile.getOidString() & 
						") has status of Resident (" & fileStatus.String & ") yet has zero length";
				cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " " & str, null);
				app.cnRaiseJossAlert(Cn_Karma_Alert,
									 "CardSchema metaschema issue",
									 str,
									 "N",
									 app.actualTime,
									 app.name,
									 kc.managedEnvironmentName,
									 kc.localFQDN,
									 kc.localIpAddress,
									 kc.myParentTcp);
			endif;
			
			// we need to exclude any partitioned control files from the backup as
			// the partition control file and its _ndx file are backed up by executing
			// DbFile::beginPartitionedFileBackup.
			totalSize := totalSize + structureLength;
			if partitionId = null and isPartitioned then
				duplicate := false;
				uniqueDbFiles.add(dbFile);
				if not duplicate then
					self.allPartitionedDbFiles.add(dbFile);
				endif;

			else
				create cnDatabaseStructure sharedTransient;
				cnDatabaseStructure.size				:= structureLength;		// so we can order the files by size
				cnDatabaseStructure.udrFileSize			:= udrFileSize;
				cnDatabaseStructure.partitionId			:= partitionId;			// DbFile = null, Partition > null (= actual partitionId)
				cnDatabaseStructure.name				:= structureName;
				cnDatabaseStructure.myDbFile			:= dbFile;
				cnDatabaseStructure.myCnDatabaseAdmin	:= self;
				
				if self.isManaged then
					index := self.backupStructureNames.indexOf64(structureName);
					if index > null then
						backupLocation := self.backupLocations.at(index) & backupDir[3:end];		// changed in 3.5.02
						cnDatabaseStructure.backupLocation	:= backupLocation;						// in 3.5.01 this contained the full path name
						app.cnManagerLog(structureName & " backed up to " & backupLocation);
						// delete the array entry so next search is faster
						self.backupStructureNames.removeAt(index);
						self.backupLocations.removeAt(index);
					endif;
				endif;
			endif;
			
		else
			self.droppedDbFileNames.add(dbFileName);
			str := ">>> not resident <<<";
		endif;

		pos := 1;
		if dbFileName.pos(" ", pos) > null then
			if self.isManaged							and																		// PAR 1053
			   not self.zSuppressEmbeddedSpaceAlert()	then																	// PAR 1053
				app.cnRaiseJossAlert(Cn_Karma_Alert,
									 "Detected mapfile with embedded space for " & kc.environmentId.toUpper() & " on " & app.cnComputerName & ".",
									 "Mapfile '" & dbFileName & "' has an embedded space. This can cause issues with backup and restore, especially when " &
									 "executed from command line. Please create incident and assign to development staff.",
									 "N",
									 app.actualTime,
									 cc.appName,
									 kc.managedEnvironmentName,
									 app.cnComputerNameAppServer,
									 null,
									 null);
			endif;
			str := str & " >>> mapfile contains space <<<";
		endif;

		if structureLength = null then
			str := Tab & str.padBlanks(27) & "  " & structureName;
			app.cnManagerLog(str);											// files to be backed up are reported in backup order later
		endif;
	endforeach;

	self.allCnDatabaseStructuresBySize.copy(self.allCnDatabaseStructures);	// so we can get entity by name
	if backupWorkers = null then
		backupWorkers := 1;
	endif;

	// now update array in descending size order and list files
	str := "Database structures to be backed up in size order:";
	app.cnManagerLog(str);
	str.fillString("=");
	app.cnManagerLog(str);
	
	if not self.isManaged then													// for non-managed backups purge the arrays, we will populate them with only the essential information we need
		self.dbFileNames.purge();
		self.dbFileLengths.purge();		
	endif;
	
	//Copy the list of partitioned files to a stack so that backup of control and index files may be multi threaded 
	self.allPartitionedDbFiles.copy(self.allPartitionedDbFilesForThreading);
	
	foreach cnDatabaseStructure in self.allCnDatabaseStructuresBySize do	// collection ordered by decreasing map file size
		structureName := cnDatabaseStructure.name;
		structureLength := cnDatabaseStructure.size;
		if not self.isManaged then												// for non-managed backups we are only interested in whats actually going to be backed up
			self.dbFileNames.add(structureName);
			self.dbFileLengths.add(structureLength);
		endif;
		
		self.allCnDatabaseStructuresForThreading.add(cnDatabaseStructure);
		str := structureLength.cnConvertToByteString();
		udrFileSize := cnDatabaseStructure.udrFileSize;
		if udrFileSize > null then
			str := str & "  (UDR=" & udrFileSize.cnConvertToByteString() & ")";
		endif;
		
		backupLocation := cnDatabaseStructure.backupLocation;
		if backupLocation <> null then
			str := str & Tab & "Backup to " & backupLocation;
		endif;

		str := Tab & str.padBlanks(27) & "  " & structureName;
		app.cnManagerLog(str);
	endforeach;
epilog
	delete fx;
	delete cndba;
	delete dbFileArray;	
	delete partitionNames;
	delete partitionIds;
	delete dbFileExcludeFromBackup;
	delete dbFileStatus;
	delete dbFileUDRLengths;
	delete dbFileUDRStructures;
	delete dbFileIsPartitioned;
	delete dbLocations;
	delete dbFrozenArray;
	delete dbOfflineArray;	
	delete iterDbFile;
	delete iterExclude;
	delete iterIsPartitioned;
	delete iterOffline;
	delete iterPartitionId;
	delete iterPartitionName;
	delete iterStatus;
	delete iterLength;
	delete iterUDRLength;
	delete uniqueDbFiles;
	delete dbEncryptionStatus;																									// JSM PAR 7050
end;
}
zBackupCommonInitiatePartitionWorkers
{
zBackupCommonInitiatePartitionWorkers(pBackupWorkers : Integer) updating, protected;

	/*
		Purpose:
		Multi-thread backup of index and control files for each partitioned file
	*/

vars
	kc			: CnKarmaCntrl;

	cc			: CnCntrl;
	
	i,
	x,
	int 		: Integer;
	proc		: Process;
	
	badObject	: Boolean;
	
	str			: String;
begin
	kc 	:= app.myCnKarmaCntrl;
	cc 	:= app.myCnCntrl;
	str := pBackupWorkers.String & " workers : passing " & self.String & ".";													// PAR 1109
	if self.isManaged then
		app.cnManagerLog("Initiating on-line database file backup threads (KCOnLinePartitionWorker) for " & str);	
		
	else
		app.cnManagerLog("Initiating database file backup threads (KCOnLinePartitionWorker) for " & str);	
	endif;	
	
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_AttemptedAccessViaNullRef, null, badObject);	// handle 1090 which can occur (licence restriction, out of memory etc)
	foreach int in 1 to pBackupWorkers do
		proc := null;			// need to initialize as failure to start the process (eg licence exceeded) causes proc to be left as last found
		proc := app.startApplicationWithParameter(CN_CARDSCHEMA, CN_KCONLINEPARTITIONWORKER, self);
		// check if valid object
		x := proc.edition;
		if badObject then
			i := i + 1;
			badObject := false;
			continue;
		endif;
		
		beginNotification(proc, Object_Delete_Event, Response_Continuous, Cn_Partition_Process_Deleted); 
		beginTransientTransaction;
		self.processSet.add(proc);
		commitTransientTransaction;
		process.sleep(500);
	endforeach;

	if self.processSet.isEmpty() then
		self.terminateManagedBackup("No partition backup workers were started, possibly exceeded licences allowed, please check logs.", Backup_Failed);
		return;
	endif;
	
	if i <> null then	// if we failed to start any backup processes then log and, if managed, issue alert						// PAR 1087
		if self.isManaged	then	// non-managed multi worker backup so just return											// PAR 1087
			app.cnManagerLog(i.String & " copies of KCOnlinePartitionWorker failed to start (check licence issue)," &			// PAR 1087
								" alert issued");																				// PAR 1087
			app.cnRaiseJossAlert(Cn_Karma_Alert,
								 "Detected failure to start backup partition workers for " & kc.environmentId.toUpper() & " on " & app.cnComputerName & ".",
								 i.String & " copies of KCOnlinePartitionWorker failed to start for JADE environment " &
								 kc.managedEnvironmentName.toUpper() & " on " & app.cnComputerName & ". Possibly licences allowed has been exceeded. Please check logs for reason.",
								 "N",
								 app.actualTime,
								 cc.appName,
								 kc.managedEnvironmentName,
								 app.cnComputerNameAppServer,
								 null,
								 null);
		else																													// PAR 1087
			app.cnManagerLog(i.String & " copies of KCOnlinePartitionWorker failed to start (check licence issue)," &			// PAR 1087
								" not managed, no alert issued");																// PAR 1087
		endif;
	endif;
end;
}
zBackupCommonInitiateWorkers
{
zBackupCommonInitiateWorkers() updating, protected;

vars
	kc			: CnKarmaCntrl;

	cc			: CnCntrl;
	
	proc		: Process;
	
	badObject	: Boolean;
	
	i,
	x,
	int 		: Integer;
	
	
	d1			: Decimal [23];
	
	
	str			: String;
begin
	kc 	:= app.myCnKarmaCntrl;
	cc 	:= app.myCnCntrl;
	str := self.backupWorkers.String & " workers : passing " & self.String & ".";
	if self.isManaged then
		app.cnManagerLog("Initiating on-line database file backup threads (KCOnLineBackupWorker) for " & str);	
		
	else
		app.cnManagerLog("Initiating database file backup threads (KCOnLineBackupWorker) for " & str);	
	endif;	
	
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_AttemptedAccessViaNullRef, null, badObject);	// handle 1090 which can occur (licence restriction, out of memory etc)
	
	d1 := app.relativeMachineTime();
	
	foreach int in 1 to self.backupWorkers do
		proc := null;			// need to initialize as failure to start the process (eg licence exceeded) causes proc to be left as last found
		proc := app.startApplicationWithParameter(CN_CARDSCHEMA, CN_KCONLINEBACKUPWORKER, self);
		// check if valid object
		x := proc.edition;
		if badObject then
			i := i + 1;
			badObject := false;
			continue;
		endif;
		
		beginNotification(proc, Object_Delete_Event, Response_Continuous, Cn_Backup_Process_Deleted); 
		beginTransientTransaction;
		self.processSet.add(proc);
		commitTransientTransaction;
		process.sleep(500);
	endforeach;

	if self.processSet.isEmpty() then
		self.terminateManagedBackup("No backup workers were started, possibly exceeded licences allowed, please check logs.", Backup_Failed);
		return;
		
	else
		app.cnManagerLog("started " & self.backupWorkers.String & " backup workers, " & d1.cnGetElapsedTimeString().cnToLowerFirst());
	endif;
	
	if i <> null then // if we failed to start any backup processes then log and if managed, issue alert						// PAR 1087
		if self.isManaged then																									// PAR 1087
			app.cnManagerLog(i.String & " copies of KCOnlineBackupWorker failed to start (check licence issue)," &				// PAR 1087
								" alert issued");																				// PAR 1087
			app.cnRaiseJossAlert(Cn_Karma_Alert,
								 "Detected failure to start backup workers for " & kc.environmentId.toUpper() & " on " & app.cnComputerName & ".",
								 i.String & " copies of KCOnlineBackupWorker failed to start for JADE environment " &
								 kc.managedEnvironmentName.toUpper() & " on " & app.cnComputerName & ". Possibly licences allowed has been exceeded. Please check logs for reason.",
								 "N",
								 app.actualTime,
								 cc.appName,
								 kc.managedEnvironmentName,
								 app.cnComputerNameAppServer,
								 null,
								 null);
		else																													// PAR 1087
			app.cnManagerLog(i.String & " copies of KCOnlineBackupWorker failed to start (check licence issue)," &				// PAR 1087
								" alert issued");																				// PAR 1087
		endif;																													// PAR 1087
	endif;
end;
}
zBackupCommonSetAbortJournalEnterBackupState
{
zBackupCommonSetAbortJournalEnterBackupState(pJdba : JadeDatabaseAdmin) updating, protected;

vars

begin
	//self.zReviveAllRequiredFiles();																						// PAR 7391. Patch for 58644 makes this call redundant.
	self.startLogNo	:= pJdba.getAbortJournalNumber();																		// PAR 577
	app.cnManagerLog("Starting database journal number = #" & self.startLogNo.String & 										// PAR 577
				" (current=" & pJdba.getCurrentJournalNumber().String & 													// PAR 577
				", abort=" & pJdba.getAbortJournalNumber().String & ").");													// PAR 577
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	app.cnManagerLog("Entering backup transaction state : quiesed=" & self.quiesce.String & ", backupDirectory='" & self.backupDir & "'");
	
	// must enter backupTransaction state before getting database info (via JadeDatabaseAdmin::getAllDbFiles)
	// JadeDatabaseAdmin::beginBackup :
	//     - forces all structure timestamps to be flushed into respective control files (_control.dat and partition control files).
	//     - No mapfile or partition status can be modified while in beginBackup state.
	//     - All modified timestamp updates are suspended until backup state is exited.
	//
	pJdba.beginBackup(self.backupDir, self.quiesce);
	app.cnManagerLog("Now in backup transaction state");
	//
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
end;
}
zBackupCommonSubscribeNotify
{
zBackupCommonSubscribeNotify(pJdba : CnJadeDatabaseAdmin) updating, protected;
constants
	BYTES_PER_EVENT_UNCOMPRESSED : Integer	= 200 * 1024 ^ 2;		// 200MB
	BYTES_PER_EVENT_COMPRESSED	 : Integer	= 5   * 1024 ^ 2;		// 50MB
vars
	msg			: CnBackupAdvice;

	cc			: CnCntrl;
	
	file		: File;

	notificationError	: Boolean;

	logName,
	path,
	str			: String;
begin
	cc := app.myCnCntrl;
	
	if self.compressFiles then
		pJdba.enableByteProgressEvents(BYTES_PER_EVENT_COMPRESSED);
		app.cnManagerLog("Byte progress events requested every " & BYTES_PER_EVENT_COMPRESSED.cnConvertToByteString() & ".");
		
	else
		pJdba.enableByteProgressEvents(BYTES_PER_EVENT_UNCOMPRESSED);
		app.cnManagerLog("Byte progress events requested every " & BYTES_PER_EVENT_UNCOMPRESSED.cnConvertToByteString() & ".");
	endif;

	create file transient;
	if system.getDatabaseRole = SDS_RoleSecondary then
		//					 			
		// Check that the current journal is there.  Immediately after restart, JADE 6.0 ::getCurrentJournalNumber may
		// return the next replayable journal number.  If this happens then we abort the backup since we can't guarantee 
		// that we'll be able to acquire a complete set of journals.
		//
		path := pJdba.getCurrentJournalDirectory();
		logName	:= path & "/db" & startLogNo.String.padLeadingZeros(10) & ".log";
		app.cnManagerLog("SDS secondary : checking that '" & logName & "' is present ...");
		file.fileName 	:= logName;
		file.mode		:= file.Mode_Input;
		if not file.isAvailable then
	  		terminateManagedBackup("Database journal #" & startLogNo.String & " not yet found (SDS secondary) : can't complete backup : " &
	  							   "try closing current journal via SDS Admin then start backup again.", Backup_Failed);
	  	else
	  		app.cnManagerLog("Current journal found OK .... continuing...");
	  	endif;
   	endif;		

	beginClassNotification(CnDatabaseAdmin, 	true, 	pJdba.File_Backup_Start_Event, 		Response_Continuous, Cn_JDB_Managed_Tag);							// 3003			
	beginClassNotification(CnDatabaseAdmin,		true, 	pJdba.File_Backup_Complete_Event, 	Response_Continuous, Cn_JDB_Managed_Tag);							// 3004
	beginClassNotification(CnDatabaseAdmin, 	true, 	pJdba.Backup_Failed_Event, 			Response_Continuous, Cn_JDB_Managed_Tag);							// 3001
	beginClassNotification(CnDatabaseAdmin, 	true, 	pJdba.Backup_Worker_Completed_Event, Response_Continuous, Cn_JDB_Managed_Tag);							// 3005

	beginClassNotification(JadeDatabaseAdmin, 	true, 	pJdba.BackupCompleteEvent, 			Response_Continuous, Cn_JDB_Managed_Tag);							// 3000
	beginClassNotification(JadeDatabaseAdmin, 	true, 	pJdba.BackupAbortedEvent, 			Response_Continuous, Cn_JDB_Managed_Tag);							// 4000
	beginClassNotification(JadeDatabaseAdmin, 	true, 	pJdba.BackupCancelledEvent, 			Response_Continuous, Cn_JDB_Managed_Tag);						// 8000
	beginClassNotification(JadeDatabaseAdmin, 	true, 	pJdba.BackupFailedEvent, 			Response_Continuous, Cn_JDB_Managed_Tag);							// 9000
	if self.isManaged then
		beginClassNotification(DbFile, 			false, 	DbFile.BackupOperationEvent,		Response_Continuous, Cn_JDB_Managed_Tag); 							// 1001
		beginClassNotification(DbFile, 			false, 	DbFile.BackupBytesDoneEvent,		Response_Continuous, Cn_JDB_Managed_Tag); 							// 1002
		beginClassNotification(DbFile, 			false, 	DbFile.BackupOutputEvent,			Response_Continuous, Cn_JDB_Managed_Tag); 							// 1003
		beginClassNotification(DbFile, 			false, 	DbFile.BackupErrorEvent,			Response_Continuous, Cn_JDB_Managed_Tag); 							// 1004
	endif;
	
	beginNotification(system, CN_BACKUP_ABORT_REQUESTED, 0 , Cn_JDB_Managed_Tag);
	
	msg := self.createBackupAdviceMessage(msg.Advice_Type_Backup_Starting);
	if not self.isManaged then
		self.dbFileNames.copy(msg.structureNames);
		self.dbFileLengths.copy(msg.structureSizes);
		app.cnManagerLog("Structure names size = " & self.dbFileNames.size64().String &
							", lengths size = " & self.dbFileLengths.size64().String);
	endif;

	self.droppedDbFileNames.copy(msg.droppedFileNames);
	if cc.appName = CN_KCDATABASEBACKUPMULTI then
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_NotificationInfoTooBig, null, notificationError);
	endif;
	
	msg.sendMessage(null);
	if notificationError then
		str := "Unable to send Backup Starting notification as notification info object too large";
		app.cnManagerLog(str);
		cc.cnWriteLog(cc.CnLogErrors, method.qualifiedName & " " & str, null);
	endif;
epilog
	delete file;
	delete msg;
end;
}
zBackupJournalsAndNonDbFiles
{
zBackupJournalsAndNonDbFiles(pLogText : String) updating, protected;

vars
	cc				: CnCntrl;

	dba				: JadeDatabaseAdmin;

	fileNameArray	: CnStringArray;
	
	fileSizeArray	: Integer64Array;
	
	inError,
	notify			: Boolean;
	
	currentJournal,
	endLogNo		: Integer;

	elapsed,
	result,
	str				: String;
	
begin
	cc		:= app.myCnCntrl;
	dba		:= self.myDba;
	notify	:= not self.disableBackupNotify;
	str := app.getProfileString(app.getIniFileName, CN_PERSISTENTDB, "MaxWaitForQuietPoint", "-1");
	cc.cnWriteLog(cc.CnLogComment, "Ini file specifies MaxWaitForQuietPoint=" & str, null);
	currentJournal := dba.getCurrentJournalNumber();
	if self.enableArchiveRecovery and 
	   system.getDatabaseRole <> SDS_RoleSecondary then
		// from Hugh McColl 2Feb2011
		// A call to closeCurrentJournal is performed as inline synchronous code, 
		// thus guaranteeing that a journal switch record is written to the current
		// journal before the line of code returns. It is an atomic operation that 
		// preps the new journal and increments the currentJournal number as accessed
		// by getCurrentJournalNumber.
		str 	:= pLogText & ", closing current transaction log (" & currentJournal.String & ").";
		dba.closeCurrentJournal();
		currentJournal := dba.getCurrentJournalNumber();
		endLogNo 	:= currentJournal - 1;																						// PAR 819
		
	else
		endLogNo 	:= currentJournal;																							// PAR 819
		str := pLogText & ", current journal #" & currentJournal.String & " will not be closed, in-use ";
		if not self.enableArchiveRecovery then
			str := str & "EnableArchivalRecovery=false.";
			
		else
			str := str & "SDS Secondary database.";
		endif;
	endif;
	
	app.cnManagerLog(str);
	cc.cnWriteLog(cc.CnLogComment, str, null);
	
	app.cnManagerLog("Logs that cover backup period are log #" & self.startLogNo.String & " thru log #" & endLogNo.String);
	elapsed 	:= self.startTime.cnGetElapsedTimeString();
	app.cnManagerLog("Elapsed time to back up database was " & elapsed);

	result := self.backupLogFiles(dba, endLogNo); 
	if result = CN_OK then
		str := "Log files backed up OK, now starting backup of non-db files..."; 
		app.cnManagerLog(str);
		cc.cnWriteLog(cc.CnLogErrors, str, null); 
		if app.name = CN_KCDATABASEBACKUPMULTI then
			if self.backupRemainingFilesInSystem then
				result := self.zBackupRemainingFilesInSystem();
				if result <> CN_OK then
					inError := true;
				endif;
			else
			
			str := self.getName() & "::zBackupRemainingFilesInSystem not executed as database files are located under the environment node.";
			app.cnManagerLog(str);
			endif;
		endif;
		
		if not inError then
			result := self.backupNonDbFiles();
			if result <> CN_OK then
				inError := true;
			else
			
				if app.name = CN_KCDATABASEBACKUPMULTI then
					result := app.myCnBackup.backupDirInclusions();
					if result <> CN_OK then
						inError := true;
					endif;
				endif;	
			endif;
			
		endif;
		
	else
		inError := true;		
	endif;
	
	create fileNameArray transient;
	create fileSizeArray transient;	
	
	if inError then
		beginTransaction;																					// PAR 544
		node.userExitCode := 1;																				// PAR 544
		commitTransaction;																					// PAR 544
		if app.name = CN_KCDATABASEBACKUPMULTI	and
		   notify								then	// only send notifications if 'DisableBackupNotifications=false' in the environments .ini file
			self.buildUserInfoNonManagedBackup(fileNameArray, fileSizeArray, Cn_Backup_Failed, result);
		endif;
		
		self.logAndTerminateBackup(result);
		
	else
		str := "Backup completed OK... see cn_backup.log for details.";
		app.cnManagerLog("Backup completed OK");		// This is the string that an initiating script will search for
		cc.cnWriteLog(cc.CnLogComment, str, null);
		beginTransaction;																					// PAR 544
		node.userExitCode := 2;							// return successful exit code of 2					// PAR 544
		commitTransaction;																					// PAR 544
		if app.name = CN_KCDATABASEBACKUPMULTI 	and
		   notify								then 	// only send notifications if 'DisableBackupNotifications=false' in the environments .ini file
			self.buildUserInfoNonManagedBackup(fileNameArray, fileSizeArray, Cn_Backup_Complete, str);		// create notification to user application
		endif;
		
		self.finalizeAndTerminate();
	endif;
epilog
	delete fileNameArray;
	delete fileSizeArray;
end;
}
zBackupRemainingFilesInSystem
{
zBackupRemainingFilesInSystem():String protected;

vars
	cc				: CnCntrl;

	d1,
	d2				: Decimal[23];
		
	ff				: FileFolder;
	
	fn				: FileNode;

	file			: File;

	str,
	errorText,
	source_Dir		: String;
	
	fileNameArray	: CnStringArray;
	
	fileSizeArray	: Integer64Array;
	
	exclusionsArray	: CnSmallStringArray;
	
	notify			: Boolean;
begin
	cc 				:= app.myCnCntrl;
	notify			:= not self.disableBackupNotify;
	
	create ff 				transient;
	create file 			transient;
	create fileNameArray 	transient;
	create fileSizeArray 	transient;
	create exclusionsArray 	transient;
	exclusionsArray.add(".dat");									// avoid touching database files
	exclusionsArray.add(".tmp");									// avoid touching database transient files

	source_Dir 	:= app.dbPath().toLower();
	source_Dir.replaceChar("\", "/");								// for linux compatibility

	ff.fileName := source_Dir;	
	foreach fn in ff.files do
		if fn.isKindOf(FileFolder) then // we are only interested in files within this single directory node
			continue;
		endif;

		if exclusionsArray.includes(fn.name.toLower()[fn.name.length - 3 : 4]) then
			continue;
		endif;
	
		file.fileName := source_Dir & "/" & fn.name;
		if notify then // only send notifications if 'DisableBackupNotifications=false' in the environments .ini file
			fileNameArray.add(fn.name);
			fileSizeArray.add(file.fileLength64());
			d2 := app.relativeMachineTime();
			if fileNameArray.size() > 500 	or	
			  (d2 - d1) > 1000				then		// don't raise an event on every single file as this could be expensive, update periodically
				self.buildUserInfoNonManagedBackup(fileNameArray, fileSizeArray, Cn_Backup_NonDbFile_Start, "Backing up file... ");
				fileNameArray.clear();
				fileSizeArray.clear();
				d1 := d2;
			endif;
		endif;
		
		app.cnManagerLog("Backing up file " & file.fileName & " as " & self.backupDir & "/" & fn.name);
		file.cnCopyFile(self.backupDir & "/" & fn.name, false, errorText);
		if errorText <> null then		// return error
			return errorText;
		endif;
	endforeach;
	
	if notify then // only send notifications if 'DisableBackupNotifications=false' in the environments .ini file
		self.buildUserInfoNonManagedBackup(fileNameArray, fileSizeArray, Cn_Backup_NonDbFile_Start, "Backing up file... "); // send through any remaining updates
	endif;
	
	return CN_OK;
epilog
	delete ff;
	delete file;
	delete fileNameArray;
	delete fileSizeArray;
	delete exclusionsArray;
end;
}
zBackupWorkersTerminated
{
zBackupWorkersTerminated() updating, protected;

vars
	cc							: CnCntrl;
	
	dbFile						: DbFile;
	
	sdsDba						: CnSDSDatabaseAdmin;
	
	isConnectedToPrimary,
	isSDS_Native,
	exception3124				: Boolean;																						// PAR 1036
	
	alertText,
	result,
	str							: String;
	
	fileNameArray 				: CnStringArray;
	
	fileSizeArray				: Integer64Array;
begin
	cc := app.myCnCntrl;
	str := "All backup worker threads have terminated, error=" & self.abnormalTermination.String & ", abortRequested=" & self.abortRequested.String;
	if not self.abnormalTermination and 
	   not self.abortRequested 		then
		str := str & " : database file backup (on-line) backup completed OK.";
	endif;
	
	app.cnManagerLog(str);
	cc.cnWriteLog(cc.CnLogComment, str, null);
	
	process.sleep(500);	// let workers shut down
	
	if not abnormalTermination then
		if abortRequested then
			app.cnManagerLog("Abort requested but abnormalTermination=false : now waiting for BackupAbortedEvent...");
			return;
		endif;
		
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_BackupIsIncompleteOrBackupinfoCorrupted, dbFile, exception3124);	// PAR 1036
		foreach dbFile in self.allPartitionedDbFiles do
			app.cnManagerLog("Committing partitioned backup on " & dbFile.getName() & "....");
			dbFile.endPartitionedFileBackup();
			if exception3124 then																								// PAR 1036
				self.terminateManagedBackup("Exception 3124 incurred on " & dbFile.getName() &									// PAR 1036
											" (Backup is incomplete or backupinfo corrupted)", Backup_Failed);					// PAR 1036
				return;																											// PAR 1036
			endif;																												// PAR 1036
		endforeach;													
		
		isSDS_Native := system.getDatabaseSubrole() = SDS_SubroleNative;														// NFS 7055
		
		if self.commitCoherentBackup and isSDS_Native then																		// NFS 7055
			create sdsDba transient;
			isConnectedToPrimary := sdsDba.getConnectionState() = SDS_Connected;												// NFS 7055
		endif;
		
		// If requested, take a backup of the SDS native database that can be restored to RPS									// NFS 7055
		if 	self.commitCoherentBackup and 
			isSDS_Native and
			isConnectedToPrimary	then																						// NFS 7055
			
			str := "Committing coherent backup";
			if self.mustBeCommitCoherentBackup then
				str := str & " (request for quiet point will not time out)";
			endif;
			str := str & "...";
			app.cnManagerLog(str);
			if self.zCommitCoherentBackup() then
				beginTransientTransaction;
				self.completedBackupIsCommitCoherent := true;
				commitTransientTransaction;
				app.cnManagerLog("Database commit coherent backup phase complete.");
			
			else
				alertText := "SDS native backup suitable for restore to RPS was specified but was not able to be achieved because a Primary quiet point request timed out. Please consult documentation for suggested remedies.";
				self.zAlertCouldNotTakeCommitCoherentBackup(alertText);
				app.cnManagerLog("Coherent commit backup failed, performing standard commit....");
				self.zCommitBackup();
				app.cnManagerLog("Database backup phase complete.");
			endif;
		else
			str := "Committing backup";																							// NFS 7055
			if self.commitCoherentBackup then 
				if not isSDS_Native then																						// NFS 7055
					str := str & " (commit coherent backup flag ignored because database sub-role is not SDS Native)";			// NFS 7055
				
				elseif not isConnectedToPrimary then
					str := str & " (commit coherent backup flag ignored because SDS Native is not connected to its primary)";	// NFS 7055
					alertText := "SDS native backup suitable for restore to RPS was specified but was not able to be achieved because the connection to the Primary was down.";
					self.zAlertCouldNotTakeCommitCoherentBackup(alertText);
				endif;
			endif;																												// NFS 7055
			
			str := str & "...";	
			app.cnManagerLog(str);
			self.zCommitBackup();																								// NFS 7055
			app.cnManagerLog("Database backup phase complete.");
		endif;
		
		//we no longer compare before vs after database file list																// 7391
		
		if app.name = CN_KCONLINEBACKUP then
			self.closeTranLogAndAdvise();
		endif;
		
		self.zCreateCnDbFiles();
		
		//  this is required for non managed multi worker backups,  from here we will backup journals and non-database files
		if app.name = CN_KCDATABASEBACKUPMULTI then
			str := "Database files backed up OK";
			if not self.disableBackupNotify then // only send notifications if 'DisableBackupNotifications=false' in the environments .ini file
				create fileNameArray transient;
				create fileSizeArray transient;
				self.buildUserInfoNonManagedBackup(fileNameArray, fileSizeArray, Cn_Backup_Workers_Complete, str & ", now performing non-database file backup...");
			endif;
			
			self.zBackupJournalsAndNonDbFiles(str);
		endif;
		
	endif;
				
	self.finalizeAndTerminate();
epilog
	if process.isInExceptionState() then																						// PAR 1036
		app.cnTerminate();																										// PAR 1036
	endif;																														// PAR 1036
	
	delete fileNameArray;
	delete fileSizeArray;
	delete sdsDba;
end;
}
zCommitBackup
{
zCommitBackup();

vars
	jdba : JadeDatabaseAdmin;
begin
	create jdba transient;
	jdba.commitBackup();
epilog
	delete jdba;
end;
}
zCommitCoherentBackup
{
zCommitCoherentBackup() : Boolean updating;

	/*
		Purpose: 
		Backup of database files has completed.
		The SDS Native backup is to be commit coherent for potential restore to an RPS database
		Returns true if able to commit
		Returns false if unable to commit
	*/

vars
	maxTries,
	retryInterval,
	tryCount		: Integer;
begin
	maxTries := self.getCommitCoherentBackupMaxTries();
	retryInterval := self.getCommitCoherentBackupRetryInterval();
	
	app.cnManagerLog(method.name & " parameters: commitCoherentBackupMaxTries=" & maxTries.String & ", commitCoherentBackupRetryInterval=" & retryInterval.String);
	
	while true do
		if self.zTryBackupCoherentCommit() then
			return true;
		endif;
		
		tryCount := tryCount + 1;
		
		if self.mustBeCommitCoherentBackup then
			//we keep trying indefinitely (unless an abort is received).
		
		elseif tryCount = maxTries then
			return false;
		endif;
		
		//wait for specified period and retry
		app.doWindowEvents(retryInterval); //allow backup abort to be processed.
		app.cnManagerLog("Retrying commitCoherent() call...");
	endwhile;
end;
}
zCommitCoherentBackupExceptionHandler
{
zCommitCoherentBackupExceptionHandler(pException : Exception; pCommitErrorCode : Integer output) : Integer;

constants
	Max_Wait_QuietPoint : Integer = 3077;
	//Primary_Not_Connected : Integer = 3221 - JADE exits backup state and fails the backup
	//SDS_Response_Not_Received_In_Time = 3212 - JADE exits backup state and fails the backup
vars

begin
	if 	pException.errorCode = Max_Wait_QuietPoint then
		
		pCommitErrorCode := pException.errorCode;
		app.cnManagerLog("Failed commitCoherent() call due to UE " & pCommitErrorCode.String & " (Maximum time to wait for a quiet point was exceeded)");
		
		return Ex_Resume_Next;
		
	else
		app.cnManagerLog("Failed commitCoherent() call due to UE " & pCommitErrorCode.String & ", passing back to global exception handler");
		return Ex_Pass_Back;
	endif;	
end;
}
zCompactWorkersTerminated
{
zCompactWorkersTerminated() updating, protected;

vars
	cnDatabaseStructure		: CnDatabaseStructure;
	
	cndba					: CnJadeDatabaseAdmin;
	
	dbFile					: DbFile;
	
	dbFileArray				: DbFileArray;
	
	msg						: CnCompactAdvice;

	cc						: CnCntrl;
	
	dbFileExcludeFromBackup,
	dbFileIsPartitioned,	
	dbFrozenArray,
	dbOfflineArray			: BooleanArray;
	
	dbFileNames,
	dbLocations,
	partitionNames			: CnStringArray;
	
	dbFileStatus,
	dbEncryptionStatus		: IntegerArray;																						// JSM PAR 7050
	
	dbFileLengths,
	dbFileUDRLengths,
	dbFileUDRStructures,
	partitionIds			: Integer64Array;
	
	fileLength				: Integer64;
	
	result,
	str						: String;
	
	fx						: CnFunctionAgent;
begin
	cc := app.myCnCntrl;

	str := "All compact worker threads have terminated, error=" & abnormalTermination.String & ", abortRequested=" & abortRequested.String;
	if not self.abnormalTermination and not self.abortRequested then
		str := str & " : database file compaction completed OK.";
	endif;
	
	app.cnManagerLog(str);
	cc.cnWriteLog(cc.CnLogComment, str, null);
	
	if not self.abnormalTermination then
		if abortRequested then
			app.cnManagerLog("Abort requested but abnormalTermination=false : sending compact interrupt advice...");
			msg := createCompactAdviceMessage(msg.Advice_Type_Compact_Interrupt);
		else
			app.cnManagerLog("Finalizing compaction process...");
			msg := createCompactAdviceMessage(msg.Advice_Type_Compact_CompleteOK);
		endif;
	
		app.cnManagerLog("Mapfile sizes after compaction :-");
		foreach cnDatabaseStructure in self.allCnDatabaseStructuresBySize do // get the file sizes again now the compaction has completed
			dbFile := cnDatabaseStructure.myDbFile.DbFile;
			fileLength := dbFile.getTotalFileLength64(dbFile.GetTotLen_Everything);												// PAR 5600
			msg.mapFileSizesAfter.add(fileLength);
			app.cnManagerLog(cnDatabaseStructure.name.padBlanks(32) & fileLength.String);
		endforeach;	
		
		msg.sendMessage(null);
		
		app.cnManagerLog("Get database structure details....");
		create cndba transient;
		create dbFileNames 				transient;
		create partitionNames			transient;
		create partitionIds				transient;
		create dbFileArray				transient;
		create dbFileExcludeFromBackup 	transient;
		create dbFileStatus 			transient;
		create dbFileLengths 			transient;
		create dbFileUDRLengths 		transient;
		create dbFileUDRStructures		transient;
		create dbFileIsPartitioned		transient;
		create dbLocations				transient;			// only required for send details advice
		create dbFrozenArray			transient;			// only required for send details advice
		create dbOfflineArray			transient;			// only required for send details advice
		create dbEncryptionStatus		transient;																					// JSM PAR 7050
		result := cndba.getAllDatabaseStructureInfo(dbFileNames,
													partitionNames,
													dbFileArray,
													dbFileStatus,
													partitionIds,
													null, 							// dbfile kind
													dbLocations,
													dbFileExcludeFromBackup, 
													dbFileLengths, 
													dbFileUDRLengths,
													dbFileUDRStructures,
													dbEncryptionStatus,				// encryption status						// PAR 1004, JSM PAR 7050
													dbFileIsPartitioned,
													null,							// dbfile partition count
													null,							// dbfile modified timestamp
													null,							// dbfile backup timeStamp
													null,							// dbfile full backup timeStamp
													dbFrozenArray,
													dbOfflineArray);
		app.cnManagerLog("Got database structure details, number of structures " & dbFileNames.size64().userNumberFormat($CnWholeNumbers));
		if result = CN_OK then
			cndba.sendDatabaseDetailsAdvice(dbFileNames,
											partitionNames,
											dbFileStatus,
											dbEncryptionStatus,																	// JSM PAR 7050
											partitionIds,
											dbFileLengths,
											dbFileUDRLengths,
											dbFileUDRStructures,
											dbLocations,
											dbFrozenArray,
											dbOfflineArray,
											dbFileExcludeFromBackup);
			create fx transient;
			fx.cnSDSStructureStatePrimUpdate(dbFileNames, dbFileStatus, partitionIds, dbFileExcludeFromBackup, dbFrozenArray, dbOfflineArray); // update the CnSDSStructureState class
		endif;
	endif;
	
	process.sleep(500);						// let workers shut down
	self.finalizeAndTerminateCompact();
epilog
	delete fx;
	delete cndba;
	delete dbFileNames;
	delete partitionNames;
	delete partitionIds;
	delete dbFileExcludeFromBackup;
	delete dbFileStatus;
	delete dbFileLengths;
	delete dbFileUDRLengths;
	delete dbFileUDRStructures;
	delete dbFileIsPartitioned;
	delete dbLocations;
	delete dbFrozenArray;
	delete dbOfflineArray;
	delete dbFileArray;
	delete dbEncryptionStatus;																									// JSM PAR 7050
end;
}
zCreateCnDbFiles
{
zCreateCnDbFiles() protected;

constants
	Unmapped					: Integer = DbFile.Status_Unmapped;
	Indent						: String  = "    ";
vars
	jdba						: CnJadeDatabaseAdmin;
	
	dbFile						: DbFile;
	
	file						: File;
	
	dbFileNames					: CnStringArray; 
	
	dbFileArray					: DbFileArray;
	
	dbFileExcludeFromBackup		: BooleanArray;
	
	dbFileStatus				: IntegerArray;
	
	iterExclude,
	iterFileStatus				: Iterator;
	
	dbFileName					: String;
	
	dbFileExclude				: Boolean;
	
	dbFileStat					: Integer;
begin
	create jdba 					transient;
	create dbFileNames 				transient;
	create dbFileArray				transient;
	create dbFileExcludeFromBackup 	transient;
	create dbFileStatus 			transient;
	create dbFile					transient;
	jdba.getAllDbFileInfo(dbFileNames, 						
							dbFileArray,
							dbFileStatus, 
							null, 							// dbfile kind
							null,							// dbfile location
							dbFileExcludeFromBackup, 
							null,							// dbFileLengths, 
							null,							// dbfile UDR file length
							null,							// dbfile ispartitioned
							null,							// dbfile partition count
							null,							// dbfile modified timestamp
							null,							// dbfile backup timeStamp
							null);							// dbfile full backup timeStamp
				
	create file transient;
	file.fileName := app.dbPath & "/" & CN_DBFILES_BACKUP;
	file.mode     := file.Mode_Output;
	file.open();

	app.cnManagerLog("Creating " & file.fileName & ", content:");
	iterExclude 	:= dbFileExcludeFromBackup.createIterator();
	iterFileStatus 	:= dbFileStatus.createIterator();
	foreach dbFileName in dbFileNames do
		iterExclude.next(dbFileExclude);
		iterFileStatus.next(dbFileStat);
		if dbFileExclude then
			app.cnManagerLog(Indent & dbFileName & " excluded");
			continue;
		endif;
		
		if dbFileStat <> DbFile.Status_Resident then
			app.cnManagerLog(Indent & dbFileName & " status " & dbFile.cnGetStatusFromInput(dbFileStat));
			continue;
		endif;

		app.cnManagerLog(Indent & dbFileName & " file backed up");
		file.writeLine(dbFileName);
	endforeach;
	
	file.close();
epilog
	delete dbFileNames;
	delete dbFileArray;
	delete dbFileExcludeFromBackup; 
	delete dbFileStatus;
	delete jdba;
	delete file;
	delete iterExclude;
	delete iterFileStatus;
	delete dbFile;
end;
}
zGetScanFileContents
{
zGetScanFileContents(pScanFileName : String) : String protected;

vars
	file		: File;
	
	len			: Integer;
	
	len64		: Integer64;
	
	truncated	: String;
begin
	create file transient;
	file.fileName 	:= pScanFileName;
	file.mode 		:= file.Mode_Input;
	// kind will default depending on JADE character set
	len64 := file.fileLength64();
	if len64 > 1024 then
		len := 1024;
		truncated := ".. [truncated]";
	
	else
		len := len64.Integer;
	endif;
	
	if not file.tryOpen() then
		return null;
	endif;
	
	return CrLf & CrLf & "Contents of " & pScanFileName & ":" & CrLf & file.readString(len) & truncated;
epilog
	delete file;
end;
}
zHandleJournalTransferEvent
{
zHandleJournalTransferEvent(pUserInfo : Any);

/*
	Purpose :
	
	When journal transfer event occurs, we initiate KCVerifyJournal if not already running
	and create a shared transient containing the journal number transferred which is to be
	verified by that application.
	
	Refer to PAR #1066.
*/
vars
	cc				: CnCntrl;
	
	kc				: CnKarmaCntrl;
	
	param			: CnParam;
	
	errorCode,
	journalNumber	: Integer;
	
	errorText,
	str				: String;
begin
	cc := app.myCnCntrl;
    on Exception do self.ehGeneralExceptionHandler(exception, errorCode, errorText);		// catch licence or other errors : returns Ex_Abort_Action
	journalNumber := pUserInfo.Integer;
			
	if not node.cnCheckApplicationAlreadyRunningInNode(CnKCVerifyJournal) then
		app.startApplication(CN_CARDSCHEMA, CN_KCVERIFYJOURNAL);
		cc.cnWriteLog(cc.CnLogComment, " " & CN_KCVERIFYJOURNAL & " not running" &
										", application is initiated", null);

	endif;
	
	beginTransientTransaction;
	create param sharedTransient;					// KCVerifyJournal's CnDatabaseAdmin object gets Object_Created notification
	param.journalNo		:= journalNumber;
	commitTransientTransaction;
	
	param.causeEvent(Cn_KCCMgr_JournalTransferEvent, true, null);
	cc.cnWriteLog(cc.CnLogComment, "Journal transfer event (#" & journalNumber.String & ") : CnParam object created for KCVerifyJournal", null);
epilog
	if process.isInExceptionState then
		kc := app.myCnKarmaCntrl;
		str		:= "Initiation of Journal Verification process failed for journal " & journalNumber.String & " for " & 
					kc.environmentId.toUpper() & " on " & node.getComputerName() & 
				   " because error " & errorCode.String & " (" & errorText & ") occurred in " & cc.appName & CrLf & CrLf &
				   "Manually verify journal " & journalNumber.String & " using jdbutil verifyJournal";
		cc.cnWriteLog(cc.CnLogErrors, str & " : raising alert to JSM.", null);
		app.cnRaiseJossAlert(Cn_Karma_Alert,
						 "Journal verification failure for " & kc.environmentId.toUpper() & " on " & node.getComputerName(),
						 str,
						 "N",
						 app.actualTime,
						 cc.appName,
						 kc.managedEnvironmentName,																				// JSM PAR 8367
						 node.getComputerName,
						 kc.networkAddressNode,		// Par 441 node.networkAddress,
						 kc.myParentTcp);
	endif;
end;
}
zPartitionWorkersTerminated
{
zPartitionWorkersTerminated()updating, protected;

vars
	cc			: CnCntrl;
	
	jdba		: CnJadeDatabaseAdmin;
	
	result,
	str			: String;
begin
	cc := app.myCnCntrl;
	str := "All partition worker threads have terminated, error=" & abnormalTermination.String & ", abortRequested=" & abortRequested.String;
	if not self.abnormalTermination and not self.abortRequested then
		str := str & " : partition file backup (on-line) completed OK.";
	endif;
	
	app.cnManagerLog(str);
	cc.cnWriteLog(cc.CnLogComment, str, null);
	
	process.sleep(500);	// let workers shut down
	
	if not abnormalTermination then
		if abortRequested then
			app.cnManagerLog("Abort requested but abnormalTermination=false : now waiting for BackupAbortedEvent...");
			return;
		endif;
		
		app.cnManagerLog("Backup of partition parts complete. Starting database file backup...");
		
		//backup database files
		create jdba transient;
		self.zBackupCommonSubscribeNotify(jdba);
		self.zBackupCommonInitiateWorkers();
	endif;
epilog
	delete jdba;
end;
}
zSetStartJournalNumber
{
zSetStartJournalNumber(pJdba : JadeDatabaseAdmin) updating, protected;

vars
	abortJournNum,
	currentJournNum,
	max,
	min			 		: Integer;
begin
	abortJournNum 	:= pJdba.getAbortJournalNumber();																		
	currentJournNum := pJdba.getAbortJournalNumber();
	
	//Workaround for JADE PAR 62941- to be sure what journals are required for a secondary backup, 
	//we require the earlier of abort number and current number
	min := abortJournNum.min(currentJournNum);																				// PAR 892
	max := abortJournNum.max(currentJournNum);																				// PAR 892
	
	//The earlier of the two journal numbers could be the larger number 
	//if the journal has reached max and started again at 1.
	if (max-min) > 900000 then																								// PAR 892
		self.startLogNo := max;																								// PAR 892
	else																													// PAR 892
		self.startLogNo := min;																								// PAR 892
	endif;
	
	app.cnManagerLog("Starting database journal number = #" & self.startLogNo.String & 										// PAR 577
				" (current=" & currentJournNum.String & 																	// PAR 577
				", abort=" & abortJournNum.String & ").");
end;
}
zSuppressEmbeddedSpaceAlert
{
zSuppressEmbeddedSpaceAlert() : Boolean protected;
/*
	Purpose :
	Refer to PAR 1053.
	
	Obtain and, optionally, initialize the ini file setting for [JSMDatabaseBackup] SuppressEmbeddedSpaceAlert
*/
vars
	iniFileName,
	iniSuppressEmbeddedSpaceAlert	: String;
begin
	iniFileName	:= app.getIniFileName();
	iniSuppressEmbeddedSpaceAlert := app.getProfileString(iniFileName, CN_JSMDATABASEBACKUP, CN_SUPPRESS_EMBEDDEDSPACE_ALERT, null);
	if iniSuppressEmbeddedSpaceAlert.toLower() <> true.String and
	   iniSuppressEmbeddedSpaceAlert.toLower() <> false.String then
		iniSuppressEmbeddedSpaceAlert := null;
	endif;
	
	if iniSuppressEmbeddedSpaceAlert = null then
		iniSuppressEmbeddedSpaceAlert := false.String;
		app.setProfileString(iniFileName, CN_JSMDATABASEBACKUP, CN_SUPPRESS_EMBEDDEDSPACE_ALERT, iniSuppressEmbeddedSpaceAlert);
	endif;
	
	return iniSuppressEmbeddedSpaceAlert.Boolean;
end;
}
zTryBackupCoherentCommit
{
zTryBackupCoherentCommit() : Boolean updating;

	/*
		Purpose:
		Try to perform a coherent commit of a backup
		Returns true if able to commit
		Returns false if unable to commit
	*/

vars
	jdba			: JadeDatabaseAdmin;
	
	exObj 			: NormalException;
	
	commitErrorCode	: Integer;
begin
	on Exception do self.zCommitCoherentBackupExceptionHandler(exception, commitErrorCode);
	
	create jdba transient;
	jdba.commitCoherentBackup();

	return commitErrorCode = 0;
epilog
	delete jdba;
end;
}
zValidationChecks
{
zValidationChecks() : String protected;

vars
	dbPath	: String;
	
	numNodes,
	pos		: Integer;
begin
	dbPath := app.cnStandardizePathName(app.dbPath);
	pos := 1;

	while true do
		pos := dbPath.pos("/", pos);
		if pos = null then
			break;
		endif;
		
		numNodes := numNodes + 1;
		pos := pos + 1;
	endwhile;
	
	if app.cnOSPlatformIsWindows() and numNodes <> 3 then
		return "Application requires 3 level directory structure, refer to CardSchema User Guide documentation";

	elseif app.cnOSPlatformIsUnix() and numNodes <> 4 then
		return "Application requires 4 level directory structure, refer to CardSchema User Guide documentation";
	endif;
		
	return CN_OK;
end;
}
	)
	CnJadeSkinsLoader (
	jadeMethodSources
reload
{
reload(fileName : String; initDir : Boolean; gui : Boolean) : Boolean updating;

vars
	file		: File;
	prop		: Property;
	len			: Integer;
	str			: String;
	fname		: String;
	bin			: Binary;
	skin		: JadeSkin;
	coll		: JadeSkinsColl;
	skinExists	: Boolean;
	type		: Type;
	cmdFile		: CMDFileOpen;
begin
	//  If initDir=true then expects that fileName is an initial directory for the cmdFileOpen dialog.
	//  If initDir=false then fileName must be a valid full path name for the skin file to be loaded.
	//  If the method is being called from a user interface then set gui=true otherwise will throw
	//  an exceoption if there's a problem.  Returns true if load is successful.

	if initDir and gui then
		create cmdFile transient;
		cmdFile.dialogTitle	:= "Select skin file";
		if initDir = null then
			cmdFile.initDir	:= "c:\temp";
		else
			cmdFile.initDir	:= fileName;
		endif;
	
		if not cmdFile.open = 0 then
			return false;
		endif;
		
		fname	:= cmdFile.fileName;
		
	else
		fname	:= fileName;
	endif;
	
	if fname <> null then	 
		create file;
		file.mode		:= file.Mode_Input;
		file.kind		:= file.Kind_Binary;
		file.fileName	:= fname;
		
		if not file.tryOpen() then
			if not gui then
				app.cnRaiseNormalException(Cn_General_Error, "CnJadeSkinsLoader::reload", 						
										   "Can't open skin extract file ' " & file.fileName & "'", false);
			else
				app.msgBox("Can't open skin extract file '" & file.fileName & "'.", "File Open Error", 48);
			endif;
					
			return false;
		endif;
		
		len		:= file.readBinary(4).Integer;
		if len > 50 then
			str	:= "Length of skin name in skin file ' " & file.fileName & "' > 50 bytes : probably not a valid skin file.";
			if not gui then
				app.cnRaiseNormalException(Cn_General_Error, "CnJadeSkinsLoader::reload", str, false); 						
			else
				app.msgBox(str, "Skin File Content Error", 48);
			endif;
					
			return false;
		endif;
		
		str		:= file.readBinary(len).String;				// skin name
		coll	:= app.getSkinCollection();					// outside BT/CT as detour for PAR 21852 5.1.10
		
		beginTransaction;
		if coll <> null then
			foreach skin in coll do
				if skin.name = str then
					skinExists := true;
					break;
				endif;
			endforeach;
		endif;
		
		if not skinExists then
			create skin;
			skin.name	:= str;
		endif;
		
		while not file.endOfFile do
			len	:= file.readBinary(4).Integer;
			str	:= file.readBinary(len).String;			// property name
			len := file.readBinary(4).Integer;
			bin	:= null;
			bin	:= file.readBinary(len);				// property value
			
			prop	:= JadeSkin.getProperty(str);
			type	:= prop.getType;
			
			if type = String then
				skin.setPropertyValue(str, bin.String);
			elseif type = Binary then
				skin.setPropertyValue(str, bin);
			elseif type = Boolean then
				skin.setPropertyValue(str, bin.Boolean);
			elseif type = Integer then
				skin.setPropertyValue(str, bin.Integer);
			endif;
		endwhile;
		
		if not coll.includes(skin) then
			coll.add(skin);
		endif;
		
		commitTransaction;
		
		if gui then
			app.msgBox("JADE skin reload completed.", "Skin Reload", 0);
		endif;
		
		return true;
	endif;

epilog
	delete file;
	delete cmdFile;
end;
}
unload
{
unload(outDir : String; initDir : Boolean) updating;

vars
	file 	: File;
	fname	: String;
	skin	: JadeSkin;
	prop	: Property;
	bin		: Binary;
	ff		: FileFolder;
	path	: String;
	dir		: String;
begin
	//  Unload skins into flat file.  If initDir=true then it is assumed that outDir
	//  is an initial directory name ONLY and a folder selection dialog will be shown.  
	//  Otherwise all skin files will be unloaded into the specified directory without
	//  displaying the folder selection dialog.
	
	if initDir or outDir = null then
		if outDir = null then
			dir	:= "c:\temp";
		else
			dir	:= outDir;
		endif;
		
		create ff transient;
		path 	:= ff.browseForFolder("Specify output directory for skin files", dir);
	
	else
		path	:= outDir;
	endif;
		
	if path <> null then
		create file;
		file.mode	:= file.Mode_Output;
		file.kind	:= file.Kind_Binary;
		
		foreach skin in JadeSkin.instances do
			file.fileName	:= path & "\JadeSkin_" & skin.name;
			file.writeBinary(skin.name.length.Binary & skin.name.Binary);
			
			foreach prop in JadeSkin.getProperties do
				file.writeBinary(prop.name.length.Binary & prop.name.Binary);
				bin := null;
				bin := skin.getPropertyValue(prop.name).Binary;
				file.writeBinary(bin.length.Binary & bin);
			endforeach;
			
			file.close(); 
		endforeach;
		
		app.msgBox("JADE skin unload completed.", "Skin Unload", 0);
	endif;
	
epilog
	delete file;
	delete ff;	
end;
}
	)
	CnNodeControl (
	jadeMethodSources
create
{
create() updating, protected;

vars
	ix			: Integer;
	ix2			: Integer;
	jawsIndex	: Integer;
	port		: String;
	appserver	: String;
	iniFileName	: String;
	cc			: CnCntrl;
	val			: String;
begin
	cc					:= app.myCnCntrl;
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " .....", null);

	self.samplingTag	:= -1;				// not sampling
	iniFileName			:= app.getIniFileNameAppServer;
	
	/////////////  Set up sampling options  ////////////////////////////////
	
	val	:= app.getProfileStringAppServer(iniFileName, "JSMStats", "DefeatNodeSampling", null).toLower();
	if val = null then
		samplingDefeated	:= true;
		app.setProfileStringAppServer(iniFileName, "JSMStats", "DefeatNodeSampling", true.String);
		
	elseif val = "true" then
		samplingDefeated 	:= true;	
	endif;
	
	if app.getProfileStringAppServer(iniFileName, "JSMStats", "SamplingNode", null).toLower() = true.String then
		samplingNode		:= true;
	endif;

	if app.name = CN_KCDATABASEBACKUPMULTI then	// don't start node sampling under KCDatabaseBackupMulti
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " Node sampling is defeated when running " & CN_KCDATABASEBACKUPMULTI , null);
		samplingDefeated	:= true;
	endif;
	
	//  All sampling for a node can be defeated, regardless of management options in JSM

	if not self.samplingDefeated then			
		create cacheDataPersistent sharedTransient;
		create cacheDataTransient sharedTransient;
		
		if not cc.karmaControl and self.samplingNode then		// set up defaults (mainly for non-managed systems)
			self.doSamplingStatusChange(cc.sampleProcessStats, cc.sampleCacheStats);
			self.samplingFrequency	:= cc.samplingFrequency;
		endif;
	endif;
	
	//  Now set up node info 
	cc.deriveNodeId(node, iniFileName, self.nodeType, self.nodeId);
end;
}
delta
{
delta(jdo1, jdo2 : JadeDynamicObject; attributeName : String) : Real protected;

vars
	int1,
	int2	: Integer64;
	
	d1,
	d2,
	d3		: Decimal [23];
	cc		: CnCntrl;
begin
	int1	:= jdo1.getPropertyValue(attributeName).Integer64;
	int2	:= jdo2.getPropertyValue(attributeName).Integer64;
	
	if int2 >= int1 then
		return (int2 - int1).Real;
	endif;
	
	//the value must have wrapped
	// we use decimal values as doing Integer64 arithmetic could cause the values 
	// in brackets to wrap around again resulting in a negative number.
	d1 := (Max_Integer64.Decimal - int1.Decimal);
	d2 := (int2.Decimal - Min_Integer64.Decimal);
	d3 := (d1 + 1 + d2).Real;
	
	// refer to JADE PAR 48965 - transient cache items are NOT multi-thread protected and can incur large errors.
	if d3 > Max_Integer64 then
		cc := app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " value for attribute '" & attributeName & "' exceeded Max_Integer64 (" & d3.String & "), returning null", null);
		return null;
	endif;
	
	return d3.Real;
end;
}
doCacheStatsRequest
{
doCacheStatsRequest() updating;

vars
	bin			: Binary;
	result		: String;
	cc			: CnCntrl;
	csvStats1	: String;
	csvStats2	: String;
	ts			: TimeStamp;
begin
	cc		:= app.myCnCntrl;
	if self.sampleCacheStats then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : preparing to get cache stats for nodeId=" & nodeId & " ....", null);
		bin	:=	getCacheStats(1, csvStats1) &					// persistent
		    	getCacheStats(2, csvStats2);					// transient
	else
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : cache stats request ignored : not enabled for node.", null);
		return;
	endif;	
		    
	if cc.karmaControl then
		sendOrStoreMessage(bin);			// reimplemented in Joss in NodeControl class
	endif;
	
	if cc.logLocalCacheStats then
		ts	:= app.actualTimeServer;
		cc.myNodeCacheStatsFile.writeLine(ts.date.cnUserFormat($CnYYMMDD_ns) & " " & ts.time.cnUserFormat($CnHHMMSS_ns) & CN_COMMA &
									      csvStats1 & CN_COMMA & csvStats2);
	endif;		
end;
}
doSamplingStatusChange
{
doSamplingStatusChange(proc, cache : Boolean) updating;

vars
	cc			: CnCntrl;
	justStarted	: Boolean;
begin
	cc	:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : CURRENT : procStats=" & sampleProcessStats.String & ", cacheStats=" & sampleCacheStats.String &
													   "; NEW : procStats=" & proc.String & ", cacheStats=" & cache.String, null);
	if not cc.clientTranStats then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : sampling status change ignored : ClientTranStats=false for this node.", null);
		return;
	endif;
	if self.samplingDefeated then
		if cc.appName = CN_KCCMGR then				// need to update my NodeControl object otherwise do nothing
			self.sampleCacheStats	:= cache;
			self.sampleProcessStats	:= proc;
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : sampling status change ignored : DefeatNodeSampling=true for this node, " &
											    "however KCCMgr has updated its NodeControl object to indicate current settings.", null);
		else
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : sampling status change ignored : DefeatNodeSampling=true for this node.", null);
		endif;
		
		return;	 
	endif;
	
	if proc or cache then
		//
		if self.samplingTag = -1 then										// sampling wasn't running
			if not cc.samplingDefeated then
				self.samplingTag 	:= node.beginSample("filesmpl", "<null>");
				justStarted			:= true;	
				cc.cnWriteLog(cc.CnLogComment, "This process has initiated node sampling for its node (" & node.name & " - " & self.nodeId &
											   ") : process stats=" & proc.String & ", cache stats=" & cache.String & ", new samplingTag=" &
											   self.samplingTag.String, null);
			else
				cc.cnWriteLog(cc.CnLogErrors, "This process was told to start sampling for node, but ini file has DefeatNodeSampling=true.", null);	
				return;
			endif;
		else
			cc.cnWriteLog(cc.CnLogComment, "Node sampling is already active for this node (" & node.name & " - " & self.nodeId &
										   ") : process stats=" & proc.String & ", cache stats=" & cache.String & ", current samplingTag=" &
											   self.samplingTag.String, null);	
		endif;

		if cache and not sampleCacheStats then
			node.getObjectCaches(cacheDataPersistent, 1);		// reset starting values
			self.zDebugJdoContents("Persistent ", self.cacheDataPersistent);
			node.getObjectCaches(cacheDataTransient, 2);
			self.zDebugJdoContents("Transient ", self.cacheDataTransient);
		endif;
		//
		self.sampleCacheStats	:= cache;
		self.sampleProcessStats	:= proc;
	endif;
			
	if samplingTag <> -1 and not justStarted then
		if not cache and not proc then
			endSampling();
		endif;
	endif;	
end;
}
endSampling
{
endSampling() updating, protected;

vars
	cc	: CnCntrl;
begin
	cc	:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : this process now ending sampling for node, using tag=" &
				  samplingTag.String, null);
	if samplingTag <> 0 then
		node.endSample(samplingTag);
		self.sampleCacheStats	:= false;
		self.sampleProcessStats	:= false;
		samplingTag	:= -1;
	endif;
end;
}
establishNodeControlProcess
{
establishNodeControlProcess();

vars
	cc			: CnCntrl;
	appName		: String;
begin
	//  Node sampling for cache stats is performed by a single process (KCNodeControl or JossNodeControl application)
	//
	cc	:= app.myCnCntrl;

	if not self.samplingDefeated and (cc.karmaControl or (not cc.karmaControl and self.samplingNode)) then
		//
		//  First find if the process is already running
		// 
		if node.cnIsApplicationRunningInNode(CN_KCNODECONTROL, false) then			// process starting KCNodeControl is other than KCNodeControl
			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : KCNodeControl application was already running in this node : not started.", null);
			return;
		endif;

		app.startApplication(CN_CARDSCHEMA, CN_KCNODECONTROL);
		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " has launched KCNodeControl application, for cache stats capture .... now sleeping for 3 secs ....", null);
		process.sleep(3000);								// PAR 329 : avoid deadlock with KCCMgr in Process/Node dictionaries
		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " has launched KCNodeControl application ... continuing....", null);
		return;
	endif;

	cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : node sampling is defeated ([JSMStats] DefeatNodeSampling=true) : " &
															  "KCNodeControl app not started.", null);
end;
}
getCacheStats
{
getCacheStats(cacheType : Integer; csvStr : String output) : Binary updating, protected;

vars
	jdo1, jdo2		: JadeDynamicObject;
	bin				: Binary;
	swappedBuffers	: Real;
	nodeCPUTime		: Real;
	hits			: Real;
	misses			: Real;
	creates			: Real;
	maxBufferSize	: Real;
	totalBuffers	: Real;
	cc				: CnCntrl;
	str				: String;
begin
	cc	:= app.myCnCntrl;

	if cacheType = 1 then			// persistent
		jdo1	:= cacheDataPersistent;
		str		:= "Persistent ";
		
	else
		jdo1	:= cacheDataTransient;
		str		:= "Transient ";
	endif;

	create jdo2 sharedTransient;
	str := str & " jdo1=" & jdo1.getObjectStringForObject(jdo1) & ", jdo2=" & jdo2.getObjectStringForObject(jdo2);
	node.getObjectCaches(jdo2, cacheType);
	self.zDebugJdoContents(str, jdo2);
	
	if not (cc.osDistribution = "SuSE" and cc.osVersion[1] = "8") then			// SUSE 8.0 threading model makes node CPU times invalid
		nodeCPUTime	:= (delta(jdo1, jdo2, Cn_NodeCPUTime)/1000).roundedTo(0);	// JADE PAR 41731 cpu time changed from millisecs to microsecs
	endif;
		
	hits			:= delta(jdo1, jdo2, Cn_Hits);
	misses			:= delta(jdo1, jdo2, Cn_Misses);
	creates			:= delta(jdo1, jdo2, Cn_CreatedBuffers);
	swappedBuffers	:= delta(jdo1, jdo2, Cn_CleanSwappedBuffers) +
					   delta(jdo1, jdo2, Cn_DirtySwappedBuffers);
					   
	maxBufferSize	:= jdo2.getPropertyValue(Cn_MaxBufferSize).Real;	// absolute values
	totalBuffers	:= jdo2.getPropertyValue(Cn_TotalBuffers).Real;				  

	if cc.karmaControl then					   
		bin			:= 0.Integer.Binary 			& 
					   nodeCPUTime.Binary			&								
					   hits.Binary 					&
					   misses.Binary 				&
					   creates.Binary 				&
					   swappedBuffers.Binary		&
					   maxBufferSize.Binary 		&									
					   totalBuffers.Binary			;
					   
		bin[1:4]	:= bin.length.Binary;
	endif;
	
	if cc.logLocalCacheStats then
		csvStr		:= nodeCPUTime.String		& CN_COMMA &
					   hits.String				& CN_COMMA &
					   misses.String			& CN_COMMA &
					   creates.String			& CN_COMMA &
					   swappedBuffers.String	& CN_COMMA &
					   maxBufferSize.String		& CN_COMMA &
					   totalBuffers.String;
	endif;

	if cacheType = 1 then
		cacheDataPersistent	:= jdo2;
	else
		cacheDataTransient	:= jdo2;
	endif;	
	
	return bin;
	
epilog
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & str, null);
	delete jdo1;
end;
}
sendOrStoreMessage
{
sendOrStoreMessage(bin : Binary) updating, protected;

vars
	tmsg		: CnMessage;
	newmsg		: CnMessage;
	msg			: CnNodeStatsAdvice;
	tcp			: CnKarmaTcpConnection;
	result		: String;
	cc			: CnCntrl;
	kc			: CnKarmaCntrl;
	now			: TimeStamp;
	tcpState	: Integer;
	badObject	: Boolean;
begin
	cc		:= app.myCnCntrl;
	kc		:= app.myCnKarmaCntrl;
	create tmsg transient;
	result := tmsg.createNewMsg(msg.Advice, msg.Node_Stats_Advice, null, null, cc.Application_Process, cc.JossCommsMgr_Process, newmsg);
	if result <> CN_OK then
		app.cnRaiseNormalException(Cn_Edit_Error, method.cnGetMethodName(), "Problem in createNewMsg : " & result, false);
	endif;
	
	msg		:= newmsg.CnNodeStatsAdvice;
	msg.setComputerName(app.cnComputerNameAppServer);
	msg.setStatsVersion(Cn_Current_Stats_Version);
	msg.setTimestamp(now);
	msg.setNodeId(nodeId);
	msg.setDataLength(bin.length);
	msg.setData(bin);
	
	if cc.appName = CN_KCCMGR then
		tcp	:= kc.myParentTcp;
		on SystemException do app.cnHandleNullOrInvObjectRef(exception, tcp, badObject);
		tcpState := tcp.state;
		if not badObject and tcpState = 2 then
			msg.sendMessage(tcp);
			return;
		endif;
	endif;
	
	msg.sendMessage(null);
epilog
	delete tmsg;
	delete msg;
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;

vars
	//  Used by non-managed apps when LogLocalCacheStats=true : see app::cnInitializeKCNodeControl 
begin
	if eventTag = 1 then
		beginTransientTransaction;
		self.doCacheStatsRequest;
		if samplingFrequency > 0 then
			beginTimer(samplingFrequency * 1000, Timer_OneShot, 1);
		endif;
		commitTransientTransaction;
	endif;
end;
}
zDebugJdoContents
{
zDebugJdoContents(pCacheType : String; pJdo : JadeDynamicObject); // protected;

vars
	index,
	propCount	: Integer;
	
	propName,
	propValue	: String;
	
begin
	if not self.DeBug then
		return;
	endif;
	
	propCount := pJdo.propertyCount();
	self.zDebugWrite(pCacheType & " : " & pJdo.String & " propertyCount=" & propCount.String);
	foreach index in 1 to propCount do
		propName := pJdo.getPropertyName(index);
		propValue := pJdo.getPropertyValueByIndex(index).String;
		self.zDebugWrite("[" & index.String & "] " & propName & " = '" & propValue & "'");
	endforeach;
end;
}
zDebugWrite
{
zDebugWrite(pText : String) protected;

vars
	cc	: CnCntrl;
begin
	if not self.DeBug then
		return;
	endif;
	
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & pText, null);
end;
}
	)
	CnSchemaAnalyser (
	jadeMethodSources
analyse
{
analyse(specificClass : Class; lincStats : Boolean) updating;
//
//	If specificClass is null then we analyse all classes in the schema. 
//  The lincStats boolean is for future use.
//
//	R W Mitchell JADE Direct 19 April 2001. 
//
//  Version 2 	New totals for real and abstract entities, forms.			23/11/01
//
vars
	cc 					: CnCntrl;
	coll				: ClassColl;
	class				: Class;
	tLines				: Integer;
	rMethods, aMethods	: Integer;
	aMeths, rMeths		: Integer;
	aClasses, rClasses	: Integer;
	aForms, rForms		: Integer;
	lines				: Integer;
	methods				: Integer;
	methDict			: MethodNDict;
	type				: Type;
	pType				: Type;
	typeColl			: TypeColl;
begin
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogComment, "----- Schema Analysis for " & currentSchema.name & "  --------", null);
	
	if class = null then
		coll	:= currentSchema.getAllClasses(false);
	
	else
		create coll transient;
		coll.add(specificClass);
	endif;
	
	create methDict transient;
	
	foreach class in coll do
		methDict.clear();
		if class.schema = currentSchema then						// locally defined classes and subschema copies only
			class.getMethods(methDict);
			countSourceLines(methDict, lines, aMeths, rMeths);
			if not (methods = 0 and class._isSubschemaCopy) then	// exclude subschema copies with no local methods
				cc.cnWriteLog(cc.CnLogComment, "     Class " & class.name & " : real methods=" & rMeths.String &
											   ", abstract methods=" & aMeths.String &  ", code lines=" & lines.String, null);
				if class.abstract then
					aClasses	:= aClasses + 1;
				else
					rClasses	:= rClasses + 1;
				endif;
				
				if class.isKindOf(GUIClass) then
					if class.abstract then
						aForms	:= aForms + 1;
					else
						rForms	:= rForms + 1;
					endif;
				endif;
				 
				aMethods	:= aMethods + aMeths;
				rMethods	:= rMethods + rMeths;
				tLines		:= tLines + lines;
			endif;
		endif;
	endforeach;
	
	typeColl	:= currentSchema.allPrimitives();
	
	foreach type in typeColl do
		methDict.clear();
		pType	:= currentSchema.getLocalPrimitive(type.name);
		if pType <> null then
			pType.getMethods(methDict);
			countSourceLines(methDict, lines, aMeths, rMeths);
			cc.cnWriteLog(cc.CnLogComment, "     Type " & pType.name & " : methods=" & (aMeths + rMeths).String & ", code lines=" & lines.String, null);
			aMethods 	:= aMethods + aMeths;
			rMethods 	:= rMethods + rMeths;
			tLines		:= tLines + lines;
		endif;
	endforeach;
	
	cc.cnWriteLog(cc.CnLogComment, " ", null);
	cc.cnWriteLog(cc.CnLogComment, "--------------------------------------------------------", null);
	cc.cnWriteLog(cc.CnLogComment, "Total classes analysed = " & (aClasses + rClasses).String & " (real=" & rClasses.String & ", abstract=" & 
								   aClasses.String & ")", null);
	cc.cnWriteLog(cc.CnLogComment, "Total GUI classes = " & (aForms + rForms).String & " (real=" & rForms.String & ", abstract=" & aForms.String &
								   ")", null);
	cc.cnWriteLog(cc.CnLogComment, "Total methods = " & (aMethods + rMethods).String & " (real=" & rMethods.String & ", abstract=" & aMethods.String &
							       ", code lines=" & tLines.String, null);
	cc.cnWriteLog(cc.CnLogComment, "---------------------------------------------------------", null);
	
epilog
	delete methDict;
	delete typeColl;
	delete coll; 
end;
}
countSourceLines
{
countSourceLines(methDict : MethodNDict; lines : Integer io; amethods, rmethods : Integer io) protected, updating;

vars
	meth	: Method;
	str		: String;
	len		: Integer;
	line	: String;
	s		: Schema;
begin
	lines		:= 0;
	amethods	:= 0;
	rmethods	:= 0;
	
	foreach meth in methDict do
		if meth.getSchema = currentSchema then			// exclude methods declared in superschemas
			if meth.abstract then
				amethods := amethods + 1;
			else
				rmethods := rmethods + 1;
			endif;
			str	:= meth.getSource;
			len	:= str.length;
			pos	:= 1;
			
			if len > 0 then
				while true do		
					line := str.scanUntil(CrLf, pos);
					if line <> "constants" 			and
					   line <> "vars" 				and
					   line <> "begin" 				and
					   line <> "epilog"				and
					   line	<> "end;"				and
					   line.trimLeft[1:2] <> "//" 	and
					   line.trimBlanks <> Tab		and
					   line.trimBlanks <> null 		then
						lines := lines + 1;
					
					else
						if pos = 0 then
							break;
						endif;
						pos		:= pos + 2;
						if pos > len then
							break;
						endif;
					endif;
					
					if pos = 0 then
						break;
					endif;
				endwhile;
			endif;
		endif;
	endforeach;	

end;
}
discardUntil
{
discardUntil(str : String) : String updating, protected;

vars
	token	: String;
	newLine	: Boolean;
begin
	while true do
		token	:= getNextToken(newLine);
		if token = str then
			return str;
		endif;
	endwhile;
end;
}
displayUnexpectedToken
{
displayUnexpectedToken(methodName : String; token : String) protected;

vars

begin
	app.msgBox("Unexpected token encountered in method " & methodName & CrLf &
			   "Token=" & token, "Program or File Format Error", 48);
end;
}
doClassConstantDefinitions
{
doClassConstantDefinitions() : String updating, protected;

vars
	token		: String;				// method not completed yet
	constName	: String;
	const		: Constant;
	line		: String;
	coll		: ConstantNDict;
	ts, ts2		: TimeStamp;
	modifier	: String;
	newLine		: Boolean;
	doneTs		: Boolean;
	noGet		: Boolean;
begin
	if currentType = null then						// new class : skip over the detail	
		while true do
			token	:= getNextToken(newLine);
			
			if token = ")" then
				token	:= getNextToken(newLine);
			endif;
			
			if token = "documentationText" then
				token	:= skipDocumentationText(newLine);
			endif;
			
			if isSectionHeading(token) 	or
			   isGroupHeading(token)	then
				return token;
			endif;
		endwhile;
	endif;
	
	printIt(INDENT & "Constants", BOLD);
	
	create coll transient;
	currentType.Class.getConstants(coll);
	
	while true do
		if token = "documentationText" then
			token	:= skipDocumentationText(newLine);
		elseif not noGet then
			token	:= getNextToken(newLine);
		endif;
		
		noGet	:= false;
		
		if token = ")" then
			return token;
		endif;
		
		if isSectionHeading(token) 	or
		   isGroupHeading(token)	then
			return token;
		else
			constName	:= token;
			line		:= INDENT & INDENT & constName;
		endif;
		
		doneTs	:= false;
		
		while true do
			token	:= getNextToken(newLine);							// now get modified timestamp line
			if token = "documentationText" then
				token	:= skipDocumentationText(newLine);
			endif;
			
			if isGroupHeading(token) or isSectionHeading(token) then
				const	:= currentType.getConstant(constName);
				if const = null then
					printIt(line & Tab & Tab & Tab & "Constant not in target schema (NEW CONSTANT)", false);
				else
					if coll.includes(const) then
						coll.remove(const);
					endif;
					ts2		:= const.cnGetModifiedTimeStamp;
					line	:= line & Tab & formatTimeStamp(null, null) & Tab & formatTimeStamp(ts2, const.cnGetModifierName);
					printComparison(line, null, ts2, false);
				endif;
				
				return token;
							
			elseif token = MODIFIED_TIMESTAMP then
				ts 		:= getTimeStamp(modifier);
				const	:= currentType.getConstant(constName);
				if const = null then
					printIt(line & Tab & formatTimeStamp(ts, modifier) & Tab & Tab & "Constant not in target schema (NEW CONSTANT)", false);
				else
					if coll.includes(const) then
						coll.remove(const);
					endif;
					ts2		:= const.cnGetModifiedTimeStamp;
					line	:= line & Tab & formatTimeStamp(ts, modifier) & Tab & formatTimeStamp(ts2, const.cnGetModifierName);
					printComparison(line, ts, ts2, false);					
				endif;
				
				break;
				
			elseif newLine and not doneTs then				// the constant we're processing had no setModifiedTime in the schema file
				noGet	:= true;
				const	:= currentType.getConstant(constName);
				if const = null then
					printIt(line & Tab & formatTimeStamp(ts, modifier) & Tab & Tab & "Constant not in target schema (NEW CONSTANT)", false);
				else
					if coll.includes(const) then
						coll.remove(const);
					endif;
					ts2		:= const.cnGetModifiedTimeStamp;
					ts		:= ts2;
					line	:= line & Tab & formatTimeStamp(ts, modifier) & Tab & formatTimeStamp(ts2, const.cnGetModifierName);
					printComparison(line, ts, ts2, false);					
				endif;
				
				break;
			endif;
		endwhile;
	endwhile;
	
epilog
	if coll <> null and completeClassDefinition then
		foreach const in coll do
		   	ts			:= const.cnGetModifiedTimeStamp;
			modifier	:= const.cnGetModifierName;
			 if ts = null then
			  	ts		:= const.creationTime;
		   	endif;
			printIt(INDENT & INDENT & const.name & Tab & Tab & formatTimeStamp(ts, modifier) & Tab & 
				        "Class constant in database but not in schema file : will be deleted" & Tab & CHECK, false);
		endforeach;
		
		delete coll;
	endif;
end;
}
doGlobalConstantDefinitions
{
doGlobalConstantDefinitions() : String protected, updating;

vars
	str			: String;
	modifier	: String;
	constName	: String;
	ts, ts2		: TimeStamp;
	line		: String;
	token		: String;
	coll		: ConstantNDict;
	const		: Constant;
	newLine		: Boolean;
	noGet		: Boolean;
	doneTs		: Boolean;
begin
	printIt(INDENT & "Global Constants", BOLD);				//  NOT FINISHED 
	
//	currentType.Class.getConstants(coll);
	
	while true do
		if token = "documentationText" then
			token	:= skipDocumentationText(newLine);
		elseif not noGet then
			token	:= getNextToken(newLine);
		endif;
		
		noGet	:= false;
		
		if token = ")" then
			return token;
		endif;
		
		if isSectionHeading(token) 	or
		   isGroupHeading(token)	then
			return token;
		else
			constName	:= token;
			line		:= INDENT & INDENT & constName;
		endif;
		
		doneTs	:= false;
		
		while true do
			token	:= getNextToken(newLine);							// now get modified timestamp line
			if token = "documentationText" then
				token	:= skipDocumentationText(newLine);
			endif;

			if isGroupHeading(token) or isSectionHeading(token) then
				const	:= currentType.getConstant(constName);
				if const = null then
					printIt(line & Tab & Tab & Tab & Tab & "Constant not in target schema (NEW CONSTANT)", false);
				else
					if coll.includes(const) then
						coll.remove(const);
					endif;
					ts2		:= const.cnGetModifiedTimeStamp;
					line	:= line & Tab & formatTimeStamp(null, null) & Tab & formatTimeStamp(ts2, const.cnGetModifierName);
					printComparison(line, null, ts2, false);
				endif;
				
				return token;
							
			elseif token = MODIFIED_TIMESTAMP then
				ts 		:= getTimeStamp(modifier);
				const	:= currentType.getConstant(constName);
				if const = null then
					printIt(line & Tab & formatTimeStamp(ts, modifier) & Tab & Tab & "Constant not in target schema (NEW CONSTANT)", false);
				else
					if coll.includes(const) then
						coll.remove(const);
					endif;
					ts2		:= const.cnGetModifiedTimeStamp;
					line	:= line & Tab & formatTimeStamp(ts, modifier) & Tab & formatTimeStamp(ts2, const.cnGetModifierName);
					printComparison(line, ts, ts2, false);					
				endif;
				
				break;
				
			elseif newLine and not doneTs then				// the constant we're processing had no setModifiedTime in the schema file
				noGet	:= true;
				const	:= currentType.getConstant(constName);
				if const = null then
					printIt(line & Tab & formatTimeStamp(ts, modifier) & Tab & Tab & "Constant not in target schema (NEW CONSTANT)", false);
				else
					if coll.includes(const) then
						coll.remove(const);
					endif;
					ts2		:= const.cnGetModifiedTimeStamp;
					ts		:= ts2;
					line	:= line & Tab & formatTimeStamp(ts, modifier) & Tab & formatTimeStamp(ts2, const.cnGetModifierName);
					printComparison(line, ts, ts2, false);					
				endif;
				
				break;
			endif;
		endwhile;
	endwhile;
	
epilog
	if coll <> null then
		foreach const in coll do
		   	ts			:= const.cnGetModifiedTimeStamp;
			modifier	:= const.cnGetModifierName;
			 if ts = null then
			  	ts		:= const.creationTime;
		   	endif;
			printIt(INDENT & INDENT & const.name & Tab & Tab & formatTimeStamp(ts, modifier) & Tab & 
				        "Constant in database but not in schema file : will be deleted" & Tab & CHECK, false);
		endforeach;
		
		delete coll;
	endif;
	end;
}
doInverseDefinitions
{
doInverseDefinitions() updating, protected;

vars

begin

end;
}
doJadeMethodDefinitions
{
doJadeMethodDefinitions(jadeMethods : Boolean) : String updating, protected;

vars
	modifier	: String;
	ts, ts2		: TimeStamp;
	line		: String;
	meth		: Method;
	methodName	: String;
	token		: String;
	coll		: MethodNDict;
	newLine		: Boolean;
	str			: String;
	doneTs		: Boolean;
	noGet		: Boolean;
begin
	if currentType = null then						// new class : skip over the detail	
		while true do
			token	:= getNextToken(newLine);
			
			if token = ")" then
				token	:= getNextToken(newLine);
			endif;
			
			if token = "documentationText" then
				token	:= skipDocumentationText(newLine);
			endif;
			
			if isSectionHeading(token) 	or
			   isGroupHeading(token)	then
				return token;
			endif;
		endwhile;
	endif;
	
	if jadeMethods then
		str	:= "Methods";
	else
		str	:= "External Methods";
	endif;
	
	printIt(INDENT & str, BOLD);
	create coll transient;
	currentType.cnGetMethods.copy(coll);

	while true do
		if token = "documentationText" then
			token	:= skipDocumentationText(newLine);
		elseif not noGet then
			token	:= getNextToken(newLine);
		endif;
		
		noGet	:= false;
		
		if isSectionHeading(token) 	or
		   isGroupHeading(token)	or
		   token = ")" 				then
			return token;
		else
			methodName	:= token;
			line	:= INDENT & INDENT & methodName;
		endif;
		
		doneTs	:= false;
		
		while true do
			token	:= getNextToken(newLine);							// now get modified timestamp line
			if token = "documentationText" then
				token	:= skipDocumentationText(newLine);
			endif;
			
			if token = MODIFIED_TIMESTAMP then
				ts 		:= getTimeStamp(modifier);
				meth	:= currentType.cnGetMethods[methodName];
				
				if meth <> null and coll.includes(meth) then
					ts2	:= meth.cnGetModifiedTimeStamp;
					line	:= line & Tab & formatTimeStamp(ts, modifier) & Tab & formatTimeStamp(meth.cnGetModifiedTimeStamp, meth.cnGetModifierName);  
					printComparison(line, ts, ts2, false);
				    coll.remove(meth);
				else
					printIt(line & Tab & formatTimeStamp(ts, modifier) & Tab & Tab & "New method", false);
				endif;
					
				break;
			endif;
		endwhile;
	endwhile;
	
epilog
	if completeClassDefinition and coll <> null then
		foreach meth in coll do
			if (jadeMethods and meth.isKindOf(JadeMethod)) or
			   (not jadeMethods and not meth.isKindOf(JadeMethod)) then
				printIt(INDENT & INDENT & meth.name & Tab & Tab & formatTimeStamp(meth.cnGetModifiedTimeStamp, meth.cnGetModifierName) & 
						Tab & "Method in database but not in schema file : will be deleted." & Tab & CHECK, false);
			endif;
		endforeach;
	endif;
	
	delete coll;
end;
}
doPropertyDefinitions
{
doPropertyDefinitions(references : Boolean) : String updating, protected;

vars
	propName	: String;
	prop		: Property;
	token		: String;
	line		: String;
	ts, ts2		: TimeStamp;
	modifier	: String;
	coll		: PropertyNDict;
	reference	: Boolean;
	listIt		: Boolean;
	str			: String;
	newLine		: Boolean;
	noGet		: Boolean;
	doneTs		: Boolean;
begin
	if currentType = null then						// new class : skip over the detail	
		while true do
			token	:= getNextToken(newLine);
			
			if token = ")" then
				token	:= getNextToken(newLine);
			endif;
			
			if token = "documentationText" then
				token	:= skipDocumentationText(newLine);
			endif;
			
			if isSectionHeading(token) 	or
			   isGroupHeading(token)	then
				return token;
			endif;
		endwhile;
	endif;

	create coll transient;
	currentType.Class.cnGetProperties.copy(coll);
	if references then
		printIt(INDENT & "References", BOLD);
	else
		printIt(INDENT & "Attributes", BOLD);
	endif;

	while true do
		if token = "documentationText" then
			token	:= skipDocumentationText(newLine);
		elseif not noGet then
			token	:= getNextToken(newLine);
		endif;
		
		noGet	:= false;
		
		if token = ")" then
			token	:= getNextToken(newLine);
		endif;
		
		if isSectionHeading(token) 	or
		   isGroupHeading(token)	then
			return token;
		else
			propName	:= token;
			line		:= INDENT & INDENT & propName;
		endif;
		
		doneTs	:= false;
	
		while true do
			token	:= getNextToken(newLine);							// now get modified timestamp line
			if token = "documentationText" then
				token	:= skipDocumentationText(newLine);
			endif;
			
			if isGroupHeading(token) or isSectionHeading(token) then
				prop	:= currentType.getProperty(propName);
				if prop = null then
					printIt(line & Tab & Tab & Tab & "Property not in target schema (NEW PROPERTY)", false);
				else
					if coll.includes(prop) then
						coll.remove(prop);
					endif;
					ts2		:= prop.cnGetModifiedTimeStamp;
					line	:= line & Tab & formatTimeStamp(null, null) & Tab & formatTimeStamp(ts2, prop.cnGetModifierName);
					printComparison(line, null, ts2, false);
				endif;
				
				return token;
							
			elseif token = MODIFIED_TIMESTAMP then
				listIt	:= false;
				ts 		:= getTimeStamp(modifier);
				doneTs	:= true;
				prop	:= currentType.getProperty(propName);
				if prop = null then
					printIt(line & Tab & formatTimeStamp(ts, modifier) & Tab & Tab & "Property not in target schema (NEW PROPERTY)", false);
				else
					if coll.includes(prop) then
						coll.remove(prop);
					endif;
					ts2		:= prop.cnGetModifiedTimeStamp;
					line	:= line & Tab & formatTimeStamp(ts, modifier) & Tab & formatTimeStamp(ts2, prop.cnGetModifierName);
					printComparison(line, ts, ts2, false);					
				endif;
				
				break;
				
			elseif newLine and not doneTs then				// the property we're processing had no setModifiedTime in the schema file
				noGet	:= true;
				prop	:= currentType.getProperty(propName);
				ts		:= null;
				modifier:= null;
				if prop = null then
					printIt(line & Tab & formatTimeStamp(ts, modifier) & Tab & Tab & "Property not in target schema (NEW PROPERTY)", false);
				else
					if coll.includes(prop) then
						coll.remove(prop);
					endif;
					ts2		:= prop.cnGetModifiedTimeStamp;
					line	:= line & Tab & formatTimeStamp(ts, modifier) & Tab & formatTimeStamp(ts2, prop.cnGetModifierName);
					printComparison(line, ts, ts2, false);					
				endif;
				
				break;
			endif;
		endwhile;
	endwhile;
	
epilog
	if coll <> null and completeClassDefinition then
	foreach prop in coll do
			reference	:= prop.isKindOf(Reference);
			if (references and reference) 			or
			   (not references and not reference) 	then 
			   	ts			:= prop.cnGetModifiedTimeStamp;
			   	modifier	:= prop.cnGetModifierName;
			   	if ts = null then
			   		ts		:= prop.creationTime;
			   	endif;
				printIt(INDENT & INDENT & prop.name & Tab & Tab & formatTimeStamp(ts, modifier) & Tab & 
				        "Property in database but not in schema file : will be deleted" & Tab & CHECK, false);
			endif;
		endforeach;
		
		delete coll;
	endif;
end;
}
doTypeDefinitions
{
doTypeDefinitions() : String updating, protected;

vars
	line		: String;
	defnStr		: String;
	token		: String;
	typeName	: String;
	ts, ts2		: TimeStamp;
	modifier	: String;
	newLine		: Boolean;
begin
	while true do
		token			:= getNextToken(newLine);
		write">>  ::doTypeDefinitions : token = " & token;
		if isSectionHeading(token) then
			return token;
		else
			typeName	:= token;
		endif;
		line			:= "Type " & typeName;
		currentType	:= targetSchema.getClass(typeName);
		if currentType = null then
			currentType	:= targetSchema.getPrimitive(typeName);
		endif;
		
		if currentType = null then
			token	:= getNextToken(newLine);							// now get modified timestamp line
			if token = MODIFIED_TIMESTAMP then
				ts 		:= getTimeStamp(modifier);
				printIt(line & Tab & formatTimeStamp(ts, modifier) & Tab & Tab & "Class not in target schema (NEW CLASS)", BOLD);
			else
				printIt(line & Tab & "<unknown>" & Tab & Tab & "Class not in target schema (NEW CLASS)", BOLD);
			endif;
			
			discardUntil(")");
			continue;
		endif;
		
		token			:= getNextToken(newLine);
		if token = "completeDefinition" then
			completeClassDefinition	:= true;
			defnStr					:= token;
		else
			completeClassDefinition	:= false;
			defnStr					:= "partialDefinition";
		endif;
			
		if completeClassDefinition then
			while true do
				token	:= getNextToken(newLine);							// now get modified timestamp line
				if token = MODIFIED_TIMESTAMP then
					ts 		:= getTimeStamp(modifier);
					if currentType = null then
						printIt(line & Tab & formatTimeStamp(ts, modifier) & Tab & Tab & "Class not in target schema (NEW CLASS)", BOLD);
					else
						ts2		:= currentType.cnGetModifiedTimeStamp;
						line	:= line & Tab & formatTimeStamp(ts, modifier) & Tab & formatTimeStamp(ts2, currentType.cnGetModifierName);
						printComparison(line, ts, ts2, BOLD);					
					endif;
					
					break;
				elseif token = ")" then
					break;
				endif;
			endwhile;
			
			token			:= getNextToken(newLine);
		else
			printIt(line & Tab & Tab & Tab & defnStr, BOLD);
		endif;
		
		if isSectionHeading(token) or isGroupHeading(token) then
			while true do
				if token = "constantDefinitions" then
					token	:= doClassConstantDefinitions();
					
				elseif token = "attributeDefinitions" then
					token	:= doPropertyDefinitions(false);
					
				elseif token = "referenceDefinitions" then
					token	:= doPropertyDefinitions(true);
					
				elseif token = "jadeMethodDefinitions" then 
					token	:= doJadeMethodDefinitions(true);
					
				elseif token = "externalMethodDefinitions" then
					token	:= doJadeMethodDefinitions(false);
					
				elseif token = "eventMethodMappings" then
					token		:= discardUntil(")");
					
				elseif token = "documentationText" then
					token		:= skipDocumentationText(newLine);
					
				elseif isSectionHeading(token) then
					return token;
				endif;
				
				if token = ")" or token = "" then
					break;
				endif;
			endwhile;
		endif;
	endwhile;

epilog
	write ">>>>>>> Exitting ::doTypeDefinitions  <<<<";	
end;
}
formatTimeStamp
{
formatTimeStamp(ts : TimeStamp; modifier : String) : String updating, protected;

vars

begin
	if ts = null then
		return " ";
	endif;
	
	return ts.date.cnUserFormat($CnDDMMYY) & "  " & ts.time.String & "  (" & modifier & ")";
end;
}
getNextToken
{
getNextToken(newLine : Boolean output) : String updating, protected;

constants
	SChars	= ' =",;:()' & Tab;
	BChars  = ' =",;:(' & Tab;
vars
	s, str	: String;
	len		: Integer;
	rs		: String;
begin
	if not lastRecord and (pos > currentLineLength or pos = 0 or currentLineLength = 0) then
		while not inFile.endOfFile do
			str				:= inFile.readLine();
			if str <> null and str <> " " then
				break;
			endif;
		endwhile;
		
		if inFile.endOfFile then
			lastRecord	:= true;
		endif;
		
		currentLine			:= str;
		currentLineLength	:= str.length;
		if currentLineLength = 0 then
			pos				:= 0;
			if lastRecord then
				endOfFile	:= true;
			endif;
		else
			pos				:= 1;
			newLine			:= true;
		endif;
	endif;
	
	if pos = 1 then
		currentLine.scanWhile(BChars, pos);			// strip leading Tabs and blanks, except ")"
		
		if pos > 0 and pos < 3 and currentLine[pos] = ")" and currentLineLength <= pos then
			rs	:= ")";
			return rs;
		endif;
	endif;
		
	if pos <> 0 then
		currentLine.scanWhile(SChars, pos);			// strip leading Tabs and blanks
		if pos <> 0 then
			if currentLine[pos] = ")" and currentLineLength <= pos then
				return ")";
			endif;

			s		:= currentLine.scanUntil(SChars, pos);
		else	
			if lastRecord then
				endOfFile	:= true;
			endif;
		endif;
	endif;		
		
	while true do
		if s = null and not endOfFile then
			s := getNextToken(newLine);
		else
			len	:= s.length;
			if (len = 2 and s[2] = ")") or (len = 1 and s = ")") then											// just a right bracket
				rs	:= ")";
			elseif s[len] = ")" and pos > 0 and currentLine[pos] <> '"' and currentLine[pos] <> ";" then		// something followed by a right bracket
				pos	:= pos - 1;
				rs	:= s[1 : len - 1]; 
			else
				rs	:= s;
			endif;
			
			if rs = "inStartupMode" then
				write "Stop here";
			endif;
			
			return rs;
		endif;
	endwhile;
	
epilog	
	write "::getNextToken = " & rs;
end;
}
getTimeStamp
{
getTimeStamp(modifier : String output) : TimeStamp updating, protected;

vars
	day, month, year	: Integer;
	hour, min, sec, ms	: Integer;
	str					: String;
	time				: Time;
	ts					: TimeStamp;
	date				: Date;
	ix					: Integer;
	newLine				: Boolean;
	token				: String;
	newPos				: Integer;
begin
	str			:= getNextToken(newLine);					// modifier
	modifier	:= str;
	str			:= getNextToken(newLine);					// Jade version	- discard
	token		:= getNextToken(newLine);
	//
	//  Now figure out whether there is a patch number or not : find the colon after
	//  the year number.
	//
	newPos	:= 1;
	currentLine.scanUntil(":", newPos);
	if newPos = pos then
		year	:= token.Integer;
	else
		year		:= getNextToken(newLine).Integer;
	endif;
	//
	month		:= getNextToken(newLine).Integer;
	day			:= getNextToken(newLine).Integer;
	date.setDate(day, month, year);
	hour		:= getNextToken(newLine).Integer;
	min			:= getNextToken(newLine).Integer;
	str			:= getNextToken(newLine);
	ix			:= 1;
	sec			:= str.scanUntil(".", ix).Integer;
	ms			:= str[ix + 1 : end].Integer;
	
	time.setTime(hour, min, sec, ms);
	ts.setTime(time);
	ts.setDate(date);
	return ts;	
end;
}
isGroupHeading
{
isGroupHeading(token : String) : Boolean protected;

vars

begin
	if token = "attributeDefinitions" 		or
	   token = "referenceDefinitions" 		or
	   token = "constantDefinitions" 		or
	   token = "jadeMethodDefinitions" 		or
	   token = "externalMethodDefinitions"	or
	   token = "eventMethodMappings" 		or	
	   token = "categoryDefinition"			or
	   token = "documentationText"			then
	   	return true;
   endif;
end;
}
isSectionHeading
{
isSectionHeading(heading : String) : Boolean protected;

vars

begin
	if heading = "constantDefinitions"				or
	   heading = "localeDefinitions"				or
	   heading = "localeFormatDefinitions"			or
	   heading = "translatableStringDefinitions"	or
	   heading = "libraryDefinitions"				or
	   heading = "typeHeaders" 						or 
	   heading = "membershipDefinitions" 			or
	   heading = "typeDefinitions" 					or
	   heading = "inverseDefinitions" 				or
	   heading = "databaseDefinitions"				or
	   heading = "typeSources"						then
	   	return true;
   endif;
end;
}
polishTable
{
polishTable(table : Table input) updating, protected;

vars
	i, j	: Integer;
	int		: Integer;
	width	: Real;
begin
	foreach i in 2 to table.rows do
		foreach j in 1 to table.columns do
			table.accessCell(i, j).alignment	:= table.Alignment_Left;
		endforeach;
	endforeach; 	

	table.cnAdjustColumnWidths;
	int		:= 0;
	foreach i in 1 to table.columns do
		int := int + table.columnWidth[i];
	endforeach;
	
    table.width	:= 980;
    if int < 980 then
    	table.columnWidth[5]	:= table.columnWidth[5] + 980 - int;
    endif;
end;
}
printComparison
{
printComparison(line : String; ts, ts2 : TimeStamp; fontBold : Boolean) protected;

vars
	comment	: String;
	action	: String;
	listIt	: Boolean;
begin
	if ts = null and ts2.isValid then
		comment	:= "Source defines new entity but entity is already in database";
		action	:= CHECK;
		listIt	:= true;
	elseif ts > forkDate and ts2 > forkDate then	// scm file and target have both been updated
		comment	:= "Source and target have both been updated since fork date";
		action	:= CHECK;
		listIt	:= true;
	elseif ts2 > forkDate then
		comment	:= "Target has been updated since fork date";
		action	:= CHECK;
		listIt	:= true;
	elseif ts > forkDate then
		listIt	:= true;
		comment	:= "Source only has been updated since fork date";	
	endif;
	
	if listIt or printAll then
		printIt(line & Tab & comment &
				Tab & action, fontBold);
	endif; 
end;
}
printIt
{
printIt(str : String; bold : Boolean) protected;

vars
	i	: Integer;
begin
	write "Printing line=" & str;

	if outFile <> null then
		outFile.writeLine(str);
	endif;
	
	i	:= pTable.addItem(str);
	if bold then
		pTable.accessCell(i, 1).fontBold	:= true;
	endif;	
end;
}
printReport
{
printReport() updating, protected;

constants
	Max_Rows_Per_Page	: Integer = 35;
vars
	form		: CnSchemaAnalysisOutputForm;
	rowHeight	: Integer;
	lastOne		: Boolean;
begin
	polishTable(pTable);
	form				:= myForm;
	form.frData.width	:= pTable.width;
	rowHeight			:= pTable.rowHeight[2];			// row 1 is higher, at 25.
	pTable.topRow		:= 2;
	
	while true do
		if pTable.rows - pTable.topRow < Max_Rows_Per_Page then
			pTable.height	:= 25 + (pTable.rows - pTable.topRow + 1) * rowHeight;
			lastOne	:= true;
		else
			pTable.height	:= 550;
		endif;
			
		form.frData.height		:= pTable.height;
		form.frMidFooter.caption 	:= "Report Run Date : " & app.actualTime.String;
       	app.printer.print(form.frData);
       	
       	if lastOne then
       		break;
       	else
       		pTable.topRow	:= pTable.topRow + Max_Rows_Per_Page;
       	endif;
   	endwhile;   	
       	
	app.printer.close();
	delete form;
end;
}
reportChangesSinceForkDate
{
reportChangesSinceForkDate(forkdate : TimeStamp; schemaFileName : String; outputFileName : String; printAllEntities : Boolean) updating;

vars
	str		: String;
	heading	: String;
	i		: Integer;
	token	: String;
	newLine	: Boolean;
begin
	create outFile transient;
	outFile.mode		:= outFile.Mode_Output;
	outFile.fileName	:= outputFileName;
	
	create inFile transient;
	inFile.mode			:= inFile.Mode_Input;
	inFile.fileName		:= schemaFileName;
	
	if not inFile.isAvailable then
		app.msgBox("Schema file '" & schemaFileName & "' not found.", "Error", 48);
		app.cnTerminate();
	endif;
	
	while not inFile.endOfFile() do
		str	:= inFile.readLine;
		pos	:= 1;
		token := str.getNextToken(pos);
		token := str.getNextToken(pos);
		if token = "subschemaOf" then
			break;
		endif;
	endwhile;
	
	if pos > 0 then
		pos	:= 1;
		token	:= str.getNextToken(pos);
		targetSchema	:= currentSchema.getSchema(token);
		self.forkDate	:= forkdate;
		token	:= str.getNextToken(pos);
		token	:= str.getNextToken(pos);
		token	:= str.getNextToken(pos);		// complete or partial definition
		if token[1:18] = "completeDefinition" then
			completeSchemaDefinition	:= true;
		endif;
	else
		app.cnTerminate();
	endif;				
	
	pos		:= 0;
	token	:= getNextToken(newLine);
	if not isSectionHeading(token) then
		app.cnTerminate();
	endif;
	
	if printAllEntities then
		printAll	:= true;
	endif;
	
	setupPrinter();
	
	while not endOfFile do
		if token = "typeSources" then
			break;
		endif;
		
		if not isSectionHeading(token) then
			token	:= getNextToken(newLine);
		endif;
		
		write "ReportChangesSinceFD : token=" & token;
		
		if token = "constantDefinitions" then						// note : not all areas of schema file yet processed !!
			token	:= doGlobalConstantDefinitions();								
		elseif token = "localeDefinitions" then
			token	:= getNextToken(newLine);
		elseif token = "translatableStringDefinitions" then
			token	:= getNextToken(newLine);
		elseif token = "libraryDefinitions" then
			token	:= getNextToken(newLine);
		elseif token = "localeFormatDefinitions" then
			token	:= getNextToken(newLine);
		elseif token = "libraryDefinitions" then
			token	:= getNextToken(newLine);
		elseif token = "externalFunctionDefinitions" then
			token	:= getNextToken(newLine);
		elseif token = "typeHeaders" then
			token	:= getNextToken(newLine);
		elseif token = "membershipDefinitions" then
			token	:= getNextToken(newLine);
		elseif token = "typeDefinitions" then
			token	:= doTypeDefinitions();
		elseif token = "inverseDefinitions" then
			token	:= getNextToken(newLine);
		elseif token = "databaseDefinitions" then
			token	:= getNextToken(newLine);
		elseif token = "typeSources" then
			break;
		endif;
	endwhile;
	
	printReport();

epilog
	delete inFile;
	delete outFile;		
end;
}
setupPrinter
{
setupPrinter() protected, updating;

vars
	form 		: CnSchemaAnalysisOutputForm;
	cmdPrint	: CMDPrint;
	str			: String;
begin
	create cmdPrint;
	if cmdPrint.open = 0 then									// not cancelled and no error 
		str := cmdPrint.printerName;							// use returned value
	else
		app.cnTerminate();
	endif;

	app.printer.setPrinter(str);
	
	create form;
	myForm	:= form;
	create pTable transient;
	pTable.rows			:= 1;
	pTable.fixedColumns	:= 0;
	pTable.columns		:= 5;
	pTable.column		:= 1;
	pTable.parent 		:= form.frData;
	form.addControl(pTable);
	pTable.fontName		:= "Arial";
	pTable.fontSize		:= 8;
	form.frData.height		:= 450;
	form.frData.width		:= 1000;
	form.frHead2.caption	:= "Schema File Name : " & inFile.fileName & "  (TimeStamp : " & inFile.lastModified.String & ")";
	form.frHead3.caption	:= "Target Schema : " & targetSchema.name & "    Target database path : " & app.dbPath;
	form.frHead4.caption	:= "Analysis of Changes Since Fork Date : " & forkDate.date.cnUserFormat($CnDDMMYY) & " " & forkDate.time.String;
   	app.printer.setHeader(form.frHeader);
	app.printer.pageBorderWidth := 0;
   	app.printer.setFooter(form.frFooter);
   	app.printer.setMargins(Print_Landscape, 5, 10, 10, 10);	
   	app.printer.printPreview	:= true;			
   	setupTableHeadings();
   	
 epilog
 	delete cmdPrint;
end;
}
setupTableHeadings
{
setupTableHeadings() updating, protected;

vars
	table	: Table;
begin
	table				:= pTable;
	table.rowHeight[1]	:= 25;
	table.backColor		:= White;
	
	table.cnSetHeading(1, "Schema Entity", 3);
	table.cnSetHeading(2, "Input File",  3);
	table.cnSetHeading(3, "Target Database",  3);
	table.cnSetHeading(4, "Comment", 3);
	table.cnSetHeading(5, "Action",  3);
end;
}
skipDocumentationText
{
skipDocumentationText(newLine : Boolean output) : String updating, protected;

vars
	token		: String;
	modifier	: String;
begin
	while token <> MODIFIED_TIMESTAMP do
		token	:= getNextToken(newLine);
	endwhile;
	
	return token;
end;
}
	)
	CnServerStatistics (
	jadeMethodSources
captureSystemStatistics
{
captureSystemStatistics() updating;

vars
	jdoCurrDbStats,
	jdoCurrDbCacheStats,																										// 3.7.05
	jdoCurrReqStats,
	jdoPrevDbStats,
	jdoPrevDbCacheStats,																										// 3.7.05
	jdoPrevReqStats		: JadeDynamicObject;
	
	bin,
	bin2				: Binary;																								// 3.7.05
	
	htmlThinSessions,																											// PAR 992
	jadeDevProcesses,																											// PAR 992
	jadeThinNonJadeDevProcesses,																								// PAR 992
	nonJadeDevProcesses,																										// PAR 992
	processesLeft					: Integer64;																				// PAR 992
begin
	if self.useFirst then
		self.useFirst 		:= false;
		jdoCurrReqStats 	:= self.jdoRequestStats1;
		jdoPrevReqStats 	:= self.jdoRequestStats2;
		jdoCurrDbStats  	:= self.jdoDatabaseStats1;
		jdoPrevDbStats 		:= self.jdoDatabaseStats2;
		jdoCurrDbCacheStats	:= self.jdoDbCacheStats1;																			// 3.7.05
		jdoPrevDbCacheStats	:= self.jdoDbCacheStats2;																			// 3.7.05
		if jdoPrevReqStats.name = null then
			jdoPrevReqStats := null;
		endif;

		if jdoPrevDbStats.name = null then
			jdoPrevDbStats 	:= null;
		endif;
		
		if jdoPrevDbCacheStats.name = null then																					// 3.7.05
			jdoPrevDbCacheStats := null;																						// 3.7.05
		endif;																													// 3.7.05
		
	else
		self.useFirst 		:= true;
		jdoCurrReqStats 	:= self.jdoRequestStats2;
		jdoPrevReqStats 	:= self.jdoRequestStats1;
		jdoCurrDbStats  	:= self.jdoDatabaseStats2;
		jdoPrevDbStats 		:= self.jdoDatabaseStats1;
		jdoCurrDbCacheStats	:= self.jdoDbCacheStats2;																			// 3.7.05
		jdoPrevDbCacheStats	:= self.jdoDbCacheStats1;																			// 3.7.05
	endif;
	
	jdoCurrReqStats.clearValues();
 	system.getRequestStats(jdoCurrReqStats);
	
	jdoCurrDbStats.clearValues();
	system.getDatabaseStats(jdoCurrDbStats);
	
	jdoCurrDbCacheStats.clearValues();																							// 3.7.05
	system.getDbDiskCacheStats(jdoCurrDbCacheStats);																			// 3.7.05
		
	self.jadeLicenceInfo.getLicenceInfo();

	// PAR 992 - when we're in a takeover situation and a SDS Primary is transition to a SDS Secondary							// PAR 992
	// PAR 992 - then some of the licence info has been observed to go negative which looks bizarre when graphing				// PAR 992
	htmlThinSessions :=	self.jadeLicenceInfo.nHtmlThinSessions.Integer64.max(0);												// PAR 992
	jadeDevProcesses :=	self.jadeLicenceInfo.nJadeDevProcesses.Integer64.max(0);												// PAR 992
	jadeThinNonJadeDevProcesses := self.jadeLicenceInfo.nJadeThinNonJadeDevProcesses.Integer64.max(0);							// PAR 992
	nonJadeDevProcesses := self.jadeLicenceInfo.nNonJadeDevProcesses.Integer64.max(0);											// PAR 992
	processesLeft	:= self.jadeLicenceInfo.nProcessesLeft.Integer64.max(0);													// PAR 992

	// Joss reporting constants
	// 	TranStatsLog.getValue derives offset depending on stats version:
	//		all counts start at offset 6 as the header is Dxxxx where x is the total length of counts in binary form
	//		version 5 - used Integer values from System.getStatistics so entities were 4 long - total length of counts in binary was 68
	//		version 6 - using Integer64 values - total length of counts = 148
	//		offset calc:
	//				ver 5 : <constant> mod 1000 * 4 + 6
	//				ver 6 : <constant> mod 1000 * 8 + 6
	// 	1000	COMMITTED_TRANS	
	// 	1001	ABORTED_TRANS
	// 	1002	GET_OBJECTS
	// 	1003	CREATE_OBJECTS
	// 	1004	DELETE_OBJECTS
	// 	1005	UPDATE_OBJECTS
	// 	1006	LOCK_OBJECTS
	// 	1007	UNLOCK_OBJECTS
	// 	1008	BEGIN_NOTES
	// 	1009	END_NOTES
	// 	1010	DELIVERED_NOTES
	// 	1011 	SERVER_METHOD_EXECUTIONS
	// 	1012	HTML_SESSIONS
	// 	1013	JADE_DEV_PROCESSES
	// 	1014 	THIN_CLIENT_APP_PROCESSES
	// 	1015	FAT_CLIENT_APP_PROCESSES
	// 	1016	PROCESSES_LEFT
	// 	1017 	QUEUED_LOCKS
	//	1018	LOCK_QUEUE_WAITTIME
	//	1019	CAUSE_EVENTS
	//	1020	CHECKPOINTS
	//	1021	CHECKPOINT_DURATION
	//	1022	SDS_REPLAY_LAG_TIME
	// 	1023	DB_CACHE_MISSES																									// 3.7.05
	//  1024	DB_CACHE_GETS																									// 3.7.05
	//	1025	DB_CACHE_PUTS																									// 3.7.05
	//  1026	DB_CACHE_BLOCK_READS																							// 3.7.05
	//  1027	DB_CACHE_GETS_WITH_FETCH																						// 3.7.05
	//	1028	DB_CACHE_PUTS_WITH_FETCH																						// 3.7.05
	//	1029	DB_CACHE_BLOCKS_FETCHED																							// 3.7.05
	//	1030	DB_CACHE_BLOCK_READS_MULTIPLE																					// 3.7.05
	//	1031	DB_CACHE_BUFFER_REASSIGNS																						// 3.7.05
	//	1032	DB_CACHE_BUFFER_STEALS																							// 3.7.05
	//	1033	DB_CACHE_MAX_HASH_COLLISIONS																					// 3.7.05
	//	1034	DB_CACHE_MAX_CONCURRNTFLUSHIOS																					// 3.7.05
	//	1035	DB_CACHE_BLOCK_WRITES																							// 3.7.05
	//	1036	DB_CACHE_BLOCK_WRITES_MULTIPLE																					// 3.7.05
	bin := (37*8).Integer.Binary &				// contains the total length of the following fields.
			jdoCurrReqStats.cnGetDeltaInteger64("committedTransactions", 	jdoPrevReqStats).Binary 	&	// 	 0
			jdoCurrReqStats.cnGetDeltaInteger64("abortedTransactions", 		jdoPrevReqStats).Binary 	&	//	 1
			jdoCurrReqStats.cnGetDeltaInteger64("getObjects", 				jdoPrevReqStats).Binary 	&	//	 2
			jdoCurrReqStats.cnGetDeltaInteger64("createObjects", 			jdoPrevReqStats).Binary 	&	//	 3
			jdoCurrReqStats.cnGetDeltaInteger64("deleteObjects", 			jdoPrevReqStats).Binary 	&	//	 4
			jdoCurrReqStats.cnGetDeltaInteger64("updateObjects", 			jdoPrevReqStats).Binary 	&	//	 5
			jdoCurrReqStats.cnGetDeltaInteger64("lockObjects", 				jdoPrevReqStats).Binary 	&	//	 6
			jdoCurrReqStats.cnGetDeltaInteger64("unlockObjects", 			jdoPrevReqStats).Binary 	&	//	 7
			jdoCurrReqStats.cnGetDeltaInteger64("beginNotifications", 		jdoPrevReqStats).Binary 	&	//	 8
			jdoCurrReqStats.cnGetDeltaInteger64("endNotifications", 		jdoPrevReqStats).Binary 	&	//	 9
			jdoCurrReqStats.cnGetDeltaInteger64("deliveredNotifications", 	jdoPrevReqStats).Binary  	&	//	10
			jdoCurrReqStats.cnGetDeltaInteger64("serverMethodExecutions", 	jdoPrevReqStats).Binary  	&	//	11
			htmlThinSessions.Binary							 											&	//	12				// PAR 992
			jadeDevProcesses.Binary							 											&	//	13				// PAR 992
			jadeThinNonJadeDevProcesses.Binary												 			&	//	14				// PAR 992
			nonJadeDevProcesses.Binary														 			&	//	15				// PAR 992
			processesLeft.Binary															 			&	//	16				// PAR 992
			jdoCurrReqStats.cnGetDeltaInteger64("queuedLocks", 				jdoPrevReqStats).Binary 	&	//	17
			jdoCurrReqStats.cnGetDeltaInteger64("totalLockQueueWaitTime", 	jdoPrevReqStats).Binary  	&	//	18
			jdoCurrReqStats.cnGetDeltaInteger64("causeEvents", 				jdoPrevReqStats).Binary		&	//	19
			jdoCurrDbStats.cnGetDeltaInteger64("checkPoints",				jdoPrevDbStats).Binary		&	//	20
			jdoCurrDbStats.getPropertyValue("lastCheckPointDuration").Binary							&	//	21
			self.zGetSDSReplayLagTime().Binary; 															//	22
	bin2 :=	jdoCurrDbCacheStats.cnGetDeltaInteger64("cacheMisses", 			jdoPrevDbCacheStats).Binary &	// 	23				// 3.7.05
			jdoCurrDbCacheStats.cnGetDeltaInteger64("gets", 				jdoPrevDbCacheStats).Binary &	// 	24				// 3.7.05
			jdoCurrDbCacheStats.cnGetDeltaInteger64("puts", 				jdoPrevDbCacheStats).Binary &	// 	25				// 3.7.05
			jdoCurrDbCacheStats.cnGetDeltaInteger64("blockReads", 			jdoPrevDbCacheStats).Binary &	// 	26				// 3.7.05
			jdoCurrDbCacheStats.cnGetDeltaInteger64("getsWithFetch", 		jdoPrevDbCacheStats).Binary &	// 	27				// 3.7.05
			jdoCurrDbCacheStats.cnGetDeltaInteger64("putsWithFetch", 		jdoPrevDbCacheStats).Binary &	// 	28				// 3.7.05
			jdoCurrDbCacheStats.cnGetDeltaInteger64("blocksFetched", 		jdoPrevDbCacheStats).Binary &	// 	29				// 3.7.05
			jdoCurrDbCacheStats.cnGetDeltaInteger64("blockReadsMultiple", 	jdoPrevDbCacheStats).Binary &	// 	30				// 3.7.05
			jdoCurrDbCacheStats.cnGetDeltaInteger64("bufferReassigns", 		jdoPrevDbCacheStats).Binary &	// 	31				// 3.7.05
			jdoCurrDbCacheStats.cnGetDeltaInteger64("bufferSteals", 		jdoPrevDbCacheStats).Binary &	// 	32				// 3.7.05
			jdoCurrDbCacheStats.cnGetDeltaInteger64("maxHashCollisions", 	jdoPrevDbCacheStats).Binary &	// 	33				// 3.7.05
			jdoCurrDbCacheStats.cnGetDeltaInteger64("maxConcFlushIos", 		jdoPrevDbCacheStats).Binary &	// 	34				// 3.7.05
			jdoCurrDbCacheStats.cnGetDeltaInteger64("blockWrites", 			jdoPrevDbCacheStats).Binary &	// 	35				// 3.7.05
			jdoCurrDbCacheStats.cnGetDeltaInteger64("blockWritesMultiple", 	jdoPrevDbCacheStats).Binary;	// 	36				// 3.7.05
			
	self.statsSummaryV1 := bin;
	self.statsSummaryV2 := bin2;																								// 3.7.05
	self.zCheckProcessLicenceCount(self.jadeLicenceInfo.nProcessesLeft);														// PAR 916
end;
}
copyTransientsToArray
{
copyTransientsToArray(pObjectArray : ObjectArray input);

vars

begin
	pObjectArray.add(self);
	pObjectArray.add(self.jadeLicenceInfo);
	pObjectArray.add(self.jdoDatabaseStats1);
	pObjectArray.add(self.jdoDatabaseStats2);
	pObjectArray.add(self.jdoRequestStats1);
	pObjectArray.add(self.jdoRequestStats2);
	pObjectArray.add(self.jdoDbCacheStats1);
	pObjectArray.add(self.jdoDbCacheStats2);
end;
}
create
{
create() updating;

vars

begin
	create self.jdoRequestStats1 transient;
	create self.jdoRequestStats2 transient;
	create self.jdoDatabaseStats1 transient;
	create self.jdoDatabaseStats2 transient;
	create self.jadeLicenceInfo  transient;
	create self.jdoDbCacheStats1 transient;
	create self.jdoDbCacheStats2 transient;
	self.useFirst := true;

	self.zGetRemainingProcessAlertThreshold();																					// PAR 953
end;
}
delete
{
delete() updating;

vars

begin
	delete self.jdoRequestStats1;
	delete self.jdoRequestStats2;
	delete self.jdoDatabaseStats1;
	delete self.jdoDatabaseStats2;
	delete self.jadeLicenceInfo;
	delete self.jdoDbCacheStats1;
	delete self.jdoDbCacheStats2;
end;
}
getStatsSummary
{
getStatsSummary() : Binary;

vars

begin
	return self.statsSummaryV1 &
		   self.statsSummaryV2;
end;
}
zCheckProcessLicenceCount
{
zCheckProcessLicenceCount(pProcessesLeft : Integer) updating, protected;
/*	
	Purpose:
	- PAR #916
	check to see if the remaining licences are under or above threshold defined in ini file.
*/
vars
	cc				: CnCntrl;
	
	kc				: CnKarmaCntrl;
	
	alertType		: Character;
	
	alertThreshold	: Integer;
	
	alertBody,
	alertHeader		: String;
begin
	cc 				:= app.myCnCntrl;
	kc				:= app.myCnKarmaCntrl;
	// threshold value defined in ini file:
	// - SDS Primary or non-SDS 	[Karma] RemainingProcessAlertThreshold 
	// - SDS Secondary native 		[Karma] RemainingProcessAlertThresholdSecondary
	// - SDS Secondary relational 	defaults to zero
	alertThreshold 	:= self.remainingProcessAlertThreshold;
	if alertThreshold = null then
		return;
	endif;
	
	if alertThreshold <= pProcessesLeft then
		if self.remainingProcessAlertTimeStamp <> null then 
			self.remainingProcessAlertTimeStamp := null;
			cc.cnWriteLog(cc.CnLogComment, "JADE License process count remaining " & pProcessesLeft.String & " now higher than threshold " & alertThreshold.String & ". Resetting threshold alert time stamp.", null);
		endif;
		
		return;
	endif;
	
	//remaining process count is less than defined threshhold create/update alert
	alertHeader := "JADE License process count threshold exceeded for environment " & kc.managedEnvironmentName;
	alertBody := "JADE License process count remaining " & pProcessesLeft.String & " below threshold " & alertThreshold.String & " specified in ini file.";
	if self.remainingProcessAlertTimeStamp = null then
		self.remainingProcessAlertTimeStamp := app.actualTime();
		cc.cnWriteLog(cc.CnLogComment, "Raising new alert : " & alertBody, null);
		alertType := "N";
			
	else
		cc.cnWriteLog(cc.CnLogComment, "Repeat alert : " & alertBody, null);
		alertType := "R";
	endif;
	
	app.cnRaiseAlert(alertHeader, alertBody, alertType, self.remainingProcessAlertTimeStamp, cc.appName, kc.localFQDN, kc.localIpAddress);
end;
}
zGetOrSetRemainingProcessAlertThreshold
{
zGetOrSetRemainingProcessAlertThreshold(pIniFileVerb : String) : Integer subschemaHidden, protected;

vars
	iniValue		: Integer;
	
	iniFileName		: String;	
begin
	iniFileName 	:= app.getIniFileName();
	iniValue 		:= app.getProfileString(iniFileName,
											CN_KARMA,
											pIniFileVerb,
											"-1").Integer;
	if iniValue = -1 then
		// if ini file setting not defined, explicitly define it
		iniValue	:= null;
		app.setProfileString(iniFileName,
							CN_KARMA,
							pIniFileVerb,
							"0");
	endif;
	
	return iniValue;
end;
}
zGetRemainingProcessAlertThreshold
{
zGetRemainingProcessAlertThreshold() updating, subschemaHidden, protected;
/*
	Purpose :
	
	Obtain the relevant Remaining Process threshold when we start alerting.
	
	This value is dependent on whether :
	- SDS Primary or non-SDS
	- SDS Secondary
	
	We ignore this value for RPS nodes.
	
	Refer to PAR #953.
*/
vars
	cc					: CnCntrl;
	
	databaseRole,
	databaseSubrole,
	iniValue,
	iniValueSecondary	: Integer;
	
	iniVerb				: String;
begin
	cc					:= app.myCnCntrl;
	// get / set  'RemainingProcessAlertThreshold' from ini file
	iniValue 			:= self.zGetOrSetRemainingProcessAlertThreshold(CN_REMAININGPROCESSALERTTHRESHOLD);
	
	// get / set  'RemainingProcessAlertThresholdSecondary' from ini file
	iniValueSecondary 	:= self.zGetOrSetRemainingProcessAlertThreshold(CN_REMAININGPROCESSALERTTHRESHOLD_SECONDARY);

	iniVerb				:= CN_REMAININGPROCESSALERTTHRESHOLD;
	databaseRole		:= system.getDatabaseRole();
	if databaseRole = SDS_RoleSecondary then
		databaseSubrole := system.getDatabaseSubrole();
		if databaseSubrole = SDS_SubroleRelational then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " RPS node, RemainingProcessAlertThreshold ignored", null);
			return;
		endif;
		
		iniValue		:= iniValueSecondary;
		iniVerb			:= CN_REMAININGPROCESSALERTTHRESHOLD_SECONDARY;
	endif;
	
	self.remainingProcessAlertThreshold := iniValue;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " RemainingProcessAlertThreshold set to " & iniValue.String, null);
end;
}
zGetSDSReplayLagTime
{
zGetSDSReplayLagTime() : Integer64 protected;

vars
	jdo						: JadeDynamicObject;
	
	sdsDba					: CnSDSDatabaseAdmin;
	
	replayTs,
	stableTs				: TimeStamp;
	
	delta					: Integer64;
begin
	create sdsDba transient;
	if sdsDba.sdsGetDatabaseRole() <> SDS_RoleSecondary then
		return null;
	endif;
	
	if not sdsDba.sdsIsRunning() then
		return null;
	endif;
	
	create jdo transient;
	sdsDba.sdsGetMyServerInfo(jdo);
	
	if jdo.getPropertyValue("connectionState").Integer <> SDS_Connected then
		return null;
	endif;

	if not jdo.getPropertyValue("tracking").Boolean then
		return null;
	endif;
	
	if jdo.getPropertyValue("syncMode").Integer <> SDS_BlockWrite then
		return null;
	endif;
	
	replayTs	:= jdo.getPropertyValue("latestReplayedAuditTimeStamp").TimeStamp;
	stableTs	:= jdo.getPropertyValue("latestStableAuditTimeStamp").TimeStamp;
	delta		:= replayTs.cnSecondsDifference(stableTs);
	return delta;
epilog
	delete jdo;
	delete sdsDba;
end;
}
	)
	CnTransactionData (
	jadeMethodSources
handleTranStatsSubmissionEvent
{
handleTranStatsSubmissionEvent(userInfo : Any) updating;

vars
 	file				: CnFile;

 	cc					: CnCntrl;
	
	kc					: CnKarmaCntrl;
	
	sd					: CnStackDump;
	
 	info,
 	tcData				: Binary;
 	
	nodeStats,
	isIPv6,
 	tranError,
	tranStatsRequired	: Boolean;																								// PAR 855
	

	clientType			: Byte;																									// PAR 632
	
	alertStatus			: Character;																							// PAR 855
 	
	date				: Date;
 	
	dbTransactionId		: Decimal[23];

	pos,
 	spos,
 	len,
 	len2,
	len3,
 	idLength,
 	index,
 	elapsed,
 	tcLen,
 	tcPos,
 	aPos,
 	bPos,
	processId,
	level				: Integer;
 	
 	cpuTime,
 	getObjects,
 	lockObjects,
 	unlockObjects,
 	createObjects,
 	updateObjects,
 	deleteObjects,
 	endTransactions,
 	causeEvents,
 	serverExecutions,
 	serverExecutionTime,
 	lockQueueWaitsTime,
 	tcMsgsAppServer,
 	tcBytesAppServer,
 	tcMsgsClient,
 	tcBytesClient,
 	tcNetworkTime,
 	perceivedResponse,
 	loopTime			: Real;
 	
 	appName,
	computerName,
	computerNameNode,																											// PAR 980
 	errString,
 	id,
	ipAddress,
	str,
 	userName			: String;
 	
	tranStatsAlertTs,																											// PAR 855
	ts,
	tsNow				: TimeStamp;																							// PAR 855
begin
	cc				:= app.myCnCntrl;
	kc				:= app.myCnKarmaCntrl;
	tranStatsRequired	:= (kc.tranStatsInterval > null);
	info			:= userInfo.Binary;
	file			:= app.myCnTranLogFile;
	if file.currentDate <> date then
		file.close;
		file.fileName		:= cc.logPath & "/cn_tranlog_" & date.cnUserFormat($CnCCYYMMDD_ns) & ".csv"; 
		file.currentDate	:= date;
		kc.setUpTranLogHeadings(file);
	endif;
	
	pos := kc.decodeTransactionStatsHeader(info,
											computerName,
											computerNameNode,																	// PAR 980
											ipAddress,
											userName,
											appName,
											nodeStats);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " processing transaction stats received from application " & appName, null);
	len				:= info.length;	
	aPos			:= 1;							// Diagnostics sequence
    bPos			:= 1000;
/*    while true do
    	if len < bPos then
   	  		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : len=" & len.String & ", startPos=" & aPos.String & ", info=" & info[aPos:end].display, null);
   	  		break;
   	  	else
   	  		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : len=" & len.String & ", startPos=" & aPos.String & ", info=" & info[aPos:bPos].display, null);
   	  		aPos	:= bPos + 1;
   	  		bPos	:= bPos + 1000;
   	  	endif;
 	endwhile;										// end of diagnostics											
*/
	while pos < len do
		spos		:= pos;
//		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " pos=" & pos.String, null);
		len2		:= info[pos:4].Integer;								// length of this binary substring 
		pos			:= pos + 4;											// write raw data to flat file and update arrays
		ts			:= info[pos:8].TimeStamp;							// and update temporary arrays as we go
		pos 		:= pos + 8;
		elapsed	 	:= info[pos:4].Integer;
		pos			:= pos + 4;
		tranError	:= info[pos:1].ansiToString().Character.Boolean;
		pos			:= pos + 1;
		idLength	:= info[pos:4].Integer;
		pos			:= pos + 4;
		id			:= info[pos:idLength].ansiToString();
		pos			:= pos + idLength;
		//																	// TWL enhanced diagnostics patch
		dbTransactionId	:= info[pos:12].Decimal;							// dbTransactionId and processId are not sent to JSA, 
		pos				:= pos + 12;										// just logged in cn_tranlog
		processId		:= info[pos:4].Integer;
		pos				:= pos + 4;
		level			:= info[pos:4].Integer;
		pos 			:= pos + 4;
		//
		len3			:= pos - spos;

		if len2 > len3 then												// there is more data : node sampling stuff is attached
			pos					:= pos + 4;
			cpuTime				:= info[pos:8].Real;
			pos					:= pos + 8;
			getObjects			:= info[pos:8].Real;
			pos					:= pos + 8;
			lockObjects			:= info[pos:8].Real;
			pos					:= pos + 8;
			unlockObjects		:= info[pos:8].Real;
			pos					:= pos + 8;
			createObjects		:= info[pos:8].Real;
			pos					:= pos + 8;
			updateObjects		:= info[pos:8].Real;
			pos					:= pos + 8;
			deleteObjects		:= info[pos:8].Real;
			pos					:= pos + 8;
			endTransactions		:= info[pos:8].Real;
			pos					:= pos + 8;
			causeEvents			:= info[pos:8].Real;
			pos					:= pos + 8;
			serverExecutions	:= info[pos:8].Real;
			pos					:= pos + 8;
			serverExecutionTime	:= info[pos:8].Real;
			pos					:= pos + 8;
			lockQueueWaitsTime	:= info[pos:8].Real;
			pos					:= pos + 8;
			
			if pos < info.length then						// get thin client data
				tcMsgsAppServer		:= 0;
				loopTime			:= 0;
				tcBytesAppServer	:= 0;
				tcMsgsClient		:= 0;
				tcBytesClient		:= 0;
				tcNetworkTime		:= 0;
				tcLen				:= info[pos:4].Integer;
				if tcLen > 0 then
					tcData				:= info[pos:tcLen];
				 	clientType			:= tcData[5].Byte;																		// PAR 632
				 	tcPos				:= 6;
					tcMsgsAppServer		:= tcData[tcPos:8].Real;
					tcPos				:= tcPos + 8;
					tcBytesAppServer	:= tcData[tcPos:8].Real;
					tcPos				:= tcPos + 8;
					tcMsgsClient		:= tcData[tcPos:8].Real;
					tcPos				:= tcPos + 8;
					tcBytesClient		:= tcData[tcPos:8].Real;
					tcPos				:= tcPos + 8;
					tcNetworkTime		:= tcData[tcPos:8].Real;
					pos					:= pos + tcLen;	
				endif;
				
				if tcMsgsAppServer > 0 then
					loopTime		:= tcNetworkTime / tcMsgsAppServer;		// single round trip to presentation client
				endif;
				
				perceivedResponse	:= elapsed + loopTime;
			endif;
		endif;

		if tranError then
			errString	:= "Error";
		else
			errString	:= " ";
		endif;			

/*		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " date=" & ts.date.cnUserFormat($CnCCYYMMDD_ns) &
																", time=" & ts.time.cnUserFormat($CnHHMMSS_ns) 	&
															   ", computerName=" & computerName.String &
															   ", ipAddress=" & ipAddress &
															   ", appName=" & appName &
															   ", userName=" & userName, null);
*/		file.writeLine(ts.date.cnUserFormat($CnCCYYMMDD_ns)	& CN_COMMA &
					   ts.time.cnUserFormat($CnHHMMSS_ns) 	& CN_COMMA &
					   computerName		 					& CN_COMMA &
					   computerNameNode						& CN_COMMA &														// PAR 980
					   ipAddress							& CN_COMMA &
					   appName								& CN_COMMA &
					   userName								& CN_COMMA &
					   id.cnFormatForCSVFile(false)			& CN_COMMA &
					   elapsed.String 						& CN_COMMA &
					   cpuTime.String						& CN_COMMA &
					   dbTransactionId.String				& CN_COMMA &
					   processId.String						& CN_COMMA &
					   errString							& CN_COMMA &
					   getObjects.String					& CN_COMMA &
					   lockObjects.String					& CN_COMMA &
					   unlockObjects.String					& CN_COMMA &
					   createObjects.String					& CN_COMMA &
					   updateObjects.String					& CN_COMMA &
					   deleteObjects.String					& CN_COMMA &
					   endTransactions.String				& CN_COMMA &
					   causeEvents.String					& CN_COMMA &
					   serverExecutions.String				& CN_COMMA &
					   serverExecutionTime.String			& CN_COMMA &
					   lockQueueWaitsTime.String			& CN_COMMA &
					   
					   tcMsgsAppServer.String				& CN_COMMA &
					   tcBytesAppServer.String				& CN_COMMA &
					   tcMsgsClient.String					& CN_COMMA &
					   tcBytesClient.String					& CN_COMMA &
					   tcNetworkTime.String					& CN_COMMA &
					   perceivedResponse.String				& CN_COMMA &
   					   level.String);

		// if we're not wanting to harvest transaction statistics then															// PAR 855
		// finish here. (JSM JadeEnvironment.tranStatsInterval = 0)																// PAR 855
		if not tranStatsRequired then																							// PAR 855
			continue;																											// PAR 855
		endif;																													// PAR 855
		
		index	:= self.tranIds.indexOf(id);
		if index = 0 then
			self.tranIds.add(id);
			self.tranCounts.add(1);
			if tranError then
				self.tranErrors.add(1);
				
			else
				self.tranErrors.add(0);
			endif;
			
			self.tranTimes.add(elapsed);
			self.tranSumOfTimes.add(elapsed);
			self.tranSumSquaresOfTimes.add(elapsed.Real ^ 2);
			self.tranCounts50ms.add(0);
			self.tranCounts100ms.add(0);
			self.tranCounts250ms.add(0);
			self.tranCounts500ms.add(0);
			self.tranCounts1sec.add(0);
			self.tranCounts2sec.add(0);
			self.tranCounts3sec.add(0);
			self.tranCounts4sec.add(0);
			self.tranCounts5sec.add(0);
			self.tranCounts6sec.add(0);
			self.tranCounts7sec.add(0);
			self.tranCounts8sec.add(0);
			self.tranCounts9sec.add(0);
			self.tranCounts10sec.add(0);
			self.tranCounts20sec.add(0);
			
			self.storeResponseTimes(self.tranIds.size, elapsed);
				
			self.tranMaxTimes.add(elapsed);
			self.tranMinTimes.add(elapsed);
			
			self.rpcCpuTimes.add(cpuTime);
			self.rpcGetObjects.add(getObjects);
			self.rpcLockObjects.add(lockObjects);
			self.rpcUnlockObjects.add(unlockObjects);
			self.rpcCreateObjects.add(createObjects);
			self.rpcUpdateObjects.add(updateObjects);
			self.rpcDeleteObjects.add(deleteObjects);
			self.rpcEndTransactions.add(endTransactions);
			self.rpcCauseEvents.add(causeEvents);
			self.rpcServerExecutions.add(serverExecutions);
			self.rpcServerExecutionTimes.add(serverExecutionTime);
			self.rpcLockQueueWaitsTimes.add(lockQueueWaitsTime);
			
			if clientType = J_key_T then							// thin client "T"											// PAR 632
				self.tcTranCounts.add(1);
				self.tcMsgsAppServers.add(tcMsgsAppServer);
				self.tcBytesAppServers.add(tcBytesAppServer);
				self.tcMsgsClients.add(tcMsgsClient);
				self.tcBytesClients.add(tcBytesClient);
				self.tcNetworkTimes.add(tcNetworkTime);
				
			else
				self.tcTranCounts.add(0);
				self.tcMsgsAppServers.add(0);
				self.tcBytesAppServers.add(0);
				self.tcMsgsClients.add(0);
				self.tcBytesClients.add(0);
				self.tcNetworkTimes.add(0);
			endif;
			
  		else
			self.tranCounts.replace(index, self.tranCounts[index] + 1);
          	self.tranTimes.replace(index, self.tranTimes[index] + elapsed);
          	if self.tranMaxTimes[index] < elapsed then
          		self.tranMaxTimes.replace(index, elapsed);
            endif;
			
            if self.tranMinTimes[index] > elapsed then
               	self.tranMinTimes.replace(index, elapsed);
            endif;
			
            if tranError then
            	self.tranErrors[index]	:= self.tranErrors[index] + 1;
            endif;
            
            self.storeResponseTimes(index, elapsed);
            
            self.tranSumOfTimes.replace(index, 			self.tranSumOfTimes[index] + elapsed);
			self.tranSumSquaresOfTimes.replace(index, 	self.tranSumSquaresOfTimes[index] + (elapsed.Real ^ 2));
			
			self.rpcCpuTimes.replace(index, 			self.rpcCpuTimes[index] + cpuTime);
			self.rpcGetObjects.replace(index, 			self.rpcGetObjects[index] + getObjects);
			self.rpcLockObjects.replace(index, 			self.rpcLockObjects[index] + lockObjects);
			self.rpcUnlockObjects.replace(index, 		self.rpcUnlockObjects[index] + unlockObjects);
			self.rpcCreateObjects.replace(index, 		self.rpcCreateObjects[index] + createObjects);
			self.rpcUpdateObjects.replace(index, 		self.rpcUpdateObjects[index] + updateObjects);
			self.rpcDeleteObjects.replace(index, 		self.rpcDeleteObjects[index] + deleteObjects);
			self.rpcEndTransactions.replace(index, 		self.rpcEndTransactions[index] + endTransactions);
			self.rpcCauseEvents.replace(index, 			self.rpcCauseEvents[index] + causeEvents);
			self.rpcServerExecutions.replace(index, 	self.rpcServerExecutions[index] + serverExecutions);
			self.rpcServerExecutionTimes.replace(index, self.rpcServerExecutionTimes[index] + serverExecutionTime);
			self.rpcLockQueueWaitsTimes.replace(index, 	self.rpcLockQueueWaitsTimes[index] + lockQueueWaitsTime);
			
			if clientType = J_key_T then			// "T"																		// PAR 632
				self.tcTranCounts.replace(index, 		self.tcTranCounts[index] + 1);
				self.tcMsgsAppServers.replace(index, 	self.tcMsgsAppServers[index] + tcMsgsAppServer);
				self.tcBytesAppServers.replace(index, 	self.tcBytesAppServers[index] + tcBytesAppServer);
				self.tcMsgsClients.replace(index, 		self.tcMsgsClients[index] + tcMsgsClient);
				self.tcBytesClients.replace(index, 		self.tcBytesClients[index] + tcBytesClient);
				self.tcNetworkTimes.replace(index, 		self.tcNetworkTimes[index] + tcNetworkTime);
			endif;
		endif;
	endwhile;
end;
}
sendTranStatsToKarma
{
sendTranStatsToKarma();

vars
	cc			: CnCntrl;

	kc			: CnKarmaCntrl;
	
	bin,
	bin2,
	locNodeData,
	rpcNodeData,
	tranData	: Binary;

	avgTime,
	i,
	locDataLen,
	nodeDataLen,
	rpcDataLen,
	size,
	tranCount,
	tranDataLen	: Integer;
	
	result,
	tranId		: String;
begin
	kc		:= app.myCnKarmaCntrl;
	cc		:= app.myCnCntrl;
	i		:= 1;									// Now we send the consolidated results to Karma.
  	size	:= self.tranIds.size();
	bin 	:= bin & cnAnsiBinary("T") & 0.Binary;	// Transaction stats (may not be any if not logging these);		

  	//  Now build tranData binary
  	
  	while i <= size do
  		tranId		:= self.tranIds[i];
  		tranCount	:= self.tranCounts[i];
		avgTime		:= self.tranTimes[i] div tranCount; 
		tranData	:= tranCount.Binary 				&			
   					   avgTime.Binary 					&
   					   self.tranMaxTimes[i].Binary 			&
   					   self.tranMinTimes[i].Binary 			&
   					   self.tranErrors[i].Binary 			&
   					   self.tranSumOfTimes[i].Binary 		&
   					   self.tranSumSquaresOfTimes[i].Binary	&
   					   self.tranCounts50ms[i].Binary			&
   					   self.tranCounts100ms[i].Binary		&
   					   self.tranCounts250ms[i].Binary		&
   					   self.tranCounts500ms[i].Binary		&
   					   self.tranCounts1sec[i].Binary			&
   					   self.tranCounts2sec[i].Binary			&
   					   self.tranCounts3sec[i].Binary			&
   					   self.tranCounts4sec[i].Binary			&
   					   self.tranCounts5sec[i].Binary			&
   					   self.tranCounts6sec[i].Binary			&
   					   self.tranCounts7sec[i].Binary			&
   					   self.tranCounts8sec[i].Binary			&
   					   self.tranCounts9sec[i].Binary			&
   					   self.tranCounts10sec[i].Binary		&
   					   self.tranCounts20sec[i].Binary 		;
   					   
   		rpcNodeData	:= self.rpcCpuTimes[i].Binary			&
					   self.rpcGetObjects[i].Binary			&
					   self.rpcLockObjects[i].Binary			&
					   self.rpcUnlockObjects[i].Binary		&
					   self.rpcCreateObjects[i].Binary		&
					   self.rpcUpdateObjects[i].Binary		&
					   self.rpcDeleteObjects[i].Binary		&
					   self.rpcEndTransactions[i].Binary		&
					   self.rpcCauseEvents[i].Binary			&
					   self.rpcServerExecutions[i].Binary	&
					   self.rpcServerExecutionTimes[i].Binary&
					   self.rpcLockQueueWaitsTimes[i].Binary	;
					   
		locNodeData := self.tcTranCounts[i].Binary			&
					   self.tcMsgsAppServers[i].Binary		&
					   self.tcBytesAppServers[i].Binary		&
					   self.tcMsgsClients[i].Binary			&
					   self.tcBytesClients[i].Binary			&
					   self.tcNetworkTimes[i].Binary;
					   
		rpcDataLen	:= rpcNodeData.length();
		locDataLen	:= locNodeData.length();
		nodeDataLen	:= rpcDataLen + locDataLen + 8;
		tranDataLen	:= nodeDataLen + tranData.length();
					   
  		bin 		:= bin &
  					   tranId.length().Binary 			&
   					   cnAnsiBinary(tranId) 			&
   					   tranDataLen.Binary 				&			// length of tranData + nodeData
   					   tranData							&
   					   nodeDataLen.Binary				&
 					   rpcDataLen.Binary				& 
   					   rpcNodeData						&
   					   locDataLen.Binary				&
   					   locNodeData;
   					   
   		i := i + 1;
   	endwhile;

	bin[2:4]		:= (bin.length - 5).Binary;	
	bin2			:= cnAnsiBinary("D") & kc.getSystemStatistics() & bin;		// Add JOM stats at front 													

	//  Now KCCMgr sends the message to KARMA / JOSS

	result := kc.sendOrStoreTranStats(bin2);
	
	if result <> CN_OK then
		app.cnRaiseNormalException(Cn_General_Error, "CnKarmaCntrl::timerEvent", result, false);
		return;
	endif;

	//  Clean up for next round

	self.tranIds.clear();
	self.tranCounts.clear();
	self.tranTimes.clear();
	self.tranMaxTimes.clear();
	self.tranMinTimes.clear();
	self.tranErrors.clear();
	self.tranSumOfTimes.clear();
	self.tranSumSquaresOfTimes.clear();
	self.tranCounts50ms.clear();
   	self.tranCounts100ms.clear();
   	self.tranCounts250ms.clear();
   	self.tranCounts500ms.clear();
   	self.tranCounts1sec.clear();
  	self.tranCounts2sec.clear();
   	self.tranCounts3sec.clear();
   	self.tranCounts4sec.clear();
   	self.tranCounts5sec.clear();
   	self.tranCounts6sec.clear();
   	self.tranCounts7sec.clear();
   	self.tranCounts8sec.clear();
   	self.tranCounts9sec.clear();
   	self.tranCounts10sec.clear();
   	self.tranCounts20sec.clear();
   	
   	self.rpcCpuTimes.clear();
   	self.rpcGetObjects.clear();
  	self.rpcLockObjects.clear();
  	self.rpcUnlockObjects.clear();
 	self.rpcCreateObjects.clear();
	self.rpcUpdateObjects.clear();
	self.rpcDeleteObjects.clear();
 	self.rpcEndTransactions.clear();
 	self.rpcCauseEvents.clear();
	self.rpcServerExecutions.clear();
	self.rpcServerExecutionTimes.clear();
	self.rpcLockQueueWaitsTimes.clear();
	
	self.tcTranCounts.clear();
	self.tcMsgsAppServers.clear();
	self.tcBytesAppServers.clear();
	self.tcMsgsClients.clear();
	self.tcBytesClients.clear();
	self.tcNetworkTimes.clear();	
end;
}
storeResponseTimes
{
storeResponseTimes(index : Integer; elapsed : Integer) protected;

vars
	//  Coded in line for efficiency
begin
	if elapsed < 50 then
		tranCounts50ms.replace(index, tranCounts50ms[index] + 1);
	endif;
	if elapsed < 100 then
		tranCounts100ms.replace(index, tranCounts100ms[index] + 1);
	endif;
	if elapsed < 250 then
		tranCounts250ms.replace(index, tranCounts250ms[index] + 1);
	endif;
	if elapsed < 500 then
		tranCounts500ms.replace(index, tranCounts500ms[index] + 1);
	endif;
	if elapsed < 1000 then
		tranCounts1sec.replace(index, tranCounts1sec[index] + 1);
	endif;
	if elapsed < 2000 then
		tranCounts2sec.replace(index, tranCounts2sec[index] + 1);
	endif;
	if elapsed < 3000 then
		tranCounts3sec.replace(index, tranCounts3sec[index] + 1);
	endif;
	if elapsed < 4000 then
		tranCounts4sec.replace(index, tranCounts4sec[index] + 1);
	endif;
	if elapsed < 5000 then
		tranCounts5sec.replace(index, tranCounts5sec[index] + 1);
	endif;
	if elapsed < 6000 then
		tranCounts6sec.replace(index, tranCounts6sec[index] + 1);
	endif;
	if elapsed < 7000 then
		tranCounts7sec.replace(index, tranCounts7sec[index] + 1);
	endif;
	if elapsed < 8000 then
		tranCounts8sec.replace(index, tranCounts8sec[index] + 1);
	endif;
	if elapsed < 9000 then
		tranCounts9sec.replace(index, tranCounts9sec[index] + 1);
	endif;
	if elapsed < 10000 then
		tranCounts10sec.replace(index, tranCounts10sec[index] + 1);
	endif;
	if elapsed < 20000 then
		tranCounts20sec.replace(index, tranCounts20sec[index] + 1);
	endif;
end;
}
	)
	CnTransactionStack (
	jadeMethodSources
create
{
create() updating;

vars
	cc			: CnCntrl;
	
	log			: JadeLog;
	
	date		: Date;
	
	filename	: String;
begin
	cc	:= app.myCnCntrl;
	create self.processPersistentStatsObjects transient;
	create self.processThinClientStatsObjects transient;
	if cc.isInTestMode() then
		if cc.appSchemaName <> CN_CARDSCHEMA then
			beginTimer(60000, Timer_Continuous, 100);
		endif;
	endif;
	
	if not cc.logLogicalTransactions then
		return;
	endif;
	
	currentLogDate			:= date;
	filename				:= cc.appName & "_" & app.cnComputerName.cnRemoveInvalidFileNameChars() & "_ltl_" & date.cnUserFormat($CnCCYYMMDD_ns) & ".csv";
	
	create log transient;
	log.filePath		:= cc.logPath;
	log.fileName		:= filename;
	log.versionFile		:= false;
	log.formatOutput	:= false;
	log.bufferOutput	:= true;
	self.myLog			:= log;
	
	writeLog(":::  Logical transaction log for application "  & cc.appName & " running on " & app.cnComputerName & "  :::");
	writeLog(":::  Application process starting at " & app.actualTime.date.String & " " & app.actualTime.time.String & "   :::");
	writeLog(" ");
	
	self.setUpLogicalTranLogHeadings();
end;
}
delete
{
delete() updating;

vars

begin
	self.zLogDynamicObjects();
	delete self.myLog;
	if self.processPersistentStatsObjects <> null then
		self.processPersistentStatsObjects.purge();
		delete self.processPersistentStatsObjects;
	endif;
	
	if self.processThinClientStatsObjects <> null then
		self.processThinClientStatsObjects.purge();
		delete self.processThinClientStatsObjects;
	endif;
end;
}
delta
{
delta(jdo1, jdo2 : CnJadeDynamicObject; attributeName : String) : Real;

vars
	int1,
	int2	: Integer64;
	
	d1,
	d2,
	d3		: Decimal [23,0];
	
	cc		: CnCntrl;
begin
	int1	:= jdo1.getPropertyValue(attributeName).Integer64;
	int2	:= jdo2.getPropertyValue(attributeName).Integer64;
	
	if int2 >= int1 then
		return (int2 - int1).Real;
	endif;

	// the value must have wrapped. 
	// Corrected algorithm as one from EncycloSys2.pdf page 440
	// from process.getRequestStatistics definition  is incorrect.
	d1 := (Max_Integer64.Decimal - int1.Decimal);
	d2 := (int2.Decimal - Min_Integer64.Decimal);
	d3 := d1 + d2;
	
	// refer to JADE PAR 48965 - transient cache items are NOT multi-thread protected and can incur large errors.
	if d3 > Max_Integer64 then
		cc := app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " value for attribute '" & attributeName & "' exceeded Max_Integer64 (" & d3.String & "), returning null", null);
		return null;
	endif;
	
	return d3.Real;
end;
}
exceptionHandler
{
exceptionHandler(exObj : Exception; error : Boolean output) : Integer;

vars

begin
	if exObj.errorCode = 1011 then			// property not valid for object
		error	:= true;
		return Ex_Resume_Next;
	else
		return Ex_Pass_Back;
	endif;
end;
}
getLocalProcessStats
{
getLocalProcessStats() : Binary protected;

vars
	jdo1			: CnJadeDynamicObject;
	jdo2			: CnJadeDynamicObject;
	bin				: Binary;
	getObjects		: Real;
	lockObjects		: Real;
	len				: Integer;
	cc				: CnCntrl;		
begin
	cc		:= app.myCnCntrl;
	jdo1	:= processPersistentStatsObjects.last;
	
	create jdo2 transient;
	process.getRequestStatistics(jdo2, 1);			// local
	
	getObjects	:= delta(jdo1, jdo2, Cn_Persistent_GetObjects);
	lockObjects	:= delta(jdo1, jdo2, Cn_Persistent_LockObjects); 
				   
	bin			:= 0.Binary														&	// length of local stats
				   (delta(jdo1, jdo2, Cn_ProcessCPUTime)/1000).roundedTo(0).Binary 					&	// local stats
				   getObjects.Binary											&
				   lockObjects.Binary											&
   				   delta(jdo1, jdo2, Cn_Persistent_UnlockObjects).Binary		&
				   delta(jdo1, jdo2, Cn_Persistent_CreateObjects).Binary		&
				   delta(jdo1, jdo2, Cn_Persistent_UpdateObjects).Binary		&
				   delta(jdo1, jdo2, Cn_Persistent_DeleteObjects).Binary		&
				   delta(jdo1, jdo2, Cn_Persistent_EndTransactions).Binary		&
				   delta(jdo1, jdo2, Cn_Persistent_CauseEvents).Binary			&
				   0.Real.Binary												&	// serverExecutions
				   0.Real.Binary												&	// serverExecutionsTime
				   0.Real.Binary												;   // lockQWaitTime
					   
	len			:= bin.length;
	bin[1:4]	:= len.Binary;
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : nodeData length=" & len.String & ", data=" & bin.display, null);
	return bin;	

epilog
	delete jdo2;
end;
}
getProcessStats
{
getProcessStats() : Binary;

vars

begin
	if node.isServerNode or
	   not app.isMultiUser then
		return getLocalProcessStats();
	else
		return getRpcProcessStats();
	endif;
end;
}
getRpcProcessStats
{
getRpcProcessStats() : Binary protected;

vars
	jdo1			: CnJadeDynamicObject;
	jdo2			: CnJadeDynamicObject;
	bin				: Binary;
	getObjects		: Real;
	lockObjects		: Real;
	len				: Integer;
	cc				: CnCntrl;		
begin
	cc		:= app.myCnCntrl;
	jdo1	:= processPersistentStatsObjects.last;
	
	create jdo2 transient;
	process.getRequestStatistics(jdo2, 2);			// remote
	
	getObjects	:= delta(jdo1, jdo2, Cn_RpcNewBufferGetObjects) 	+
				   delta(jdo1, jdo2, Cn_RpcUpdatedBufferGetObjects) +
				   delta(jdo1, jdo2, Cn_RpcNonUpdatedBufferGetObjs) + 
				   delta(jdo1, jdo2, Cn_RpcTemporaryBufferGetObjs)	;
				   
	lockObjects	:= delta(jdo1, jdo2, Cn_RpcNewBufferLockObjects) 	+
				   delta(jdo1, jdo2, Cn_RpcUpdatedBufferLockObjects) +
				   delta(jdo1, jdo2, Cn_RpcNonUpdatedBufferLockObjs) + 
				   delta(jdo1, jdo2, Cn_RpcTemporaryBufferLockObjs)	;
				   
	bin			:= 0.Binary &													// length of remote stats
				   (delta(jdo1, jdo2, Cn_ProcessCPUTime)/1000).roundedTo(0).Binary 	&		// remote stats
				   getObjects.Binary									&
				   lockObjects.Binary									&
   				   delta(jdo1, jdo2, Cn_RpcUnlockObjects).Binary		&
				   delta(jdo1, jdo2, Cn_RpcCreateObjects).Binary		&
				   delta(jdo1, jdo2, Cn_RpcUpdateObjects).Binary		&
				   delta(jdo1, jdo2, Cn_RpcDeleteObjects).Binary		&
				   delta(jdo1, jdo2, Cn_RpcEndTransactions).Binary		&
				   delta(jdo1, jdo2, Cn_RpcCauseEvents).Binary			&
				   delta(jdo1, jdo2, Cn_RpcServerExecutions).Binary		&
				   delta(jdo1, jdo2, Cn_RpcServerExecutionsTime).Binary &
				   delta(jdo1, jdo2, Cn_RpcLockQueueWaitsTime).Binary	;
					   
	len			:= bin.length;
	bin[1:4]	:= len.Binary;
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : nodeData length=" & len.String & ", data=" & bin.display, null);
	return bin;	

epilog
	delete jdo2;
end;
}
getThinClientProcessStats
{
getThinClientProcessStats() : Binary;

vars
	jdo1			: CnJadeDynamicObject;
	jdo2			: CnJadeDynamicObject;
	bin				: Binary;
	getObjects		: Real;
	lockObjects		: Real;
	len				: Integer;
	cc				: CnCntrl;
	clientType		: Byte;																										// PAR 632	
begin
	cc		:= app.myCnCntrl;
	jdo1	:= processThinClientStatsObjects.last;
	if process.isUsingThinClient then
		clientType	:= J_key_T.Byte;			// "T";																			// PAR 632
		
	else
		clientType	:= J_key_F.Byte;			// "F";					// fat													// PAR 632
	endif;
	
	create jdo2 transient;
	process.getRequestStatistics(jdo2, 1);			// local
	
	bin			:= 0.Binary &						// length of local stats
				   clientType.Binary 									&
				   delta(jdo1, jdo2, Cn_TC_MsgsFromAppServer).Binary	&
				   delta(jdo1, jdo2, Cn_TC_BytesFromAppServer).Binary 	&
				   delta(jdo1, jdo2, Cn_TC_MsgsFromClient).Binary		&
				   delta(jdo1, jdo2, Cn_TC_BytesFromClient).Binary		&
				   delta(jdo1, jdo2, Cn_TC_LogicMsgWaitTime).Binary 	;
					   
	len			:= bin.length;
	bin[1:4]	:= len.Binary;
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : nodeData length=" & len.String & ", data=" & bin.display, null);
	return bin;	

epilog
	delete jdo2;
end;
}
setUpLogicalTranLogHeadings
{
setUpLogicalTranLogHeadings() updating;

vars
	line	: String;
begin
	line	:= "Date" 				& CN_COMMA &
			   "Time" 				& CN_COMMA &
			   "Tran Id"			& CN_COMMA &
			   "Elapsed (msecs)"	& CN_COMMA &
			   "Error?"				& CN_COMMA &
			   "CPU (msecs)"		& CN_COMMA &
			   "GetObjs"			& CN_COMMA &
			   "LockObjs"			& CN_COMMA &
			   "Unlocks"			& CN_COMMA &
			   "Creates"			& CN_COMMA &
			   "Updates"			& CN_COMMA &
			   "Deletes"			& CN_COMMA &
			   "Commits"			& CN_COMMA &
			   "Events"				& CN_COMMA &
			   "Server Exec"  		& CN_COMMA &
			   "Server Time"  		& CN_COMMA &
			   "LockQ Time"			& CN_COMMA &
			   "TC AppServer Msgs"	& CN_COMMA &	
			   "TC AppServer Bytes"	& CN_COMMA &
			   "TC Client Msgs"		& CN_COMMA &
			   "TC Client Bytes"	& CN_COMMA &
			   "TC Msg WaitTime"	& CN_COMMA &
			   "Level";

	myLog.info(line);
	myLog.info(" ");	 	
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;

vars

begin
	if eventTag = 100 then
		self.zLogDynamicObjects();
		return;
	endif;
end;
}
writeLog
{
writeLog(str : String) clientExecution, updating;

vars
	log		: JadeLog;
	date	: Date;
	line	: String;
	t		: TimeStamp;
	filename: String;
	cc		: CnCntrl;
begin
	log := self.myLog;
	cc	:= app.myCnCntrl;
	
	if date <> currentLogDate then
		log.commitLog();
		self.currentLogDate	:= date;
		filename		:= cc.appName & "_" & app.cnComputerName.cnRemoveInvalidFileNameChars() & "_ltl_" & date.cnUserFormat($CnCCYYMMDD_ns) & ".csv";
		log.fileName	:= filename;									// PAR 2286

		self.setUpLogicalTranLogHeadings();
		
		log.info(":::  Logical transaction log for application "  & cc.appName & " running on " & app.cnComputerName & "  :::");
		log.info(":::  Application process starting at " & app.actualTime.date.String & " " & app.actualTime.time.String & "   :::");
		log.info(" ");
	endif;

	log.info(str);
end;
}
zLogDynamicObjects
{
zLogDynamicObjects() updating;

vars
	cc			: CnCntrl;
	
	jdo			: CnJadeDynamicObject;
	
	obj			: Object;
	
	objArray	: ObjectArray;
		
	count,
	sz			: Integer;
begin
	cc := app.myCnCntrl;
	create objArray transient;
	CnJadeDynamicObject.allProcessTransientInstances(objArray, 1000, false);

	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " total CnJadeDynamic objects=" & objArray.size().userNumberFormat($CnWholeNumbers) & 
														", persistent stats size=" & self.processPersistentStatsObjects.size().userNumberFormat($CnWholeNumbers) &
														", thinclient stats size=" & self.processThinClientStatsObjects.size().userNumberFormat($CnWholeNumbers), null);
	
	foreach jdo in self.processPersistentStatsObjects do
		count := count + 1;
		if count = 1 then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " list of persistent stats objects:", null);
		endif;
		
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " [" & count.String & "] " & jdo.String & " created at " & jdo.creationTime().cnFormat_DDMMYY_hhmmss(), null);
		objArray.remove(jdo);
	endforeach;

	count := null;
	foreach jdo in self.processThinClientStatsObjects do
		count := count + 1;
		if count = 1 then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " list of thinclient stats objects:", null);
		endif;
		
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " [" & count.String & "] " & jdo.String & " created at " & jdo.creationTime().cnFormat_DDMMYY_hhmmss(), null);
		objArray.remove(jdo);
	endforeach;
	
	count := null;
	sz	  := objArray.size();
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " " & sz.String & " remaining CnJadeDynamicObjects", null);
	foreach obj in objArray do
		count := count + 1;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " [" & count.String & "] " & obj.String & " created at " & obj.creationTime().cnFormat_DDMMYY_hhmmss(), null);
	endforeach;
	
	objArray.clear();
	JadeDynamicObject.allProcessTransientInstances(objArray, 1000, false);
	count := null;
	sz	  := objArray.size();
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " " & sz.String & " found JadeDynamicObjects", null);
	foreach obj in objArray do
		count := count + 1;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " [" & count.String & "] " & obj.String & " created at " & obj.creationTime().cnFormat_DDMMYY_hhmmss(), null);
	endforeach;
epilog
	delete objArray;
end;
}
	)
	CnTransactionStatistics (
	jadeMethodSources
sendTranStats
{
sendTranStats() updating;

vars
 	cc		: CnCntrl;

 	kc		: CnKarmaCntrl;

	newmsg,
 	tmsg	: CnMessage;
 
 	msg		: CnStatisticsAdvice;
	
	ts		: TimeStamp;
begin
	//	Note that this method gets reimplemented in the Joss schema
	//
	kc 	:= app.myCnKarmaCntrl;
    cc	:= app.myCnCntrl;

	create tmsg;
//	cc.cnWriteLog(cc.CnLogDiag, "Received " & self.String & ", send CnStatisticsAdvice to JSA , binDataLength=" & self.dataLength.String, null);
	tmsg.createNewMsg(msg.Advice, msg.Statistics_Advice, kc.localFQDN, kc.localIpAddress,
					 cc.KCCMgr_Process, cc.JossCommsMgr_Process, newmsg);
	msg	:= newmsg.CnStatisticsAdvice;
	msg.setStatsVersion(Cn_Current_Stats_Version);
	msg.setData(self.data);
	msg.setDataLength(self.dataLength);
	msg.setMsgParam1(msg.Advice_Type_Tran_Stats);
	msg.setManagedEnvironmentName(kc.managedEnvironmentName);
	msg.setTimestamp(ts);
	msg.sendMessage(kc.myParentTcp);
	beginTransientTransaction;
	delete self;
	commitTransientTransaction;
epilog
	delete msg;
	delete tmsg;
end;
}
setData
{
setData(bin : Binary) updating;

vars

begin
 	self.data := bin;
end;
}
setDataLength
{
setDataLength(length : Integer) updating;

vars

begin
 	self.dataLength := length;
end;
}
	)
	CnUtility (
	jadeMethodSources
extractDatabaseStructureInfo
{
extractDatabaseStructureInfo();

constants
	Partition_Kind					: Integer	= 999;
	File_Name						: String	= "AllDatabaseStructures.csv";
vars
	ff							: FileFolder;
	
	file						: File;
	
	cndba						: CnJadeDatabaseAdmin;
	
	obj							: Object;
	
	dbFile						: DbFile;
	
	strucArray					: DbFileArray;

	frozenArray,
	offlineArray				: BooleanArray;
	
	backupStr,
	encryptedStr,																												// PAR 1004
	fullBackupStr,
	fileName,
	fileSizeStr,
	fileStatusStr,
	frozenStr,
	kindStr,
	modifiedStr,
	offlineStr,
	path,
	partitionName,
	partitionedStr,
	result,
	str,
	strucLocation,
	strucName,
	udrFileSizeStr,
	udrFileStructuresStr		: String;
	
	fileExclude,
	frozen,
	isPartitioned,
	offline						: Boolean;

	fileEncryptionStatus,																										// PAR 1004
	fileKind,
	fileStatus					: Integer;
	
	partitionCount,
	partitionId,
	udrFileStructures			: Integer64;
	
	fileSize,
	udrFileSize					: Decimal [23];
	
	strucModified,
	strucBackup,
	strucFullBackup				: TimeStamp;
	
	dbFileExcludeFromBackup,
	dbFileIsPartitioned			: BooleanArray;
	
	strucDbFileNames,
	strucLocations,
	strucPartitionNames			: CnStringArray;

	strucEncryptionStatus,																										// PAR 1004
	strucKind,
	strucStatus 				: IntegerArray;
	
	partitionIds,
	strucLengths,
	strucUDRLengths,
	strucUDRStructures,
	dbFilePartitionCounts		: Integer64Array;
	
	strucModifiedTimeStamps,
	strucBackupTimeStamps,
	strucFullBackupTimeStamps	: TimeStampArray;
	
	iterFrozen,
	iterOffline,
	iterStructure,
	iterLocation,
	iterEncryptionStatus,																										// PAR 1004
	iterExclude,
	iterKind,
	iterIsPartitioned,
	iterPartitionCount,
	iterPartitionId,
	iterPartitionName,
	iterStatus,
	iterLength,
	iterUDRLength,
	iterUDRStructures,
	iterDbFileModified,
	iterDbFileBackup,
	iterDbFileFullBackup		: Iterator;
	
	d1							: Decimal[23];
	
	cc							: CnCntrl;
	
	createdCC					: Boolean;
begin
	cc := app.myCnCntrl;
	if cc = null then
		create app.myCnCntrl transient;
		cc := app.myCnCntrl;
		createdCC := true;
	endif;
	
	path := app.dbPath();
	path := path[1: path.reversePos(CN_BACK_SLASH)] & "c_misc";
	d1 := app.relativeMachineTime();
	create ff transient;
	ff.fileName := path;
	if not ff.isAvailable() then
		ff.make();
	endif;

	create file transient;
	file.fileName := path & CN_BACK_SLASH & File_Name;
	file.mode     := file.Mode_Output;
	file.open();
	file.writeLine("Structure Name," &
				   "Exclude," &
				   "Kind," &
				   "FileStatus," &
				   "Frozen," &
				   "Offline," &
				   "FileLength," &
				   "UDRFileLength," & 
				   "UDRFileStructures," & 
				   "Encrypted," & 																								// PAR 1004
				   "Partitioned," &
				   "Partition Count," &
				   "Partition Id," & 
				   "Modified," &
				   "Backup," &
				   "FullBackup," &
				   "Location");
	
	create cndba transient;
	create strucDbFileNames			transient;
	create strucPartitionNames		transient;
	create strucArray				transient;
	create strucLocations			transient;
	create dbFileExcludeFromBackup 	transient;
	create strucStatus 				transient;
	create strucKind 				transient;
	create strucLengths 			transient;
	create strucUDRLengths 			transient;
	create strucUDRStructures		transient;
	create strucEncryptionStatus	transient;																					// PAR 1004
	create dbFileIsPartitioned		transient;
	create dbFilePartitionCounts	transient;
	create strucModifiedTimeStamps	transient;
	create strucBackupTimeStamps	transient;
	create strucFullBackupTimeStamps	transient;
	create frozenArray				transient;
	create offlineArray				transient;
	create partitionIds				transient;
	result := cndba.getAllDatabaseStructureInfo(strucDbFileNames, 
												strucPartitionNames,
												strucArray,
												strucStatus,
												partitionIds,
												strucKind, 
												strucLocations,
												dbFileExcludeFromBackup, 
												strucLengths, 
												strucUDRLengths,
												strucUDRStructures,
												strucEncryptionStatus,															// PAR 1004
												dbFileIsPartitioned,
												dbFilePartitionCounts,
												strucModifiedTimeStamps,
												strucBackupTimeStamps,
												strucFullBackupTimeStamps,
												frozenArray,
												offlineArray);	
	if result <> CN_OK then
		file.writeLine(result);
	endif;
	
	iterPartitionId			:= partitionIds.createIterator();
	iterPartitionName		:= strucPartitionNames.createIterator();
	iterStructure			:= strucArray.createIterator();
	iterLocation  			:= strucLocations.createIterator();
	iterExclude				:= dbFileExcludeFromBackup.createIterator();
	iterKind				:= strucKind.createIterator();
	iterStatus				:= strucStatus.createIterator();
	iterLength				:= strucLengths.createIterator();
	iterUDRLength			:= strucUDRLengths.createIterator();
	iterUDRStructures		:= strucUDRStructures.createIterator();
	iterEncryptionStatus	:= strucEncryptionStatus.createIterator();															// PAR 1004
	iterIsPartitioned		:= dbFileIsPartitioned.createIterator();
	iterPartitionCount		:= dbFilePartitionCounts.createIterator();
	iterDbFileModified		:= strucModifiedTimeStamps.createIterator();
	iterDbFileBackup		:= strucBackupTimeStamps.createIterator();
	iterDbFileFullBackup	:= strucFullBackupTimeStamps.createIterator();
	iterFrozen				:= frozenArray.createIterator();
	iterOffline				:= offlineArray.createIterator();
	
	foreach strucName in strucDbFileNames do
		dbFile := null;
		iterKind.next(fileKind);
		iterStructure.next(dbFile);
		iterPartitionName.next(partitionName);
		iterLocation.next(strucLocation);
		iterExclude.next(fileExclude);
		iterStatus.next(fileStatus);
		iterLength.next(fileSize);
		iterUDRLength.next(udrFileSize);
		iterUDRStructures.next(udrFileStructures);
		iterEncryptionStatus.next(fileEncryptionStatus);																		// PAR 1004
		iterIsPartitioned.next(isPartitioned);
		iterPartitionCount.next(partitionCount);
		iterDbFileModified.next(strucModified);
		iterDbFileBackup.next(strucBackup);
		iterDbFileFullBackup.next(strucFullBackup);
		iterFrozen.next(frozen);
		iterOffline.next(offline);
		iterPartitionId.next(partitionId);
		encryptedStr := null;																									// PAR 1004
		if fileEncryptionStatus <> DbFile.CryptStatus_Not then																	// PAR 1004
			if fileEncryptionStatus = DbFile.CryptStatus_Encrypted then															// PAR 1004
				encryptedStr := "encrypted";																					// PAR 1004
				
			elseif fileEncryptionStatus = DbFile.CryptStatus_Pending then														// PAR 1004
				encryptedStr := "pending encrypt/decrypt";																		// PAR 1004
				
			elseif fileEncryptionStatus = DbFile.CryptStatus_ReencryptPending then												// PAR 1004
				encryptedStr := "pending re-encryption";																		// PAR 1004
				
			else																												// PAR 1004
				encryptedStr := "unknown (" & fileEncryptionStatus.String & ")";												// PAR 1004
			endif;																												// PAR 1004
		endif;																													// PAR 1004

		frozenStr := null;
		if frozen then
			frozenStr := "frozen";
		endif;
		
		offlineStr := null;
		if offline then
			offlineStr := "offline";
		endif;
		
		if fileKind = Partition_Kind then
			kindStr := "Partition";
			fileStatusStr := dbFile.cnGetStatusFromInput(fileStatus);
			
		else
			kindStr := dbFile.cnGetKind();
			if fileKind = dbFile.Kind_Control or
			   fileKind = dbFile.Kind_Environmental then
				fileStatusStr := "<undefined>";
			
			else
				fileStatusStr := dbFile.cnGetStatus();
			endif;
		endif;

		if fileSize = null then
			fileSizeStr := null;
		
		else
			fileSizeStr := fileSize.String;
		endif;
		
		if udrFileSize = null then
			udrFileSizeStr := null;
		
		else
			udrFileSizeStr := udrFileSize.String;
		endif;
		
		if udrFileStructures = null then
			udrFileStructuresStr := null;
		
		else
			udrFileStructuresStr := udrFileStructures.String;
		endif;

		if not isPartitioned then
			partitionedStr := null;
		
		else
			partitionedStr := isPartitioned.String;
		endif;
		
		if strucModified = null then
			modifiedStr := null;
		
		else
			modifiedStr := strucModified.date().cnUserFormat($CnCCYYMMDD) & " " & strucModified.time().cnUserFormat($CnHHMMSS);
		endif;
		
		if strucBackup = null then
			backupStr := null;
		
		else
			backupStr := strucBackup.date().cnUserFormat($CnCCYYMMDD) & " " & strucBackup.time().cnUserFormat($CnHHMMSS);
		endif;

		if strucFullBackup = null then
			fullBackupStr := null;
		
		else
			fullBackupStr := strucFullBackup.date().cnUserFormat($CnCCYYMMDD) & " " & strucFullBackup.time().cnUserFormat($CnHHMMSS);
		endif;

		if partitionName <> null then
			strucName := strucName & "_" & partitionName;
		endif;
		
		file.writeLine(strucName & "," &
					   fileExclude.String & "," &
					   kindStr & "," &
					   fileStatusStr & "," &
					   frozenStr & "," &
					   offlineStr & "," &
					   fileSizeStr & "," &
					   udrFileSizeStr & "," &
					   udrFileStructuresStr & "," &
					   encryptedStr & "," &																						// PAR 1004
					   partitionedStr & "," &
					   partitionCount.cnNullStringWhenZero() & "," &
					   partitionId.cnNullStringWhenZero() & "," &
					   modifiedStr & "," &
					   backupStr & "," &
					   fullBackupStr & "," &
					   strucLocation);
	endforeach;
	
	file.close();
epilog
	delete strucKind;
	delete cndba;
	delete file;
	delete ff;
	delete strucDbFileNames;
	delete strucPartitionNames;
	delete strucArray;
	delete strucLocations;
	delete dbFileExcludeFromBackup;
	delete strucStatus;
	delete strucLengths;
	delete strucUDRLengths;
	delete strucUDRStructures;
	delete strucEncryptionStatus;																								// PAR 1004
	delete dbFileIsPartitioned;
	delete dbFilePartitionCounts;
	delete strucModifiedTimeStamps;
	delete strucBackupTimeStamps;
	delete strucFullBackupTimeStamps;
	delete partitionIds;
	delete frozenArray;
	delete offlineArray;
	delete iterStructure;
	delete iterLocation;
	delete iterExclude;
	delete iterKind;
	delete iterStatus;
	delete iterLength;
	delete iterUDRLength;
	delete iterUDRStructures;
	delete iterEncryptionStatus;																								// PAR 1004
	delete iterIsPartitioned;
	delete iterPartitionCount;
	delete iterPartitionName;
	delete iterDbFileModified;
	delete iterDbFileBackup;
	delete iterDbFileFullBackup;
	delete iterFrozen;
	delete iterOffline;
	delete iterPartitionId;
	delete cndba;
	
	if app.applicationType = app.ApplicationType_GUI and
	   not process.isInExceptionState() then
		app.msgBox("File " & File_Name & " available." & CrLf & d1.cnGetElapsedTimeString(), null, null);
	endif;
	
	app.cnCheckForTransients();
	if createdCC then
		delete cc;
	endif;
end;
}
extractDbFileInfo
{
extractDbFileInfo();

vars
	ff						: FileFolder;
	
	file					: File;
	
	cndba					: CnJadeDatabaseAdmin;
	
	dbFile					: DbFile;
	
	dbFileArray				: DbFileArray;
	
	backupStr,
	fullBackupStr,
	dbFileLocation,
	dbFileName,
	fileStatusStr,
	modifiedStr,
	result,
	str						: String;
	
	fileExclude,
	isPartitioned			: Boolean;
	
	fileKind,
	fileStatus				: Integer;
	
	partitionCount			: Integer64;
	
	fileSize,
	udrFileSize				: Decimal [23];
	
	dbFileModified,
	dbFileBackup,
	dbFileFullBackup		: TimeStamp;
	
	dbFileNames	 			: CnStringArray;
	
	dbFileLocations			: CnStringArray;
	
	dbFileExcludeFromBackup,
	dbFileIsPartitioned		: BooleanArray;
	
	dbFileKind,
	dbFileStatus 			: IntegerArray;
	
	dbFileLengths,
	dbFileUDRLengths,
	dbFilePartitionCounts	: Integer64Array;
	
	dbFileModifiedTimeStamps,
	dbFileBackupTimeStamps,
	dbFileFullBackupTimeStamps	: TimeStampArray;
	
	iterDbFile,
	iterDbFileLocation,
	iterExclude,
	iterKind,
	iterIsPartitioned,
	iterPartitionCount,
	iterStatus,
	iterLength,
	iterUDRLength,
	iterDbFileModified,
	iterDbFileBackup,
	iterDbFileFullBackup		: Iterator;
begin
	create ff transient;
	ff.fileName := "c:\temp";
	if not ff.isAvailable() then
		ff.make();
	endif;
	
	create file transient;
	file.fileName := "c:\temp\All_DbFiles.csv";
	file.mode     := file.Mode_Output;
	file.open();
	file.writeLine("DbFileName," &
				   "Exclude," &
				   "Kind," &
				   "FileStatus," &
				   "FileLength," &
				   "UDRFileLength," & 
				   "Partitioned," &
				   "Partition Count," &
				   "Modified," &
				   "Backup," &
				   "FullBackup," &
				   "Location");
	
	create cndba transient;
	create dbFileNames 				transient;
	create dbFileArray				transient;
	create dbFileLocations			transient;
	create dbFileExcludeFromBackup 	transient;
	create dbFileStatus 			transient;
	create dbFileKind 				transient;
	create dbFileLengths 			transient;
	create dbFileUDRLengths 		transient;
	create dbFileIsPartitioned		transient;
	create dbFilePartitionCounts	transient;
	create dbFileModifiedTimeStamps	transient;
	create dbFileBackupTimeStamps	transient;
	create dbFileFullBackupTimeStamps	transient;
	result := cndba.getAllDbFileInfo(dbFileNames, 
										dbFileArray,
										dbFileStatus, 
										dbFileKind, 
										dbFileLocations,
										dbFileExcludeFromBackup, 
										dbFileLengths, 
										dbFileUDRLengths,
										dbFileIsPartitioned,
										dbFilePartitionCounts,
										dbFileModifiedTimeStamps,
										dbFileBackupTimeStamps,
										dbFileFullBackupTimeStamps);	
	if result <> CN_OK then
		file.writeLine(result);
	endif;
	
	iterDbFile			:= dbFileArray.createIterator();
	iterDbFileLocation  := dbFileLocations.createIterator();
	iterExclude			:= dbFileExcludeFromBackup.createIterator();
	iterKind			:= dbFileKind.createIterator();
	iterStatus			:= dbFileStatus.createIterator();
	iterLength			:= dbFileLengths.createIterator();
	iterUDRLength		:= dbFileUDRLengths.createIterator();
	iterIsPartitioned	:= dbFileIsPartitioned.createIterator();
	iterPartitionCount	:= dbFilePartitionCounts.createIterator();
	iterDbFileModified	:= dbFileModifiedTimeStamps.createIterator();
	iterDbFileBackup	:= dbFileBackupTimeStamps.createIterator();
	iterDbFileFullBackup	:= dbFileFullBackupTimeStamps.createIterator();
	foreach dbFileName in dbFileNames do
		iterDbFile.next(dbFile);
		iterDbFileLocation.next(dbFileLocation);
		iterExclude.next(fileExclude);
		iterKind.next(fileKind);
		iterStatus.next(fileStatus);
		iterLength.next(fileSize);
		iterUDRLength.next(udrFileSize);
		iterIsPartitioned.next(isPartitioned);
		iterPartitionCount.next(partitionCount);
		iterDbFileModified.next(dbFileModified);
		iterDbFileBackup.next(dbFileBackup);
		iterDbFileFullBackup.next(dbFileFullBackup);
		if fileKind = dbFile.Kind_Control or
		   fileKind = dbFile.Kind_Environmental then
			fileStatusStr := "<undefined>";
		
		else
			fileStatusStr := dbFile.cnGetStatus().String;
		endif;

		if dbFileModified = null then
			modifiedStr := null;
		
		else
			modifiedStr := dbFileModified.date().cnUserFormat($CnCCYYMMDD) & " " & dbFileModified.time().cnUserFormat($CnHHMMSS);
		endif;
		
		if dbFileBackup = null then
			backupStr := null;
		
		else
			backupStr := dbFileBackup.date().cnUserFormat($CnCCYYMMDD) & " " & dbFileBackup.time().cnUserFormat($CnHHMMSS);
		endif;

		if dbFileFullBackup = null then
			fullBackupStr := null;
		
		else
			fullBackupStr := dbFileFullBackup.date().cnUserFormat($CnCCYYMMDD) & " " & dbFileFullBackup.time().cnUserFormat($CnHHMMSS);
		endif;
		
		file.writeLine(dbFileName & "," &
					   fileExclude.String & "," &
					   dbFile.cnGetKind().String & "," &
					   fileStatusStr & "," &
					   fileSize.String & "," &
					   udrFileSize.String & "," &
					   isPartitioned.String & "," &
					   partitionCount.String & "," &
					   modifiedStr & "," &
					   backupStr & "," &
					   fullBackupStr & "," &
					   dbFileLocation);
	endforeach;
	
	file.close();
epilog
	delete cndba;
	delete file;
	delete ff;
	delete dbFileNames;
	delete dbFileArray;
	delete dbFileKind;
	delete dbFileLocations;
	delete dbFileExcludeFromBackup;
	delete dbFileStatus;
	delete dbFileLengths;
	delete dbFileUDRLengths;
	delete dbFileIsPartitioned;
	delete dbFilePartitionCounts;
	delete dbFileModifiedTimeStamps;
	delete dbFileBackupTimeStamps;
	delete dbFileFullBackupTimeStamps;
	delete iterDbFile;
	delete iterDbFileLocation;
	delete iterExclude;
	delete iterKind;
	delete iterStatus;
	delete iterLength;
	delete iterUDRLength;
	delete iterIsPartitioned;
	delete iterPartitionCount;
	delete iterDbFileModified;
	delete iterDbFileBackup;
	delete iterDbFileFullBackup;
	delete cndba;
end;
}
initializeMapFilePaths
{
initializeMapFilePaths();

vars
	jda		: JadeDatabaseAdmin;
	db		: DbFile;
	dba		: DbFileArray;
begin
	create jda transient;
	create dba transient;
	
	jda.getDbFiles(DbFile.Kind_User_Data, dba);
	
	beginTransaction;
	foreach db in dba do
		if db.path <> null then
			db.setPropertyValue("path", "");
		endif;
	endforeach;
	commitTransaction;
epilog
	delete dba;
	delete jda;
end;
}
jc24CheckCommandLine
{
jc24CheckCommandLine();

constants
	EXCLUDE_CARDSCHEMA	: Boolean	= true;

vars
	obj			: Object;
	
	appl		: Application;
	
	jadeMethod	: JadeMethod;
	
	file,
	fileDiag	: File;
	
	scmColl		: SchemaColl;
	
	scm			: Schema;
	
	initMethod,
	meth		: Method;
	
	classColl 	: ClassColl;
	
	cls			: Class;
	
	methDict	: MethodNDict;
	
	initMethodArray	: ObjectArray;
	
	envName,
	schemaName,
	snippet,
	source,
	sourceLower,
	str,
	token		: String;

	commandLineMeth,
	lngth,
	possAppCount,
	pos,
	start		: Integer;
begin
	pos := 4;
	envName := app.dbPath.scanUntil("\", pos).toUpper();
	create file transient;
	file.fileName := "c:\temp\commandline_usage_" & envName & ".txt";
	file.mode := file.Mode_Output;
	file.open();

	create fileDiag transient;
	fileDiag.fileName := "c:\temp\commandline_usage_" & envName & "_diag.txt";
	fileDiag.mode := fileDiag.Mode_Output;
	fileDiag.open();
	
	create scmColl transient;
	create methDict transient;
	create initMethodArray transient;

	scm := rootSchema;
	self.zJC24GetSchemaCollection(scm, scmColl);

	foreach scm in scmColl do
		schemaName := scm.name;
		if schemaName = "JadeDumpLoadSchema" 	or
		   schemaName = "JadeMonitorSchema" 	or
		   schemaName = "JadeSchema" 			or
		   schemaName = "JadeToolsSchema" 		then
			continue;
		endif;
		
		if EXCLUDE_CARDSCHEMA and schemaName[1:10] = "CardSchema" then
			continue;
		endif;
		
		foreach appl in scm.cnGetApplications do
			initMethod := appl.initializeMethod;
			if initMethod = null then
				fileDiag.writeLine("No initialize method for application " & scm.name & "::" & appl.name);
				continue;
			endif;
		
			fileDiag.writeLine("Scanning initialize method for application " & scm.name & "::" & appl.name & " " & initMethod.qualifiedName());
			source := initMethod.getSource().trimBlanks();
			if source = null then
				fileDiag.writeLine("No source found for application " & scm.name & "::" & appl.name & " " & initMethod.qualifiedName());
				continue;
			endif;
			
			pos := 1;
			token := source.scanUntil(";", pos);
			pos := 1;
			token.scanUntil("(", pos);
			if pos = null or 
				(pos > null and token.length() < (pos + 1))	then
				fileDiag.writeLine("No arguments #1 found for application " & scm.name & "::" & appl.name & " " & initMethod.qualifiedName());
				continue;
			endif;
			
			pos := pos + 1;
			token := token.scanUntil(")", pos);
			pos := 1;
			pos := token.pos(":", pos);
			if pos = null or
				(pos > null and token.length() < (pos + 1))	then
				fileDiag.writeLine("No arguments #2 found for application " & scm.name & "::" & appl.name & " " & initMethod.qualifiedName());
				continue;
			endif;
			
			pos := pos + 1;
			token := token[pos:end].trimLeft();
			pos := 1;
			if token <> "Object" then
				fileDiag.writeLine("No Object argument found for application " & scm.name & "::" & appl.name & " " & initMethod.qualifiedName() & " - " & token);
				continue;
			endif;
			
			fileDiag.writeLine(">>> Application " & scm.name & "::" & appl.name & " is a potential jadclient candidate");
			file.writeLine("Application " & scm.name & "::" & appl.name & " is a potential jadclient candidate, initialize method " & scm.name & "::" & initMethod.qualifiedName);
			initMethodArray.add(initMethod);
			possAppCount := possAppCount + 1;
		endforeach;
		
		classColl := scm.getAllClasses(false);
		foreach cls in classColl do
			if cls.schema <> scm then
				continue;
			endif;
			
			cls.getMethods(methDict);
			foreach meth in methDict do
				if meth.getSchema() <> scm then			// ignore methods not declared for current schema
					continue;
				endif;
				
				source := meth.getSource();
				sourceLower := source.toLower();
				pos := 1;
				pos := sourceLower.pos("getcommandline", pos);
				if pos = null then
					fileDiag.writeLine("Method " & scm.name & "::" & meth.qualifiedName & " no command line");
				
				else
					while pos > null do
						fileDiag.writeLine(">>> Method " & scm.name & "::" & meth.qualifiedName & " command line pos=" & pos.String);
						
						// show detail on either side
						lngth := source.length() - pos;
						if lngth > 50 then
							lngth := 50;
						endif;
	
						if pos > 30 then
							start := pos - 30;
						
						else
							start := 1;
						endif;
	
						snippet := source[start:lngth];
						snippet.replaceChar(Cr, " ");
						snippet.replaceChar(Lf, " ");
						file.writeLine("Method " & scm.name & "::" & meth.qualifiedName & " command line pos=" & pos.String & " [..." & snippet & "...]");
						pos := pos + 14;
						pos := sourceLower.pos("getcommandline", pos);
					endwhile;

					commandLineMeth := commandLineMeth + 1;
				endif;

				pos := 1;
				pos := sourceLower.pos("endjade", pos);
				if pos = null then
					fileDiag.writeLine("Method " & scm.name & "::" & meth.qualifiedName & " no endJade");
				
				else
					while pos > null do
						fileDiag.writeLine(">>> Method " & scm.name & "::" & meth.qualifiedName & " endjade pos=" & pos.String);
						
						// show detail on either side
						lngth := source.length() - pos;
						if lngth > 50 then
							lngth := 50;
						endif;
	
						if pos > 30 then
							start := pos - 30;
						
						else
							start := 1;
						endif;
	
						snippet := source[start:lngth];
						snippet.replaceChar(Cr, " ");
						snippet.replaceChar(Lf, " ");
						file.writeLine("Method " & scm.name & "::" & meth.qualifiedName & " endjade pos=" & pos.String & " [..." & snippet & "...]");
						pos := pos + 7;
						pos := sourceLower.pos("endjade", pos);
					endwhile;

					commandLineMeth := commandLineMeth + 1;
				endif;

			endforeach;
			
			methDict.clear();
		endforeach;
		
		delete classColl;
	endforeach;	

	file.writeLine(null);
	file.writeLine("Possible jadclient applications : " & possAppCount.String);
	file.writeLine("Methods using 'getCommandLine' variants : " & commandLineMeth.String);
	file.writeLine(null);
	foreach obj in initMethodArray do
		initMethod := obj.Method;
		file.writeLine("Initialize method source for " & initMethod.getSchema().name & "::" & initMethod.qualifiedName & ":" & CrLf & initMethod.getSource().trimBlanks());
		file.writeLine(null);
	endforeach;

	file.close;
epilog
	delete file;
	delete fileDiag;
	delete initMethodArray;
	delete scmColl;
	delete methDict;
end;
}
renameMapfile
{
renameMapfile(pNames : String);
/*
	Names are concatenated by the | character with the first
	name being the current mapfile name and the second name
	being the one it needs to change to.

*/

constants
	DELIMITER	: String	= ",";
vars
	nameToBe,
	nameNow		: String;
	
	pos			: Integer;
	
	dbFile 		: DbFile;
begin
	pos := 1;
	nameNow := pNames.scanUntil(DELIMITER, pos).trimBlanks();
	if pos = null then
		beginTransaction;
		node.userExitCode := 1;
		commitTransaction;
		return;
	endif;
	
	pNames.scanWhile(DELIMITER, pos);
	nameToBe := pNames.scanUntil(DELIMITER, pos).trimBlanks();
	
	if nameNow = null then
		beginTransaction;
		node.userExitCode := 2;
		commitTransaction;
		return;
	endif;
	
	if nameToBe = null then
		beginTransaction;
		node.userExitCode := 3;
		commitTransaction;
		return;
	endif;

	foreach dbFile in DbFile.instances do
		if dbFile.name = nameNow then
			beginTransaction;
			dbFile.setPropertyValue("name", nameToBe);
			commitTransaction;

			beginTransaction;
			dbFile._rename();
			commitTransaction;
			break;
		endif;		
	endforeach;
end;
}
resetUserAppliedPatchesAll
{
resetUserAppliedPatchesAll();

vars
	scm			: Schema;
	
	scmColl		:SchemaColl;
	
	xName		: String;
begin
	create scmColl transient;
	rootSchema.allSubschemas(scmColl);
	foreach scm in scmColl do
		xName := scm.name;
		if xName = "JadeDumpLoadSchema" or
		   xName = "JadeMonitorSchema" or
		   xName = "JadeToolsSchema" or
		   xName = "JadeSchema" then
		    continue;
		endif;

		scm.resetUserAppliedPatches(xName);
	endforeach;
epilog
	delete scmColl;
end;
}
schemaFilesFreezeThaw
{
schemaFilesFreezeThaw(pFreezeOrThaw : String);

vars
	dbArray	: DbFileArray;
	
	jdba	: JadeDatabaseAdmin;
	
	dbFile	: DbFile;
	
	kind,
	status : Integer;
	
	param	: String;
begin
	param := pFreezeOrThaw.toLower();
	if param <> "f" and
	   param <> "t" then
		beginTransaction;
		node.userExitCode := 2;
		commitTransaction;
		return;
	endif;
	
	create jdba transient;
	create dbArray transient;
	kind := DbFile.Kind_User_Schema;
	jdba.getDbFiles(kind, dbArray);
	
	if param = "f" then
		beginTransaction;
		foreach dbFile in dbArray do
			if not dbFile.isFrozen() then
				dbFile.freeze();
			endif;
		endforeach;
		node.userExitCode := 1;
		commitTransaction;
		return;
	endif;
	
	beginTransaction;
	foreach dbFile in dbArray do
		if dbFile.isFrozen() then
			dbFile.thaw();
		endif;
	endforeach;
	node.userExitCode := 1;
	commitTransaction;

epilog
	delete dbArray;
	delete jdba;
end;
}
startMonitorBackgroundServer
{
startMonitorBackgroundServer() serverExecution;

vars
	file			: File;

	directivesFile,
	iniFile,
	osVersion,
	path			: String;
	
	osArchitecture,
	osPlatform,
	pos				: Integer;
	
	updateIni		: Boolean;
begin
	iniFile := app.getIniFileName();
	directivesFile := app.getProfileString(iniFile, "JadeMonitorBackground", "DirectivesFile", null);
	
	// if ini file setting not found then default to <env>/server/c_bin/directives.txt
	if directivesFile = null then
		updateIni := true;
		osPlatform	:= node.getOSPlatform(osVersion, osArchitecture);
		path := app.dbPath;
		path.replaceChar("\", "/");
		if path[path.length:1] = "/" then
			path := path[1:path.length-1];
		endif;
		
		pos := path.reversePos("/");
		if osPlatform = Node.OSWindows 				or
		   osPlatform = Node.OSWindowsEnterprise 	or
		   osPlatform = Node.OSWindowsHome			then
			path := path[1:pos] & "c_bin";
			
		else
			path := path[1:pos] & "bin";
		endif;
		
		directivesFile := path & "/directives.txt";
	endif;
	
	create file transient;
	file.fileName := directivesFile;
	file.mode := file.Mode_Input;
	if not file.isAvailable() then
		app.cnRaiseNormalException(Cn_General_Error, "Start JadeMonitorBackground Error", "Unable to locate directives file '" & directivesFile & "'", false);
		return;
	endif;
	
	if updateIni then
		app.setProfileString(iniFile, "JadeMonitorBackground", "DirectivesFile", directivesFile);
	endif;
	
	app.startApplication(CN_JADEMONITORSCHEMA, CN_JADEMONITORBACKGROUND);
epilog
	delete file;
end;
}
validateMethods
{
validateMethods();

vars
	schema,	
	lSchema	: Schema;
	
	coll	: SchemaColl;
	
	error	: Boolean;
begin
	//  This method is used by JADECare Systems Agent during managed deployments.
	//
	create coll transient;
	rootSchema.allSubschemas(coll);
	
	foreach schema in coll do
		lSchema	:= schema.getLatestVersion();
		lSchema._validateMethods(lSchema.name);
	endforeach;
epilog
	delete coll;
end;
}
zJC24GetSchemaCollection
{
zJC24GetSchemaCollection(pSchema : Schema; pSchemaColl : SchemaColl input) protected;

vars
	scm			: Schema;
	
	scmDict		: SchemaNDict;
begin
	create scmDict transient;
	pSchema.getSubschemas(scmDict);
	foreach scm in scmDict do
		if not pSchemaColl.includes(scm) then
			pSchemaColl.add(scm);
		endif;
		
		self.zJC24GetSchemaCollection(scm, pSchemaColl);
	endforeach;
epilog
	delete scmDict;
end;
}
	)
	CnApp (
	jadeMethodSources
setAppName
{
setAppName(appname : String) updating;

vars

begin
	self.appName := appname;
end;
}
setAppSchemaName
{
setAppSchemaName(pValue : String) updating;

vars

begin
	self.appSchemaName := pValue;
end;
}
setEnvironmentId
{
setEnvironmentId(id : String) updating;

vars

begin
	self.environmentId := id;
end;
}
setLogonTime
{
setLogonTime(ts : TimeStamp) updating;

vars

begin
	self.logonTime := ts;
end;
}
setMyCnCntrl
{
setMyCnCntrl(cc : CnCntrl) updating;

vars

begin
 	self.myCnCntrl := cc;
end;
}
setMyKarmaCntrl
{
setMyKarmaCntrl(kc : CnKarmaCntrl) updating;

vars

begin
 	self.myKarmaCntrl := kc;
end;
}
setMyMachine
{
setMyMachine(mach : CnMachine) updating;

vars

begin
 	self.myCnMachine := mach;
end;
}
userNotification
{
userNotification(eventType: Integer; theObject: Object; eventTag: Integer; userInfo: Any) updating;

vars
	cc : CnCntrl;
	msg : CnMessage;
begin
 	cc	:= app.myCnCntrl;
 	cc.cnWriteLog(cc.CnLogErrors, "In CnApp::userNotification : event=" & eventType.String & ", CnApp=" & self.String &
 			 ", theObject=" & theObject.String & " ::: didn't expect to be here ?", null);
 	
	if self.myCnCntrl = null then
		self.myCnCntrl := cc;
	endif;
end;
}
	)
	CnClusterInfo (
	jadeMethodSources
create
{
create() updating, protected;

vars
	result	: Integer;
	hosts	: String;
	errText	: String;
	len,
	pos		: Integer;
	cc		: CnCntrl;
begin
	cc		:= app.myCnCntrl;
	if not app.cnOSPlatformIsWindows then
		cc.cnWriteLog(cc.CnLogComment, "Non-Windows OS platform : cluster details have not been set up.", null);
		return;
	endif;

	result 	:= getClusterInfo(self.jawsVersion, 
								self.clusterName, 
								self.windowStation, 
								self.serviceName, 
								self.virtualMachineName, 
								self.preferredHost, 
								hosts, 
								self.clusterGroup, 
								errText);
	if cc <> null then
		cc.cnWriteLog(cc.CnLogComment, "CnClusterInfo : result=" & result.String & 
														", errText=" & errText & 
														", jawsVer=" & self.jawsVersion &
														", clusterName=" & self.clusterName & 
														", clusterGroup=" & self.clusterGroup & 
														", windowStation=" & self.windowStation & 
														", service=" & self.serviceName &
														", virtualMachine=" & self.virtualMachineName & 
														", preferredHost=" & self.preferredHost & 
														", hosts=" & hosts, null);
		//
		if virtualMachineName <> null and preferredHost = null then					// outcome of contact #2333 : new edit for 3.1
			cc.cnWriteLog(cc.CnLogErrors, ">>>>>> ERROR in CnClusterInfo::create : environment appears to be a cluster but preferredHost " &
										  "is not defined : mandatory for JADECare Systems Management : fix in Windows Cluster Administrator.", null);
			app.cnRaiseNormalException(Cn_General_Error, "CnClusterInfo", "Preferred host not defined for cluster.", false);
		endif;
	endif;

	if result > 4 then			// result 4 usually means we aren't in a cluster
		app.cnRaiseNormalException(Cn_General_Error, "CnClusterInfo", "Problem getting cluster details : " & errText, false); 						
	endif;
	
	len := hosts.length();
	if len = null then
		return;
	endif;
	
	pos	:= 1;

	while pos > null and pos <= len do
		possibleHosts.add(hosts.scanUntil("|", pos));
		if pos = null then
			break;
		endif;

		pos	:= pos + 1;
	endwhile;
end;
}
	externalMethodSources
clusterVirtualOnMe
{
clusterVirtualOnMe(
			virtualName: String io; 
			machineName: String output): Boolean is "emClusterVirtualOnMe" in "karma" updating, number = 1003;
}
getClusterInfo
{
getClusterInfo(
			jawsVersion: String output; 
			clusterName: String output; 
			windowStation: String output; 
			serviceName: String output; 
			virtualMachineName: String output; 
			preferredHost: String output; 
			hosts: String output;
			clusterGroup: String output;
			errorText: String output): Integer is "emMMapInfo2" in "karma" updating, protected, number = 1002;
}
	)
	CnCntrl (
	jadeMethodSources
bumpConnectionCount
{
bumpConnectionCount() updating;

vars

begin
	self.connectionCount := self.connectionCount + 1;
end;
}
bumpConnectionNo
{
bumpConnectionNo() updating;

vars

begin
 	self.connectionNo := self.connectionNo + 1;
end;
}
cnLogCallStack
{
cnLogCallStack(id : String) updating;

vars
	//  Diagnostic aid to record method call stack into log
	//
	pc			: ProcessStackArray;
	meth		: MethodCallDesc;
	theMethod	: Method;
	i			: Integer;
	str			: String;
	badObject	: Boolean;
begin
	create pc transient;
	process.currentStack(pc);
    i := 3;							// exclude myself etc

	cnWriteLog(CnLogDiag, "----------------- Call Stack Snapshot, ID = " & id & "   -------------------------------", null);
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, theMethod, badObject);
    while i <= pc.size do
   		meth	:= pc[i];
   		theMethod := meth.method;
		str := theMethod.class().name;
		if badObject then
			badObject := false;
			cnWriteLog(CnLogDiag, theMethod.String & " (Invalid)", null);
		
		else
			cnWriteLog(CnLogDiag, "       " & (i- 2).String & " : " & meth.display & "  (" &
								  str & ")", null); 
		endif;

		i := i + 1;
	endwhile;

	cnWriteLog(CnLogDiag, "------------------------ End Call Stack Snapshot  -------------------------------", null);

epilog
	if pc <> null then
		pc.purge();
		delete pc;	
	endif;
end;
}
cnWriteLog
{
cnWriteLog(entryType : Integer; msg : String; tcp : CnTcpConnection) clientExecution, updating;

vars
	appl		: Application;

	cnApp		: CardSchema;
	
	log			: JadeLog;
	
	badObject	: Boolean;
	
	etype,
	logline,
	processInfo,
	remoteName,
	s			: String;
	
	t 			: TimeStamp;
begin
	appl := process.getProcessApp();
	if appl.isKindOf(CardSchema) then
		cnApp := appl.CardSchema;
	
	else
		cnApp := app.cnGetCardSchemaApp(true);
	endif;
	
	processInfo := appl.name & "/" & self.cnGetInstanceId64(process).String;
	if appl <> app then
		processInfo := processInfo & " [" & app.name & "/" & self.cnGetInstanceId64(app).String & "]";			// deliberately use local app as this is package application
	endif;
	
	if entryType = self.CnLogComment 		then
		etype := "CMT";
		
	elseif entryType = self.CnLogConnect 	then
		etype := "CON";
		
	elseif entryType = self.CnLogTransmit 	then
		etype := "XMT";
		
	elseif entryType = self.CnLogReceive 	then
		etype := "RCV";
		
	elseif entryType = self.CnLogDiag 		then
		etype := "DIA";
		
	elseif entryType = self.CnLogQual 		then
		etype := "QUAL";
		
	elseif entryType = self.CnLogMsgAssemble	then																			// PAR 6782
		etype := "ASMB";																										// PAR 6782
	
	elseif entryType = self.CnLogMsgLoad	then																				// PAR 6782
		etype := "LOAD";																										// PAR 6782
		
	elseif entryType = self.CnLogErrors 	then
		etype := ">>>>";
		
	elseif entryType = self.CnLogProgramError then
		etype := "****";
		
	else		 
		etype := "???";
	endif;

	if self.logToScreen or entryType = CnLogProgramError then
		write processInfo & " " & etype & ":" & msg;
	endif;

	if not self.logging 					and 
	   entryType <> self.CnLogProgramError 	and 
	   entryType <> self.CnLogErrors 		then
		return;
	endif;
	
	if entryType = self.CnLogDiag or
	   entryType = self.CnLogQual then
		if not self.logDiagnostics 	then 
			return;
		endif;
	endif;
	
	if (entryType = self.CnLogTransmit or
	    entryType = self.CnLogReceive)		and 
	   not self.logCommsBuffers				then																				// PAR 6782 - no longer checking self.logDiagnostics as well
		return;
	endif;
	
	if (entryType = self.CnLogMsgAssemble or
	    entryType = self.CnLogMsgLoad)		and 
	   not self.logMessaging 				then																				// PAR 6782 - no longer checking self.logDiagnostics as well
		return;
	endif;
	
	if entryType = self.CnLogConnect 	and 
	   not self.logCommsConnections 	then																					// PAR 6782 - no longer checking self.logDiagnostics as well
		return;
	endif;
	
	if tcp <> null then
		on SystemException do app.cnHandleSpecifiedInvalidObjRef(exception, tcp, badObject);
		remoteName := tcp.remoteName;
		if not badObject 						and 
		   self.logCommsComputer <> null 		and
		   remoteName <> self.logCommsComputer 	then
			return;
		endif;
	endif;   

	log 	:= cnApp.myCnLog;
	t		:= app.actualTimeAppServer();
	s 		:= t.date().userFormat($CnCCYYMMDD) & " " 					& 
				t.time().String & "." 									& 
				t.time().milliSecond().String.padLeadingZeros(3) & ": " &
				etype.padBlanks(4);
    logline := s & ":" & processInfo & ": " & msg; // & CrLf;

    //   In JADE 5.0.16 the JadeLog class had a bug which resulted in an overrun and JADE.EXE crash when writing
    //   a log entry that was longer than 10,000 bytes.  The following check detours the problem.
    //
    //   We use uncommitted writes except for every twentieth entry, to speed things up.  MUST do committed write
    //   periodically so that JadeLog checks the size of the output file.

	if logline.length > 9920 then
		if immediateCommit or logImmediateCommit or logEntries > 18 then
			log.log(logline[1:9920] & ". . . .[TRUNCATED @ 9920 : ACTUAL LENGTH WAS " & logline.length.String & "]");
			logEntries := 0;
			
		else
			log.info(logline[1:9920] & ". . . .[TRUNCATED @ 9920 : ACTUAL LENGTH WAS " & logline.length.String & "]");
			logEntries := logEntries + 1;
		endif;
		
	else
		if immediateCommit or logImmediateCommit or logEntries > 18 then
			log.log(logline);
			logEntries	:= 0;
			
		else
			log.info(logline);
			logEntries	:= logEntries + 1;
		endif;
	endif;
	
	immediateCommit := false;	
end;
}
cnWriteLogCommit
{
cnWriteLogCommit(entryType : Integer; msg : String; tcp : CnTcpConnection) clientExecution, updating;

vars

begin
	immediateCommit := true;
	cnWriteLog(entryType, msg, tcp);
end;
}
create
{
create() updating;

vars
 	cnApp	: CardSchema;
	
	appl	: Application;
begin
	appl := process.getProcessApp();
	if appl.isKindOf(CardSchema) then
		cnApp := appl.CardSchema;
		
	else
		cnApp := app;
	endif;
	
	if cnApp <> null then
		cnApp.myCnCntrl			:= self;
	endif;

	if cnApp.cnApplicationType = null then
		cnApp.setCnApplicationType(app.applicationType);
		app.setCnApplicationType(app.applicationType);
	endif;
	
	app.myCnCntrl			:= self;			// set up package application
	self.appName			:= appl.name;
	self.appSchemaName		:= appl.class().schema.name;
	self.computerName 		:= cnApp.cnComputerNameAppServer;
	create self.myTransientGlobal transient;
	self.myProcess	 		:= process;

	/////// This method now sets default values for some other parameters in CnCntrl //////

	self.resolveRemoteName 	:= true;
	self.setupControlOptions;				// read .ini file for [CardLog] section plus some Karma stuff, create JadeLog object
	self.setupExceptionFlags;

	self.serverLogPath 		:= self.myTransientGlobal.cnGetServerLogPath;
	self.serverLogFileName	:= self.myTransientGlobal.cnGetServerLogFileName;
	self.setConnectionRetryLimit(3);
	self.setConnectionResponseTime(60);						// seconds
	self.setMaxMessageSize(1000);							// bytes, excludes header
	self.setHeaderLength(10);
	self.setAutoReOpen(true);
	self.setAutoReListen(true);
	self.setOsDistroAndVersion();
	self.nameFromCommandLine	:= node.cnGetNameFromCommandLine();
	
	self.setupForSystemShutDown();
	self.setTestModeFromIni();
end;
}
decrementConnectionCount
{
decrementConnectionCount() updating;

vars

begin
	self.connectionCount := self.connectionCount - 1;
end;
}
delete
{
delete() updating;

vars
	appl			: Application;

	cnApp			: CardSchema;
	
	cnNodeControl	: CnNodeControl;
begin
	appl := process.getProcessApp();
	if appl.isKindOf(CardSchema) then
		cnApp := appl.CardSchema;
		
	else
		cnApp := app;
	endif;
	
	if cnApp.myCnTransactionStack <> null then
		delete cnApp.myCnTransactionStack;
	endif;
	  	
  	self.allCnTcpConnections.purge();
  	
  	delete self.myTransientGlobal;
	
	if self.appName = CN_KCCMGR then
		self.endNotificationForSubscriber(self);
		self.endTimer(CN_NODE_MONITOR_TIMER);
		if self.myNodeMonitoringFile <> null then
			delete self.myNodeMonitoringFile;			// this also closes the file if open.
		endif;
	endif;

	if cnApp.myCnLog <> null then
		delete cnApp.myCnLog;
	endif;
	
	cnNodeControl := self.myNodeControl;
	if cnNodeControl <> null then
		beginTransientTransaction;
		cnNodeControl.allNodeControlCnCntrlArray.remove(self.myNodeControlCnCntrl);
		delete self.myNodeControlCnCntrl;
		commitTransientTransaction;
	endif;
end;
}
deriveNodeId
{
deriveNodeId(pNode : Node; pIniFileName : String; pNodeType : Character output; pNodeId : String output) updating;
/*
	This logic is executed from not only the executing node but also from KCCMgr when trying to identify the node
	as part of node monitoring.
	
	If the ini file name argument is null (executed from KCCMgr) then don't access the ini file.
*/
vars
	array,
	arrayLower	: CnStringArray;

	ix,
	ix2,
	jawsIndex,
	nameIndex,
	pos			: Integer;

	appName,
	appserver,
	cmdLine,
	exeName,
	port,
	schemaName	: String;
begin
	//  Now set up node info 
	if pNode.isServerNode then
		pNodeType		:= Cn_NodeType_Server;
		pNodeId			:= "DbServer";
		return;
	endif;
	
	if pNode.isApplicationServer() then
		pNodeType		:= Cn_NodeType_AppServer;
	
	else
		pNodeType		:= Cn_NodeType_Jade;
	endif;
	
	// Note that for node sampling, the node id needs to be unique so as to avoid cache sampling statistics
	// being duplicated when captured in JSM. Duplicates are discarded by JSM
	//
	// The following identifies how the NodeId is derived:
	//
	// - use JawsId=<nodeid> from command line (only added when ctl file [JawsOptions] AppendJawsIdEndJade is true) - added for 3.3
	// - use Name=<nodeid> if name defined (ctl file sections allow Name=<nodeid> to be defined
	// - derive the name from commandline values or ini file (see logic below)
	cmdLine 	:= pNode.getCommandLine();
	array		:= cmdLine.cnGetTokensUsingTruthSet(" =");
	arrayLower 	:= cmdLine.toLower().cnGetTokensUsingTruthSet(" =");
	jawsIndex := arrayLower.indexOf("jawsid");
	if jawsIndex <> null and
	   arrayLower.size() > jawsIndex then
		pNodeId := array[jawsIndex+1];
		return;
	endif;
	
	nameIndex	:= arrayLower.indexOf("name");
	if nameIndex > null and
	   arrayLower.size() > nameIndex then 
		pNodeId := array[nameIndex + 1];
		return;
	endif;
	
	if pNodeType = Cn_NodeType_AppServer then
		ix2			:= arrayLower.indexOf("endjade");
		if ix2 = null then
			ix2		:= 999;
		endif;
		
		ix			:= arrayLower.indexOf("appserverport");
		if ix > null and ix < ix2 then
			port	:= array[ix + 1];
			
		elseif pIniFileName <> null then
			port	:= app.getProfileStringAppServer(pIniFileName, "JadeAppServer", "AppServerPort", "<unknown>");
		
		else
			port	:= "<unknown>";
		endif;
		
		ix			:= arrayLower.indexOf("appserver");
		if ix > null and ix < ix2 then
			appserver	:= array[ix + 1].toUpper();
			
		elseif pIniFileName <> null then
			appserver	:= app.getProfileStringAppServer(pIniFileName, "JadeAppServer", "AppServer", null).toUpper;
		endif;

		if appserver = null then
			appserver	:= app.cnComputerNameAppServer();		// PAR 558
		endif;
		
		pNodeId		:= "AppServer=" & appserver & " AppServerPort=" & port;
		return;
	endif;

	// so must be a standard fat-client
	ix	:= arrayLower.indexOf("schema");
	ix2	:= arrayLower.indexOf("app");
	if ix > null and
	   ix2 > null then
	
		if ix > null 				and
		   arrayLower.size() > ix 	then 
			schemaName := array[ix + 1];
		
		else
			schemaName := "<unknown>";
		endif;

		if ix2 > null 				and
		   arrayLower.size() > ix2 	then 
			appName := array[ix2 + 1];
		
		else
			appName := "<unknown>";
		endif;
	
		pNodeId			:= "Schema=" & schemaName & " App=" & appName;
		return;
	endif;
	
	// not the usual standard fat-client so just show the executable name
	pos			:= cmdLine.toLower().pos(".exe", 1);
	if pos > null then
		exeName := cmdLine[1:pos-1];
		exeName.replaceChar(CN_SLASH, CN_BACK_SLASH);
		pos := exeName.reversePos(CN_BACK_SLASH);
		if pos > null then
			exeName := exeName[pos+1:end];
		endif;
		
		pNodeId := exeName;
		return;
	endif;
	
	pNodeId := "Fat-client";
	return;
epilog
	delete arrayLower;
	delete array;
end;
}
doLockControlSetup
{
doLockControlSetup(pSchemaName, pApplicationName: String; pAllowDuplicateProcesses : Boolean) updating;

vars
	jdba			: JadeDatabaseAdmin;
	
	proc			: Process;
	
	root			: CnRoot;
	
	count,
	role,
	rpsStorageMode	: Integer;
	
	rpsMappingName,
	schemaName		: String;
begin
	self.cnWriteLog(CnLogComment, "Performing lock control setup for " & pSchemaName & "," & pApplicationName & " .....", null);
	root	:= CnRoot.firstInstance;
	if root = null then
		if app.cnIsRPSNode then								// relational population service node
			create jdba transient;
			jdba.rpsGetDatabaseParameters(schemaName, rpsMappingName, rpsStorageMode);
			if rpsStorageMode = jdba.RpsStorageMode_WorkingSet then
				self.cnWriteLog(self.CnLogErrors, ">>>> RPS node can't find CnRoot instance in Working Set", null);
				self.cnWriteLog(self.CnLogErrors, ">>>> JADECare managed applications are not supported in this mode!", null);
				app.cnTerminate();
			endif;
			
			if rpsStorageMode = jdba.RpsStorageMode_MappedExtent then
				self.cnWriteLog(self.CnLogErrors, ">>>> RPS node can't find CnRoot instance in Mapped Extent", null);
				self.cnWriteLog(self.CnLogErrors, ">>>> Either define CnRoot and CnLockTarget as Mapped Classes in schema " & schemaName & 
													" RPS Mappings '" & rpsMappingName & " or", null);
				self.cnWriteLog(self.CnLogErrors, ">>>> Do not activate KarmaControl in this application", null);
				app.cnTerminate();
			endif;

			self.cnWriteLog(self.CnLogErrors, ">>>> RPS node can't find CnRoot instance in Full Extent", null);
			self.cnWriteLog(self.CnLogErrors, ">>>> Ensure that KCCMgr has executed on SDS Primary and reclone database", null);
			app.cnTerminate();
		endif;

		role	:= system.getDatabaseRole();																					// PAR 453
		if app.name = CN_KCCMGR and role <> SDS_RoleSecondary then	// primary or non-SDS										// PAR 453
			beginTransaction;																									// PAR 453
			create root;																										// PAR 453
			commitTransaction;																									// PAR 453
			
		else
			self.cnWriteLog(self.CnLogErrors, ">>>> Can't find CnRoot persistent object : KCCMgr has not been run.", null);
			app.cnTerminate();
		endif;
	endif;
	
	app.setMyCnRoot(root);
//	self.cnWriteLog(CnLogDiag, "Obtaining CnRoot.allLockTargets lock to single thread lock check....", null);					// JSM PAR 5288
/*	lock(glob, Exclusive_Lock, Session_Duration, 0);									// single thread						// JSM PAR 5288
	while not tryLock(root, Exclusive_Lock, Session_Duration, 100) do									// single thread		// JSM PAR 5288
		count := count + 1;																										// JSM PAR 5288
		self.cnWriteLog(CnLogDiag, "Obtain CnRoot lock failed, count = " & count.String & ", retry in 5 seconds.", null);		// JSM PAR 5288
		process.sleep(5000);																									// JSM PAR 5288
	endwhile;																													// JSM PAR 5288
	
	exclusiveLock(root.allLockTargets);																							// JSM PAR 5288
*/	count := null;																												// JSM PAR 5288
	while not tryLock(root.allLockTargets, Exclusive_Lock, Session_Duration, 100) do											// JSM PAR 5288
		count := count + 1;																										// JSM PAR 5288
		self.cnWriteLog(CnLogDiag, "Obtain CnRoot.allLockTargets lock failed, count = " & count.String & 						// JSM PAR 5288
									", retry in 5 seconds.", null);																// JSM PAR 5288
		process.sleep(5000);																									// JSM PAR 5288
		if count > 20 then																										// JSM PAR 5288
			self.cnWriteLog(CnLogDiag, 																							// JSM PAR 5288
						"Obtain CnRoot.allLockTargets lock failed, exceeded maximum retries, one last ditch attempt...", null);	// JSM PAR 5288
			// try one last time and let JADE handle failure as we usually haven't armed global exception handlers by this stage// JSM PAR 5288
			exclusiveLock(root.allLockTargets);																					// JSM PAR 5288
		endif;																													// JSM PAR 5288
	endwhile;																													// JSM PAR 5288

//	self.cnWriteLog(self.CnLogDiag, method.cnGetMethodName() & " CnRoot.allLockTargets exclusive lock obtained.", null);		// JSM PAR 5288
	proc	:= self.getProcessForLock(pSchemaName, pApplicationName, false);
	if proc = null or pAllowDuplicateProcesses then
		self.setLockForProcess(pSchemaName, pApplicationName, true, true);					// currentSchema.name, app.name
		
	else
		self.cnWriteLog(CnLogErrors, "Duplicate copy of application started : not allowed, will terminate.", null);
		self.setTerminatingDuplicateProcess(true);																				// JSM PAR 5083
		app.cnTerminate();
	endif;
epilog
	delete jdba;
	if root <> null then
		unlock(root.allLockTargets);
//		unlock(root);																											// JSM PAR 5288
	endif;
end;
}
getBaseFileName
{
getBaseFileName(filename : String) : String;

vars
	pos : Integer;
begin
 	pos := filename.reversePos(".");
 	if pos > 0 then
 		return filename[1 : pos - 1];
 	endif;
end;
}
getProcessForLock
{
getProcessForLock(pSchemaName, pAppName : String; pApplyCollectionLock : Boolean) : Process;

vars
	cc					: CnCntrl;
	
	target				: CnLockTarget;

	root				: CnRoot;
	
	proc				: Process;
	
	dict				: ProcessDict;
	
	d1,
	d2					: Decimal[23];
	
	forceLog			: Boolean;

	count,
	sz					: Integer;
	
	accessCollElapsed,
	getLockObjElapsed,
	logStr				: String;
begin
	//   This method is used to control the startup of KCCMgr, and JSM background clients. When these apps start, they
	//   instantiate the CnLockTarget if necessary, and then acquire a sharelock on the target.  The existence of
	//   this lock is used here to detect and obtain a reference to the background process that locked it.
	//   This approach was designed to avoid database updates when using SDS secondaries in JADE 6.0.
	//
	//	 In this version, only two CnLockTarget objects will exist : one for the background client and the other
	//	 for a process that is starting the background client.
	//
	//	 See companion method ::setLockForProcess.
	//
	//	 This method returns the process that matches the processType holding the lock.	
	//
	d1		:= app.relativeMachineTime();
	cc 		:= app.myCnCntrl;
	root	:= app.myCnRoot;
	if pApplyCollectionLock then
		// use tryLock initially and wait for up to 1 second before going into a retry loop.
		if not self.tryLock(root.allLockTargets, Exclusive_Lock, Transaction_Duration, 1000) then
			count := count + 1;
			// if we've retried 3 times then try unconditionally one last time which 
			// will either succeed or fail. The latter will cause an exception which may
			// be caught by local exception handler or the global lock exception handler.
			if count > 2 then
				exclusiveLock(root.allLockTargets);
			endif;
		endif;
	endif;
	
	d2		:= app.relativeMachineTime();
	target	:= root.allLockTargets[pSchemaName, pAppName];
	accessCollElapsed := d2.cnGetElapsedTime();
	if target = null then
		logStr := "CnLockTarget entry for " & pSchemaName & "," & pAppName & " not found";
		forceLog := true;
/*		foreach target in root.allLockTargets do
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & "    " & target.String & " " & target.schemaName & "," & target.appName, null);
		endforeach;
*/		
		return null;
	endif;
	
	create dict transient;
	d2		:= app.relativeMachineTime();
	system.getObjectLockProcesses(target, dict, 10);
	getLockObjElapsed := d2.cnGetElapsedTime();
	
	sz 		:= dict.size();
	if sz > null then				// should normally only be one process locking the CnLockTarget
		logStr := sz.String & " number of locks on " & target.String;
		forceLog := (sz > 1);
		return dict.first;
	endif;

	logStr	:= "no locks found for " & target.String;
	forceLog := true;
	return null;
epilog
	delete dict;
	if pApplyCollectionLock then
		unlock(root.allLockTargets);
	endif;
	
	if forceLog or
	   d1.cnElapsedTimeInMilliSeconds() > 5 then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & logStr & 
																", " & d1.cnGetElapsedTimeString() &
																", accessColl=" & accessCollElapsed &
																", getLockObj=" & getLockObjElapsed, null);
	endif;
end;
}
initializeProcesses
{
initializeProcesses() updating;

vars
	kc			: CnKarmaCntrl;
	
	jadeNode	: Node;
	
	jadeProcess	: Process;
	
	type		: Integer;
	
	badObject	: Boolean;
	
	file		: File;
	
	cc			: CnCntrl;
begin
	if self.appName <> CN_KCCMGR then
		return;
	endif;
	
	kc := app.myCnKarmaCntrl;
	cc := self;

   	if cc.karmaControl then
		create file transient;
		cc.zFileJadeDevelopmentActivity(file);
		beginTimer(86400000, Timer_Continuous, CN_DEVELOPMENT_ACTIVITY);			// 86,400,000 = every 24 hours
	endif;

	self.zJadeApplicationCreate();		// scan ini file and build CnJadeApplication entries that are to ignore reg check
	
	// PAR 445 - moved from app to CnCntrl to avoid issues where sub-schema's application class
	// implements sysNotification method and doesn't do an inheritMethod.
	// Unable to use CnKarmaCntrl as sysNotification has been remimplemented by Joss on CnJossCntrl sub-class
   	cc.beginClassNotification(Process, false, Object_Delete_Event, Response_Continuous, Cn_Process_Class);
	cc.beginClassNotification(Process, false, Object_Update_Event, Response_Continuous, Cn_Process_Class);
   	cc.beginClassNotification(Process, false, Object_Create_Event, Response_Continuous, Cn_Process_Class);
	cc.beginClassNotification(Process, false, Cn_ForceCreateOfProcess, Response_Continuous, Cn_Process_Class);					// PAR 883
	cc.beginClassNotification(Process, false, Cn_ForceDeleteOfProcess, Response_Continuous, Cn_Process_Class);					// PAR 883
	cc.beginClassNotification(Node, false, CN_REGISTER_MAXLOCALPROCESSES, Response_Continuous, Cn_Node_Class);
	
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : KCCMgr now asking all processes to submit SessionOpenAdvices", null);
	on SystemException do app.cnHandleSpecifiedInvalidObjRef(exception, jadeProcess, badObject);
	foreach jadeProcess in Process.instances do
		badObject := false;
		type := jadeProcess.type.Integer; 
		if badObject then
			continue;
		endif;

		if self.zRpsNodeAdded(type, jadeProcess, true) then																		// PAR 1042
			continue;																											// PAR 1042
		endif;																													// PAR 1042
		
		if type <> 1 and				// Dev Environment
		   type <> 2 then				// non-development process
			continue;
		endif;
		
		self.zJadeProcessCreate(jadeProcess, true);
		if jadeProcess = process or		// ignore myself
		   badObject 			 then
			continue;
		endif;
		
		if type = 2 then				// no point in issuing SOA request to Dev Env
			jadeProcess.causeEvent(Cn_Session_Open_Advice_Request, true, 0);
		endif;
	endforeach;
epilog
	delete file;
end;
}
isInTestMode
{
isInTestMode() : Boolean;

vars
	pos				: Integer;
	
	dbPath,
	testPrefix		: String;
begin
	dbPath			:= app.dbPath();
	testPrefix		:= dbPath[4:3].toLower();
	return self.testMode <> null 			and
		   (testPrefix = "jcd"	or
		    testPrefix = "tes"	or
			testPrefix = "tst");
end;
}
logDevelopmentActivity
{
logDevelopmentActivity(pCnJadeProcess : CnJadeProcess);

vars
	file			: CnFile;

	pos,
	result			: Integer;

	elapsedTime,																												// PAR 1032
	fqdn,
	ipAddress,
	kccmgrStartUp,
	signOnDate,																													// PAR 1032
	signOnTime,																													// PAR 1032
	signOnServerDate,																											// PAR 1032
	signOnServerTime,																											// PAR 1032
	signOnUserCode,																												// PAR 1032
	userCode		: String;																									// PAR 1032
	
	ts				: TimeStamp;
	
	tsi				: TimeStampInterval;
	
	cem				: CnExternalMethods;
begin
  	create file transient;
   	self.zFileJadeDevelopmentActivity(file);
	
	ipAddress := pCnJadeProcess.ipAddress;
	if ipAddress = null then
		fqdn := "localhost";
	
	else
		create cem transient;
		result := cem.emGetHostByAddress(ipAddress, fqdn);				// result = 0 means OK
		if result <> null then
			fqdn := ipAddress;
		endif;
	endif;
	
	if pCnJadeProcess.kccmgrStartUp then
		kccmgrStartUp := "Y";
	endif;

	signOnDate	 	:= pCnJadeProcess.signOnTime.date().cnUserFormat($CnCCYYMMDD_ns);											// PAR 1032
	signOnTime 		:= pCnJadeProcess.signOnTime.time().cnUserFormat($CnHHMMSS_ns);												// PAR 1032
	elapsedTime 	:= "<unknown>";																								// PAR 1032
	signOnUserCode	:= "<unknown>";																								// PAR 1032
	userCode		:= "<unknown>";																								// PAR 1032
	if pCnJadeProcess.signedOn then																								// PAR 1032
		tsi := ts - pCnJadeProcess.signOnTimeServer;																			// PAR 1032
		elapsedTime 		:= tsi.cnFormatted();																				// PAR 1032
		elapsedTime			:= elapsedTime.cnRemoveChars(CN_COMMA);																// PAR 1032
		signOnServerDate 	:= pCnJadeProcess.signOnTimeServer.date().cnUserFormat($CnCCYYMMDD_ns);								// PAR 1032
		signOnServerTime 	:= pCnJadeProcess.signOnTimeServer.time().cnUserFormat($CnHHMMSS_ns);								// PAR 1032
		userCode			:= pCnJadeProcess.userCode;																			// PAR 1032
		signOnUserCode		:= pCnJadeProcess.signOnUserCode;																	// PAR 1032
	endif;
	
	file.writeLine(ts.date().cnUserFormat($CnCCYYMMDD_ns)								& CN_COMMA &
				   ts.time().cnUserFormat($CnHHMMSS_ns)									& CN_COMMA &
				   pCnJadeProcess.processId.String										& CN_COMMA &
				   pCnJadeProcess.myCnJadeNode.osID.String								& CN_COMMA &
				   userCode																& CN_COMMA &							// PAR 1032
				   fqdn																	& CN_COMMA &
				   signOnDate															& CN_COMMA &							// PAR 1032
				   signOnTime															& CN_COMMA &							// PAR 1032
				   signOnUserCode														& CN_COMMA &							// PAR 1032
				   signOnServerDate														& CN_COMMA &							// PAR 1032
				   signOnServerTime														& CN_COMMA &							// PAR 1032
				   kccmgrStartUp														& CN_COMMA &
				   elapsedTime															& CN_COMMA &							// PAR 1032
				   pCnJadeProcess.usingThinClient.String);
epilog
	delete file;
	delete cem;
end;
}
nodeMonitorChange
{
nodeMonitorChange(pCheckInterval, pThresholdPercent, pDefaultMaxLocalProcesses : Integer) : String updating;

vars
	kc				: CnKarmaCntrl;
	
	cnJadeNode		: CnJadeNode;
	
	option,
	timeRemaining	: Integer;
	
	cc				: CnCntrl;
begin
	cc := app.myCnCntrl;
	if cc.appName <> CN_KCCMGR then
		self.cnWriteLog(self.CnLogProgramError, method.cnGetMethodName() & " invalid method for this application.", null);
		return CN_OK;
	endif;
	
	if self.nodeMonitoringCheckInterval > null then
		if self.nodeMonitoringThresholdPercent <> pThresholdPercent or
		   self.nodeMonitoringCheckInterval	   <> pCheckInterval 	then
			self.endTimer(CN_NODE_MONITOR_TIMER);
			if self.myNodeMonitoringFile <> null then																			// PAR 618
				self.myNodeMonitoringFile.close();			// also close off file
			endif;																												// PAR 618
			
			self.nodeMonitoringDate := null;
			self.cnWriteLog(self.CnLogDiag, method.cnGetMethodName() & " CN_NODE_MONITOR_TIMER has been stopped as values have changed.", null);
		endif;
	endif;

	if self.nodeMonitoringThresholdPercent <> pThresholdPercent then
		self.nodeMonitoringThresholdPercent := pThresholdPercent;
	endif;
	
	if self.nodeMonitoringCheckInterval	<> pCheckInterval then
		self.nodeMonitoringCheckInterval := pCheckInterval;
	endif;
	
	if self.nodeMonitoringCheckInterval > null then
		if not self.getTimerStatus(CN_NODE_MONITOR_TIMER, option, timeRemaining) then
			self.beginTimer(pCheckInterval * 60 * 1000, Timer_Continuous, CN_NODE_MONITOR_TIMER);
			self.cnWriteLog(self.CnLogDiag, method.cnGetMethodName() & " CN_NODE_MONITOR_TIMER has been started (check interval = " & 
																	pCheckInterval.String & "mins, threshold=" & 
																	pThresholdPercent.String & "%).", null);
		endif;
	endif;
	
	if self.nodeMonitoringMaxProcessDef <> pDefaultMaxLocalProcesses then
		self.nodeMonitoringMaxProcessDef := pDefaultMaxLocalProcesses;
	
		// now update CnJadeNodes with default value
		kc := app.myCnKarmaCntrl;
		foreach cnJadeNode in kc.allCnJadeNodes do
			if cnJadeNode.isDefaultValue then
				cnJadeNode.setMaxLocalProcesses(pDefaultMaxLocalProcesses);
			endif;
		endforeach;
	endif;
	
	return CN_OK;
end;
}
setAutoReListen
{
setAutoReListen(set : Boolean) updating;

vars

begin
  	self.autoReListen := set;
end;
}
setAutoReOpen
{
setAutoReOpen(set : Boolean) updating;

vars

begin
  	self.autoReOpen := set;
end;
}
setCheckTransientsOnShutDown
{
setCheckTransientsOnShutDown(set : Boolean) updating;

vars

begin
 	self.checkTransientsOnShutDown := set;
end;
}
setClientTranStats
{
setClientTranStats(set : Boolean) updating;

vars

begin
 	self.clientTranStats := set;
end;
}
setClientUsesReadOnlySchema
{
setClientUsesReadOnlySchema(set : Boolean) updating;

vars

begin
	self.clientUsesReadOnlySchema := set;
end;
}
setComputerName
{
setComputerName(name : String) updating;

vars

begin
 	self.computerName := name;
end;
}
setConnectionResponseTime
{
setConnectionResponseTime(seconds : Integer) updating;

vars

begin
 	self.connectionResponseTime := seconds;
end;
}
setConnectionRetryDelay
{
setConnectionRetryDelay(delay : Integer) updating;

vars

begin
 	self.connectionRetryDelay := delay;
end;
}
setConnectionRetryLimit
{
setConnectionRetryLimit(limit : Integer) updating;

vars

begin
 	self.connectionRetryLimit := limit;
end;
}
setDeadlockRetryLimit
{
setDeadlockRetryLimit(retries : Integer) updating;

vars

begin
	self.deadlockRetryLimit := retries;
end;
}
setDefaultMaxLocalProcesses
{
setDefaultMaxLocalProcesses(pValue : Integer) updating;

vars

begin
	self.defaultMaxLocalProcesses := pValue;
end;
}
setDumpXamlObjectProperties
{
setDumpXamlObjectProperties(pValue : Boolean) updating;

vars

begin
	self.dumpXamlObjectProperties := pValue;
end;
}
setExceptionDisplayModal
{
setExceptionDisplayModal(set : Boolean) updating;

vars

begin
	self.exceptionDisplayModal := set;
end;
}
setExceptionDisplayTimeout
{
setExceptionDisplayTimeout(timeout : Integer) updating;

vars

begin
 	self.exceptionDisplayTimeout := timeout;
end;
}
setExceptionHandlerType
{
setExceptionHandlerType(type : Integer) updating;

vars

begin
 	self.exceptionHandlerType := type;		// 0=Jade, 1=CardSchema, 2=All
end;
}
setFullDiagnostics
{
setFullDiagnostics(set : Boolean) updating;

vars

begin
	setLogging(true);
	setLogCommsComputer(null);
	setLogCommsConnections(set);
	setLogDiagnostics(set);
	setLogCommsBuffers(set);
	// allow JSM/JSA ini file settings to take effect.																			// PAR 6782
//	setLogMessaging(not set);																									// PAR 6782
	setLogErrors(set);
	setLogToScreen(set);
end;
}
setHeaderLength
{
setHeaderLength(length : Integer) updating;

vars

begin
 	self.headerLength := length;
 	if app.myCnKarmaCntrl <> null then
 		cnWriteLog(CnLogComment, "TCP/IP message header length has now been set to " & headerLength.String & " bytes (octets)", null);
 	endif;
end;
}
setIsService
{
setIsService(set : Boolean) updating;

vars

begin
	self.isService := set;
end;
}
setJavaThinClient
{
setJavaThinClient(set : Boolean) updating;

vars

begin
 	self.javaThinClient := set; 
end;
}
setKarmaControl
{
setKarmaControl(set : Boolean) updating;

vars

begin
	self.karmaControl := set;
end;
}
setLockForProcess
{
setLockForProcess(pSchemaName, pAppName : String; pSet, pApplyCollectionLock : Boolean) : Boolean updating;

vars
	cc		: CnCntrl;
	
	target	: CnLockTarget;

	root	: CnRoot;

	proc	: Process;
	
	dict	: ProcessDict;
begin
	//   This method is used to control the startup of KCCMgr, and JSM background clients. When these apps start, they
	//   instantiate the CnLockTarget if necessary, and then acquire a sharelock on the target.  The existence of
	//   this lock is used here to detect and obtain a reference to the background process that locked it.
	//   This approach was designed to avoid database updates when using SDS secondaries in JADE 6.0.
	//
	//	 See companion method ::getProcessForLock.
	//
	//   This method sets or unsets the lock on the CnLockTarget object(s).  It is called by the initialising background client,
	//   (processType=1) or the background client starter client (processType=2).
	//
	cc		:= app.myCnCntrl;
	root	:= app.myCnRoot;
	if pApplyCollectionLock then
		exclusiveLock(root.allLockTargets);
	endif;
	
	target	:= root.allLockTargets[pSchemaName, pAppName];
/*	if target = null then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " no lock target found for " & pSchemaName & "," & pAppName, null);
	
	else
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & target.String & " located for " & pSchemaName & "," & pAppName, null);	
	endif;
*/	
	if target = null and pSet then
		target	:= root.allLockTargets[pSchemaName, pAppName];
		if target = null then
			if app.cnDatabaseSubrole = SDS_SubroleNative or
			   app.cnDatabaseSubrole = SDS_SubroleRelational then
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " unable to create CnLockTarget instance on SDS Secondary for this application (" & pSchemaName & "," & pAppName & ")", null);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " suggest that CnLockTarget instance be created on SDS Primary for this application", null);
				terminate;
			endif;
			
			beginTransaction;
			create target persistent;
			target.loadSelf(pSchemaName, pAppName);
			commitTransaction;
//			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " created " & target.String & " for " & pSchemaName & "," & pAppName, null);
		endif;
	endif;
		
	if pSet then
		if tryLock(target, Share_Lock, Session_Duration, 0) then
//			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " session lock acquired on " & target.String, null);
			return true;
		endif;

		return false;
	endif;
	
	if target <> null then
		unlock(target);
	endif;
	
	return false;
epilog
	if pApplyCollectionLock then
		unlock(root.allLockTargets);
	endif;
end;
}
setLockRetryTime
{
setLockRetryTime(millisecs : Integer) updating;

vars

begin
	self.lockRetryTime := millisecs;
end;
}
setLockTimeOut
{
setLockTimeOut(pMilliSeconds : Integer) updating;

vars

begin
	self.lockTimeOut := pMilliSeconds;
end;
}
setLogCallStackDump
{
setLogCallStackDump(set : Boolean) updating;

vars

begin
 	self.logCallStackDump := set;
end;
}
setLogCommsBuffers
{
setLogCommsBuffers(set : Boolean) updating;

vars

begin
 	self.logCommsBuffers := set;
end;
}
setLogCommsComputer
{
setLogCommsComputer(computer : String) updating;

vars

begin
 	self.logCommsComputer := computer;
end;
}
setLogCommsConnections
{
setLogCommsConnections(set : Boolean) updating;

vars

begin
  	self.logCommsConnections := set;
end;
}
setLogDiagnostics
{
setLogDiagnostics(set : Boolean) updating;

vars

begin
	self.logDiagnostics := set;
end;
}
setLogErrors
{
setLogErrors(set : Boolean) updating;

vars

begin
 	self.logErrors := true;
end;
}
setLogFileMaxSize
{
setLogFileMaxSize(size : Integer) updating;

vars

begin
 	self.logFileMaxSize := size;
end;
}
setLogFileName
{
setLogFileName(name : String) updating;

vars

begin
 	self.logFileName := name;
end;
}
setLogImmediateCommit
{
setLogImmediateCommit(set : Boolean) updating;

vars

begin
 	self.logImmediateCommit := set;
end;
}
setLogLogicalTransactions
{
setLogLogicalTransactions(set : Boolean) updating;

vars

begin
 	self.logLogicalTransactions	:= set;
end;
}
setLogMessaging
{
setLogMessaging(pValue : Boolean) updating;

vars

begin
	self.logMessaging := pValue;
end;
}
setLogMiniStackDump
{
setLogMiniStackDump(set : Boolean) updating;

vars

begin
 	logMiniStackDump := set;
end;
}
setLogMiniStackDumpForLocks
{
setLogMiniStackDumpForLocks(set : Boolean) updating;

vars

begin
	self.logMiniStackDumpForLocks := set;
end;
}
setLogPath
{
setLogPath(pLogPath : String) updating;

vars
	len		: Integer;
	
	path	: String;
begin
	path	:= pLogPath;
	path.replaceChar(CN_SLASH, CN_BACK_SLASH);
	
	len		:= path.length;
	if path[len] = CN_BACK_SLASH then
		path 	:= path[1:len-1];
	endif;

	self.logPath := path;
end;
}
setLogPathError
{
setLogPathError(set : Boolean) updating;

vars

begin
	logPathError	:= set;
end;
}
setLogStackDumpCensored
{
setLogStackDumpCensored(pValue : Boolean) updating;

vars

begin
	self.logStackDumpCensored := pValue;
end;
}
setLogStackDumpTruncateObjectString
{
setLogStackDumpTruncateObjectString(pValue : Boolean) updating;																		// JCS NFS 936

vars

begin
 	self.logStackDumpTruncateObjectString := pValue;
end;
}
setLogToScreen
{
setLogToScreen(set : Boolean) updating;

vars

begin
	self.logToScreen := set; 	
end;
}
setLogging
{
setLogging(set : Boolean) updating;

vars

begin
 	self.logging := set;
end;
}
setMaxArrayElementsInDump
{
setMaxArrayElementsInDump(count : Integer) updating;

vars

begin
 	maxArrayElementsInDump := count;
end;
}
setMaxMessageSize
{
setMaxMessageSize(int : Integer) updating;

vars

begin
	self.maxMessageSize := int;
	if app.myCnKarmaCntrl <> null then
		cnWriteLog(CnLogComment, "TCP/IP max message body size has now been set to " & int.String & " bytes (octets)", null); 
	endif;
end;
}
setMyBackgroundClientProcess
{
setMyBackgroundClientProcess(proc : Process) updating;

vars

begin
   	self.myBackgroundClientProcess := proc;
end;
}
setMyNodeControl
{
setMyNodeControl(nodeControl : CnNodeControl input) updating;

vars
	cnNodeControlCnCntrl	: CnNodeControlCnCntrl;
begin
	create cnNodeControlCnCntrl sharedTransient;
	nodeControl.allNodeControlCnCntrlArray.add(cnNodeControlCnCntrl);

	self.myNodeControl	:= nodeControl;
	self.myNodeControlCnCntrl := cnNodeControlCnCntrl;
end;
}
setNoPingReplies
{
setNoPingReplies(set : Boolean) updating;

vars

begin
 	self.noPingReplies := set;
end;
}
setNodeMonitoringThresholdInfo
{
setNodeMonitoringThresholdInfo(pCheckInterval, pThresholdPercent : Integer) updating;

vars

begin
	self.nodeMonitoringCheckInterval 	:= pCheckInterval;
	self.nodeMonitoringThresholdPercent := pThresholdPercent;
end;
}
setOmitBinaryVersionControlChk
{
setOmitBinaryVersionControlChk(set : Boolean) updating;

vars

begin
 	self.omitBinaryVersionControlCheck := set;
end;
}
setOsDistroAndVersion
{
setOsDistroAndVersion() updating;

vars
	file		: File;
	str			: String;
	pos			: Integer;
	firstOne	: Boolean;
begin
	osDistribution	:= null;
	firstOne		:= true;

	create file transient;
	file.usePresentationFileSystem	:= false;
	file.mode		:= file.Mode_Input;
	file.endOfLine	:= Lf;
	file.fileName	:= "/opt/cardinal/etc/distro_ver.txt";
	if file.isAvailable() then
		osDistribution := "<unknown>";

	else
		file.fileName	:= "/etc/SuSE-release";
		if file.isAvailable then
			osDistribution	:= "SuSE";
		else
			file.fileName	:= "/etc/redhat-release";
			if file.isAvailable then
				osDistribution	:= "RedHat";
			else
				file.fileName	:= "/etc/whitebox-release";
				if file.isAvailable then
					osDistribution	:= "RedHat";
				endif;
			endif;
		endif;
	endif;
	
	if osDistribution <> null then
		file.kind		:= file.Kind_ANSI;			
		while not file.endOfFile do
			str	:= file.readLine().toLower.trimBlanks;
			if firstOne then
				osDistributionEx	:= str;
				if osDistributionEx.toLower().cnContains("centos") then
					osDistribution := "Redhat";
				endif;
				
				firstOne			:= false;
			endif;
			
			if str[1:7] = "version" then
				pos			:= str.pos("=", 8);	
				pos			:= pos + 1;
				osVersion	:= str[pos:end].trimBlanks;
				break;
			endif;
		endwhile;
	endif;
epilog
	delete file;	
end;
}
setReadOnlySchema
{
setReadOnlySchema(set : Boolean) updating;

vars

begin
	self.readOnlySchema := set;
end;
}
setReportExceptions
{
setReportExceptions(set : Boolean) updating;

vars

begin
 	self.reportExceptions := set;
end;
}
setResolveRemoteName
{
setResolveRemoteName(set : Boolean) updating;

vars

begin
	self.resolveRemoteName := set;
end;
}
setSamplingDefeated
{
setSamplingDefeated(set : Boolean) updating;

vars

begin
	self.samplingDefeated := set;
end;
}
setServerLogFileName
{
setServerLogFileName(name : String) updating;

vars

begin
 	self.serverLogFileName := name;
end;
}
setServerLogPath
{
setServerLogPath(path : String) updating;

vars

begin
  	self.serverLogPath := path;	
end;
}
setSuppressAlerts
{
setSuppressAlerts(pValue : Boolean) updating;

vars

begin
	self.suppressAlerts := pValue;
end;
}
setSuppressManagementDialogs
{
setSuppressManagementDialogs(set : Boolean) updating;

vars

begin
	self.suppressManagementDialogs := set;
end;
}
setSuppressStackDump
{
setSuppressStackDump(pValue : Boolean) updating;

vars

begin
	self.suppressStackDump := pValue;
end;
}
setSystemShutDownEvent
{
setSystemShutDownEvent(eventTag : Integer) updating;

vars

begin
	self.systemShutDownEvent	:= eventTag;
end;
}
setTcpExceptionHandlerArmed
{
setTcpExceptionHandlerArmed(set : Boolean) updating;

vars

begin
 	self.tcpExceptionHandlerArmed := set;
end;
}
setTerminatingDuplicateProcess
{
setTerminatingDuplicateProcess(pValue : Boolean) updating;

vars

begin
	self.terminatingDuplicateProcess := pValue;
end;
}
setTestMode
{
setTestMode(pValue : Integer) updating;

vars

begin
	self.testMode := pValue;
end;
}
setTestModeFromIni
{
setTestModeFromIni() updating;

vars
	xTestMode	: Integer;
begin
	xTestMode	:= app.cnGetProfileStringServer(CN_KARMA, CN_TESTMODE, "0").Integer;
	self.setTestMode(xTestMode);
end;
}
setupControlOptions
{
setupControlOptions() updating;

vars
	appl			: Application;

	cnApp			: CardSchema;

    ff				: FileFolder;

    log				: JadeLog;

	array			: CnStringArray;

	ix, 
    len,
	maxIndex,
    maxSize,
	osPlatform,
	osArchitecture,
    pos				: Integer;

    compName,
    defLogPath,
	dir,
    factor,
 	iniFile,
    logfilename,
    logpath,
	osVersion,
    sizeStr,
    str				: String;
begin
	appl := process.getProcessApp();
	if appl.isKindOf(CardSchema) then
		cnApp := appl.CardSchema;
	
	else
		cnApp := app;
	endif;
	
	///
	///  This method sets up CnCntrl's logging (and other) attributes based on the settings found in
	///  the application's .ini file, in the [CardLog] and [Karma] section.  If the section is not
	///  found, or if certain key attributes are not found, then in some cases they are added using default settings.
	if cnApp.cnOSPlatform = null then
		osPlatform	:= node.getOSPlatform(osVersion, osArchitecture);
		cnApp.cnSetOSPlatform(osPlatform);
		app.cnSetOSPlatform(osPlatform);
	endif;
	
	iniFile		:= cnApp.getIniFileNameAppServer;
	
	////////////////////  Force database backup thread priority  //////////////////////////////////////////
	
	if cnApp.name = CN_KCCMGR 		or 
	   cnApp.name = CN_JOSSCOMMSMGR then
		cnApp.setProfileString(iniFile, CN_PERSISTENTDB, "BackupThreadPriority", "Lowest");
	endif; 

	////////////////////  Miscellaneous Karma Control Stuff   //////////////////////////////////////////////////

	str		:= cnApp.getProfileStringAppServer(iniFile, CN_KARMA, CN_KARMACONTROL, "").toLower();
	if str = null then
		str	:= false.String;
		cnApp.setProfileString(iniFile, CN_KARMA, CN_KARMACONTROL, str);
	endif;
	
   	self.setKarmaControl(str = true.String);

	str		:= cnApp.getProfileStringAppServer(iniFile, CN_KARMA, CN_SUPPRESSALERTS, "").toLower();
	if str = null then
		str	:= false.String;
		cnApp.setProfileString(iniFile, CN_KARMA, CN_SUPPRESSALERTS, str);
	endif;
	
   	self.setSuppressAlerts(str = true.String);
	
    if cnApp.getProfileStringAppServer(iniFile, "AppEnvironment", "SuppressManagementDialogs", "false").toLower = "true" then
    	self.setSuppressManagementDialogs(true);
    endif;

	if cnApp.getProfileStringAppServer(iniFile, "JadeClient", "ReadOnlySchema", "false").toLower = "true" then
    	self.setClientUsesReadOnlySchema(true);
    endif;

    if cnApp.getProfileStringAppServer(iniFile, "AppEnvironment", "OmitBinaryVersionControlFileCheck", "false").toLower = "true" then
    	self.setOmitBinaryVersionControlChk(true);
    endif;

    if cnApp.getProfileStringAppServer(iniFile, "JadeClient", "ReadOnlySchema", "false").toLower = "true" then
    	self.setReadOnlySchema(true);
    endif;

	str := cnApp.getProfileStringAppServer(iniFile, "JSMStats", "ClientTranStats", null).toLower;
	if str = null then
		cnApp.setProfileStringAppServer(iniFile, "JSMStats", "ClientTranStats", "true");
		self.setClientTranStats(true);
		
	elseif str.toLower = "true" then
		self.setClientTranStats(true);
	endif;
	
	if not clientTranStats then													// check for thin client ini file setting
		if cnApp.getProfileString(cnApp.getIniFileName, "JSMStats", "ClientTranStats", null).toLower = "true" then
			self.setClientTranStats(true);
		endif;
	endif;
	
	str := self.myTransientGlobal.cnGetProfileStringServer("JSMStats", "SystemTranStats", "-1");
	if str = "-1" then
		self.myTransientGlobal.cnSetProfileStringServer("JSMStats", "SystemTranStats", "0");
		self.setClientTranStats(false);
	elseif str = "0" then
		self.setClientTranStats(false);
	elseif str = "2" then
		self.setClientTranStats(true);
	endif;

	str := cnApp.getProfileStringAppServer(iniFile, "JSMStats", "LogLogicalTransactions", null).toLower;
	if str = null then
		cnApp.setProfileStringAppServer(iniFile, "JSMStats", "LogLogicalTransactions", "false");
		self.setLogLogicalTransactions(false);

	elseif str.toLower = "true" then
		self.setLogLogicalTransactions(true);
	endif;
	
	str := cnApp.getProfileStringAppServer(iniFile, "JSMStats", "LogLocalCacheStats", null).toLower;
	if str = null then
		cnApp.setProfileStringAppServer(iniFile, "JSMStats", "LogLocalCacheStats", "false");
		self.logLocalCacheStats	:= false;

	elseif str.toLower = "true" then
		self.logLocalCacheStats	:= true;
	endif;

    self.setLogErrors(true);						// not an option right now

    ///////////////////////////   Now set up logging stuff   ///////////////////////////////////////////////
	self.zSetupLoggingOptions(iniFile);
    
    self.dbLogPath	:= cnApp.cnGetProfileStringServer("PersistentDb", "JournalRootDirectory", null).toLower;
    if self.dbLogPath = null then							// can happen if ini file option is set to <default>
		if cnApp.cnOSPlatformIsWindows() then
			self.dbLogPath	:= self.logPath;				// use [CardLog]LogPath instead
			
		else
			self.dbLogPath	:= cnApp.dbPath & "/journals";	// Linux ALWAYS /opt/env/system/journals
		endif;
    endif;
    
   	//  Now set up the logging file object.  To ensure that log file writes are
	//  single-threaded (necessary because of file renames) we use a lockable 
	//  persistent object.

	create log transient;			// 'log' transient is referenced by app.myCnLog and required for duration of process.
	log.filePath		:= self.logPath;
	log.fileName		:= self.logFileName;
	log.versionFile		:= true;
	log.maxFileSize		:= self.logFileMaxSize;
	log.formatOutput	:= false;
	log.bufferOutput	:= true;
   	cnApp.setMyCnLog(log);
	app.setMyCnLog(log);		// set up package application
	
   	if logPathError then
   		cnWriteLog(CnLogComment, method.cnGetMethodName() & " : ini file error : [CardLog] LogPath has defaulted to " & self.logPath, null);
    endif;

	str := cnApp.getProfileStringAppServer(iniFile, "CardLog", "CheckTransientsOnShutDown", null).toLower;
	if str = null then
		cnApp.setProfileStringAppServer(iniFile, "CardLog", "CheckTransientsOnShutDown", "false");
	endif;

	if str = "true" then
		self.setCheckTransientsOnShutDown(true);
	endif;
	
	str := cnApp.getProfileStringAppServer(iniFile, "CardLog", "LogStackDumpOnTerminate", null).toLower;
	if str = null then
		cnApp.setProfileStringAppServer(iniFile, "CardLog", "LogStackDumpOnTerminate", "false");
	endif;

	if str = null or str = "true" then
		self.logStackDumpOnTerminate	:= true;
	endif;
	
	////////////   Store exception form picture specification  //////////////
	
	str	:= cnApp.getProfileStringAppServer(iniFile, "AppExceptions", "ExceptionDisplayPicture", null).toLower;
	if str = "greenfrog" then
		self.exceptionFormPicture	:= Cn_Green_Frog;
		
	elseif str = "originalgreenfrog" then
		self.exceptionFormPicture	:= Cn_Original_Green_Frog;
		
	elseif str = "greenfrogphoto" then
		self.exceptionFormPicture	:= Cn_Green_Frog_Photo;
		
	elseif str = "rainbowfrog" then
		self.exceptionFormPicture	:= Cn_Rainbow_Frog;
		
	else
		self.exceptionFormPicture	:= Cn_Road_Sign; 
	endif;
	
	///////////  Set up options for non-managed sampling.  Note that these only have effect for first process on node ...   ////
	///////////  see CnNodeControl::create method for rest of set up														////
	
	if cnApp.getProfileStringAppServer(cnApp.getIniFileNameAppServer, "JSMStats", "SampleProcessStatistics", null).toLower = "true" then
		sampleProcessStats	:= true;
	endif;
	
	if cnApp.getProfileStringAppServer(cnApp.getIniFileNameAppServer, "JSMStats", "SampleCacheStatistics", null).toLower = "true" then
		sampleCacheStats	:= true;
		samplingFrequency	:= cnApp.getProfileStringAppServer(cnApp.getIniFileNameAppServer, "JSMStats", "SamplingFrequency", "30").Integer;	
	endif;
	
	////////////  Journal Verification  ////////////////////////////////////
	
	if cnApp.name = CN_KCCMGR or cnApp.name = CN_JOSSCOMMSMGR then
		str	:= cnApp.getProfileString(cnApp.getIniFileName, "AppEnvironment", "VerifyDatabaseJournals", null).toLower();
		if str = null then
			cnApp.setProfileString(cnApp.getIniFileName, "AppEnvironment", "VerifyDatabaseJournals", true.String);
			self.verifyDatabaseJournals := true;
			
		else
			self.verifyDatabaseJournals := (str = true.String);
		endif;
	endif;
	
	archivalRecoveryEnabled		:= cnApp.cnGetProfileStringServer("PersistentDb", "EnableArchivalRecovery", "false").toLower = "true";
	
	/////////////  Other Application properties /////////////////////////////
	
	if cnApp.cnOSPlatformIsUnix() then
		if self.karmaControl then
			cnApp.setCnApplicationRootDir("/opt/");							// mandatory if managed
			
		else
			array	:= cnApp.getJadeInstallDirAppServer.cnGetTokens("/");
			maxIndex	:= array.size() - 2;								// strip off <env>/bin
			dir			:= "/";
			if maxIndex > 0 then
				foreach ix in 1 to maxIndex do
					dir	:= dir & array[ix] & "/";							// PAR 468
				endforeach;
			endif;
			
			cnApp.setCnApplicationRootDir(dir);			
		endif;
	endif;
epilog
	delete array;
end;
}
setupExceptionDefaults
{
setupExceptionDefaults(pIniFile : String) updating;

vars
	bResult : Boolean;
begin
 	bResult := app.setProfileStringAppServer(pIniFile, "AppExceptions", "ReportExceptions", True);
	if not bResult then
		if app.msgBox("Application " & self.appName & " unable to set exception handling defaults into your .ini file." & CrLf &
				 	  "Ini file name used = " & pIniFile & CrLf & Lf &
				  	 "If you press Cancel, then your application will terminate, else press " &
				  	 "OK to continue.", "Unexpected Error", MsgBox_OK_Cancel) = MsgBox_Return_Cancel then
			app.cnTerminate();
		endif;
	endif;

	self.setReportExceptions(true);							// report exceptions to KCCMgr / Joss
	self.reportExceptionsAll	:= false;					// report ALL exceptions regardless of reportExceptions setting
	self.setLogCallStackDump(true);							// dump call stack into log
	self.setExceptionDisplayTimeout(60);					// Exceptions disappear after 60 secs
	self.setExceptionDisplayModal(false);					// Exceptions aren't modally displayed
	self.setLockRetryTime(60000);							// milliseconds
	self.setLockTimeOut(10000);								// milliseconds
	self.setDeadlockRetryLimit(0);							// must be explicitly set by application

    app.setProfileStringAppServer(pIniFile, "AppExceptions", "ReportExceptions", true.String);
    app.setProfileStringAppServer(pIniFile, "AppExceptions", "ReportAllExceptions", true.String);
    app.setProfileStringAppServer(pIniFile, "AppExceptions", "ExceptionHandler", "CardSchema");
	app.setProfileStringAppServer(pIniFile, "AppExceptions", "LockRetryTime", "60");
	app.cnSetProfileStringServer("JadeServer", "ServerTimeout", "10000");
//  app.setProfileStringAppServer(pIniFile, "AppExceptions", "BackgroundClientExceptionsOnly", True);							// deleted for 3.5
    app.setProfileStringAppServer(pIniFile, "AppExceptions", "LogCallStackDump", true.String);
	app.setProfileStringAppServer(pIniFile, "AppExceptions", "LogMiniStackDump", false.String);
	app.setProfileStringAppServer(pIniFile, "AppExceptions", "LogMiniStackDumpForLocks", true.String);
	app.setProfileStringAppServer(pIniFile, "AppExceptions", "LogStackDumpCensored", false.String);								// PAR 667
	app.setProfileStringAppServer(pIniFile, "AppExceptions", "MaxArrayElementsInDump", "100");
	app.setProfileStringAppServer(pIniFile, "AppExceptions", "LogStackDumpTruncateObjectString", true.String);					// NFS 936
    app.setProfileStringAppServer(pIniFile, "AppExceptions", "ExceptionDisplayModal", false.String);
    app.setProfileStringAppServer(pIniFile, "AppExceptions", "ExceptionDisplayTimeout", "60"); 
	app.setProfileStringAppServer(pIniFile, "AppExceptions", "DumpXamlObjectProperties", false.String);
end;
}
setupExceptionFlags
{
setupExceptionFlags() updating;

vars
 	iniFile		: String;
    str			: String;
    timeout		: String;
    iniStr		: String;
	lockTimeOut	: Integer;
begin
	///
	///  This method sets up CnCntrl's exception handling attributes based on the settings found in
	///  the application's .ini file, in the [AppExceptions] section.  If the section is not
	///  found, or if certain key attributes are not found, then in some cases they are added using default settings.

	iniFile := app.getIniFileNameAppServer;
    str 	:= app.getProfileStringAppServer(iniFile, "AppExceptions", "ExceptionHandler", null).toLower();

    if str = null then
    	self.setupExceptionDefaults(iniFile);				// updates .ini file, sets CnCntrl attributes
		
    else
		str := app.getProfileStringAppServer(iniFile, "AppExceptions", "ReportExceptions", null);
		if str = null then
			str := true.String;
			app.setProfileStringAppServer(iniFile, "AppExceptions", "ReportExceptions", str);
		endif;
			
    	self.setReportExceptions(str.Boolean);
    	
		str := app.getProfileStringAppServer(iniFile, "AppExceptions", "ReportAllExceptions", null);
		if str = null then
			str := true.String;
			app.setProfileStringAppServer(iniFile, "AppExceptions", "ReportAllExceptions", str);
		endif;
		
    	self.reportExceptionsAll := str.Boolean;

	    iniStr := app.getProfileStringAppServer(iniFile, "AppExceptions", "ExceptionHandler", null).toLower();
	    if iniStr = "jade" then
	    	setExceptionHandlerType(Exception_Handler_Jade);
			
	    elseif iniStr = "cardschema" then
	    	setExceptionHandlerType(Exception_Handler_CardSchema);
			
	    elseif iniStr = "both" then
	    	setExceptionHandlerType(Exception_Handler_Both);
			
		elseif iniStr = "bothifnotservice" then
			setExceptionHandlerType(Exception_Handler_Both_NotSvce);
			
	    elseif iniStr = "jadedebug" then
	    	setExceptionHandlerType(Exception_Handler_Jade_Debug);
			
	    elseif iniStr = null then
    		setExceptionHandlerType(Exception_Handler_CardSchema);
    		app.setProfileStringAppServer(iniFile, "AppExceptions", "ExceptionHandler", "CardSchema");
	    endif; 

		str := app.getProfileStringAppServer(iniFile, "AppExceptions", "LockRetryTime", null);
		if str = null then
			str := "60";
			app.setProfileStringAppServer(iniFile, "AppExceptions", "LockRetryTime", str);
		endif;
		
	    self.setLockRetryTime(str.Integer * 1000);

		// we leave lockTimeOut in milliseconds as it could be set to a small value like 500ms
		// which we can't integerize into seconds.
		str := app.cnGetProfileStringServer("JadeServer", "ServerTimeout", null);
		if str = null then
			str := "10000";
			app.cnSetProfileStringServer("JadeServer", "ServerTimeout", str);
		endif;
		
		self.setLockTimeOut(str.Integer);
		
		str := app.getProfileStringAppServer(iniFile, "AppExceptions", "LogCallStackDump", null);
		if str = null then
			str := true.String;
			app.setProfileStringAppServer(iniFile, "AppExceptions", "LogCallStackDump", str);
		endif;
		
	    setLogCallStackDump(str.Boolean);

		str := app.getProfileStringAppServer(iniFile, "AppExceptions", "LogMiniStackDump", null);
		if str = null then
			str := false.String;
			app.setProfileStringAppServer(iniFile, "AppExceptions", "LogMiniStackDump", str);
		endif;
		
	    self.setLogMiniStackDump(str.Boolean);
	    
		str := app.getProfileStringAppServer(iniFile, "AppExceptions", "LogMiniStackDumpForLocks", null);
		if str = null then
			str := true.String;
			app.setProfileStringAppServer(iniFile, "AppExceptions", "LogMiniStackDumpForLocks", str);
		endif;
		
	    self.setLogMiniStackDumpForLocks(str.Boolean);
		
		// requested by Brian Johnstone on behalf of Investigator																// PAR 667
		str := app.getProfileStringAppServer(iniFile, "AppExceptions", "LogStackDumpCensored", null);							// PAR 667
		if str = null then																										// PAR 667
			str := false.String;																								// PAR 667
			app.setProfileStringAppServer(iniFile, "AppExceptions", "LogStackDumpCensored", str);								// PAR 667
		endif;																													// PAR 667
		
		self.setLogStackDumpCensored(str.Boolean);																				// PAR 667

		str := app.getProfileStringAppServer(iniFile, "AppExceptions", "MaxArrayElementsInDump", null);
		if str = null then
			str := "100";
			app.setProfileStringAppServer(iniFile, "AppExceptions", "MaxArrayElementsInDump", str);
		endif;
		
		self.setMaxArrayElementsInDump(str.Integer);
		
		str := app.getProfileStringAppServer(iniFile, "AppExceptions", "LogStackDumpTruncateObjectString", null);				// NFS 936
		if str = null then																										// NFS 936
			str := true.String;																									// NFS 936
			app.setProfileStringAppServer(iniFile, "AppExceptions", "LogStackDumpTruncateObjectString", str);					// NFS 936
		endif;																													// NFS 936
		
	    self.setLogStackDumpTruncateObjectString(str.Boolean);																		// NFS 936
		
		str := app.getProfileStringAppServer(iniFile, "AppExceptions", "ExceptionDisplayModal", null);
		if str = null then
			str := false.String;
			app.setProfileStringAppServer(iniFile, "AppExceptions", "ExceptionDisplayModal", str);
		endif;
		
	    self.setExceptionDisplayModal(str.Boolean);

		str := app.getProfileStringAppServer(iniFile, "AppExceptions", "ExceptionDisplayTimeout", null);
		if str = null then
			str := "60";
			app.setProfileStringAppServer(iniFile, "AppExceptions", "ExceptionDisplayTimeout", str);
		endif;
		
	   	self.setExceptionDisplayTimeout(str.Integer);
		
		str := app.getProfileStringAppServer(iniFile, "AppExceptions", "DumpXamlObjectProperties", false.String);
		if str = null then
			str := false.String;
			app.getProfileStringAppServer(iniFile, "AppExceptions", "DumpXamlObjectProperties", str);
		endif;
		
		self.setDumpXamlObjectProperties(str.Boolean);
    endif;
end;
}
setupForSystemShutDown
{
setupForSystemShutDown() updating;

vars
	event	: Integer;
	str		: String;
begin
	str		:= app.getProfileStringAppServer(app.getIniFileNameAppServer, "JadeClient", "ExternalEventOnSystem", null);
	
	if str <> null then
		event	:= str.Integer;
	else
		event	:= User_Max_Event - 1;
	endif;
	
	self.setSystemShutDownEvent(event);
	
	beginNotification(system, event, Response_Continuous, 0); 	
end;
}
startUserServerApplications
{
startUserServerApplications(pIniFileName	: String;
							pDatabaseRole 	: Integer;
							pLaunch		  	: Boolean) updating;
constants
	Delay_Initialized	: Integer	= -1;
vars
	/*  Method normally called from app::cnInitializeKCCMgr if running on server node.
		Starts apps defined in [Karma] section of ini file as 'ServerApplication<nnn>=<schema>,<app>,<optional database role>,<optional numeric prelaunch delay>
		If prelaunch delay is not specified, a 5 second default applies.
		NOTE: the delays are cumulative so that each application is started at the next cumulative delay calculated if database roles match or database role is 
		not specified.
		
		Example:
		ServerApplication1=TestSchema,TestApp1
		ServerApplication2=TestSchema,TestApp2,10
		ServerApplication3=TestSchema,TestApp3
		ServerApplication4=TestSchema,TestApp4,Primary
		ServerApplication5=TestSchema,TestApp5,Secondary
		
		TestApp1 will be started 5 seconds from now   						- delay = 0 + 5 = 5
		TestApp2 will be started 15 seconds from now						- delay = delay + 10 = 15
		TestApp3 will be started 20 seconds from now 					    - delay = delay + 5 = 20
		TestApp4 will be started 25 seconds from now if primary database    - delay = delay + 5 = 25
		TestApp5 will be started 25 seconds from now if secondary database  - delay = delay + 5 = 25
		
		Argument pLaunch will be true if executed by KCCMgr and false if from Unit Test framework
	*/
	
	cc				: CnCntrl;
	
	launcher		: CnApplicationLauncher;	
	
	actualDelay,
	delay,
	dbRole,
	i,
	launched,
	len,
	pos,
	specifiedDelay	: Integer;
	
	appname,
	databaseRole,
	delayStr,
	key,
	keyValue,
	schemaname,
	str1,
	str2			: String;
begin
	cc := self;
	if pDatabaseRole = SDS_RolePrimary then
		databaseRole := "Primary";
		
	elseif pDatabaseRole = SDS_RoleSecondary then
		databaseRole := "Secondary";
	
	else
		databaseRole := "Undefined";
	endif;
	
	cc.cnWriteLog(CnLogComment, "Database Role " & databaseRole & ", checking [Karma] section of ini file " & pIniFileName & " for user server applications (1 to 100) to schedule for start ...", null);	// PAR 621
	
	foreach i in 1 to 100 do																									// PAR 621
		key	:= "ServerApplication" & i.String;
		keyValue	:= app.getProfileString(pIniFileName, CN_KARMA, key, null);
		if keyValue = null then
			continue;
		endif;
		
		len				:= keyValue.length();
//		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " keyValue length=" & len.String & " (" & keyValue & ")", null);
		appname			:= null;
		schemaname		:= null;
		dbRole			:= null;
		specifiedDelay	:= Delay_Initialized;
		
		pos				:= 1;
		schemaname		:= keyValue.scanUntil(CN_COMMA, pos).trimBlanks();
		if schemaname = null then
			cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " schemaname not located for [Karma] " & key & "=" & keyValue, null);
			continue;
		endif;
		
		if pos = null then
			cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " missing application name, incomplete definition for [Karma] " & key & "=" & keyValue, null);
			continue;
		endif;
		
		pos				:= pos + 1;
		appname			:= keyValue.scanUntil(CN_COMMA, pos).trimBlanks();
		if appname = null then
			cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " appname not located for [Karma] " & key & "=" & keyValue, null);
			continue;
		endif;
		
		if pos > null then
//			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " pos > null, pos=" & pos.String, null);
			str1 		:= null;
			str2 		:= null;
			pos 		:= pos + 1;
//			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " V1 pos=" & pos.String & ", len=" & len.String, null);
			if len >= pos then
//				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " V1 len > pos, pos=" & pos.String, null);
				// str1 could be a null string or contain a database role or a numeric launch delay
				str1	:= keyValue.scanUntil(CN_COMMA, pos).trimBlanks();
//				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " str1=" & str1, null);
//				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " V2 pos=" & pos.String & ", len=" & len.String, null);
				if pos > null then
					pos := pos + 1;
					if len >= pos then
//						cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " V2 len > pos, pos=" & pos.String, null);
						// str2 will contain
						str2	:= keyValue[pos:end].String;
//						cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " str2=" & str2, null);
					endif;
				endif;
			endif;
			
			if str1 = null and
			   str2 = null then
//				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " str1 and str2 are null", null);
			
			else
				// str1 could be a database role or a launch delay
//				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " checking str1...", null);
				dbRole := SDS_RoleUndefined;
				if str1.toLower() = "primary" then
					dbRole := SDS_RolePrimary;
				
				elseif str1.toLower() = "secondary" then
					dbRole := SDS_RoleSecondary;
				
				elseif str1 <> null and		// str2 must be a launch delay
					   str1.isInteger() then
					specifiedDelay := str1.Integer;
				
				else
					cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " 3rd parameter invalid, should be database role or numeric launch delay; [Karma] " & key & "=" & keyValue, null);
					continue;
				endif;
				
				if str2 <> null and
				   specifiedDelay <> Delay_Initialized then
					cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " 4th parameter invalid, numeric launch delay already specified in 3rd parameter; [Karma] " & key & "=" & keyValue, null);
					continue;
				endif;
				
				if str2 <> null and
				   str2.isInteger() then
					specifiedDelay := str2.Integer;
				
				elseif str2 <> null then
					cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " 4th parameter invalid, expected numeric launch delay; [Karma] " & key & "=" & keyValue, null);
					continue;
				endif;
			endif;
			
		else
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " no database role or specific delay defined", null);
		endif;
		
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " schema=" & schemaname & ", appName=" & appname & ", dbRole=" & dbRole.String & ", delay=" & specifiedDelay.String, null);
		
		if dbRole = pDatabaseRole or
		   dbRole = SDS_RoleUndefined then
			if specifiedDelay = Delay_Initialized then	
				delay			:= delay + 5;
				actualDelay		:= delay;
				
			else
				delay			:= delay + specifiedDelay;
				actualDelay  	:= delay;
			endif;

			if dbRole = pDatabaseRole then
				str1 := "Application launch specified for " & databaseRole;
				
			elseif dbRole = SDS_RoleUndefined then
				str1 := "Application launch unconditional";
			endif;
			
			create launcher transient;							// launcher transient is deleted by itself within the 'timerEvent'
			launcher.loadSelf(schemaname, appname, dbRole, actualDelay);
			launched	:= launched + 1;
			if pLaunch then
				cc.cnWriteLog(CnLogComment, str1 & ". Scheduling launch of app " & appname & " of schema " & schemaname & 
													" : pre-launch delay will be " & actualDelay.String & " seconds from now...", null);
				launcher.beginTimer(actualDelay * 1000, Timer_OneShot, 1);
			
			else
				cc.cnWriteLog(CnLogDiag, "Testing : Launch ignored. oid=" & launcher.getOidString() & str1 & ". App " & appname & " of schema " & schemaname & 
													" : pre-launch delay would be " & actualDelay.String & " seconds from now.", null);
			endif;
			
		else
			cc.cnWriteLog(CnLogComment, "Bypass launch of app " & appname & " of schema " & schemaname & " as database role " & databaseRole & " mismatch", null);
		endif;
	endforeach;
	
	cnWriteLog(CnLogComment, "User application launch checks complete : " & launched.String &
							 " applications have been scheduled for launching.", null);			
end;
}
sysNotification
{
sysNotification(eventType: Integer; theObject: Object; eventTag: Integer) updating;

vars
	jadeProcess	: Process;
begin
	if eventTag <> Cn_Process_Class then
		return;
	endif;
	
	if eventType <> Object_Create_Event and
	   eventType <> Object_Update_Event and
	   eventType <> Object_Delete_Event then
		return;
	endif;

	jadeProcess		:= theObject.Process;																						// PAR 883
	if eventType = Object_Create_Event or
	   eventType = Object_Update_Event then
		self.zHandleProcessCreateUpdate(jadeProcess, eventType);																// PAR 883
		return;
	endif;
	
	if self.appName = CN_KCNODECONTROL 	then
		self.zHandleNodeControl();																								// PAR 883
		return;
	endif;
	
	self.zHandleProcessDelete(jadeProcess);																						// PAR 883
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;

vars
	file	: File;
begin
	if eventTag = CN_NODE_MONITOR_TIMER then
		if self.appName = CN_KCCMGR then
			self.zTimerNodeMonitor();
		endif;
		
		return;
	endif;
	
	if eventTag = CN_DEVELOPMENT_ACTIVITY then
		create file transient;
		self.zFileJadeDevelopmentActivity(file);
	endif;
epilog
	delete file;
end;
}
userNotification
{
userNotification(eventType: Integer; theObject: Object; eventTag: Integer; userInfo: Any) updating;

vars
	cc					: CnCntrl;
	
	cnJadeNode			: CnJadeNode;
	
	index,
	instanceId,
	maxLocalProcesses,
	suspendTime			: Integer;
	
	str					: String;
begin
	cc					:= self;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : event=" & eventType.String, null);
	if eventType = systemShutDownEvent and theObject = system then
		app.cnHandleSystemShutDownEvent();
		return;
	endif;
	
	if eventTag = Cn_Node_Class and eventType = CN_REGISTER_MAXLOCALPROCESSES then
		instanceId := self.cnGetInstanceId(theObject);			// theObject is of class Node
		cnJadeNode := app.myCnKarmaCntrl.allCnJadeNodes[instanceId];
		if cnJadeNode = null then
			cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " NODE_MONITOR process registered maxLocalProcesses and node instance not found, instance " & instanceId.String &
																", PID=" & theObject.Node.osID.String & 
																", nodeName=" & theObject.Node.name, null);
			return;
		endif;
		
		maxLocalProcesses := userInfo.Integer;
		if cnJadeNode.isDefaultValue then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " NODE_MONITOR node " & cnJadeNode.osID.String & 
																" " & cnJadeNode.nodeName &
																" changing maxLocalProcesses from default of " & cnJadeNode.maxLocalProcesses.String & 
																" to " & maxLocalProcesses.String, null);
			cnJadeNode.setMaxLocalProcesses(maxLocalProcesses);
			cnJadeNode.setIsDefaultValue(false);
		
		else
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " NODE_MONITOR node " & cnJadeNode.osID.String & 
																" " & cnJadeNode.nodeName &
																" maxLocalProcesses already " & cnJadeNode.maxLocalProcesses.String & 
																", ignoring new value of " & maxLocalProcesses.String, null);
		endif;
		
		return;
	endif;
	
	if eventType = CN_QUAL_APPSERVERMONITOR_SUSPEND then
		suspendTime := userInfo.Integer * 1000;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " executing process.sleep for " & suspendTime.userNumberFormat($CnWholeNumbers) & "ms...", null);
		process.sleep(suspendTime);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " process.sleep cycle has completed", null);
		return;
	endif;
	
	if eventType = Cn_ForceCreateOfProcess then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " create JADE process from " & theObject.String, null);
		self.zJadeProcessCreate(theObject.Process, false);
		return;
	endif;
	
	if eventType = Cn_ForceDeleteOfProcess then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " delete JADE process from " & theObject.String, null);
		self.zHandleProcessDelete(theObject.Process);
		return;
	endif;
	
	if eventTag = CN_RPS_APPLICATION_EVENT then																					// PAR 1042
		index := self.myRPSProcesses.indexOf(theObject);																		// PAR 1042
		str := "[" & index.String & "] oid=" & self.getOidStringForObject(theObject);											// PAR 1042
		if eventType = process.RPS_EXTRACT_FAILED_EVENT then																	// PAR 1042
			str := str & " registered RPS_EXTRACT_FAILED_EVENT";																// PAR 1042

		elseif eventType = process.RPS_EXTRACT_FINISHED_EVENT then																// PAR 1042
			str := str & " registered RPS_EXTRACT_FINISHED_EVENT";																// PAR 1042
			
		else																													// PAR 1042
			str := str & " registered unknown type (" & eventType.String & ")";													// PAR 1042
		endif;																													// PAR 1042
		
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " " & str, null);													// PAR 1042
	endif;																														// PAR 1042
end;
}
zCheckNodeMonitorFile
{
zCheckNodeMonitorFile() updating, protected;

vars
	jda		: JadeDatabaseAdmin;

	file	: File;
	
	path	: String;
	
	ts		: TimeStamp;
	
	kc		: CnKarmaCntrl;
begin
	kc	 := app.myCnKarmaCntrl;
	file := self.myNodeMonitoringFile;
	if file = null then
		create jda transient;
		path := jda.getCurrentJournalDirectory();
		path.replaceChar("\", "/");
		path := path[1: path.reversePos("/")-1];
		path := path[1: path.reversePos("/")-1];
		self.nodeMonitoringPath := path;
	
		create file transient;						// 'file' singleton instance referenced by CnCntrl singleton's 'myNodeMonitoringFile'
		self.myNodeMonitoringFile := file;
		file.usePresentationFileSystem := true;
		file.kind := file.Kind_ANSI;				// needs to be ANSI as on a Unicode system, the default format means Excel won't reformat into cells.
		file.mode := file.Mode_Output;
		self.nodeMonitoringDate := null;
	endif;
	
	if self.nodeMonitoringDate <> null then
		if self.nodeMonitoringDate = ts.date then		// keep current file
			return;
		endif;
		
		file.close();							// date's changed, close current file
	endif;
	
	self.nodeMonitoringDate := ts.date;
	file.fileName := self.nodeMonitoringPath & "/NodeMonitor_" & kc.environmentId & "_" & ts.date.userFormat($CnCCYYMMDD_ns) & "_" & ts.time.userFormat($CnHHMMSS_ns) & ".csv";
	file.open();
	
	file.writeLine("Date" & CN_COMMA &
					"Time" & CN_COMMA &
					"PID" & CN_COMMA &
					"MaxLocalProcesses" & CN_COMMA &
					"Actual" & CN_COMMA &
					"NodeName" & CN_COMMA &
					"NodeType" & CN_COMMA &
					"Total" & CN_COMMA &
					"Not Registered" & CN_COMMA &
					"Exceeded" & CN_COMMA & CN_COMMA &
					kc.environmentId.toUpper() & " - Threshold % " & self.nodeMonitoringThresholdPercent.String & "; Check Interval " & self.nodeMonitoringCheckInterval.String & " min.");
epilog
	delete jda;
end;
}
zFileJadeDevelopmentActivity
{
zFileJadeDevelopmentActivity(pFile : File input);

vars
	date	: Date;
	
	ts		: TimeStamp;
begin
   	pFile.fileName 		:= self.logPath & "\cn_jade_development_activity_" & date.year().String & date.month().String.padLeadingZeros(2) & ".csv"; 
    pFile.mode			:= pFile.Mode_Append;
    pFile.shareMode		:= pFile.Share_Read;
    pFile.kind			:= pFile.Kind_ANSI;
    
    if pFile.isAvailable() then			// if already exists, don't set up headings
		pFile.cnSetLastModified(ts);	// change last modified to avoid deletion by housekeeping
		return;
	endif;
	
	pFile.writeLine("End Date" 				& CN_COMMA &
					"End Time" 				& CN_COMMA &
					"Instance" 				& CN_COMMA &
					"PID"					& CN_COMMA &
					"Usercode" 				& CN_COMMA &
					"IP Address" 			& CN_COMMA &
					"SignOn Date" 			& CN_COMMA &
					"SignOn Time" 			& CN_COMMA &
					"SignOn Usercode" 		& CN_COMMA &
					"SignOn Date Server" 	& CN_COMMA &
					"SignOn Time Server" 	& CN_COMMA &
					"KCCMgr Startup"		& CN_COMMA &
					"Elapsed Time"			& CN_COMMA &
					"Thin-client");
end;
}
zHandleNodeControl
{
zHandleNodeControl() protected;

vars
	cc			: CnCntrl;
	
	nodeType	: Integer;
begin
	cc			:= app.myCnCntrl;
	nodeType	:= node.nodeType();																							// PAR 944
	if nodeType = 4 		 	or					// type 4 = fat client JADE.EXE
	   nodeType = 16			or					// type 16 = fat client JADCLIENT.EXE									// PAR 944
	   not app.isMultiUser 		then
		//
		//  Note that app servers are not catered for here : the premise is that
		//  app servers will normally run KCNodeControl continuously once launched.
		//
		if node.processes.size64() < 3 then					// myself and clientBackground
			cc.cnWriteLog(cc.CnLogComment, "No processes remain on this fat client node apart from me : terminating...", null);
			app.cnTerminate();
		endif;
	endif;
end;
}
zHandleProcessCreateUpdate
{
zHandleProcessCreateUpdate(pJadeProcess : Process; pEventType : Integer) protected;

vars
	cc			: CnCntrl;
	
	badObject	: Boolean;
	
	type		: Integer;
begin
	cc			:= app.myCnCntrl;
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, pJadeProcess, badObject);
	type := pJadeProcess.type.Integer;
	if pEventType = Object_Create_Event					and																		// PAR 1042
	   self.appName = CN_KCCMGR							and																		// PAR 1042
	   self.zRpsNodeAdded(type, pJadeProcess, false)	then																	// PAR 1042
		return;																													// PAR 1042
	endif;																														// PAR 1042
	
	if type <> 1 and			// dev environment
	   type <> 2 then			// non-development process
		return;
	endif;		
	
	if self.appName = CN_KCCMGR then
		if pEventType = Object_Create_Event then
			self.zJadeProcessCreate(pJadeProcess, false);			// create CnJadeNode (if reqd) and CnJadeProcess
		
		else
			self.zJadeProcessUpdate(pJadeProcess);
		endif;
	endif;
end;
}
zHandleProcessDelete
{
zHandleProcessDelete(pJadeProcess : Process) protected;

vars
	cnApp		: CnApp;

	cc			: CnCntrl;
	
	kc			: CnKarmaCntrl;
	
	msg,
	newMsg		: CnMessage;
	
	cnproc		: CnProcess;
	
	badObject,
	error		: Boolean;
	
	procid		: Integer;
	
	applName,
	schemaName	: String;
begin
	cc			:= app.myCnCntrl;
	kc			:= app.myCnKarmaCntrl;
	if app.cnDatabaseSubrole = SDS_SubroleRelational and																		// PAR 1042
	   self.appName = CN_KCCMGR 					 and																		// PAR 1042
	   self.myRPSProcesses.includes(pJadeProcess)	 then																		// PAR 1042
		self.myRPSProcesses.remove(pJadeProcess);																				// PAR 1042
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " datapump terminated, oid=" & self.getOidStringForObject(pJadeProcess) & // PAR 1042
								", " & self.myRPSProcesses.size().String & " running", null);									// PAR 1042
		return;																													// PAR 1042
	endif;																														// PAR 1042
	
	self.zJadeProcessDelete(pJadeProcess);				// delete CnJadeProcess (if found) and CnJadeNode (if no more processes)
	procid 		:= self.cnGetInstanceId(pJadeProcess);
	cnproc 		:= kc.allCnProcesses[procid];
	if app.myCnLockCheck  <> null then
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_EntryNotFoundInCollection, app.myCnLockCheck.processesWithNoLockChecks, error);
		beginTransientTransaction;
		app.myCnLockCheck.processesWithNoLockChecks.remove(pJadeProcess);		// proc will be invalid object ref at this time
		commitTransientTransaction;										// but this works because we are using a Set.
	endif;
	
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, cnproc, badObject);
	cnproc.edition;
	if badObject then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " unable to find CnProcess object for " & procid.String & ", SessionCloseAdvice not issued", null);
		return;
	endif;

	applName 	:= cnproc.myCnApp.appName;
	schemaName	:= cnproc.myCnApp.appSchemaName;
	cc.cnWriteLog(cc.CnLogDiag, "App=" & schemaName & CN_COMMA & applName & "/" & procid.String & " ended : now sending session close msg to Karma", null);	// PAR 883
	create msg;
	msg.createNewMsg(msg.Advice, msg.Session_Close, kc.localFQDN, kc.localIpAddress, cc.KCCMgr_Process, cc.JossCommsMgr_Process, newMsg);
	newMsg.setCreatorMethod(method.name);
	newMsg.setProcessId(procid);
	newMsg.setAppName(applName);
	newMsg.setAppSchemaName(schemaName);
	newMsg.setClientFQDN(cnproc.myMachine.clientFQDN);
	newMsg.setClientIpAddress(cnproc.myMachine.ipAddress);
	newMsg.setComputerName(cnproc.computerName);
	newMsg.sendMessage(kc.myParentTcp); 					// tcp will be null
	
epilog
	delete newMsg;
	delete msg;
	delete cnproc;
end;
}
zJadeApplicationCreate
{
zJadeApplicationCreate() protected;
/*
	Scan ini file for Ignore_KarmaControlCheck<n> entries.
	For each entry found, create a transient CnJadeApplication and 
	update so that the KarmaControl registration check is ignored.
*/
vars
	kc					: CnKarmaCntrl;
	
	cc					: CnCntrl;

	cnJadeApplication	: CnJadeApplication;
	
	xAppName,
	iniFile,
	schemaAppName,
	schemaName			: String;
	
	int,
	pos					: Integer;
	
begin
	kc := app.myCnKarmaCntrl;
	cc := app.myCnCntrl;
	
	iniFile := app.getIniFileName();		// this runs from KCCMgr so inifile is dbServer ini file
	foreach int in 1 to Max_Integer do
		schemaAppName := app.getProfileString(iniFile, CN_KARMA, CN_IGNORE_KARMACONTROL_CHECK & int.String, null);
		if schemaAppName = null then		// exit when we don't find anymore
			break;
		endif;
		
		pos := 1;
		schemaName := schemaAppName.scanUntil(CN_COMMA, pos);
		if pos = null then
			cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " ini file setting [Karma] " & CN_IGNORE_KARMACONTROL_CHECK & int.String &
																" has invalid schema,application pair : " & schemaAppName, null);
			continue;
		endif;
		
		pos := pos + 1;
		xAppName := schemaAppName[pos:end];
		
		// check for duplicates
		cnJadeApplication := kc.allCnJadeApplications[schemaName, xAppName];
		if cnJadeApplication <> null then
			cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " ini file setting [Karma] " & CN_IGNORE_KARMACONTROL_CHECK & int.String &
																" has duplicate schema,application pair : " & schemaAppName, null);
			continue;
		endif;
		
		create cnJadeApplication transient;						// always create as none others will exist at the time we'r invoked.
		cnJadeApplication.loadSelf(schemaName, xAppName);
		cnJadeApplication.setIgnoreRegistrationFailure(true);
	endforeach;
end;
}
zJadeProcessCreate
{
zJadeProcessCreate( pJadeProcess 	: Process;
					pKCCMgrStartUp 	: Boolean) protected;

vars
	jadeNode			: Node;
	
	kc					: CnKarmaCntrl;
	
	cnJadeApplication	: CnJadeApplication;
	
	cnJadeNode			: CnJadeNode;
	
	cnJadeProcess		: CnJadeProcess;
	
	nodeInstanceId,
	type				: Integer;
	
	applicationName,
	schemaAppOid,
	schemaName			: String;
	
	
	cc					: CnCntrl;
begin
	kc := app.myCnKarmaCntrl;
	cc := self;
	type := pJadeProcess.type.Integer;
	if type <> 1 and			// dev environment
	   type <> 2 then			// non-development process
	    return;
	endif;
	
	jadeNode 		:= pJadeProcess.node;
	nodeInstanceId 	:= self.cnGetInstanceId(jadeNode);
	cnJadeNode 		:= kc.allCnJadeNodes[nodeInstanceId];
	if cnJadeNode = null then
		create cnJadeNode transient;
		cnJadeNode.loadSelf(nodeInstanceId, jadeNode);
	endif;
	
	schemaName		:= pJadeProcess.schema.name;
	applicationName := pJadeProcess.persistentApp.name;
	cnJadeApplication := kc.allCnJadeApplications[schemaName, applicationName];
	if cnJadeApplication = null then
		create cnJadeApplication transient;
		cnJadeApplication.loadSelf(schemaName, applicationName);
	endif;
	
	cnJadeProcess := cnJadeApplication.allCnJadeProcesses[app.cnGetInstanceId(pJadeProcess)];
	if cnJadeProcess <> null then
		return;
	endif;
	
	// PAR 604 - only start timer for newly created process.
	// PAR 604 - note that KCCMgr could have subscribed to events, iterated through existing process
	// PAR 604 - creating assoc transients and then, after completing initialize, find that create events
	// PAR 604 - are received for the processes already located. This could cause a UE 1400 where the
	// PAR 604 - CnJadeProcess receiver has already registered this timer.
	create cnJadeProcess transient;
	cnJadeProcess.loadSelf(pJadeProcess, cnJadeNode, cnJadeApplication, pKCCMgrStartUp);
	
	// if process has signed on set timer to fire in 60 seconds so we issue alert if JADE process
	// hasn't registered within that time (by register we mean SessionOpenAdvice received
	// when process has instantiaed CnKarmaControl).
	if type = 1 			 or			// dev environment
	   pJadeProcess = process then		// don't start timer if KCCMgr
		return;
	endif;
	
	// we always want to start timer regardless of 'ignoreRegistrationFailure'
	// as we keep count of applications that haven't registered per node.
	schemaAppOid	:= schemaName & "," & applicationName & " (" & pJadeProcess.getObjectStringForObject(pJadeProcess) & ")";
	if cnJadeProcess.signedOn then
		cnJadeProcess.beginTimer(CN_PROCESSREGISTRATION_TIMEINT, Timer_OneShot, CN_PROCESSREGISTRATION_TIMER);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " set start timer CN_PROCESSREGISTRATION_TIMER on " & cnJadeProcess.getObjectStringForObject(cnJadeProcess) & " " & schemaAppOid, null);

	else
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " deferring start timer CN_PROCESSREGISTRATION_TIMER on " & cnJadeProcess.getObjectStringForObject(cnJadeProcess) &
																	" until process " & schemaAppOid & " has signed on.", null);
	endif;
end;
}
zJadeProcessDelete
{
zJadeProcessDelete(pObject : Object) protected;

vars
	kc				: CnKarmaCntrl;
	
	cnJadeNode		: CnJadeNode;
	
	cnJadeProcess	: CnJadeProcess;
	
	instanceId,
	pos,
	x				: Integer;
	
	class,
	classAndOid		: String;
	
	badObject		: Boolean;
	
	cc				: CnCntrl;
begin
	kc := app.myCnKarmaCntrl;
	cc := self;
	
	classAndOid := app.cnGetClassAndOid(pObject);
	pos := 1;
	class := classAndOid.scanUntil("/", pos);
	if class <> Process.name then
		return;
	endif;
	
	instanceId := self.cnGetInstanceId(pObject);
	cnJadeProcess := kc.allCnJadeProcesses[instanceId];
	if cnJadeProcess = null then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " NODE_MONITOR process instance not found " & instanceId.String, null);
		return;
	endif;
	
	// cnJadeProcess will only exist for dev env or user-application
	if cnJadeProcess.type = 1 then
		self.logDevelopmentActivity(cnJadeProcess);
	
	else
		cnJadeProcess.endTimer(CN_PROCESSREGISTRATION_TIMER);
	endif;
	
	cnJadeNode := cnJadeProcess.myCnJadeNode;
	
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " NODE_MONITOR deleted " & cnJadeProcess.String & 
//													   ", instanceId=" & instanceId.String, null);
	delete cnJadeProcess;
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, cnJadeNode, badObject);
	x := cnJadeNode.edition;
	if badObject then
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " NODE_MONITOR badObject : CnJadeNode already deleted, oid=" & self.getObjectStringForObject(cnJadeNode), null);
		return;
	endif;
		
	if cnJadeNode.allCnJadeProcesses.isEmpty() then
		if Cn_Debug_NodeProcessMonitoring then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " NODE_MONITOR deleted " & cnJadeNode.String & 
														", instanceId=" & cnJadeNode.nodeId.String & 
														", PID=" & cnJadeNode.osID.String, null);
		endif;

		delete cnJadeNode;
	endif;
end;
}
zJadeProcessUpdate
{
zJadeProcessUpdate(pJadeProcess : Process) protected;

vars
	cc					: CnCntrl;

	kc					: CnKarmaCntrl;
	
	cnJadeNode			: CnJadeNode;
	
	cnJadeProcess		: CnJadeProcess;

	jadeNode			: Node;

	alreadySignedOn,
	justSignedOn		: Boolean;
	
	instanceId,
	nodeInstanceId,
	type				: Integer;
	
	schemaAppOid			: String;
begin
	kc := app.myCnKarmaCntrl;
	cc := self;
	type := pJadeProcess.type.Integer;
	if type <> 1 and			// dev environment
	   type <> 2 then			// non-development process
	    return;
	endif;
	
	jadeNode 		:= pJadeProcess.node;
	nodeInstanceId 	:= self.cnGetInstanceId(jadeNode);
	cnJadeNode 		:= kc.allCnJadeNodes[nodeInstanceId];
	if cnJadeNode = null then																									// PAR 611
		self.zJadeProcessCreate(pJadeProcess, false);																						// PAR 611
		return;																													// PAR 611
	endif;																														// PAR 611
	
	instanceId		:= self.cnGetInstanceId(pJadeProcess);
	cnJadeProcess   := cnJadeNode.allCnJadeProcesses[instanceId];
	if cnJadeProcess = null then																								// PAR 611
		self.zJadeProcessCreate(pJadeProcess, false);																						// PAR 611
		return;																													// PAR 611
	endif;																														// PAR 611

	alreadySignedOn := cnJadeProcess.signedOn;
	justSignedOn	:= (not alreadySignedOn and pJadeProcess.number <> null);
	cnJadeProcess.loadSelf(pJadeProcess, null, null, false);
	
	// now set timer to fire in 60 seconds so we issue alert if JADE process
	// hasn't registered within that time (by register we mean SessionOpenAdvice received
	// when process has instantiaed CnKarmaControl).
	if type = 1 			 or			// dev environment
	   pJadeProcess = process then		// don't start timer if KCCMgr
		return;
	endif;
	
	// we always want to start timer regardless of 'ignoreRegistrationFailure'
	// as we keep count of applications that haven't registered per node.
	schemaAppOid := cnJadeProcess.getName() & pJadeProcess.getObjectStringForObject(pJadeProcess);
	if alreadySignedOn then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ignore start timer CN_PROCESSREGISTRATION_TIMER on " & cnJadeProcess.getObjectStringForObject(cnJadeProcess) &
																" as process " & schemaAppOid & " already signed on.", null);
	
	elseif justSignedOn then
		cnJadeProcess.beginTimer(CN_PROCESSREGISTRATION_TIMEINT, Timer_OneShot, CN_PROCESSREGISTRATION_TIMER);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " set start timer CN_PROCESSREGISTRATION_TIMER on " & cnJadeProcess.getObjectStringForObject(cnJadeProcess) & " " & schemaAppOid, null);

	else
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " deferring start timer CN_PROCESSREGISTRATION_TIMER on " & cnJadeProcess.getObjectStringForObject(cnJadeProcess) &
																" until process " & schemaAppOid & " has signed on.", null);
	
	endif;
end;
}
zRpsNodeAdded
{
zRpsNodeAdded(pType 			: Integer;
			  pJadeProcess 		: Process;
			  pAlreadyStarted	: Boolean) : Boolean;
/*
	Purpose:
	
	PAR 1042. 
	
	If RPS node and process is datapump then:
	- add to collection
	- log the addition
	- subscribe to notifications available
*/
vars
	cc		: CnCntrl;
	
	dupl	: Boolean;
begin
	cc		:= app.myCnCntrl;
    if pType <> 6 then
		return false;
	endif;
	
	if app.cnDatabaseSubrole <> SDS_SubroleRelational then
		return false;
	endif;
		  
	if pJadeProcess.isUserDataPump() 						or
	   pJadeProcess.persistentApp.name = CN_JADERPSDATAPUMP then
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectAlreadyInCollection, self.myRPSProcesses, dupl);
		self.myRPSProcesses.add(pJadeProcess);
		if dupl then
			return true;
		endif;
		
		if pAlreadyStarted then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " datapump already started '" & pJadeProcess.persistentApp.name & "' oid=" & self.getOidStringForObject(pJadeProcess) &
								"; " & self.myRPSProcesses.size().String & " running", null);

		else
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " datapump just started '" & pJadeProcess.persistentApp.name & "' oid=" & self.getOidStringForObject(pJadeProcess) &
											"; " & self.myRPSProcesses.size().String & " running", null);

		endif;

		self.beginNotification(pJadeProcess, pJadeProcess.RPS_EXTRACT_FAILED_EVENT, Response_Continuous, CN_RPS_APPLICATION_EVENT);
		self.beginNotification(pJadeProcess, pJadeProcess.RPS_EXTRACT_FINISHED_EVENT, Response_Continuous, CN_RPS_APPLICATION_EVENT);
		return true;
	endif;
	
	return false;
end;
}
zSetupLoggingOptions
{
zSetupLoggingOptions(pIniFile : String) updating, protected;

vars
	ff				: FileFolder;

	compName,
	factor,
	xlogfilename,
	xlogpath,
	str				: String;
	
	bResult			: Boolean;

	len,
	maxSize,
	pos				: Integer;
	
	cnApp			: CardSchema;
	
	appl			: Application;
	
	cem				: CnExternalMethods;
	
	appType			: Character;
begin
	appl := process.getProcessApp();
	appType := appl.applicationType;
	if appl.isKindOf(CardSchema) then
		cnApp := appl.CardSchema;
	
	else
		cnApp := app;
	endif;
    
	str 	:= app.getProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGGING, null).toLower();

    if str = null then
		bResult := app.setProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGGING, True);
		if not bResult then
			app.cnRaiseNormalException(Cn_General_Error,
										pIniFile,
										"Problem accessing your ini file" & CrLf &
										"Application " & appl.name & " is unable to set logging defaults into your .ini file." & CrLf &
										"Ini file name used = " & pIniFile & ".",
										false);
		endif;
		
		self.setLogging(true);
	
	else
		self.setLogging(str.Boolean);
	endif;

	xlogpath := app.getProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGPATH, null);
	if xlogpath = null then
		// default to using logs under environment heading, replaces use of c:\temp
		xlogpath	:= app.dbPath;
		xlogpath.replaceChar(CN_BACK_SLASH, CN_SLASH);
		pos		:= xlogpath.reversePos(CN_SLASH);
		xlogpath	:= xlogpath[1 : pos] & "logs";
		app.setProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGPATH, xlogpath);
		self.cnWriteLog(self.CnLogDiag, method.cnGetMethodName() & " logPathError=true, " & CN_LOGPATH & " not found in ini, nameFromCommandLine='" & self.nameFromCommandLine & "'", null);
	
	elseif xlogpath[xlogpath.length()] = CN_SLASH then
		xlogpath := xlogpath[1: xlogpath.length() - 1];
	endif;
    	
	create ff;
	ff.fileName 	:= xlogpath;
	ff.usePresentationFileSystem := false;

	if not ff.isAvailable() then
		create cem transient;
		xlogpath := cem.emGetEnvironmentVariable("TEMP");
		str		:= "Log path in [" & CN_CARDLOG & "] section of App Server .ini file (" & pIniFile & ") is invalid or not specified. " &
				   "Application logs will be directed to " & xlogpath;
		if appType <> appl.ApplicationType_Web_Enabled 				and 
		   appType <> appl.ApplicationType_Non_GUI_Web 				and
		   appType <> appl.ApplicationType_Non_GUI 	  				and															// PAR 540
		   appType <> appl.ApplicationType_SilverLight				and															// PAR 619
		   appType <> appl.ApplicationType_Non_GUI_Rest				and															// PAR 1083
		   appType <> appl.ApplicationType_Rest_Services			and															// PAR 1083
		   not suppressManagementDialogs 							and 
		   not node.isServerNode									then			// not a server app
			cnApp.msgBox(str, "Warning for Application " & cnApp.name, 48);
		endif;
		
		self.setLogPathError(true);
	endif;

	self.setLogPath(xlogpath);
	xlogfilename := app.getProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGFILENAME, null);
	if xlogfilename = null then
		xlogfilename	:= self.Default_LogFileName;
		app.setProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGFILENAME, self.Default_LogFileName);
	endif;
	
	if process.isUsingThinClient then
		compName := cnApp.cnComputerName;
		if compName = "<unavailable>" or
		   cnApp.getProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGNAMESUSEIPADDRESS, "false").toLower() = "true" then
			compName := process.networkAddress;
		endif;
		
		xlogfilename := getBaseFileName(xlogfilename) & "_" & compName.cnRemoveInvalidFileNameChars() & "_.log"; // held on app server :  avoid bottlenecking
	endif;
	
  	self.setLogFileName(xlogfilename);

	str := app.getProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGTOSCREEN, null).toLower();
	if str = null then
		app.setProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGTOSCREEN, false.String);
		self.setLogToScreen(false);
	
	else
		self.setLogToScreen(str.Boolean);
	endif;

	str := app.getProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGDIAGNOSTICS, null).toLower();
	if str = null then
		app.setProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGDIAGNOSTICS, true.String);
		self.setLogDiagnostics(true);
	
	else
		self.setLogDiagnostics(str.Boolean);
	endif;
	
	str := app.getProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGMESSAGING, null).toLower();								// PAR 6782
	if str = null then																											// PAR 6782
		app.setProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGMESSAGING, false.String);										// PAR 6782
		self.setLogMessaging(false);																							// PAR 6782
	
	else																														// PAR 6782
		self.setLogMessaging(str.Boolean);																						// PAR 6782
	endif;																														// PAR 6782
		
	str := app.getProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGCOMMSBUFFERS, null).toLower();
	if str = null then
		app.setProfileStringAppServer(pIniFile, CN_CARDLOG,  CN_LOGCOMMSBUFFERS, false.String);
		self.setLogCommsBuffers(false);
	
	else
		self.setLogCommsBuffers(str.Boolean);
	endif;

	str := app.getProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGCOMMSCONNECTIONS, null).toLower();
	if str = null then
		app.setProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGCOMMSCONNECTIONS, false.String);
		self.setLogCommsConnections(false);
	
	else
		self.setLogCommsConnections(str.Boolean);
	endif;
	
	str := app.getProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGIMMEDIATECOMMIT, null).toLower();
	if str = null then
		app.setProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGIMMEDIATECOMMIT, false.String);
		self.setLogImmediateCommit(false);
	
	else
		self.setLogImmediateCommit(str.Boolean);
	endif;
	
	str := app.getProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGFILEMAXSIZE, null);
	if str = null then
    	app.setProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGFILEMAXSIZE, Default_LogFileMaxSize.String);
		str := Default_LogFileMaxSize.String;
	endif;
	
	len		:= str.length;
	factor	:= str[len].toUpper();
	if factor = "M" then
		maxSize	:= str[1 : len - 1].trimBlanks.Integer * CN_BYTES_PER_MEGABYTE;
		
	elseif factor = "K" then
		maxSize	:= str[1 : len - 1].trimBlanks.Integer * CN_BYTES_PER_KILOBYTE;
		
	else
		maxSize	:= str.Integer;
	endif;
	
	if maxSize < 10000 then
		maxSize	:= 10000;
	endif;
		
	self.setLogFileMaxSize(maxSize);
	
   	str := cnApp.getProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGCOMMSCOMPUTER, null).toLower();
	if str = null then
		app.setProfileStringAppServer(pIniFile, CN_CARDLOG, CN_LOGCOMMSCOMPUTER, "All");
		self.setLogCommsComputer(null);
	
	elseif str = "all" then
		self.setLogCommsComputer(null);
		
	else
		self.setLogCommsComputer(str);
	endif;
	
epilog
	delete ff; 
	delete cem;
end;
}
zTimerNodeMonitor
{
zTimerNodeMonitor() updating, protected;

constants
	ALERT_SHORT_DESCRIPTION		: String	= " : Processes per node threshold exceeded";
vars
	cc				: CnCntrl;
	
	kc				: CnKarmaCntrl;
	
	cnJadeNode		: CnJadeNode;
	
	cnJadeProcess	: CnJadeProcess;

	countNotRegistered,
	countTotal,
	maxLocalProcesses,
	pid,
	thresholdValue	: Integer;

	file			: File;
	
	alertTime,
	timeNow			: TimeStamp;
	
	actualMaxLocalProcesses,
	exceeded,
	nodeName,
	nodeType,
	str,
	str2			: String;
	
	alertType		: Character;
begin
	
	cc := app.myCnCntrl;
	kc := app.myCnKarmaCntrl;
	self.zCheckNodeMonitorFile();
	file := self.myNodeMonitoringFile;
	foreach cnJadeNode in kc.allCnJadeNodes discreteLock do
		countTotal 				:= null;
		countNotRegistered 		:= null;
		foreach cnJadeProcess in cnJadeNode.allCnJadeProcesses discreteLock do
			countTotal 			:= countTotal + 1;
			countNotRegistered 	:= countNotRegistered + cnJadeProcess.notRegistered.Integer;
		endforeach;
		
		pid 					:= cnJadeNode.osID;
		nodeName 				:= cnJadeNode.nodeName;
		nodeType				:= cnJadeNode.getNodeTypeString();
		maxLocalProcesses		:= null;
		thresholdValue			:= null;
		actualMaxLocalProcesses := null;
		exceeded := null;
		if cnJadeNode.nodeType = 2 then
			maxLocalProcesses 		:= cnJadeNode.maxLocalProcesses;
			thresholdValue 			:= maxLocalProcesses * self.nodeMonitoringThresholdPercent div 100;
			
			if not cnJadeNode.isDefaultValue then
				actualMaxLocalProcesses := "Yes";
			endif;
		endif;
		
		if cnJadeNode.nodeType = 2 and						// node monitoring alerting restricted to App Servers only 
		   countTotal > thresholdValue then
			exceeded := "Yes";
			str := countTotal.String & " processes detected for node (PID=" & pid.String & ") on " & nodeName & " (" & nodeType & "), exceeds threshold of " & thresholdValue.String;
			if cnJadeNode.alertTimeStamp = null then
				alertType := "N";		// new alert
				cnJadeNode.setAlertTimeStamp(alertTime);
				str2 := "NODE_MONITOR new alert : ";
				
			else
				alertTime := cnJadeNode.alertTimeStamp;
				alertType := "R";		// repeat alert
				str2 := "NODE_MONITOR repeat alert : ";
			endif;
			
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & str2 & str, null);
			app.cnRaiseJossAlert(Cn_Karma_Alert,
								 kc.environmentId.toUpper() & ALERT_SHORT_DESCRIPTION,
								 str & CrLf & "Open a Priority B incident and assign to the CSR.",
								alertType,
								alertTime,
								cc.appName,
								kc.managedEnvironmentName,																		// JSM PAR 8367
								kc.localFQDN,
								kc.localIpAddress,
								kc.myParentTcp);
								 
			
		elseif cnJadeNode.alertTimeStamp <> null then		// need to clear alert
			alertTime := cnJadeNode.alertTimeStamp;
			alertType := "C";			// Clear
			cnJadeNode.setAlertTimeStamp(null);
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " NODE_MONITOR clear alert for " & pid.String & ", number of processes = " & countTotal.String & ", threshold=" & thresholdValue.String, null);
			app.cnRaiseJossAlert(Cn_Karma_Alert,
								 kc.environmentId.toUpper() & ALERT_SHORT_DESCRIPTION,
								"Environment now within threshold " & thresholdValue.String & ", " & countTotal.String & " processes running for node PID=" & pid.String & " on " & nodeName  & " (" & nodeType & ")",
								alertType,
								alertTime,
								cc.appName,
								kc.managedEnvironmentName,																		// JSM PAR 8367
								kc.localFQDN,
								kc.localIpAddress,
								kc.myParentTcp);
		endif;
		
		file.writeLine(timeNow.date.userFormat($CnCCYYMMDD) 	& CN_COMMA &
					   timeNow.time.userFormat($CnHHMMSS) 		& CN_COMMA &
					   pid.String 								& CN_COMMA &
					   maxLocalProcesses.String					& CN_COMMA &
					   actualMaxLocalProcesses					& CN_COMMA &
					   nodeName 								& CN_COMMA &
					   nodeType									& CN_COMMA &
					   countTotal.String 						& CN_COMMA &
					   countNotRegistered.String 				& CN_COMMA &
					   exceeded);
	endforeach;
end;
}
	)
	CnDeadlockHandler (
	jadeMethodSources
setDeadlockRetryCount
{
setDeadlockRetryCount(count : Integer) updating;

vars

begin
	self.deadlockRetryCount := count;
end;
}
setMethodName
{
setMethodName(name : String) updating;

vars

begin
	self.methodName := name;
end;
}
setMyParameterArray
{
setMyParameterArray(array : CnVariantArray) updating;

vars

begin
	self.myParameterArray := array;
end;
}
setMyReceiver
{
setMyReceiver(obj : Object) updating;

vars

begin
	self.myReceiver := obj;
end;
}
userNotification
{
userNotification(eventType: Integer; theObject: Object; eventTag: Integer; userInfo: Any) updating;

vars
	cc		: CnCntrl;
	pa		: CnVariantArray;
	size	: Integer64;
begin
	cc := app.myCnCntrl;

	/////////////////////////////////////////////  Deadlock Retry  ///////////////////////////////////////////////////
	
	pa		:= myParameterArray;
	
	if eventType = Cn_Deadlock_Retry_Event then
		process.sleep(500);
		
		size	:= pa.size64();
		cc.cnWriteLog(cc.CnLogErrors, "Replaying transaction " & self.myReceiver.getName & "::" & self.methodName & 
					  ", number of parameters=" & size.String, null);
					  
		if size = 0 then
        	callMethodWith0Param(myReceiver, methodName);
        	
        elseif size = 1 then
           	callMethodWith1Param(myReceiver, methodName, pa[1].getValue);

        elseif size = 2 then
     		callMethodWith2Params(myReceiver, methodName, pa[1].getValue,
     													  pa[2].getValue
     													  );
        elseif size = 3 then
     		callMethodWith3Params(myReceiver, methodName, pa[1].getValue,
     													  pa[2].getValue,   	
     													  pa[3].getValue
     													  );
        elseif size = 4 then
     		callMethodWith4Params(myReceiver, methodName, pa[1].getValue,
     													  pa[2].getValue,   	
     													  pa[3].getValue,
     													  pa[4].getValue
     													  );
        elseif size = 5 then
     		callMethodWith5Params(myReceiver, methodName, pa[1].getValue,
     													  pa[2].getValue,   	
     													  pa[3].getValue,
     													  pa[4].getValue,
     													  pa[5].getValue
     													  );
        elseif size = 6 then
     		callMethodWith6Params(myReceiver, methodName, pa[1].getValue,
     													  pa[2].getValue,   	
     													  pa[3].getValue,
     													  pa[4].getValue,
     													  pa[5].getValue,
     													  pa[6].getValue
     													  );
        elseif size = 7 then
     		callMethodWith7Params(myReceiver, methodName, pa[1].getValue,
     													  pa[2].getValue,   	
     													  pa[3].getValue,
     													  pa[4].getValue,
     													  pa[5].getValue,
     													  pa[6].getValue,
     													  pa[7].getValue
     													  );
        elseif size = 8 then
     		callMethodWith8Params(myReceiver, methodName, pa[1].getValue,
     													  pa[2].getValue,   	
     													  pa[3].getValue,
     													  pa[4].getValue,
     													  pa[5].getValue,
     													  pa[6].getValue,
     													  pa[7].getValue,
     													  pa[8].getValue
     													  );
        elseif size = 9 then
     		callMethodWith9Params(myReceiver, methodName, pa[1].getValue,
     													  pa[2].getValue,   	
     													  pa[3].getValue,
     													  pa[4].getValue,
     													  pa[5].getValue,
     													  pa[6].getValue,
     													  pa[7].getValue,
     													  pa[8].getValue,
     													  pa[9].getValue
     													  );
        elseif size = 10 then
     		callMethodWith10Params(myReceiver, methodName, pa[1].getValue,
     													   pa[2].getValue,   	
     													   pa[3].getValue,
     													   pa[4].getValue,
     													   pa[5].getValue,
     													   pa[6].getValue,
     													   pa[7].getValue,
     													   pa[8].getValue,
     													   pa[9].getValue,
     													   pa[10].getValue
     													   );
        elseif size = 11 then
     		callMethodWith11Params(myReceiver, methodName, pa[1].getValue,
     													   pa[2].getValue,   	
     													   pa[3].getValue,
     													   pa[4].getValue,
     													   pa[5].getValue,
     													   pa[6].getValue,
     													   pa[7].getValue,
     													   pa[8].getValue,
     													   pa[9].getValue,
     													   pa[10].getValue,
     													   pa[11].getValue
     													   );
        elseif size = 12 then
     		callMethodWith12Params(myReceiver, methodName, pa[1].getValue,
     													   pa[2].getValue,   	
     													   pa[3].getValue,
     													   pa[4].getValue,
     													   pa[5].getValue,
     													   pa[6].getValue,
     													   pa[7].getValue,
     													   pa[8].getValue,
     													   pa[9].getValue,
     													   pa[10].getValue,
     													   pa[11].getValue,
     													   pa[12].getValue
     													   );
     	endif;
	endif;

epilog
	if eventType = Cn_Deadlock_Retry_Event and not process.isInExceptionState then
		setDeadlockRetryCount(0);
	endif;
end;
}
	externalMethodSources
callMethodWith0Param
{
callMethodWith0Param(
			receiver: Object; 
			methodName: String) is "emCallMethod" in "karma" protected, number = 1007;
}
callMethodWith10Params
{
callMethodWith10Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any; 
			param6: Any; 
			param7: Any; 
			param8: Any; 
			param9: Any; 
			param10: Any) is "emCallMethod" in "karma" protected, number = 1010;
}
callMethodWith11Params
{
callMethodWith11Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any; 
			param6: Any; 
			param7: Any; 
			param8: Any; 
			param9: Any; 
			param10: Any; 
			param11: Any) is "emCallMethod" in "karma" protected, number = 1009;
}
callMethodWith12Params
{
callMethodWith12Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any; 
			param6: Any; 
			param7: Any; 
			param8: Any; 
			param9: Any; 
			param10: Any; 
			param11: Any; 
			param12: Any) is "emCallMethod" in "karma" protected, number = 1008;
}
callMethodWith1Param
{
callMethodWith1Param(
			receiver: Object; 
			methodName: String; 
			param1: Any) is "emCallMethod" in "karma" protected, number = 1004;
}
callMethodWith2Params
{
callMethodWith2Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any) is "emCallMethod" in "karma" protected, number = 1018;
}
callMethodWith3Params
{
callMethodWith3Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any) is "emCallMethod" in "karma" protected, number = 1017;
}
callMethodWith4Params
{
callMethodWith4Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any) is "emCallMethod" in "karma" protected, number = 1016;
}
callMethodWith5Params
{
callMethodWith5Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any) is "emCallMethod" in "karma" protected, number = 1015;
}
callMethodWith6Params
{
callMethodWith6Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any; 
			param6: Any) is "emCallMethod" in "karma" protected, number = 1014;
}
callMethodWith7Params
{
callMethodWith7Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any; 
			param6: Any; 
			param7: Any) is "emCallMethod" in "karma" protected, number = 1013;
}
callMethodWith8Params
{
callMethodWith8Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any; 
			param6: Any; 
			param7: Any; 
			param8: Any) is "emCallMethod" in "karma" protected, number = 1012;
}
callMethodWith9Params
{
callMethodWith9Params(
			receiver: Object; 
			methodName: String; 
			param1: Any; 
			param2: Any; 
			param3: Any; 
			param4: Any; 
			param5: Any; 
			param6: Any; 
			param7: Any; 
			param8: Any; 
			param9: Any) is "emCallMethod" in "karma" protected, number = 1011;
}
	)
	CnInternet (
	jadeMethodSources
cnCloseConnection
{
cnCloseConnection() updating;

vars
	result	: Integer;
begin
	self.cnCloseFile();																											// PAR 803
	if self.connectionHandle <> null then
		result := self.emCloseHandle(self.connectionHandle);
		self.connectionHandle 	:= null;
		self.zLogResult(result, "close connection handle");
	endif;
	
	if self.sessionHandle <> null then																							// PAR 970
		result := self.emCloseHandle(self.sessionHandle);																		// PAR 970
		self.sessionHandle := null;																								// PAR 970
		self.zLogResult(result, "close session handle");																		// PAR 970
	endif;																														// PAR 970
end;
}
cnCloseFile
{
cnCloseFile() updating;

vars
	result	: Integer;
begin
	if self.fileHandle <> null then																								// PAR 803
		result := self.emCloseHandle(self.fileHandle);																			// PAR 803
		self.fileHandle := null;																								// PAR 803
		self.zLogResult(result, "close file handle");
	endif;	
end;
}
cnCloseSession
{
cnCloseSession() updating;

/*
	Created by PAR803
*/
vars
	result : Integer;
begin
	self.cnCloseConnection();
	
	if self.sessionHandle <> null then
		result := self.emCloseHandle(self.sessionHandle);
		self.sessionHandle := null;
		self.zLogResult(result, "close session handle");
	endif;
end;
}
cnConnect
{
cnConnect(): String updating, abstract, number = 1001;
}
cnGetFile
{
cnGetFile(	sourceFile 					: String; 
			destFile					: String;
			usePresentationFileSystem 	: Boolean): String updating, abstract, number = 1002;
}
cnGetFileInfo
{
cnGetFileInfo(
			fileName: String; 
			attributes: String output; 
			filesize: Integer output; 
			lastModified: TimeStamp output): String updating, abstract, number = 1003;
}
cnGetFileSize
{
cnGetFileSize(filename : String; filesize : Integer output) : String updating;

vars
	attributes,
 	result		: String;

 	lastmod		: TimeStamp;
begin
 	result := self.cnGetFileInfo(filename, attributes, filesize, lastmod);
    return result;
end;
}
cnGetInternetError
{
cnGetInternetError(errorCode : Integer) : String;

vars
	errorText	: String;
begin
 	self.emGetInternetError(errorCode, errorText);																				// PAR 803
 	return errorText;
end;
}
cnGetLastModifiedTimeGMT
{
cnGetLastModifiedTimeGMT(
			filename: String io; 
			lastModified: TimeStamp output): String updating, abstract, number = 1006;
}
cnGetWindowsErrorText
{
cnGetWindowsErrorText(errorCode : Integer) : String;

vars
	result	: Integer;
	text	: String;
	cem		: CnExternalMethods;
begin
	create cem transient;
	result := cem.emGetErrorText(errorCode, text, 127);
	
	if result = null then
		return text;
	endif;

	return "Unrecognised windows error #" & errorCode.String;
epilog
	delete cem;
end;
}
cnOpenConnection
{
cnOpenConnection():String updating, protected;

vars
 	result 		: Integer;
 	errorText	: String;
 	cc			: CnCntrl;
 	str			: String;
begin
    cc	:= app.myCnCntrl;
	if self.useProxy then
		result := self.emOpenInternetSessionPreConfig(self.sessionHandle, cc.appName);											// PAR 803
		
	else
		result := self.emOpenInternetSession(self.sessionHandle, cc.appName);													// PAR 803
	endif;
	
	if result <> 0 then
        errorText := self.cnGetInternetError(result);

        cc.cnWriteLog(cc.CnLogErrors, "Error opening internet session : result=" & result.String & " (" & errorText & ").", null);
        str	:= "Error opening internet session : see CardSchema log : " & errorText;
        NormalException.raise_(Cn_Exception_Base + Cn_Windows_Error, str[1 : 60]);
		return CN_NOT_OK;
	endif;
	
	return CN_OK;
end;
}
cnSetModifyTime
{
cnSetModifyTime(filename : String; ts : TimeStamp; pUsePresentationFileSystem : Boolean) : String updating;

vars
	date, time 	: Integer;
	int			: Integer;
	str			: String;
	d			: Date;
	t			: Time;
	result		: Integer;
	
	file		: File;
	
	cem			: CnExternalMethods;
begin
	if ts = null then
		return "Null timestamp submitted to CnInternet::cnSetModifyTime";
	endif;

	d 		:= ts.date;
	date 	:= d.year * 10000 + d.month * 100 + d.day;
	t		:= ts.Time;
	time	:= t.hour * 10000 + t.minute * 100 + t.second;

	if pUsePresentationFileSystem then					// thin client must have karma.dll
		result	:= call cnSetModifyTime(filename, date, time);
	else
		create file transient;
		result := file.emSetModifyTime(filename, date, time);
	endif;
	
	if result <> 0 then
		create cem transient;
		int := cem.emGetErrorText(result, str, 127);
		return "CnInternet::cnSetModifyTime error : error=" & result.String & " (" & str & ")";
	else
		return CN_OK;
	endif; 

epilog
	delete file;
	delete cem;
end;
}
delete
{
delete() updating;

vars
  	frm : Form;
begin
	if self.fileHandle <> null then																								// PAR 803
		self.emCloseHandle(self.fileHandle);																					// PAR 803
	endif;																														// PAR 803
	
	if self.connectionHandle <> null then																						// PAR 803
		self.emCloseHandle(self.connectionHandle);																				// PAR 803
	endif;																														// PAR 803
	
	if self.sessionHandle <> null then																							// PAR 803
		self.emCloseHandle(self.sessionHandle);
	endif;																														// PAR 803
	
    if not app.cnIsServerApp 										and
       not node.isServerNode 										and
       not app.cnApplicationType = app.ApplicationType_Non_GUI 		and
       not app.cnApplicationType = app.ApplicationType_Non_GUI_Web	then
		frm := app.getForm(CnTransferProgress.name);
		if frm <> null then
			frm.unloadForm;
		endif;
	endif;
end;
}
setCurrentFileLastModified
{
setCurrentFileLastModified(ts : TimeStamp) updating;

vars

begin
	self.currentFileLastModified := ts;
end;
}
setMyNotifyObject
{
setMyNotifyObject(obj : Object) updating;

vars

begin
 	myNotifyObject := obj;
end;
}
setServerName
{
setServerName(name : String) updating;

vars

begin
 	self.serverName := name;
end;
}
setServerType
{
setServerType(type : Integer) updating;

vars

begin
 	self.serverType := type;
end;
}
setUseProxy
{
setUseProxy(pUseProxy : Boolean) updating;

vars

begin
	self.useProxy := pUseProxy;
end;
}
setUserId
{
setUserId(user, pw : String) updating;

vars
	cc : CnCntrl;
begin
	if self.connectionHandle <> null then
		cc := app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogErrors, "CnInternet::setUserId ignored : can't change user id for connection while connection is active", null);
	else
		self.userId 	:= user;
		self.password 	:= pw;
	endif;
end;
}
zLogResult
{
zLogResult(pResult : Integer; pQualifier : String) protected;

vars
	cc 	: CnCntrl;
	
	err	: String;
begin
	if pResult = null then
		return;
	endif;
	
	cc := app.myCnCntrl;
	self.emGetInternetError(pResult, err);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & pQualifier & " result : " & err, null);
end;
}
	externalMethodSources
emCloseHandle
{
emCloseHandle(handle: MemoryAddress): Integer is "emInternetCloseHandle" in "karma" protected, number = 1014;
}
emGetInternetError
{
emGetInternetError(
			errorCode: Integer; 
			errorText: String output): Integer is "emGetInternetError" in "karma" protected, number = 1016;
}
emHttpSendRequestEx
{
emHttpSendRequestEx(requestHandle	: MemoryAddress;  
					headers			: String; 
					extraInfo		: Binary): Integer is emHttpSendRequestEx in karma updating, protected;
}
emInternetReadFile
{
emInternetReadFile(
			fileHandle: MemoryAddress; 
			buffer: Binary output; 
			bytesWanted: Integer; 
			bytesRead: Integer output): Integer is "emInternetReadFile" in "karma" protected, number = 1017;
}
emInternetSetNumericOption
{
emInternetSetNumericOption(sessionHandle 		: MemoryAddress;
						   internetOption		: Integer;
						   internetOptionValue	: Integer) : Integer is emInternetSetNumericOption in karma protected;

//  Sets the Internet options for an internet session. See MSDN InternetSetOption documentation for full description.
//  Requires karma.dll 2.7.0.46 or later.
//  Pass self.sessionHandle to this method as the first parameter.
//  See CnInternet class constants INT_OPTION_xxxx for internetOption specifiers.
//  internetOptionValue is specified in milliseconds.
}
emOpenInternetSession
{
emOpenInternetSession(
			handle: MemoryAddress output; 
			appName: String): Integer is "emInternetOpen" in "karma" protected, number = 1018;
}
emOpenInternetSessionPreConfig
{
emOpenInternetSessionPreConfig(
			handle: MemoryAddress output; 
			appName: String): Integer is emInternetOpenPreConfig in karma protected;
}
	)
	CnFtp (
	jadeMethodSources
cnConnect
{
cnConnect() : String updating;

constants
	PASSIVE_FLAG = #08000000;
vars
	passiveFlag,																												// PAR 983
	result,
	iResult		: Integer;
	
	open,
	errorText	: String;
begin
	if self.sessionHandle <> null then																							// PAR 803
	   open := CN_OK;																											// PAR 803
	   
	else																														// PAR 803
		open := self.cnOpenConnection();
	endif;																														// PAR 803
	
	if open = CN_OK then
		if self.userId = null then
			self.userId		:= "anonymous";
			self.password 	:= "password";
		endif;
	
		if self.passive then																									// PAR 983
			passiveFlag	:= PASSIVE_FLAG;																						// PAR 983
		endif;																													// PAR 983
		
		if self.portNumber = null then																							// PAR 983
			self.portNumber := self.Default_FTP_PortNumber;																		// PAR 983
		endif;																													// PAR 983
		
		result := self.emFtpConnectEx2(self.connectionHandle,																	// PAR 983 
										self.sessionHandle,																		// PAR 983
										self.serverName,																		// PAR 983
										self.userId,																			// PAR 983
										self.password,																			// PAR 983
										passiveFlag,																			// PAR 983
										self.portNumber);																		// PAR 983
		if result <> null then
			return method.cnGetMethodName() & " failed : reason=" & self.cnGetInternetError(result); 
		endif;
	endif;
	
	return CN_OK;
end;
}
cnGetFile
{
cnGetFile(sourceFile, destFile : String; pUsePresentationFileSystem : Boolean) : String updating;

vars
	cc			: CnCntrl;

	outfile		: File;

	bin			: Binary;

	bytesRead,
	result		: Integer;
	
	attributes,
	str			: String;

	tsGMT		: TimeStamp;
begin
	cc := app.myCnCntrl;

	self.cnCloseConnection();
	str := self.cnGetFileInfo(sourceFile, attributes, self.currentFileSize, self.currentFileLastModified);
	if str <> CN_OK then
		return str;
	endif;

	str := self.cnConnect();						// cnGetFileInfo closes the connection, so we have to open it again
	if str <> CN_OK then
		return str;
	endif;

	result := self.emFtpOpenFile(self.fileHandle, self.connectionHandle, sourceFile, false, self.modeAscii);
	if result <> 0 then
		return method.cnGetMethodName() & " file open failed for " & sourceFile & " : " & self.cnGetInternetError(result);
	endif;

	self.currentFileName := sourceFile;

	create outfile transient;
	outfile.usePresentationFileSystem	:= pUsePresentationFileSystem;
   	outfile.fileName					:= destFile;
   	if outfile.isAvailable() then
  		outfile.purge();
  	endif;

	outfile.kind		:= outfile.Kind_Binary;
	outfile.mode		:= outfile.Mode_Output;
	outfile.open();
	fileBytesTransferred:= 0;

	if totalBytesToBeTransferred = 0 then						// normally set up by user external to class
   		totalBytesToBeTransferred 	:= currentFileSize;
   		totalBytesTransferred		:= 0;
   	endif;

	while true do
    	result := self.emInternetReadFile(self.fileHandle, bin, FTP_Block_Size, bytesRead);
    	if result <> 0 then
    		return method.cnGetMethodName() & " failed read : " & self.cnGetInternetError(result);

    	elseif bytesRead = 0 then
    		outfile.close;
			self.cnCloseConnection();																							// PAR 803
            if currentFileLastModified <> null then
	            tsGMT := currentFileLastModified.cnConvertToGMT(self.serverGMTBias);		// detour Microsoft's faulty implementation of
	            currentFileLastModified := tsGMT.cnLocalTime.cnZeroMilliseconds;			// FTP in IIS 4.0

	            str := self.cnSetModifyTime(destFile, currentFileLastModified, pUsePresentationFileSystem);
	            if str <> CN_OK then
	            	return method.cnGetMethodName() & " transferred file " & sourceFile & " to " & destFile & " appeared to complete OK but " &
	            	       "modify timestamp failed : " & str;
	            endif;

	    		cc.cnWriteLog(cc.CnLogComment, "FTP file transfer completed from source file " & sourceFile & " to " & destFile &
	    					  ", LastModifiedTime set to " & currentFileLastModified.String & " (local), " & tsGMT.String & " (GMT)", null);
	    	endif;

    		return CN_OK;											// file transfer completed.  

        else
        	outfile.writeBinary(bin);
           	fileBytesTransferred 	:= fileBytesTransferred + bytesRead;
            totalBytesTransferred	:= totalBytesTransferred + bytesRead;
            counter := counter + 1;
            if counter >= 5 and myNotifyObject <> null then
            	myNotifyObject.causeEvent(Cn_Transfer_Progress, true, totalBytesTransferred.String & "/" & 
            							  totalBytesToBeTransferred.String & "/");	
            	counter := 0;
            	if not app.cnIsServerApp 										and
            	   not app.cnApplicationType = app.ApplicationType_Non_GUI		and
           	   	   not app.cnApplicationType = app.ApplicationType_Non_GUI_Web 	then
            		app.doWindowEvents(5);
            	endif;
            endif;
        endif;
   	endwhile;

	return "Unexpected error in " & method.cnGetMethodName();

epilog
	self.cnCloseConnection();
	self.currentFileName := null;
	delete outfile;
end;
}
cnGetFileBasic
{
cnGetFileBasic(sourceFile, destFile : String; pUsePresentationFileSystem : Boolean) : String updating;

vars
	result		: Integer;
	str			: String;
	bin			: Binary;
	outfile		: File;
	bytesRead 	: Integer;
	cc			: CnCntrl;
	attributes 	: String;
	tsGMT		: TimeStamp;
	localBias	: Integer;	
begin
	cc := app.myCnCntrl;

	self.cnCloseConnection();																									//PAR 803

	str := cnConnect();						// cnGetFileInfo closes the connection, so we have to open it again
	if str <> CN_OK then
		return str;
	endif;

	result := self.emFtpOpenFile(self.fileHandle, self.connectionHandle, sourceFile, false, self.modeAscii);
	if result <> null then
		return method.cnGetMethodName() & " file open failed for " & sourceFile & " : " & self.cnGetInternetError(result);
	endif;

	self.currentFileName := sourceFile;

	create outfile transient;
	outfile.usePresentationFileSystem	:= pUsePresentationFileSystem;
   	outfile.fileName					:= destFile;
   	if outfile.isAvailable then
  		outfile.purge;
  	endif;

	outfile.kind		:= outfile.Kind_Binary;
	outfile.mode		:= outfile.Mode_Output;
	outfile.open();
	fileBytesTransferred := null;

	while true do
    	result := self.emInternetReadFile(self.fileHandle, bin, FTP_Block_Size, bytesRead);
    	if result <> 0 then
    		return method.cnGetMethodName() & " failed read : " & self.cnGetInternetError(result);
		endif;

    	if bytesRead = null then
    		outfile.close;
			self.cnCloseConnection();																							// PAR 803
    		return CN_OK;											// file transfer completed.  
		endif;
		
		outfile.writeBinary(bin);
		fileBytesTransferred 	:= fileBytesTransferred + bytesRead;
		totalBytesTransferred	:= totalBytesTransferred + bytesRead;
   	endwhile;

	return "Unexpected error in " & method.cnGetMethodName();
epilog
	self.cnCloseConnection();																									// PAR 803
	self.currentFileName := null;
	delete outfile;
end;
}
cnGetFileInfo
{
cnGetFileInfo(pFileName 	: String; 
			  pAttributes 	: String output; 
			  pFilesize 	: Integer output; 
			  pLastModified : TimeStamp output) : String updating;

vars
	cc			: CnCntrl;

	file		: File;

 	array		: CnStringArray;

	fileinfo	: Binary;

	isDirectory	: Boolean;

	d 			: Date;

	accessDate,
	accessTime,
	creationDate,
	creationTime,
	fileNameLength,
	foundFileLength,
	len,
	pos,
	result,
	updateDate,
	updateTime	: Integer;
	
	fileSize	: Integer64;

	errortext,
	fileNameLC,
 	findFile,
	foundfile,
	simpleName,
	str			: String;

	t			: Time;
	
	ts			: TimeStamp;
begin
	self.cnCloseConnection();
    str := self.cnConnect();													// connect
    if str <> CN_OK then
    	return str;
    endif;
    
    findFile	:= pFileName;
	create file transient;
	file.fileName := findFile;
	simpleName := file.cnGetSimpleFileName();
	simpleName.replaceChar(" ", "?");				// replace any spaces with wild card
	len := simpleName.length();
	findFile := findFile[1:findFile.length()-len] & simpleName;

    result := self.emFtpFindFirstFile(self.fileHandle, self.connectionHandle, findFile, fileinfo, foundfile, isDirectory);		// PAR 532 - was incorrectly using simpleName
    if result <> 0 then
    	return "CnFtp::cnGetFileInfo::emFtpFindFirstFile failed for file " & pFileName & " : " & self.cnGetInternetError(result);
    endif;

	if serverType = Server_Type_Novell then
		array 		:= foundfile.cnGetTokens(" ");
		foundfile	:= array.last;

    elseif foundfile.length > 11 and foundfile[1:11] = "Report for:" then 	// Unisys A Series
    	pos 		:= 1;
    	foundfile.cnGetToken(pos, ")");										// Find end of usercode.

    	if pos = 0 then														// no usercode
    		pos := foundfile.reversePos(" ");								// find blank before file name
    		if pos < 12 then
    			foundfile := foundfile[12 : end];
    		else
    			foundfile := foundfile[pos + 1 : end];
    		endif;
		else
    		foundfile	:= foundfile.cnGetToken(pos, " ");
    	endif;
   	endif; 

   	foundfile		:= foundfile.toLower();	
	foundFileLength	:= foundfile.length();
	fileNameLength	:= pFileName.length();
	fileNameLC		:= pFileName.toLower();
    if foundfile = null 						or
       foundFileLength > fileNameLength			or
      (foundFileLength > null					and
       fileNameLC[fileNameLength - foundFileLength + 1 : foundFileLength] <> foundfile) then
    	return method.cnGetMethodName() & " didn't find file '" & fileNameLC & "' : instead found '" & foundfile & "'";
    endif;
	
    result := self.emGetFileInfo(fileinfo, foundfile, pAttributes, fileSize, creationDate, creationTime,
								accessDate, accessTime, updateDate, updateTime);
	//
	//  For Unisys A Series, the response to a DIR includes filetype information that seems to
	//  confuse wininet, so the lastModified time typically ends up as 1/1/80.  Class client will
	//  need to handle this situation outside of this class, if he wants to.                            
   	//                 
    if result = 1 then
    	return method.cnGetMethodName() & " : fileInfo packet is too small for emGetFileInfo";
		
    elseif result = 2 then
    	return method.cnGetMethodName() & " : fileInfo packet is empty in emGetFileInfo";
    endif;

	if fileSize < 0 or
	   fileSize > Max_Integer then
		return "CnFtp::cnGetFileInfo file " & pFileName & " appears to exceed 2GB, suggest using CnFtp64 class";
	endif;
	
	pFilesize := fileSize.Integer;
	d.setDate (updateDate mod 100 , 					// day                
					(updateDate div 100) mod 100 , 		// month 
					 updateDate div 10000  				// year
                  ) ;
   	t.setTime (updateTime div 10000 , 					// hour
                   (updateTime div 100) mod 100 , 		// minute
                    updateTime mod 100 ,     			// seconds
                    0                    				// millisecs
                  ) ;

    ts.setTime(t);
    ts.setDate(d);
    pLastModified := ts;
    return CN_OK;
epilog
	delete file;
	delete array;
	self.cnCloseConnection();
end;
}
cnGetLastModifiedTimeGMT
{
cnGetLastModifiedTimeGMT(filename : String io; lastModified : TimeStamp output) : String updating;

vars
 	filesize,
 	iResult		: Integer;
	
 	attributes,
 	result		: String;
 	
	modifydate	: TimeStamp;
begin
	///  In Windows NT the ftp getFileInfo call returns a lastModified timestamp in
	///  my local time format (karma.dll receives it in UTC format and converts it to local time.)
	///  In AIX/SP we think that the ftp server will need to be configured as being in UTC timezone
	///  in order to be compatible with this.

	filename := filename.toLower();
    result := self.cnGetFileInfo(filename, attributes, filesize, modifydate);

    if self.serverGMTBias = 0 then
    	iResult := modifydate.cnGetGMTBias(serverGMTBias);
    endif;

    lastModified := modifydate.cnConvertToGMT(serverGMTBias);
    return result;
end;
}
cnPutFile
{
cnPutFile(sourceFile, destFile : String; pUsePresentationFileSystem : Boolean; closeConnectionWhenFinished : Boolean) : String updating;

	// returns "OK" if good result
	// closeWhenFinished if true will close the connection after the putFile. 

vars
	cc			: CnCntrl;

	kc			: CnKarmaCntrl;		

	infile		: File;

	bin			: Binary;
	
	intOverflow	: Boolean;

	bytesWritten,
	result		: Integer;
	
	str			: String;
begin
	cc := app.myCnCntrl;
	kc := app.myCnKarmaCntrl;

	create infile transient;
	infile.fileName 					:= sourceFile;
	infile.kind							:= infile.Kind_Binary;
	infile.mode							:= infile.Mode_Input;
	infile.usePresentationFileSystem	:= pUsePresentationFileSystem;

	if not infile.isAvailable() then
		return "Source file " & sourceFile & " not found.";
	endif;

	on SystemException do app.cnGenericExceptionHandler(exception, Cn_ResultExpressionIntOverflow, infile, intOverflow);
    currentFileSize			 	:= infile.fileLength();
	if intOverflow then
		return "CnFtp::cnPutFile attempted to reference file over 2GB, suggest using class CnFtp64";
	endif;
	
	fileBytesTransferred		:= 0;

	result := self.emFtpOpenFile(self.fileHandle, self.connectionHandle, destFile, true, self.modeAscii);	// if modeAscii is false, then mode is binary
	if result <> 0 then
		return "CnFtp::cnPutFile file open failed for " & destFile & " : " & self.cnGetInternetError(result);
	endif; 

	self.currentFileName 		:= sourceFile;
	if totalBytesToBeTransferred = 0 then						// normally set up by user external to class
   		totalBytesToBeTransferred 	:= currentFileSize;
   		totalBytesTransferred	:= 0;
   	endif;
	
	on FileException do kc.fileExceptionHandler(exception); 
	kc.setHadFileException(false);
	kc.setFileRetryNo(0);
	infile.open;
	if kc.hadFileException then
		return "CnFTP::cnPutFile unable to open source file " & infile.fileName;
	endif;

	while not infile.endOfFile do
		kc.setHadFileException(false);
		kc.setFileRetryNo(0);
		bin := infile.readBinary(FTP_Block_Size);
		if kc.hadFileException then
			return "CnFTP::cnPutFile had problem reading source file " & sourceFile & " : error=" &
					kc.exceptionErrorCode.String & " : " & kc.exceptionText;
		endif;

    	result := self.emInternetWriteFile(self.fileHandle, bin, FTP_Block_Size, bytesWritten);
    	if result <> 0 then
    		return "CnFtp::cnPutFile failed write : " & self.cnGetInternetError(result);

    	elseif bytesWritten < bin.length then
    		infile.close;
            self.cnCloseConnection();
            return "CnFtp::cnPutFile failed : attempted to write " & bin.length.String & " bytes, but only " &
            	   bytesWritten.String & " were written.";

        else
           	fileBytesTransferred 	:= fileBytesTransferred + bytesWritten;
            totalBytesTransferred	:= totalBytesTransferred + bytesWritten;
            counter := counter + 1;
             if counter >= 5 and myNotifyObject <> null then
            	myNotifyObject.causeEvent(Cn_Transfer_Progress, true, totalBytesTransferred.String & "/" & 
            							  totalBytesToBeTransferred.String & "/");	
            	counter := 0;
            	if not app.cnIsServerApp 										and
            	   not app.cnApplicationType = app.ApplicationType_Non_GUI		and
           	   	   not app.cnApplicationType = app.ApplicationType_Non_GUI_Web 	then
            		app.doWindowEvents(5);
            	endif;
            endif;
        endif;
   	endwhile;
   	
    if fileBytesTransferred <> infile.fileLength() then
    	str := "FTP file transfer error : file length=" & infile.fileLength().String & " but bytes written was only=" & 
    			fileBytesTransferred.String & " : file=" & infile.fileName;
    	cc.cnWriteLog(cc.CnLogErrors, str, null);
    	return str;
    endif; 

	cc.cnWriteLog(cc.CnLogComment, "FTP file transfer completed from source file " & sourceFile & " to " & destFile, null);
    return CN_OK;											// file transfer completed.  

epilog
	if closeConnectionWhenFinished then
	   	process.sleep(1000);						// allow IIS time to deal with the file closure 	
		self.cnCloseConnection();
		
	else
		self.cnCloseFile();			
	endif;
	
	self.currentFileName := null;
	delete infile;
end;
}
cnRenameFile
{
cnRenameFile(oldName : String; newName : String) : String;

vars
	//  This is an FTP rename, typically used after using ::cnPutFile.
	//  Returns OK or an error string.
	
	result	: Integer;
	errText	: String;
	str		: String;
begin
	if self.sessionHandle = null then
		return "Can't rename file - no current FTP session";
	endif;
	
	result := self.emFtpRenameFile(self.connectionHandle, oldName, newName);
	if result <> 0 then
		str := "CnFtp::cnRenameFile failed for file " & oldName & " : ";
		if result > 12000 then
			return str & self.cnGetInternetError(result);
		else
			return str & self.cnGetWindowsErrorText(result);		
		endif;
	endif;
		
	return CN_OK;					
end;
}
setModeAscii
{
setModeAscii(set : Boolean) updating;

vars

begin
 	self.modeAscii := set;
end;
}
setServerGMTBias
{
setServerGMTBias(bias : Integer) updating;

vars

begin
  	self.serverGMTBias := bias;
end;
}
	externalMethodSources
emFtpCommand
{
emFtpCommand(connectionHandle : MemoryAddress; commandString : String) : Integer is emFtpCommand in karma;

/*
	The emFtpCommand requires use of 'Raw FTP Commands'
	
	ie to make a directory use 'MKD <remote-directory>'.
	
	MKDIR will cause an error 12003 result INTERNET_EXTENDED ERROR as the command
	is not a 'Raw FTP command'
*/
}
emFtpConnect
{
emFtpConnect(
			connHandle: MemoryAddress output; 
			sessHandle: MemoryAddress; 
			serverName: String; 
			user: String; 
			password: String): Integer is "emFtpConnect" in "karma" number = 1008;
}
emFtpConnectEx
{
emFtpConnectEx(
			connHandle: MemoryAddress output; 
			sessHandle: MemoryAddress; 
			serverName: String; 
			user: String; 
			password: String; 
			flags: Integer): Integer is "emFtpConnectEx" in "karma" number = 1019;
}
emFtpConnectEx2
{
emFtpConnectEx2(ftpHandle     : MemoryAddress output ;
                sessionHandle : MemoryAddress ;
                ftpServer     : String ;
                user          : String ; 
                password      : String  ;
                flags         : Integer ;
                portnbr       : Integer) : Integer is emFtpConnectEx2 in karma;
}
emFtpCreateDirectory
{
emFtpCreateDirectory(connectionHandle: MemoryAddress; 
					directory: String): Integer is "emFtpCreateDirectory" in "karma" number = 1020;
}
emFtpDeleteFile
{
emFtpDeleteFile(ftpConnectionHandle	: MemoryAddress; 
				fileName			: String): Integer is "emFtpDeleteFile" in "karma" number = 1018;
}
emFtpFindFirstFile
{
emFtpFindFirstFile(
			fileHandle: MemoryAddress output; 
			connectionHandle: MemoryAddress; 
			mask: String; 
			fileInfo: Binary output; 
			fileName: String output; 
			isDirectory: Boolean output): Integer is "emFtpFindFirstFile" in "karma" number = 1009;
}
emFtpFindNextFile
{
emFtpFindNextFile(
			fileHandle: MemoryAddress io; 
			fileInfo: Binary output; 
			fileName: String output; 
			isDirectory: Boolean output): Integer is "emFtpFindNextFile" in "karma" number = 1017;
}
emFtpGetCurrentDirectory
{
emFtpGetCurrentDirectory(
			connectionHandle: MemoryAddress; 
			directory: String output): Integer is "emFtpGetCurrentDirectory" in "karma" number = 1023;
}
emFtpGetFile
{
emFtpGetFile(
			connHandle: MemoryAddress; 
			sourceFile: String; 
			destFile: String): Integer is "emFtpGetFile" in "karma" number = 1010;
}
emFtpGetFileExt
{
emFtpGetFileExt(
			handle: MemoryAddress; 
			sourceFileName: String; 
			destFileName: String; 
			ftpFlags: Integer; 
			fileFlags: Integer): Integer is "emFtpGetFileExt" in "karma" number = 1011;
}
emFtpOpenFile
{
emFtpOpenFile(
			fileHandle: MemoryAddress output; 
			connectionHandle: MemoryAddress; 
			fileName: String; 
			writing: Boolean; 
			ascii: Boolean): Integer is "emFtpOpenFile" in "karma" number = 1012;
}
emFtpRemoveDirectory
{
emFtpRemoveDirectory(
			connectionHandle: MemoryAddress; 
			directory: String): Integer is "emFtpRemoveDirectory" in "karma" number = 1021;
}
emFtpRenameFile
{
emFtpRenameFile(
			connectionHandle: MemoryAddress; 
			fileName: String; 
			newFileName: String): Integer is "emFtpRenameFile" in "karma" protected, number = 1015;
}
emFtpSetCurrentDirectory
{
emFtpSetCurrentDirectory(
			connectionHandle: MemoryAddress; 
			directory: String): Integer is "emFtpSetCurrentDirectory" in "karma" number = 1022;
}
emGetFileInfo
{
emGetFileInfo(
			fileInfo: Binary; 
			fileName: String output; 
			attributes: String output; 
			fileSize: Integer output; 
			creationDate: Integer output; 
			creationTime: Integer output; 
			accessDate: Integer output; 
			accessTime: Integer output; 
			updateDate: Integer output; 
			updateTime: Integer output): Integer is "emGetFileInfo" in "karma" protected, number = 1013;
}
emInternetWriteFile
{
emInternetWriteFile(
			fileHandle: MemoryAddress; 
			buffer: Binary; 
			bytesToWrite: Integer; 
			bytesWritten: Integer output): Integer is "emInternetWriteFile" in "karma" protected, number = 1014;
}
	)
	CnHttp (
	jadeMethodSources
cnConnect
{
cnConnect() : String updating;

vars
	open	: String;

 	result	: Integer;
begin
	open := self.cnOpenConnection();
	if open <> CN_OK then
		return "Failed to connect";
	endif;
	
	if self.userId = null then					// HTTP defaults
		self.userId := " ";
		self.password := " ";
	endif;

	result := self.emHttpConnect(self.connectionHandle, self.sessionHandle, self.serverName, self.userId, self.password, self.secure);
	if result <> 0 then
		return "CnHttp::cnConnect failed : reason=" & self.cnGetInternetError(result);
		
	else
		return CN_OK;
	endif;
end;
}
cnGetFile
{
cnGetFile(sourceFile, destFile : String; pUsePresentationFileSystem : Boolean) : String updating;

vars
	result	: Integer;
	str		: String;
	bin		: Binary;
	outfile	: File;
	bytesRead : Integer;
	cc		: CnCntrl;
	attributes : String;					// not applicable for HTTP
begin
	cc := app.myCnCntrl;

	if self.connectionHandle = null then
		return "CnHttp::cnGetFile : no current connection, can't get file " & sourceFile;
		
	else
		str := self.cnGetFileInfo(sourceFile, attributes, currentFileSize, currentFileLastModified);
		if str <> CN_OK then
			return str;
		endif;

    	result := self.emHttpOpenRequest(self.requestHandle, self.connectionHandle, "GET", sourceFile, self.secure);		// prepare request
    	if result <> 0 then
    		return "CnHttp::cnGetFile failed : httpOpenRequest error : " & self.cnGetInternetError(result);
    	endif;

    	result := self.emHttpSendRequest(self.requestHandle, "");												// send request
    	if result <> 0 then
    		return "CnHttp::cnGetFile failed : httpSendRequest error : " & self.cnGetInternetError(result);
    	endif;

    	result := self.emHttpQueryInfo(self.requestHandle, Status_Code, str);
    	if result <> 0 then
    		return "CnHttp::cnGetFile failed : httpQueryInfo #1 error : " & self.cnGetInternetError(result);

    	elseif str <> "200" then																		// 200=OK
    		return "CnHttp::cnGetFile : file " & sourceFile & " not found, status=" & self.cnGetHttpQueryStatus(str);
    	endif;

		self.currentFileName := sourceFile;

    	create outfile transient;
    	outfile.usePresentationFileSystem	:= pUsePresentationFileSystem;
    	outfile.fileName					:= destFile;
    	
    	if outfile.isAvailable() then
   			outfile.purge();
   		endif;

   		outfile.kind		:= outfile.Kind_Binary;
   		outfile.mode		:= outfile.Mode_Append;
   		fileBytesTransferred:= 0;

   		if totalBytesToBeTransferred = 0 then						// normally set up by user external to class
   			totalBytesToBeTransferred 	:= currentFileSize;
   			totalBytesTransferred		:= 0;
   		endif;

   		while true do
        	result := self.emInternetReadFile(self.requestHandle, bin, HTTP_Block_Size, bytesRead);
        	if result <> 0 then
        		return "CnHttp::cnGetFile failed read : " & self.cnGetInternetError(result);

        	elseif bytesRead = 0 then
        		outfile.close;
				outfile.kind	:= outfile.Kind_Unknown_Text;	// detour for PAR 19010
				
        		if outfile.fileLength() <> self.currentFileSize then
        			return "CnHttp::cnGetFile got bad copy of file " & sourceFile & " : source size=" & self.currentFileSize.String &
        			       ", copied file size=" & outfile.fileLength().String;
        		endif;

        		cnSetModifyTime(destFile, currentFileLastModified.cnLocalTime.cnZeroMilliseconds, pUsePresentationFileSystem);
        		cc.cnWriteLog(cc.CnLogComment, "HTTP file transfer completed for source file " & sourceFile & " to " & destFile, null);
        		return CN_OK;											// file transfer completed															

            else
            	outfile.writeBinary(bin);
               	fileBytesTransferred 	:= fileBytesTransferred + bytesRead;
               	totalBytesTransferred	:= totalBytesTransferred + bytesRead;
               	counter := counter + 1;
                if counter >= 5 and myNotifyObject <> null then
            		myNotifyObject.causeEvent(Cn_Transfer_Progress, true, totalBytesTransferred.String & "/" & 
            							  totalBytesToBeTransferred.String & "/");	
            		counter := 0;
            	if not app.cnIsServerApp 										and
            	   not app.cnApplicationType = app.ApplicationType_Non_GUI		and
           	   	   not app.cnApplicationType = app.ApplicationType_Non_GUI_Web 	then
            			app.doWindowEvents(5);
            		endif;
            	endif;
            endif;
       	endwhile;
    endif;

	return "Unexpected error in CnHttp::cnGetFile";

epilog
	delete outfile;
	self.emCloseHandle(self.requestHandle);
	self.requestHandle := null;
end;
}
cnGetFileInfo
{
cnGetFileInfo(filename  : String; 
			  attributes : String output; 
			  filesize 	: Integer output; 
			  lastModified : TimeStamp output) : String updating;
vars
	result 		: Integer;
	fileSize64	: Integer64;																									// PAR 928
	buffer		: String;
begin
 	if self.connectionHandle = null then
 		return "CnHttp::cnGetFileInfo failed : HTTP connection to host " & self.serverName & " is not established";
	endif;
	
	result := self.emHttpOpenRequest(self.requestHandle, self.connectionHandle, "HEAD", filename, self.secure);		// prepare request
	if result <> 0 then
		return "CnHttp::cnGetFileInfo failed : httpOpenRequest error : " & self.cnGetInternetError(result);
	endif;

	result := self.emHttpSendRequest(self.requestHandle, "");												// send request
	if result <> 0 then
		return "CnHttp::cnGetFileInfo failed : httpSendRequest error : " & self.cnGetInternetError(result);
	endif;

	result := self.emHttpQueryInfo(self.requestHandle, Status_Code, buffer);
	if result <> 0 then
		return "CnHttp::cnGetFileInfo failed : httpQueryInfo #1 error : " & self.cnGetInternetError(result);

	elseif buffer <> "200" then																		// 200=OK
		return "CnHttp::cnGetFileInfo : file " & filename & " not found : status=" & self.cnGetHttpQueryStatus(buffer);
	endif;

	result := self.emHttpQueryInfo(self.requestHandle, File_Length, buffer);
	if result <> 0 then
		return "CnHttp::cnGetFileInfo failed : httpQueryInfo # 2 error : " & self.cnGetInternetError(result);
	endif;
	
	fileSize64 := buffer.Integer64;																								// PAR 928
	if fileSize64 > Max_Integer then																							// PAR 928
		return "CnHttp::cnGetFileInfo file " & filename & " appears to exceed 2GB, suggest using CnHttp64 class";				// PAR 928
	endif;																														// PAR 928
	
	filesize := fileSize64.Integer;

	result := self.emHttpQueryInfo(self.requestHandle, Last_Modified_Date, buffer);
	if result <> 0 then
		return "CnHttp::cnGetFileInfo failed : httpQueryInfo # 3 error : " & self.cnGetInternetError(result);
	endif;

	lastModified.setDate(buffer[6:11].Date);		// Assumes RFC1123 date format : Mon, 06 Apr 1998 05:05:10
	lastModified.setTime(buffer[18:8].Time);		// Might need to be enhanced if we encounter old Internet servers, but
													// this works OK with IIS 2.0.
	return CN_OK;
epilog
	self.emCloseHandle(self.requestHandle);
	self.requestHandle := null;	
end;
}
cnGetHttpQueryStatus
{
cnGetHttpQueryStatus(status : String) : String protected;

vars

begin
 	if 	   status = "200" then
 		return CN_OK;
 	elseif status = "201" then 
 		return "Created";
 	elseif status = "202" then
 		return "Accepted";
 	elseif status = "204" then
 		return "No Content";
 	elseif status = "301" then
 		return "Moved Permanantly";
 	elseif status = "302" then
 		return "Moved Temporarily";
 	elseif status = "304" then
 		return "Not Modified";
 	elseif status = "400" then
 		return "Bad Request";
 	elseif status = "401" then
 		return "Unauthorised";
 	elseif status = "403" then
 		return "Forbidden";
 	elseif status = "404" then
 		return "Not Found";
 	elseif status = "500" then
 		return "Internal Server Error";
 	elseif status = "501" then
 		return "Not Implemented";
 	elseif status = "502" then
 		return "Bad Gateway";
 	elseif status = "503" then
 		return "Service Unavailable";
 	else
 		return status & " : unknown error status code";
 	endif;
end;
}
cnGetLastModifiedTimeGMT
{
cnGetLastModifiedTimeGMT(filename : String io; lastModified : TimeStamp output) : String updating;

vars
 	result 		: String;
 	attributes	: String;
 	filesize	: Integer;
begin
 	return self.cnGetFileInfo(filename, attributes, filesize, lastModified);
end;
}
setSecure
{
setSecure(set : Boolean) updating;

vars

begin
	self.secure := set;
end;
}
	externalMethodSources
emHttpConnect
{
emHttpConnect(
			connHandle: MemoryAddress output; 
			sessHandle: MemoryAddress; 
			serverName: String; 
			user: String; 
			password: String; 
			secure: Boolean): Integer is "emHttpConnect" in "karma" number = 1007;
}
emHttpOpenRequest
{
emHttpOpenRequest(
			requestHandle: MemoryAddress output; 
			connectionHandle: MemoryAddress; 
			command: String; 
			fileName: String; 
			secure: Boolean): Integer is "emHttpOpenRequest" in "karma" protected, number = 1008;
}
emHttpQueryInfo
{
emHttpQueryInfo(
			requestHandle: MemoryAddress; 
			attribute: Integer; 
			buffer: String output): Integer is "emHttpQueryInfo" in "karma" protected, number = 1009;
}
emHttpSendRequest
{
emHttpSendRequest(
			requestHandle: MemoryAddress; 
			headers: String): Integer is "emHttpSendRequest" in "karma" protected, number = 1010;
}
	)
	CnInternet64 (
	jadeMethodSources
cnCloseConnection
{
cnCloseConnection() updating;

vars
	result	: Integer;
begin
	self.cnCloseFile();																											// PAR 803
	if self.connectionHandle <> null then
		result := self.emCloseHandle(self.connectionHandle);
		self.connectionHandle 	:= null;
		self.zLogResult(result, "close connection handle");
	endif;
	
	if self.sessionHandle <> null then																							// PAR 970
		result := self.emCloseHandle(self.sessionHandle);																		// PAR 970
		self.sessionHandle := null;																								// PAR 970
		self.zLogResult(result, "close session handle");																		// PAR 970
	endif;																														// PAR 970
end;
}
cnCloseFile
{
cnCloseFile() updating;

vars
	result	: Integer;
begin
	if self.fileHandle <> null then																								// PAR 803
		result := self.emCloseHandle(self.fileHandle);																			// PAR 803
		self.fileHandle := null;																								// PAR 803
		self.zLogResult(result, "close file handle");
	endif;	
end;
}
cnCloseSession
{
cnCloseSession() updating;

/*
	Created by PAR803
*/
vars
	result : Integer;
begin
	self.cnCloseConnection();
	
	if self.sessionHandle <> null then
		result := self.emCloseHandle(self.sessionHandle);
		self.sessionHandle := null;
		self.zLogResult(result, "close session handle");
	endif;
end;
}
cnConnect
{
cnConnect(): String updating, abstract, number = 1001;
}
cnGetFile
{
cnGetFile(	sourceFile 					: String; 
			destFile					: String;
			usePresentationFileSystem 	: Boolean): String updating, abstract, number = 1002;
}
cnGetFileInfo
{
cnGetFileInfo(
			fileName: String; 
			attributes: String output; 
			filesize: Integer64 output; 
			lastModified: TimeStamp output): String updating, abstract, number = 1003;
}
cnGetFileSize
{
cnGetFileSize(	filename : String; 
				filesize : Integer64 output) : String updating;

vars
	attributes,
 	result		: String;

 	lastmod		: TimeStamp;
begin
 	result := self.cnGetFileInfo(filename, attributes, filesize, lastmod);
    return result;
end;
}
cnGetInternetError
{
cnGetInternetError(errorCode : Integer) : String;

vars
	errorText	: String;
begin
 	self.emGetInternetError(errorCode, errorText);																				// PAR 803
 	return errorText;
end;
}
cnGetLastModifiedTimeGMT
{
cnGetLastModifiedTimeGMT(filename		: String io; 
						 lastModified	: TimeStamp output): String updating, abstract, number = 1006;
}
cnGetWindowsErrorText
{
cnGetWindowsErrorText(errorCode : Integer) : String;

vars
	result	: Integer;
	text	: String;
	cem		: CnExternalMethods;
begin
	create cem transient;
	result := cem.emGetErrorText(errorCode, text, 127);
	
	if result = null then
		return text;
	endif;

	return "Unrecognised windows error #" & errorCode.String;
epilog
	delete cem;
end;
}
cnOpenConnection
{
cnOpenConnection():String updating, protected;

vars
 	result 		: Integer;
 	errorText	: String;
 	cc			: CnCntrl;
 	str			: String;
begin
    cc	:= app.myCnCntrl;
	if self.useProxy then
		result := self.emOpenInternetSessionPreConfig(self.sessionHandle, cc.appName);											// PAR 803
		
	else
		result := self.emOpenInternetSession(self.sessionHandle, cc.appName);													// PAR 803
	endif;
	
	if result <> 0 then
        errorText := self.cnGetInternetError(result);

        cc.cnWriteLog(cc.CnLogErrors, "Error opening internet session : result=" & result.String & " (" & errorText & ").", null);
        str	:= "Error opening internet session : see CardSchema log : " & errorText;
        NormalException.raise_(Cn_Exception_Base + Cn_Windows_Error, str[1 : 60]);
		return CN_NOT_OK;
	endif;
	
	return CN_OK;
end;
}
cnSetModifyTime
{
cnSetModifyTime(filename : String; ts : TimeStamp; pUsePresentationFileSystem : Boolean) : String updating;

vars
	date, time 	: Integer;
	int			: Integer;
	str			: String;
	d			: Date;
	t			: Time;
	result		: Integer;
	
	file		: File;
	
	cem			: CnExternalMethods;
begin
	if ts = null then
		return "Null timestamp submitted to CnInternet::cnSetModifyTime";
	endif;

	d 		:= ts.date;
	date 	:= d.year * 10000 + d.month * 100 + d.day;
	t		:= ts.Time;
	time	:= t.hour * 10000 + t.minute * 100 + t.second;

	if pUsePresentationFileSystem then					// thin client must have karma.dll
		result	:= call cnSetModifyTime(filename, date, time);
	else
		create file transient;
		result := file.emSetModifyTime(filename, date, time);
	endif;
	
	if result <> 0 then
		create cem transient;
		int := cem.emGetErrorText(result, str, 127);
		return "CnInternet::cnSetModifyTime error : error=" & result.String & " (" & str & ")";
	else
		return CN_OK;
	endif; 

epilog
	delete file;
	delete cem;
end;
}
delete
{
delete() updating;

vars
  	frm : Form;
begin
	if self.fileHandle <> null then																								// PAR 803
		self.emCloseHandle(self.fileHandle);																					// PAR 803
	endif;																														// PAR 803
	
	if self.connectionHandle <> null then																						// PAR 803
		self.emCloseHandle(self.connectionHandle);																				// PAR 803
	endif;																														// PAR 803
	
	if self.sessionHandle <> null then																							// PAR 803
		self.emCloseHandle(self.sessionHandle);
	endif;																														// PAR 803
	
    if not app.cnIsServerApp 										and
       not node.isServerNode 										and
       not app.cnApplicationType = app.ApplicationType_Non_GUI 		and
       not app.cnApplicationType = app.ApplicationType_Non_GUI_Web	then
		frm := app.getForm(CnTransferProgress.name);
		if frm <> null then
			frm.unloadForm;
		endif;
	endif;
end;
}
setCurrentFileLastModified
{
setCurrentFileLastModified(ts : TimeStamp) updating;

vars

begin
	self.currentFileLastModified := ts;
end;
}
setMyNotifyObject
{
setMyNotifyObject(obj : Object) updating;

vars

begin
 	self.myNotifyObject := obj;
end;
}
setServerName
{
setServerName(name : String) updating;

vars

begin
 	self.serverName := name;
end;
}
setServerType
{
setServerType(type : Integer) updating;

vars

begin
 	self.serverType := type;
end;
}
setUseProxy
{
setUseProxy(pUseProxy : Boolean) updating;

vars

begin
	self.useProxy := pUseProxy;
end;
}
setUserId
{
setUserId(user, pw : String) updating;

vars
	cc : CnCntrl;
begin
	if self.connectionHandle <> null then
		cc := app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogErrors, "CnInternet::setUserId ignored : can't change user id for connection while connection is active", null);
	else
		self.userId 	:= user;
		self.password 	:= pw;
	endif;
end;
}
zLogResult
{
zLogResult(pResult : Integer; pQualifier : String) protected;

vars
	cc 	: CnCntrl;
	
	err	: String;
begin
	if pResult = null then
		return;
	endif;
	
	cc := app.myCnCntrl;
	self.emGetInternetError(pResult, err);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & pQualifier & " result : " & err, null);
end;
}
	externalMethodSources
emCloseHandle
{
emCloseHandle(handle: MemoryAddress): Integer is "emInternetCloseHandle" in "karma" protected, number = 1014;
}
emGetInternetError
{
emGetInternetError(	errorCode: Integer; 
					errorText: String output): Integer is "emGetInternetError" in "karma" protected, number = 1016;
}
emHttpSendRequestEx
{
emHttpSendRequestEx(requestHandle	: MemoryAddress;  
					headers			: String; 
					extraInfo		: Binary): Integer is emHttpSendRequestEx in karma updating, protected;
}
emInternetReadFile
{
emInternetReadFile(	fileHandle	: MemoryAddress; 
					buffer		: Binary output; 
					bytesWanted	: Integer64; 
					bytesRead	: Integer64 output): Integer is "emInternetReadFile" in "karma" protected, number = 1017;
}
emInternetSetNumericOption
{
emInternetSetNumericOption(sessionHandle 		: MemoryAddress;
						   internetOption		: Integer;
						   internetOptionValue	: Integer) : Integer is emInternetSetNumericOption in karma protected;

//  Sets the Internet options for an internet session. See MSDN InternetSetOption documentation for full description.
//  Requires karma.dll 2.7.0.46 or later.
//  Pass self.sessionHandle to this method as the first parameter.
//  See CnInternet class constants INT_OPTION_xxxx for internetOption specifiers.
//  internetOptionValue is specified in milliseconds.
}
emOpenInternetSession
{
emOpenInternetSession(	handle	: MemoryAddress output; 
						appName	: String): Integer is "emInternetOpen" in "karma" protected, number = 1018;
}
emOpenInternetSessionPreConfig
{
emOpenInternetSessionPreConfig(	handle	: MemoryAddress output; 
								appName	: String): Integer is emInternetOpenPreConfig in karma protected;
}
	)
	CnFtp64 (
	jadeMethodSources
cnConnect
{
cnConnect() : String updating;

constants
	PASSIVE_FLAG = #08000000;
vars
	passiveFlag,																												// PAR 983
	result,
	iResult		: Integer;
	
	open,
	errorText	: String;
begin
	if self.sessionHandle <> null then																							// PAR 803
	   open := CN_OK;																											// PAR 803
	   
	else																														// PAR 803
		open := self.cnOpenConnection();
	endif;																														// PAR 803
	
	if open = CN_OK then
		if self.userId = null then
			self.userId		:= "anonymous";
			self.password 	:= "password";
		endif;
	
		if self.passive then																									// PAR 983
			passiveFlag	:= PASSIVE_FLAG;																						// PAR 983
		endif;																													// PAR 983
		
		if self.portNumber = null then																							// PAR 983
			self.portNumber := self.Default_FTP_PortNumber;																		// PAR 983
		endif;																													// PAR 983
		
		result := self.emFtpConnectEx2(self.connectionHandle,																	// PAR 983 
										self.sessionHandle,																		// PAR 983
										self.serverName,																		// PAR 983
										self.userId,																			// PAR 983
										self.password,																			// PAR 983
										passiveFlag,																			// PAR 983
										self.portNumber);																		// PAR 983
		if result <> null then
			return method.cnGetMethodName() & " failed : reason=" & self.cnGetInternetError(result); 
		endif;
	endif;
	
	return CN_OK;
end;
}
cnGetFile
{
cnGetFile(sourceFile, destFile : String; pUsePresentationFileSystem : Boolean) : String updating;

vars
	cc			: CnCntrl;

	outfile		: File;

	bin			: Binary;

	result		: Integer;
	
	bytesRead	: Integer64;

	attributes,
	str			: String;

	tsGMT		: TimeStamp;
begin
	cc := app.myCnCntrl;

	self.cnCloseConnection();
	str := self.cnGetFileInfo(sourceFile, attributes, self.currentFileSize, self.currentFileLastModified);
	if str <> CN_OK then
		return str;
	endif;

	str := self.cnConnect();						// cnGetFileInfo closes the connection, so we have to open it again
	if str <> CN_OK then
		return str;
	endif;

	result := self.emFtpOpenFile(self.fileHandle, self.connectionHandle, sourceFile, false, self.modeAscii);
	if result <> 0 then
		return method.cnGetMethodName() & " file open failed for " & sourceFile & " : " & self.cnGetInternetError(result);
	endif;

	self.currentFileName := sourceFile;

	create outfile transient;
	outfile.usePresentationFileSystem	:= pUsePresentationFileSystem;
   	outfile.fileName					:= destFile;
   	if outfile.isAvailable() then
  		outfile.purge();
  	endif;

	outfile.kind				:= outfile.Kind_Binary;
	outfile.mode				:= outfile.Mode_Output;
	outfile.open();
	self.fileBytesTransferred	:= null;

	if self.totalBytesToBeTransferred = null then						// normally set up by user external to class
   		self.totalBytesToBeTransferred 	:= self.currentFileSize;
   		self.totalBytesTransferred		:= null;
   	endif;

	while true do
    	result := self.emInternetReadFile(self.fileHandle, bin, FTP_Block_Size, bytesRead);
    	if result <> 0 then
    		return method.cnGetMethodName() & " failed read : " & self.cnGetInternetError(result);

    	elseif bytesRead = 0 then
    		outfile.close;
			self.cnCloseConnection();																							// PAR 803
            if self.currentFileLastModified <> null then
	            tsGMT := self.currentFileLastModified.cnConvertToGMT(self.serverGMTBias);		// detour Microsoft's faulty implementation of
	            self.currentFileLastModified := tsGMT.cnLocalTime.cnZeroMilliseconds;			// FTP in IIS 4.0

	            str := self.cnSetModifyTime(destFile, self.currentFileLastModified, pUsePresentationFileSystem);
	            if str <> CN_OK then
	            	return method.cnGetMethodName() & " transferred file " & sourceFile & " to " & destFile & " appeared to complete OK but " &
	            	       "modify timestamp failed : " & str;
	            endif;

	    		cc.cnWriteLog(cc.CnLogComment, "FTP file transfer completed from source file " & sourceFile & " to " & destFile &
	    					  ", LastModifiedTime set to " & self.currentFileLastModified.String & " (local), " & tsGMT.String & " (GMT)", null);
	    	endif;

    		return CN_OK;											// file transfer completed.  

        else
        	outfile.writeBinary(bin);
           	self.fileBytesTransferred 	:= self.fileBytesTransferred + bytesRead;
            self.totalBytesTransferred	:= self.totalBytesTransferred + bytesRead;
            self.counter := self.counter + 1;
            if self.counter >= 5 and self.myNotifyObject <> null then
            	self.myNotifyObject.causeEvent(Cn_Transfer_Progress, true, self.totalBytesTransferred.String & "/" & 
            							  self.totalBytesToBeTransferred.String & "/");	
            	self.counter := null;
            	if not app.cnIsServerApp 										and
            	   not app.cnApplicationType = app.ApplicationType_Non_GUI		and
           	   	   not app.cnApplicationType = app.ApplicationType_Non_GUI_Web 	then
            		app.doWindowEvents(5);
            	endif;
            endif;
        endif;
   	endwhile;

	return "Unexpected error in " & method.cnGetMethodName();

epilog
	self.cnCloseConnection();
	self.currentFileName := null;
	delete outfile;
end;
}
cnGetFileBasic
{
cnGetFileBasic(sourceFile, destFile : String; pUsePresentationFileSystem : Boolean) : String updating;

vars
	cc			: CnCntrl;

	outfile		: File;
	
	bin			: Binary;

	localBias,
	result		: Integer;
	
	bytesRead	: Integer64;
	
	attributes,
	str			: String;
	
	tsGMT		: TimeStamp;
begin
	cc := app.myCnCntrl;

	self.cnCloseConnection();																									//PAR 803

	str := cnConnect();						// cnGetFileInfo closes the connection, so we have to open it again
	if str <> CN_OK then
		return str;
	endif;

	result := self.emFtpOpenFile(self.fileHandle, self.connectionHandle, sourceFile, false, self.modeAscii);
	if result <> null then
		return method.cnGetMethodName() & " file open failed for " & sourceFile & " : " & self.cnGetInternetError(result);
	endif;

	self.currentFileName := sourceFile;

	create outfile transient;
	outfile.usePresentationFileSystem	:= pUsePresentationFileSystem;
   	outfile.fileName					:= destFile;
   	if outfile.isAvailable then
  		outfile.purge;
  	endif;

	outfile.kind		:= outfile.Kind_Binary;
	outfile.mode		:= outfile.Mode_Output;
	outfile.open();
	self.fileBytesTransferred := null;

	while true do
    	result := self.emInternetReadFile(self.fileHandle, bin, FTP_Block_Size, bytesRead);
    	if result <> 0 then
    		return method.cnGetMethodName() & " failed read : " & self.cnGetInternetError(result);
		endif;

    	if bytesRead = null then
    		outfile.close;
			self.cnCloseConnection();																							// PAR 803
    		return CN_OK;											// file transfer completed.  
		endif;
		
		outfile.writeBinary(bin);
		self.fileBytesTransferred 	:= self.fileBytesTransferred + bytesRead;
		self.totalBytesTransferred	:= self.totalBytesTransferred + bytesRead;
   	endwhile;

	return "Unexpected error in " & method.cnGetMethodName();
epilog
	self.cnCloseConnection();																									// PAR 803
	self.currentFileName := null;
	delete outfile;
end;
}
cnGetFileInfo
{
cnGetFileInfo(pFileName 	: String; 
			  pAttributes 	: String output; 
			  pFilesize 	: Integer64 output; 
			  pLastModified : TimeStamp output) : String updating;

vars
	cc			: CnCntrl;

	file		: File;

 	array		: CnStringArray;

	fileinfo	: Binary;

	isDirectory	: Boolean;

	d 			: Date;

	accessDate,
	accessTime,
	creationDate,
	creationTime,
	fileNameLength,
	foundFileLength,
	len,
	pos,
	result,
	updateDate,
	updateTime	: Integer;
	
	fileSize	: Integer64;

	errortext,
	fileNameLC,
 	findFile,
	foundfile,
	simpleName,
	str			: String;

	t			: Time;
	
	ts			: TimeStamp;
begin
	self.cnCloseConnection();
    str := self.cnConnect();													// connect
    if str <> CN_OK then
    	return str;
    endif;
    
    findFile	:= pFileName;
	create file transient;
	file.fileName := findFile;
	simpleName := file.cnGetSimpleFileName();
	simpleName.replaceChar(" ", "?");				// replace any spaces with wild card
	len := simpleName.length();
	findFile := findFile[1:findFile.length()-len] & simpleName;

    result := self.emFtpFindFirstFile(self.fileHandle, self.connectionHandle, findFile, fileinfo, foundfile, isDirectory);		// PAR 532 - was incorrectly using simpleName
    if result <> 0 then
    	return "CnFtp::cnGetFileInfo::emFtpFindFirstFile failed for file " & pFileName & " : " & self.cnGetInternetError(result);
    endif;

	if serverType = Server_Type_Novell then
		array 		:= foundfile.cnGetTokens(" ");
		foundfile	:= array.last;

    elseif foundfile.length > 11 and foundfile[1:11] = "Report for:" then 	// Unisys A Series
    	pos 		:= 1;
    	foundfile.cnGetToken(pos, ")");										// Find end of usercode.

    	if pos = 0 then														// no usercode
    		pos := foundfile.reversePos(" ");								// find blank before file name
    		if pos < 12 then
    			foundfile := foundfile[12 : end];
    		else
    			foundfile := foundfile[pos + 1 : end];
    		endif;
		else
    		foundfile	:= foundfile.cnGetToken(pos, " ");
    	endif;
   	endif; 

   	foundfile		:= foundfile.toLower();	
	foundFileLength	:= foundfile.length();
	fileNameLength	:= pFileName.length();
	fileNameLC		:= pFileName.toLower();
    if foundfile = null 						or
       foundFileLength > fileNameLength			or
      (foundFileLength > null					and
       fileNameLC[fileNameLength - foundFileLength + 1 : foundFileLength] <> foundfile) then
    	return method.cnGetMethodName() & " didn't find file '" & fileNameLC & "' : instead found '" & foundfile & "'";
    endif;
	
    result := self.emGetFileInfo(fileinfo, foundfile, pAttributes, fileSize, creationDate, creationTime,
								accessDate, accessTime, updateDate, updateTime);
	//
	//  For Unisys A Series, the response to a DIR includes filetype information that seems to
	//  confuse wininet, so the lastModified time typically ends up as 1/1/80.  Class client will
	//  need to handle this situation outside of this class, if he wants to.                            
   	//                 
    if result = 1 then
    	return method.cnGetMethodName() & " : fileInfo packet is too small for emGetFileInfo";
		
    elseif result = 2 then
    	return method.cnGetMethodName() & " : fileInfo packet is empty in emGetFileInfo";
    endif;

	d.setDate (updateDate mod 100 , 					// day                
					(updateDate div 100) mod 100 , 		// month 
					 updateDate div 10000  				// year
                  ) ;
   	t.setTime (updateTime div 10000 , 					// hour
                   (updateTime div 100) mod 100 , 		// minute
                    updateTime mod 100 ,     			// seconds
                    0                    				// millisecs
                  ) ;

    ts.setTime(t);
    ts.setDate(d);
    pLastModified := ts;
	pFilesize := fileSize;
    return CN_OK;
epilog
	delete file;
	delete array;
	self.cnCloseConnection();
end;
}
cnGetLastModifiedTimeGMT
{
cnGetLastModifiedTimeGMT(filename : String io; lastModified : TimeStamp output) : String updating;

vars
 	iResult		: Integer;
	
 	filesize	: Integer64;
	
 	attributes,
 	result		: String;
 	
	modifydate	: TimeStamp;
begin
	///  In Windows NT the ftp getFileInfo call returns a lastModified timestamp in
	///  my local time format (karma.dll receives it in UTC format and converts it to local time.)
	///  In AIX/SP we think that the ftp server will need to be configured as being in UTC timezone
	///  in order to be compatible with this.

	filename := filename.toLower();
    result := self.cnGetFileInfo(filename, attributes, filesize, modifydate);

    if self.serverGMTBias = 0 then
    	iResult := modifydate.cnGetGMTBias(serverGMTBias);
    endif;

    lastModified := modifydate.cnConvertToGMT(serverGMTBias);
    return result;
end;
}
cnPutFile
{
cnPutFile(sourceFile, destFile : String; pUsePresentationFileSystem : Boolean; closeConnectionWhenFinished : Boolean) : String updating;

	// returns "OK" if good result
	// closeWhenFinished if true will close the connection after the putFile. 

vars
	cc			: CnCntrl;

	kc			: CnKarmaCntrl;		

	infile		: File;

	bin			: Binary;

	result		: Integer;
	
	bytesWritten: Integer64;
	
	str			: String;
begin
	cc := app.myCnCntrl;
	kc := app.myCnKarmaCntrl;

	create infile transient;
	infile.fileName 					:= sourceFile;
	infile.kind							:= infile.Kind_Binary;
	infile.mode							:= infile.Mode_Input;
	infile.usePresentationFileSystem	:= pUsePresentationFileSystem;

	if not infile.isAvailable then
		return "Source file " & sourceFile & " not found.";
	endif;

	result := self.emFtpOpenFile(self.fileHandle, self.connectionHandle, destFile, true, self.modeAscii);	// if modeAscii is false, then mode is binary
	if result <> null then
		return "CnFtp::cnPutFile file open failed for " & destFile & " : " & self.cnGetInternetError(result);
	endif; 

	self.currentFileName 				:= sourceFile;
	if self.totalBytesToBeTransferred = null then						// normally set up by user external to class
   		self.totalBytesToBeTransferred 	:= self.currentFileSize;
   		self.totalBytesTransferred		:= null;
   	endif;
	
    self.currentFileSize	 			:= infile.fileLength64();
	self.fileBytesTransferred			:= null;

	on FileException do kc.fileExceptionHandler(exception); 
	kc.setHadFileException(false);
	kc.setFileRetryNo(0);
	infile.open;
	if kc.hadFileException then
		return "CnFTP::cnPutFile unable to open source file " & infile.fileName;
	endif;

	while not infile.endOfFile do
		kc.setHadFileException(false);
		kc.setFileRetryNo(null);
		bin := infile.readBinary(FTP_Block_Size);
		if kc.hadFileException then
			return "CnFTP::cnPutFile had problem reading source file " & sourceFile & " : error=" &
					kc.exceptionErrorCode.String & " : " & kc.exceptionText;
		endif;

    	result := self.emInternetWriteFile(self.fileHandle, bin, FTP_Block_Size, bytesWritten);
    	if result <> 0 then
    		return "CnFtp::cnPutFile failed write : " & self.cnGetInternetError(result);

    	elseif bytesWritten < bin.length then
    		infile.close;
            self.cnCloseConnection();
            return "CnFtp::cnPutFile failed : attempted to write " & bin.length.String & " bytes, but only " &
            	   bytesWritten.String & " were written.";

        else
           	self.fileBytesTransferred 	:= self.fileBytesTransferred + bytesWritten;
            self.totalBytesTransferred	:= self.totalBytesTransferred + bytesWritten;
            self.counter := self.counter + 1;
            if self.counter >= 5 and self.myNotifyObject <> null then
            	self.myNotifyObject.causeEvent(Cn_Transfer_Progress, true, self.totalBytesTransferred.String & "/" & 
            							  self.totalBytesToBeTransferred.String & "/");	
            	self.counter := null;
            	if not app.cnIsServerApp 										and
            	   not app.cnApplicationType = app.ApplicationType_Non_GUI		and
           	   	   not app.cnApplicationType = app.ApplicationType_Non_GUI_Web 	then
            		app.doWindowEvents(5);
            	endif;
            endif;
        endif;
   	endwhile;
   	
    if self.fileBytesTransferred <> infile.fileLength64() then
    	str := "FTP file transfer error : file length=" & infile.fileLength64().String & " but bytes written was only=" & 
    			fileBytesTransferred.String & " : file=" & infile.fileName;
    	cc.cnWriteLog(cc.CnLogErrors, str, null);
    	return str;
    endif; 

	cc.cnWriteLog(cc.CnLogComment, "FTP file transfer completed from source file " & sourceFile & " to " & destFile, null);
    return CN_OK;											// file transfer completed.  

epilog
	if closeConnectionWhenFinished then
	   	process.sleep(1000);						// allow IIS time to deal with the file closure 	
		self.cnCloseConnection();
		
	else
		self.cnCloseFile();			
	endif;
	
	self.currentFileName := null;
	delete infile;
end;
}
cnRenameFile
{
cnRenameFile(oldName : String; newName : String) : String;

vars
	//  This is an FTP rename, typically used after using ::cnPutFile.
	//  Returns OK or an error string.
	
	result	: Integer;
	errText	: String;
	str		: String;
begin
	if self.sessionHandle = null then
		return "Can't rename file - no current FTP session";
	endif;
	
	result := self.emFtpRenameFile(self.connectionHandle, oldName, newName);
	if result <> 0 then
		str := "CnFtp::cnRenameFile failed for file " & oldName & " : ";
		if result > 12000 then
			return str & self.cnGetInternetError(result);
		else
			return str & self.cnGetWindowsErrorText(result);		
		endif;
	endif;
		
	return CN_OK;					
end;
}
setModeAscii
{
setModeAscii(set : Boolean) updating;

vars

begin
 	self.modeAscii := set;
end;
}
setServerGMTBias
{
setServerGMTBias(bias : Integer) updating;

vars

begin
  	self.serverGMTBias := bias;
end;
}
	externalMethodSources
emFtpCommand
{
emFtpCommand(	connectionHandle 	: MemoryAddress; 
				commandString 		: String) : Integer is emFtpCommand in karma;

/*
	The emFtpCommand requires use of 'Raw FTP Commands'.
	
	ie to make a directory use 'MKD <remote-directory>'.
	
	MKDIR will cause an error 12003 result INTERNET_EXTENDED ERROR as the command
	is not a 'Raw FTP command'
*/
}
emFtpConnect
{
emFtpConnect(	connHandle	: MemoryAddress output; 
				sessHandle	: MemoryAddress; 
				serverName	: String; 
				user		: String; 
				password	: String): Integer is "emFtpConnect" in "karma" number = 1008;
}
emFtpConnectEx
{
emFtpConnectEx(	connHandle	: MemoryAddress output; 
				sessHandle	: MemoryAddress; 
				serverName	: String; 
				user		: String; 
				password	: String; 
				flags		: Integer): Integer is "emFtpConnectEx" in "karma" number = 1019;
}
emFtpConnectEx2
{
emFtpConnectEx2(ftpHandle     : MemoryAddress output ;
                sessionHandle : MemoryAddress ;
                ftpServer     : String ;
                user          : String ; 
                password      : String  ;
                flags         : Integer ;
                portnbr       : Integer) : Integer is emFtpConnectEx2 in karma;
}
emFtpCreateDirectory
{
emFtpCreateDirectory(	connectionHandle	: MemoryAddress; 
						directory			: String): Integer is "emFtpCreateDirectory" in "karma" number = 1020;
}
emFtpDeleteFile
{
emFtpDeleteFile(	ftpConnectionHandle	: MemoryAddress; 
					fileName			: String): Integer is "emFtpDeleteFile" in "karma" number = 1018;
}
emFtpFindFirstFile
{
emFtpFindFirstFile(	fileHandle		: MemoryAddress output; 
					connectionHandle: MemoryAddress; 
					mask			: String; 
					fileInfo		: Binary output; 
					fileName		: String output; 
					isDirectory		: Boolean output): Integer is "emFtpFindFirstFile" in "karma" number = 1009;
}
emFtpFindNextFile
{
emFtpFindNextFile(	fileHandle	: MemoryAddress io; 
					fileInfo	: Binary output; 
					fileName	: String output; 
					isDirectory	: Boolean output): Integer is "emFtpFindNextFile" in "karma" number = 1017;
}
emFtpGetCurrentDirectory
{
emFtpGetCurrentDirectory(	connectionHandle	: MemoryAddress; 
							directory			: String output): Integer is "emFtpGetCurrentDirectory" in "karma" number = 1023;
}
emFtpGetFile
{
emFtpGetFile(	connHandle	: MemoryAddress; 
				sourceFile	: String; 
				destFile	: String): Integer is "emFtpGetFile" in "karma" number = 1010;
}
emFtpGetFileExt
{
emFtpGetFileExt(handle			: MemoryAddress; 
				sourceFileName	: String; 
				destFileName	: String; 
				ftpFlags		: Integer; 
				fileFlags		: Integer): Integer is "emFtpGetFileExt" in "karma" number = 1011;
}
emFtpOpenFile
{
emFtpOpenFile(	fileHandle		: MemoryAddress output; 
				connectionHandle: MemoryAddress; 
				fileName		: String; 
				writing			: Boolean; 
				ascii			: Boolean): Integer is "emFtpOpenFile" in "karma" number = 1012;
}
emFtpRemoveDirectory
{
emFtpRemoveDirectory(	connectionHandle: MemoryAddress; 
						directory		: String): Integer is "emFtpRemoveDirectory" in "karma" number = 1021;
}
emFtpRenameFile
{
emFtpRenameFile(	connectionHandle	: MemoryAddress; 
					fileName			: String; 
					newFileName			: String): Integer is "emFtpRenameFile" in "karma" protected, number = 1015;
}
emFtpSetCurrentDirectory
{
emFtpSetCurrentDirectory(	connectionHandle	: MemoryAddress; 
							directory			: String): Integer is "emFtpSetCurrentDirectory" in "karma" number = 1022;
}
emGetFileInfo
{
emGetFileInfo(	fileInfo	: Binary; 
				fileName	: String output; 
				attributes	: String output; 
				fileSize	: Integer64 output; 
				creationDate: Integer output; 
				creationTime: Integer output; 
				accessDate	: Integer output; 
				accessTime	: Integer output; 
				updateDate	: Integer output; 
				updateTime	: Integer output): Integer is "emGetFileInfo" in "karma" protected, number = 1013;
}
emInternetWriteFile
{
emInternetWriteFile(	fileHandle	: MemoryAddress; 
						buffer		: Binary; 
						bytesToWrite: Integer64; 
						bytesWritten: Integer64 output): Integer is "emInternetWriteFile" in "karma" protected, number = 1014;
}
	)
	CnHttp64 (
	jadeMethodSources
cnConnect
{
cnConnect() : String updating;

vars
	open	: String;

 	result	: Integer;
begin
	open := self.cnOpenConnection();
	if open <> CN_OK then
		return "Failed to connect";
	endif;
	
	if self.userId = null then					// HTTP defaults
		self.userId := " ";
		self.password := " ";
	endif;

	result := self.emHttpConnect(self.connectionHandle, self.sessionHandle, self.serverName, self.userId, self.password, self.secure);
	if result <> 0 then
		return "CnHttp::cnConnect failed : reason=" & self.cnGetInternetError(result);
		
	else
		return CN_OK;
	endif;
end;
}
cnGetFile
{
cnGetFile(sourceFile, destFile : String; pUsePresentationFileSystem : Boolean) : String updating;

vars
	cc		: CnCntrl;

	outfile		: File;

	bin			: Binary;

	result		: Integer;
	
	bytesRead 	: Integer64;

	attributes,					// not applicable for HTTP
	str		: String;
begin
	cc := app.myCnCntrl;

	if self.connectionHandle = null then
		return "CnHttp::cnGetFile : no current connection, can't get file " & sourceFile;
		
	else
		str := self.cnGetFileInfo(sourceFile, attributes, self.currentFileSize, self.currentFileLastModified);
		if str <> CN_OK then
			return str;
		endif;

    	result := self.emHttpOpenRequest(self.requestHandle, self.connectionHandle, "GET", sourceFile, self.secure);		// prepare request
    	if result <> 0 then
    		return "CnHttp::cnGetFile failed : httpOpenRequest error : " & self.cnGetInternetError(result);
    	endif;

    	result := self.emHttpSendRequest(self.requestHandle, "");												// send request
    	if result <> 0 then
    		return "CnHttp::cnGetFile failed : httpSendRequest error : " & self.cnGetInternetError(result);
    	endif;

    	result := self.emHttpQueryInfo(self.requestHandle, Status_Code, str);
    	if result <> 0 then
    		return "CnHttp::cnGetFile failed : httpQueryInfo #1 error : " & self.cnGetInternetError(result);

    	elseif str <> "200" then																		// 200=OK
    		return "CnHttp::cnGetFile : file " & sourceFile & " not found, status=" & self.cnGetHttpQueryStatus(str);
    	endif;

		self.currentFileName := sourceFile;

    	create outfile transient;
    	outfile.usePresentationFileSystem	:= pUsePresentationFileSystem;
    	outfile.fileName					:= destFile;
    	
    	if outfile.isAvailable() then
   			outfile.purge();
   		endif;

   		outfile.kind				:= outfile.Kind_Binary;
   		outfile.mode				:= outfile.Mode_Append;
   		self.fileBytesTransferred	:= null;

   		if self.totalBytesToBeTransferred = null then						// normally set up by user external to class
   			self.totalBytesToBeTransferred 	:= self.currentFileSize;
   			self.totalBytesTransferred		:= null;
   		endif;

   		while true do
        	result := self.emInternetReadFile(self.requestHandle, bin, HTTP_Block_Size, bytesRead);
        	if result <> 0 then
        		return "CnHttp::cnGetFile failed read : " & self.cnGetInternetError(result);

        	elseif bytesRead = 0 then
        		outfile.close;
				outfile.kind	:= outfile.Kind_Unknown_Text;	// detour for PAR 19010
				
        		if outfile.fileLength64() <> self.currentFileSize then
        			return "CnHttp::cnGetFile got bad copy of file " & sourceFile & " : source size=" & self.currentFileSize.String &
        			       ", copied file size=" & outfile.fileLength64().String;
        		endif;

        		cnSetModifyTime(destFile, self.currentFileLastModified.cnLocalTime.cnZeroMilliseconds, pUsePresentationFileSystem);
        		cc.cnWriteLog(cc.CnLogComment, "HTTP file transfer completed for source file " & sourceFile & " to " & destFile, null);
        		return CN_OK;											// file transfer completed															

            else
            	outfile.writeBinary(bin);
               	self.fileBytesTransferred 	:= self.fileBytesTransferred + bytesRead;
               	self.totalBytesTransferred	:= self.totalBytesTransferred + bytesRead;
               	self.counter := self.counter + 1;
                if self.counter >= 5 and self.myNotifyObject <> null then
            		self.myNotifyObject.causeEvent(Cn_Transfer_Progress, true, self.totalBytesTransferred.String & "/" & 
            							  self.totalBytesToBeTransferred.String & "/");	
            		self.counter := null;
					if not app.cnIsServerApp 										and
					   not app.cnApplicationType = app.ApplicationType_Non_GUI		and
					   not app.cnApplicationType = app.ApplicationType_Non_GUI_Web 	then
            			app.doWindowEvents(5);
            		endif;
            	endif;
            endif;
       	endwhile;
    endif;

	return "Unexpected error in CnHttp::cnGetFile";

epilog
	delete outfile;
	self.emCloseHandle(self.requestHandle);
	self.requestHandle := null;
end;
}
cnGetFileInfo
{
cnGetFileInfo(filename  	: String; 
			  attributes 	: String output; 
			  filesize 		: Integer64 output; 
			  lastModified 	: TimeStamp output) : String updating;
vars
	result 	: Integer;
	buffer	: String;
begin
 	if self.connectionHandle = null then
 		return "CnHttp::cnGetFileInfo failed : HTTP connection to host " & self.serverName & " is not established";
	endif;
	
	result := self.emHttpOpenRequest(self.requestHandle, self.connectionHandle, "HEAD", filename, self.secure);		// prepare request
	if result <> 0 then
		return "CnHttp::cnGetFileInfo failed : httpOpenRequest error : " & self.cnGetInternetError(result);
	endif;

	result := self.emHttpSendRequest(self.requestHandle, "");												// send request
	if result <> 0 then
		return "CnHttp::cnGetFileInfo failed : httpSendRequest error : " & self.cnGetInternetError(result);
	endif;

	result := self.emHttpQueryInfo(self.requestHandle, Status_Code, buffer);
	if result <> 0 then
		return "CnHttp::cnGetFileInfo failed : httpQueryInfo #1 error : " & self.cnGetInternetError(result);

	elseif buffer <> "200" then																		// 200=OK
		return "CnHttp::cnGetFileInfo : file " & filename & " not found : status=" & self.cnGetHttpQueryStatus(buffer);
	endif;

	result := self.emHttpQueryInfo(self.requestHandle, File_Length, buffer);
	if result <> 0 then
		return "CnHttp::cnGetFileInfo failed : httpQueryInfo # 2 error : " & self.cnGetInternetError(result);
	endif;

	filesize := buffer.Integer64;																								// PAR 927

	result := self.emHttpQueryInfo(self.requestHandle, Last_Modified_Date, buffer);
	if result <> 0 then
		return "CnHttp::cnGetFileInfo failed : httpQueryInfo # 3 error : " & self.cnGetInternetError(result);
	endif;

	lastModified.setDate(buffer[6:11].Date);		// Assumes RFC1123 date format : Mon, 06 Apr 1998 05:05:10
	lastModified.setTime(buffer[18:8].Time);		// Might need to be enhanced if we encounter old Internet servers, but
													// this works OK with IIS 2.0.
	return CN_OK;
epilog
	self.emCloseHandle(self.requestHandle);
	self.requestHandle := null;	
end;
}
cnGetHttpQueryStatus
{
cnGetHttpQueryStatus(status : String) : String protected;

vars

begin
 	if 	   status = "200" then
 		return CN_OK;
 	elseif status = "201" then 
 		return "Created";
 	elseif status = "202" then
 		return "Accepted";
 	elseif status = "204" then
 		return "No Content";
 	elseif status = "301" then
 		return "Moved Permanantly";
 	elseif status = "302" then
 		return "Moved Temporarily";
 	elseif status = "304" then
 		return "Not Modified";
 	elseif status = "400" then
 		return "Bad Request";
 	elseif status = "401" then
 		return "Unauthorised";
 	elseif status = "403" then
 		return "Forbidden";
 	elseif status = "404" then
 		return "Not Found";
 	elseif status = "500" then
 		return "Internal Server Error";
 	elseif status = "501" then
 		return "Not Implemented";
 	elseif status = "502" then
 		return "Bad Gateway";
 	elseif status = "503" then
 		return "Service Unavailable";
 	else
 		return status & " : unknown error status code";
 	endif;
end;
}
cnGetLastModifiedTimeGMT
{
cnGetLastModifiedTimeGMT(filename : String io; lastModified : TimeStamp output) : String updating;

vars
 	filesize	: Integer64;

 	attributes,
 	result 		: String;
begin
 	return self.cnGetFileInfo(filename, attributes, filesize, lastModified);
end;
}
setSecure
{
setSecure(set : Boolean) updating;

vars

begin
	self.secure := set;
end;
}
	externalMethodSources
emHttpConnect
{
emHttpConnect(	connHandle	: MemoryAddress output; 
				sessHandle	: MemoryAddress; 
				serverName	: String; 
				user		: String; 
				password	: String; 
				secure		: Boolean): Integer is "emHttpConnect" in "karma" number = 1007;
}
emHttpOpenRequest
{
emHttpOpenRequest(	requestHandle	: MemoryAddress output; 
					connectionHandle: MemoryAddress; 
					command			: String; 
					fileName		: String; 
					secure			: Boolean): Integer is "emHttpOpenRequest" in "karma" protected, number = 1008;
}
emHttpQueryInfo
{
emHttpQueryInfo(	requestHandle	: MemoryAddress; 
					attribute		: Integer; 
					buffer			: String output): Integer is "emHttpQueryInfo" in "karma" protected, number = 1009;
}
emHttpSendRequest
{
emHttpSendRequest(	requestHandle	: MemoryAddress; 
					headers			: String): Integer is "emHttpSendRequest" in "karma" protected, number = 1010;
}
	)
	CnKarmaCntrl (
	jadeMethodSources
buildDummyVersionControlFile
{
buildDummyVersionControlFile(path : String; fileName : String; ts : TimeStamp) updating;

vars
	file	: File;
	ff		: FileFolder;
	cc		: CnCntrl;
begin
	cc	:= app.myCnCntrl;
	
	create ff transient;
	ff.fileName						:= path;
	ff.usePresentationFileSystem	:= false;
	if not ff.isAvailable then
		ff.make;
		cc.cnWriteLog(cc.CnLogComment, "New directory " & path & " created.", null);
	endif;	
	
	if fileName <> null then
		create file transient;
		file.usePresentationFileSystem	:= false;
		file.mode		:= file.Mode_IO;
		file.fileName	:= path & "/" & fileName;
		if file.isAvailable then
			file.purge;
		endif;
		
		file.writeLine("Dummy, auto-created version control file.");
	 	file.close;
	 	file.cnSetLastModified(ts);
	 	cc.cnWriteLog(cc.CnLogComment, "New dummy version file '" & file.fileName & "' created : timestamp=" & ts.String, null);
	endif;
epilog
	delete ff;
 	delete file;
 end;
}
buildDummyVersionControlFiles
{
buildDummyVersionControlFiles() updating;

vars
	path	: String;
	ts		: TimeStamp;
begin
	//  Per PAR 1531, enhanced for 3.0 to create missing directories if necessary
	//
	path	:= driveLetter & ":/" & environmentId & "/";
	buildDummyVersionControlFile(path & "c_bin", 	environmentId & "_bin.ver", ts);
	buildDummyVersionControlFile(path & "c_misc",	environmentId & "_misc.ver", ts);
	buildDummyVersionControlFile(path & "c_schema", environmentId & "_schema.ver", ts);
	buildDummyVersionControlFile(path & "n_bin", 	null, ts);
	buildDummyVersionControlFile(path & "n_misc",	null, ts);
	buildDummyVersionControlFile(path & "n_schema", null, ts);
 end;
}
captureSystemStatistics
{
captureSystemStatistics() updating;

vars
 	ss	: CnServerStatistics;
begin
	ss	:= self.myCnServerStatistics;
	if ss = null then
		create ss transient;
		self.myCnServerStatistics := ss;
	endif;

	ss.captureSystemStatistics();
end;
}
checkDllType
{
checkDllType(file : File) : Boolean;

vars
	cc 		: CnCntrl;
	ver		: String;
	pos		: Integer;
	desc	: String;
	str		: String;
	ok		: Boolean;
begin
	cc 		:= app.myCnCntrl;
	ok		:= true;
	if file.usePresentationFileSystem and process.isUsingThinClient then
			str	:= "Thin client";
	elseif process.isUsingThinClient then
			str := "App server";
	elseif node.isServerNode then
			str := "Server node";
	else
			str := "Fat client";
	endif; 
	
	desc	:= file.cnGetFileDescription;		// returns variable results if DLL is wrong version
	ver		:= app.cnGetJadeVersion();
	if desc[6 : 3] <> ver[1 : 3] then
		cc.cnWriteLog(cc.CnLogErrors, str & " has incompatible version of " & file.cnGetSimpleFileName & " : JADE version is " & ver &
									  " but DLL is for version " & desc[1 : 9], null);
		ok	:= false;
	endif;
	
	if app.isUnicode and desc.toLower.cnContains("ansi") then
		cc.cnWriteLog(cc.CnLogErrors, str & " has incompatible version of " & file.cnGetSimpleFileName & " : ANSI dll found for Unicode application.", null);
		ok	:= false;
		
	elseif not app.isUnicode and desc.toLower.cnContains("unicode") then
		cc.cnWriteLog(cc.CnLogErrors, str & " has incompatible version of " & file.cnGetSimpleFileName & " : Unicode dll found for ANSI application.", null);
		ok	:= false;		
	endif;
	
	if ok then
		cc.cnWriteLog(cc.CnLogComment, file.cnGetSimpleFileName.toUpper & " on " & str & " is " & desc, null);
	endif;
	
	return ok;				
end;
}
copyFile
{
copyFile(sourceFile, destFile : String; failIfExists : Boolean) : Boolean;

vars
	int,
	result		: Integer;
	
	cc			: CnCntrl;

	errortext,
	str			: String;
	
	cem			: CnExternalMethods;
	
	file		: File;
begin
	cc		:= app.myCnCntrl;

	create file transient;
	result 	:= file.emCopyFile(sourceFile, destFile, failIfExists);
    str		:= "Copy of " & sourceFile & " to " & destFile;

	if result = null then 
 		cc.cnWriteLog(cc.CnLogDiag, str & " was successful", null); 	
 		return true;
	endif;
	
	create cem transient;
	int	:= cem.emGetErrorText(result, errortext, 127);
	if int <> 0 then
		cc.cnWriteLog(cc.CnLogErrors, "CnExternalMethods::emGetErrorText got error result=" & int.String, null);
	endif;
	
	str := str & " failed, result=" & result.String & ":" & errortext;
	cc.cnWriteLog(cc.CnLogErrors, str, null); 
	return false;
epilog
	delete cem;
	delete file;
end;
}
create
{
create() updating;

vars
	processApp			: Application;

	cnApp				: CardSchema;

	clusterInfo			: CnClusterInfo;

	cc 					: CnCntrl;

	deadlockHandler		: CnDeadlockHandler;

	cem					: CnExternalMethods;

	frm					: CnMsgForm;
	
	cnproc				: CnProcess;

	root				: CnRoot;

	sdsDba,													// subclass of JadeDatabaseAdmin
	sdsDba2				: CnSDSDatabaseAdmin;				// subclass of JadeDatabaseAdmin

	tranData			: CnTransactionData;

	stack				: CnTransactionStack;

	appServerFile,
	file,
	karmaFile,
	tcFile				: File;

	glob				: GCardSchema;

	dba,
	jdba				: JadeDatabaseAdmin;

	jdoNode,
	jdoProcess			: JadeDynamicObject;

	proc 				: Process;
	
	applArray			: ApplicationArray;
	
	array				: CnStringArray;
	resultsArray		: CnStringArray;
	
	paramArray			: CnVariantArray;

	clientHasKarmaDll,
	clientOnServer,											// now indicates that client uses server binaries
	ignoreKarmaControl,
	iSetXnState,																												// PAR 600
	lockedForReorg,																												// PAR 1007
	karmaDownload,																												// PAR 574
	karmaFileError,																												// PAR 526
	runningAsService	: Boolean;

	characterSize,
	osArchitecture,
	osPlatform,
	pid,
	pos,
	result,
	role,
	rpsStorageMode,
	signonUsage,
	statsInterval,
	sz,
	tcOSArchitecture,
	tcOSPlatform		: Integer;
	
	appServerThinClientDownloadDir,
	buildArchitecture,
	cfgDir,
	cfgName,
	compname,
	distribution,
	distType,
	downLoadDir,																												// PAR 574
	errText,
	extent,
	fqdn,
	iniFileName,
	ipaddress,
	karmaLibrary,																												// PAR 574
	karmaBin1,																													// PAR 574
	karmaBin2,																													// PAR 574
	key,
	mapname,
	osVersion,
	resultStr,																													// PAR 601
	rpsMappingName,
	rpsSchemaName,
	section,
	str, 
	str2,
	tcDistribution,
	tcOSVersion			: String;
begin
	processApp := process.getProcessApp();
	if processApp.isKindOf(CardSchema) then
		cnApp := processApp.CardSchema;
	
	else
		cnApp := app;
	endif;
	
	cnApp.setCnApplicationType(cnApp.applicationType);
	app.setCnApplicationType(cnApp.applicationType);
	app.cnSetCurrentLocaleDefaultCountryCode(app.currentLocaleInfo.defaultCountryCode);
	
	self.zSetupMessagingClassDetails();			// This needs to be done pretty early in case we get an exception during this create
	
	create jdoNode transient;
	node.getOSDetails(jdoNode);
	osPlatform 			:= jdoNode.getPropertyValue(CN_OSDETAIL_PLATFORMID).Integer;
	osArchitecture 		:= jdoNode.getPropertyValue(CN_OSDETAIL_ARCHITECTURE).Integer;
	osVersion			:= jdoNode.getPropertyValue(CN_OSDETAIL_VERSION).String;
	buildArchitecture 	:= jdoNode.getPropertyValue(CN_OSDETAIL_BUILDARCHITECTURE).String;
	characterSize		:= jdoNode.getPropertyValue(CN_OSDETAIL_CHARACTERSIZE).Integer;
	if characterSize = 1 then
		distType := CN_DISTRIBUTION_ANSI;
	
	else
		distType := CN_DISTRIBUTION_UNICODE;
	endif;
	
	pos := buildArchitecture.pos(distType, 1);
	distribution		:= buildArchitecture[1:pos-1];
	cnApp.cnSetOSPlatform(osPlatform);
	cnApp.cnSetOSArchitecture(osArchitecture);
	cnApp.cnSetOSVersion(osVersion);
	cnApp.cnSetDistributionNode(distribution);
	// items are required very early in setup so setup for package application too!
	app.cnSetOSPlatform(osPlatform);
	app.cnSetOSArchitecture(osArchitecture);
	app.cnSetOSVersion(osVersion);
	app.cnSetDistributionNode(distribution);
	
	if process.isUsingThinClient then
		create jdoProcess transient;
		process.getOSDetails(jdoProcess);
		tcOSPlatform 		:= jdoProcess.getPropertyValue(CN_OSDETAIL_PLATFORMID).Integer;										// PAR 601
		tcOSArchitecture 	:= jdoProcess.getPropertyValue(CN_OSDETAIL_ARCHITECTURE).Integer;									// PAR 601
		tcOSVersion			:= jdoProcess.getPropertyValue(CN_OSDETAIL_VERSION).String;											// PAR 601
		buildArchitecture 	:= jdoProcess.getPropertyValue(CN_OSDETAIL_BUILDARCHITECTURE).String;								// PAR 601
		characterSize		:= jdoProcess.getPropertyValue(CN_OSDETAIL_CHARACTERSIZE).Integer;									// PAR 601
		if characterSize = 1 then
			distType := CN_DISTRIBUTION_ANSI;
		
		else
			distType := CN_DISTRIBUTION_UNICODE;
		endif;
		
		pos := buildArchitecture.pos(distType, 1);
		if pos = null then																										// PAR 619
			if processApp.applicationType = processApp.ApplicationType_SilverLight then											// PAR 619
				tcDistribution		:= distribution;																			// PAR 619
			
			else																												// PAR 619
				app.cnRaiseNormalException(Cn_General_Error, 																	// PAR 619
											"ThinClient BuildArchitecture", 													// PAR 619
											buildArchitecture & " invalid format for application type '" & 						// PAR 619
											app.cnApplicationType, 																// PAR 619, 1083
											false);																				// PAR 619
			endif;																												// PAR 619
			
		else																													// PAR 619
			tcDistribution		:= buildArchitecture[1:pos-1];
		endif;																													// PAR 619
		
		cnApp.cnSetThinClientOSPlatform(tcOSPlatform);
		cnApp.cnSetThinClientOSArchitecture(tcOSArchitecture);
		cnApp.cnSetThinClientOSVersion(tcOSVersion);
		cnApp.cnSetDistributionProcess(tcDistribution);
		app.cnSetThinClientOSPlatform(tcOSPlatform);
		app.cnSetThinClientOSArchitecture(tcOSArchitecture);
		app.cnSetThinClientOSVersion(tcOSVersion);
		app.cnSetDistributionProcess(tcDistribution);
		
	else	// process and node are same distribution
		cnApp.cnSetDistributionProcess(distribution);
		app.cnSetDistributionProcess(distribution);
	endif;

	create cc;									// CnCntrl singelton lasts for life of JADE application
	if cc.karmaControl then
		cc.setFullDiagnostics(true);
		cc.setLogToScreen(false);
	endif;
	
	cnApp.cnSetSystemType();
	if cc.appName = CN_KCDUMMY	then							// JADE Systems Management App
		cc.setSuppressManagementDialogs(true);
	endif;

	if node.isServerNode and processApp.isMultiUser() then										     		
		cnApp.setCnIsServerApp(true);							// MUST be set up before any exception handlers are invoked
	endif;

	self.setNetworkAddressNode(app.cnGetNetworkAddressNode);		// NFS 777	// PAR 441 save network address here as causes server execution
	self.setNetworkAddressProcess(app.cnGetNetworkAddressProcess);	// NFS 777	// PAR 441 save network address here as causes server execution
/*	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " networkAddressNode=" & self.networkAddressNode & 
														", networkAddressProcess=" & self.networkAddressProcess &
														", osPlatform=" & osPlatform.String &
														", osArchitecture=" & osArchitecture.String &
														", osVersion=" & osVersion &
														", buildArchitecture=" & buildArchitecture &
														", characterSize=" & characterSize.String, null);
*/	on LockException do cnApp.cnGlobalLockExceptionHandler(exception);
	cc.cnWriteLog(cc.CnLogComment, "-----------------  Application Start Up ---------------------------", null);
	
	str :=  "CardSchema Class Library Version " & app.cnGetCardSchemaVersion() & ", JADE version " & processApp.getSystemVersion();
	if not processApp.isKindOf(CardSchema) then
		cc.cnWriteLog(cc.CnLogComment, "Process executing from schema " & processApp.class().schema.name & " which is not a subschema of CardSchema.", null);
	endif;
	
	if processApp.isUnicode() then
		str := str & " (Unicode)";
		
	else
		str := str & " (ANSI)";
	endif;
	
	cc.cnWriteLog(cc.CnLogComment, str & ", process usercode=" & process.userCode & ", app.userName=" & processApp.userName & ".", null);			    
	cc.cnWriteLog(cc.CnLogComment, "Database path=" & processApp.dbPath & ".", null);
	
	str	:= "Platform type for this node=";
	if cnApp.cnOSPlatformIsWindows()	then
		str	:= str & "Windows";
		
	elseif osPlatform = Node.OSUnixLinux 		then
		str	:= str & "Linux (" & cc.osDistribution & " " & cc.osVersion & ")";
		
	elseif osPlatform = Node.OSUnixAIX			then
		str := str & "AIX";
		
	else
		str	:= str & "<unknown OS platform '" & osPlatform.String & "'>";
	endif;
	
	str	:= str & ", OS version=" & osVersion & ", platform architecture=";
	if osArchitecture = Node.Architecture_32Big_Endian then
		str	:= str & "Architecture_32Big_Endian";
		
	elseif osArchitecture = Node.Architecture_32Little_Endian then
		str	:= str & "Architecture_32Little_Endian";

	elseif osArchitecture = Node.Architecture_64Big_Endian then
		str	:= str & "Architecture_64Big_Endian";

	elseif osArchitecture = Node.Architecture_64Little_Endian then
		str	:= str & "Architecture_64Little_Endian";
		
	elseif osArchitecture = Node.Architecture_Gui then
		str	:= str & "Architecture_Gui (currently Windows 32 bit little endian)";
	endif;
	
	str := str & ", distribution=" & distribution;
	
	cc.cnWriteLog(cc.CnLogComment, str, null);
	
	str				:= "Database is not an SDS system.";
	role			:= system.getDatabaseRole();
	
	if role = SDS_RolePrimary then
		str			:= "Database is an SDS primary system.";
		cc.cnWriteLog(cc.CnLogComment, str, null);	 	
		
	elseif role = SDS_RoleSecondary then
		cnApp.cnDatabaseSubrole	:= system.getDatabaseSubrole();
		
		if cnApp.cnDatabaseSubrole = SDS_SubroleRelational then
			create sdsDba2 transient;
			rpsStorageMode := -1;
			extent := sdsDba2.getRPSStorageModeString(rpsSchemaName, rpsMappingName, rpsStorageMode);
			str		:= "Database is a RPS server (RPS schema '" & rpsSchemaName & "', RPS Mapping '" & rpsMappingName & ", " & extent & ").";
			cc.cnWriteLog(cc.CnLogComment, str, null);	 	

			if rpsStorageMode = sdsDba2.RpsStorageMode_MappedExtent then
				// identify whether CardSchema classes CnRoot and CnLockTarget is mapped
				self.zCheckMappedExtentClasses(rpsMappingName);
			endif;

		else
			str		:= "Database is an SDS secondary system.";
			cc.cnWriteLog(cc.CnLogComment, str, null);	 	
		endif;
	endif;
	
	if role = SDS_RoleSecondary and 
	   cc.appName <> CN_KCCMGR 	then
		cc.cnWriteLog(cc.CnLogComment, cc.appName & " is running in SDS Secondary .... checking that read access is available...", null);
		
		while true do
			if not cnApp.cnSdsReadAccessEnabled() then
				cc.cnWriteLog(cc.CnLogComment, "Database read access is not yet available - process will wait.", null);
				if processApp.applicationType = processApp.ApplicationType_GUI then
					if cnApp.msgBox("Database read access is currently disabled : application " & cc.appName &
								  " cannot start yet.", "Warning : SDS Secondary Database", MsgBox_Retry_Cancel + 48) <> MsgBox_Return_Retry then
						cnApp.cnTerminate();
					endif;
					
				else
					process.sleep(5000);
				endif;
				
			else
				cc.cnWriteLog(cc.CnLogComment, "Database read access now available .... continuing...", null);	
				break;
			endif;
		endwhile;
	endif;

	create applArray transient;
	process.getAllApps(applArray);
	sz := applArray.size();
	if processApp <> app or 
	   sz > 1 then
		cc.cnWriteLog(cc.CnLogComment, "Application's schema or superschema has imported packages, number of applications = " & sz.String, null);
	endif;
	
	cc.cnWriteLog(cc.CnLogComment, "TCP/IP defaults : max message body size =" & cc.maxMessageSize.String & " bytes (octets), " &
								   "header length = " & cc.headerLength.String & " bytes (octets)", null);
	if cnApp.cnIsServerApp then
		compname := cnApp.cnComputerName();																						// PAR 619
		if compname = "<unavailable>" then																						// PAR 619
			compname := self.networkAddressNode;																				// PAR 619
		endif;																													// PAR 619
		
		cc.cnWriteLog(cc.CnLogComment, "Application is executing on server node (server application) at " & compname & ".", null);	// PAR 619

	elseif process.isUsingThinClient() then
		if processApp.isPortableGui() then
			str	:= CN_PORTABLE_GUI;
			
		else
			str	:= CN_JADE_EXE;
		endif;
		
		cc.cnWriteLog(cc.CnLogComment, "Application execution is using a JADE thin client " & str & " via jadapp/jadappb.", null);
		cc.cnWriteLog(cc.CnLogComment, "Thin client is " & cnApp.cnComputerName & " (" & self.networkAddressProcess & ").", null);		// PAR 441
		str	:= "Thin client platform type =";
		if cnApp.cnThinClientOSIsWindows()	then
			str	:= str & "Windows";
			
		elseif cnApp.cnThinClientOSIsWindowsMobile() then
			str	:= str & "Windows Mobile";
		
		else
			str	:= str & "<unknown OS platform '" & cnApp.cnThinClientOSPlatform.String & "'>";
		endif;
		
		str	:= str & ", OS version=" & cnApp.cnThinClientOSVersion & ", architecture=";
		if cnApp.cnThinClientOSArchitecture = Node.Architecture_32Big_Endian then
			str	:= str & "Architecture_32Big_Endian";
			
		elseif cnApp.cnThinClientOSArchitecture = Node.Architecture_32Little_Endian then
			str	:= str & "Architecture_32Little_Endian";
			
		elseif cnApp.cnThinClientOSArchitecture = Node.Architecture_64Big_Endian then
			str	:= str & "Architecture_64Big_Endian";

		elseif cnApp.cnThinClientOSArchitecture = Node.Architecture_64Little_Endian then
			str	:= str & "Architecture_64Little_Endian";
			
		elseif cnApp.cnThinClientOSArchitecture = Node.Architecture_Gui then
			str	:= str & "Architecture_Gui (currently Windows 32 bit little endian)";
		endif;
		
		str := str & ", distribution=" & tcDistribution;

		cc.cnWriteLog(cc.CnLogComment, str, null);
		
	elseif node.isApplicationServer then
		cc.cnWriteLog(cc.CnLogComment, "Application is executing in app server node (JADAPP) on " & cnApp.cnComputerNameAppServer &
									   " (" & self.networkAddressNode & ").", null);				   	// PAR 441
									   
	else
		if processApp.isPortableGui() then
			str	:= CN_PORTABLE_GUI;
			
		else
			str	:= CN_JADE_EXE;
		endif;
		
		cc.cnWriteLog(cc.CnLogComment, "Application is executing out of a fat client " & str & " on " &
										cnApp.cnComputerName & " (" & self.networkAddressProcess & ").", null);	
	endif;

	if node.isReadOnlySchema then
    	cc.cnWriteLog(cc.CnLogComment, "Node is using read-only schema.", null);
    endif;

	signonUsage := process.getSignOnUsage();
	if signonUsage = process.SignOn_Usage_NoAudit then
		cc.cnWriteLog(cc.CnLogComment, "Process signed on as No_Audit", null);
	
	elseif signonUsage = process.SignOn_Usage_OdbcLogin then
		cc.cnWriteLog(cc.CnLogComment, "Process signed on as ODBC LogIn", null);
	
	elseif signonUsage = process.SignOn_Usage_ReadOnly then
		cc.cnWriteLog(cc.CnLogComment, "Process signed on as ReadOnly", null);
	
	elseif signonUsage = process.SignOn_Usage_Update then
		cc.cnWriteLog(cc.CnLogComment, "Process signed on as Update", null);
	
	else
		cc.cnWriteLog(cc.CnLogComment, "Process sign on is **unknown**", null);
	endif;
	if process.isUsingThinClient then
		if cnApp.cnComputerNameAppServer = cc.myTransientGlobal.cnGetServerComputerName then
			cnApp.setCnAppServerIsOnServer(true);
		endif;
	endif;
	
	on LockException do null;

	if cnApp.cnExceptionHandlerType > 0 then											// set up by user before instantiating CnKarmaCntrl,
		cc.setExceptionHandlerType(cnApp.cnExceptionHandlerType);						// overrides .ini file setting.
	endif;

	if cc.exceptionHandlerType <> cc.Exception_Handler_Jade then						// use CardSchema handlers
		on Exception do cnApp.cnGlobalExceptionHandler(exception) global;				// tcp exception handler gets armed separately in listen or open methods
		on LockException do cnApp.cnGlobalLockExceptionHandler(exception) global;		//
		on DeadlockException do cnApp.cnGlobalDeadlockExHandler(exception) global;
		str := ".";
		if cnApp <> app then
			str := " in application " & app.cnGetClassAndOid(app) & " context.";
		endif;
		
		if cnApp.cnIsServerApp then
			cc.cnWriteLog(cc.CnLogComment, "CardSchema exception handlers (deadlock, lock, global) now armed" & str, null);
		
		else
			cc.cnWriteLog(cc.CnLogComment, "CardSchema client exception handlers (deadlock, lock, global) now armed" & str, null);
		endif;
		
		if cnApp.isMultiUser() and not cnApp.cnIsServerApp then
			cnApp.cnArmServerGlobalExceptHandler();
			cnApp.cnArmServerLockExceptHandler();
			cnApp.cnArmServerDeadlockExHandler();
			cc.cnWriteLog(cc.CnLogComment, "CardSchema server exception handlers (deadlock, lock, global) now armed" & str, null);
		endif;
		
		if cc.exceptionHandlerType = cc.Exception_Handler_Jade_Debug then
			cc.cnWriteLog(cc.CnLogComment, "ExceptionHandler=JadeDebug : if invoked, CardSchema's global exception handler " &
										   "will display unhandled exception dialog.", null);
		endif;

	elseif cnApp.cnSystemType > null then						// Joss or Karma
		on LockException do cnApp.cnGlobalLockExceptionHandler(exception) global;
		on DeadlockException do cnApp.cnGlobalDeadlockExHandler(exception) global; 
		cc.cnWriteLog(cc.CnLogComment, "JSM or related app : CardSchema client lock & deadlock exception handlers armed, otherwise ExceptionHandler=Jade", null);
		cnApp.cnArmServerLockExceptHandler();
		cnApp.cnArmServerDeadlockExHandler();
		cc.cnWriteLog(cc.CnLogComment, "JSM or related app : CardSchema server lock & deadlock exception handlers armed, otherwise ExceptionHandler=Jade", null);

	else  
		cc.cnWriteLog(cc.CnLogComment, "CardSchema exception handlers NOT armed - JADE handlers will be used.", null);
	endif;

	create deadlockHandler transient;					// CnDeadLockHandler singelton lasts for life of JADE application
	create paramArray transient;						// CnVariantArray singelton lasts for life of JADE application
	deadlockHandler.setMyParameterArray(paramArray);
	self.myDeadlockHandler	:= deadlockHandler;
	deadlockHandler.beginNotification(self, Cn_Deadlock_Retry_Event, 0, 0);
	beginNotification(process, Cn_Analyze_Transients, Response_Continuous, null);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " armed process notification on Cn_Analyze_Transients (" & Cn_Analyze_Transients.String & ")", null);
	
	create stack transient;								 // CnTransactionStack singelton lasts for life of JADE application
	cnApp.setMyCnTransactionStack(stack);

	cnApp.myCnKarmaCntrl 	:= self;
	app.myCnKarmaCntrl		:= self;		// set up reference for package application
	
	if processApp.applicationType = processApp.ApplicationType_SilverLight then													// PAR 619
		self.setBinPath("<invalid>");																							// PAR 619
	
	else																														// PAR 619
		self.setBinPath(cnApp.cnStandardizePathName(cnApp.getJadeInstallDir));  			// defaults
	endif;																														// PAR 619
	
	self.setBinPathAppServer(cnApp.cnStandardizePathName(cnApp.getJadeInstallDirAppServer));
	self.setDbPath(cnApp.dbPath);
	self.setEnvironmentId();														// if too long can terminate the app
	self.setManagedEnvironmentName(self.environmentId);											// 3.0
	self.setDriveLetter();															// sets it to app server's JadeInstallDir letter
	
	////////  Now check that karma.dll is present  ////////////						
	create karmaFile;
	karmaFile.mode		:= File.Mode_Input;

	if process.isUsingThinClient and not cnApp.cnThinClientOSIsWindowsMobile() then		// excludes Windows Mobile
		karmaFile.usePresentationFileSystem	:= false;
		if cnApp.cnThinClientOSIsWindows() then																					// PAR 574
			karmaLibrary	:= "karma.dll";																						// PAR 574
			karmaBin1		:= "/download/bin";																					// PAR 574
			karmaBin2		:= "/download/c_bin";																				// PAR 574
		
		else																													// PAR 574
			karmaLibrary	:= "libkarma.so";																					// PAR 574
			karmaBin1		:= "/download/bin";																					// PAR 574
		endif;																													// PAR 574

		str2 := tcDistribution & distType;																						// PAR 574
		str  := app.getIniFileNameAppServer();																					// PAR 574
		downLoadDir := app.getProfileStringAppServer(str, str2, "DownLoadDirectory", null);										// PAR 574
		if downLoadDir = null then																								// PAR 574
			karmaDownload := true;			// default to true																	// PAR 574	
			if cc.karmaControl then
				app.cnRaiseAlert("Possible ini file configuration error",														// PAR 574
								 "AppServer ini file '" & str & "' doesn't contain entry for [" & 								// PAR 574
								 str2 & "] DownLoadDirectory, possible thin-client issue.",										// PAR 574
								 "N",																							// PAR 574
								 app.actualTime,																				// PAR 574
								 cc.appName,																					// PAR 574
								 null,																							// PAR 574
								 null);																							// PAR 574
			endif;
		
		else																													// PAR 574
			appServerThinClientDownloadDir := downLoadDir & karmaBin1 & "/" & karmaLibrary;										// PAR 574
			karmaFile.usePresentationFileSystem	:= false;																		// PAR 574
			karmaFile.fileName	:= appServerThinClientDownloadDir;																// PAR 574
			karmaDownload := karmaFile.isAvailable();																			// PAR 574
			if not karmaDownload then
				appServerThinClientDownloadDir := downLoadDir & karmaBin2 & "/" & karmaLibrary;									// PAR 574
				karmaFile.fileName	:= appServerThinClientDownloadDir;															// PAR 574
				karmaDownload := karmaFile.isAvailable();																		// PAR 574
			endif;
		endif;																													// PAR 574

		if processApp.applicationType <> processApp.ApplicationType_SilverLight then											// PAR 619
			karmaFile.usePresentationFileSystem	:= true;			
			karmaFile.fileName	:= self.binPath & "/" & karmaLibrary;															// PAR 574
			if karmaFile.isAvailable() then
				// start of diagnostic for PAR 769
				executeWhen Cn_Debug_KarmaDllBad;
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " thin-client karma.dll is available", null);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " app server thinclient download directory (" & appServerThinClientDownloadDir & 
																	") contains karma.dll = " & karmaDownload.String, null);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " thin client O/S is windows = " & cnApp.cnThinClientOSIsWindows().String, null);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " app.cnComputerName() = " & app.cnComputerName(), null);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " app.cnComputerNameAppServer() = " & app.cnComputerNameAppServer(), null);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " global.cnGetServerComputerName() = " & global.cnGetServerComputerName(), null);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " self.binPath = " & self.binPath, null);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " global.cnGetServerInstallDir() = " & global.cnGetServerInstallDir(), null);
				endExecuteWhen;
				// end of diagnostic for PAR 769
				if karmaDownload then																							// PAR 574
					if cnApp.cnThinClientOSIsWindows() then																		// PAR 574
						on NormalException do app.cnGenericExceptionHandler(exception, Cn_LibraryNotFound, null, karmaFileError);	// PAR 526
						cc.cnWriteLog(cc.CnLogComment, "Thin client has KARMA library, version " & karmaFile.cnGetFileVersion, null);
						on NormalException do null;																				// PAR 526
						
						if karmaFileError then																						// PAR 526
							cc.cnWriteLog(cc.CnLogComment, "Thin client has KARMA library, error getting version", null);			// PAR 526
							cnApp.msgBox("Incompatible version of " & karmaLibrary.toUpper() & " in your binaries directory." & 	// PAR 526
											CrLf & karmaFile.fileName, "Fatal Error", 48);											// PAR 526
							cnApp.cnTerminate();																					// PAR 526
						endif; 																										// PAR 526
							
						clientHasKarmaDll := true;
						if not self.checkDllType(karmaFile) then
							cnApp.msgBox("Incompatible version of " & karmaLibrary.toUpper() & " in your binaries directory." & 	// PAR 526
											CrLf & karmaFile.fileName, "Fatal Error", 48);											// PAR 526
							cnApp.cnTerminate();																					// PAR 526
						endif; 		
					
					else
						cc.cnWriteLog(cc.CnLogComment, "Thin client has KARMA library.", null);
					endif;
	
				elseif app.cnComputerName() = app.cnComputerNameAppServer() 				and										// PAR 608
					   app.cnComputerName() = global.cnGetServerComputerName() 				and										// PAR 608
					   self.binPath.toLower() = global.cnGetServerInstallDir().toLower() 	then									// PAR 608, 782
					cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & 															// PAR 608
										" Thin-client, AppServer and Database Server using common files.", null);					// PAR 608
					
				elseif app.cnComputerName() = app.cnComputerNameAppServer() 				and										// PAR 608
					   self.binPath.toLower() = app.getJadeInstallDirAppServer().toLower() 	then									// PAR 608, 782
					cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & 															// PAR 608
										" Thin-client and AppServer using common files.", null);									// PAR 608

				else
					resultStr := karmaFile.cnRenameFile(karmaFile.fileName & ".bad", 1, 1000);										// PAR 601
					if resultStr = CN_OK then																						// PAR 601
						cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & 															// PAR 574
											" KARMA library located on thin-client but not in AppServer download directory '" &		// PAR 574
											downLoadDir & ", has been renamed.", null);												// PAR 574
											
					else																											// PAR 601
						cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & 															// PAR 601
											" KARMA library located on thin-client but not in AppServer download directory '" &		// PAR 601
											downLoadDir & ", attempt to rename failed : " & resultStr & " : continuing", null);		// PAR 601
					endif;																											// PAR 601
				endif;
				
			elseif cc.appName = CN_JOSS then
				cc.cnWriteLog(cc.CnLogErrors, "Thin client does not have KARMA.DLL in its binaries path - required for JOSS.", null);
				cnApp.msgBox("File KARMA.DLL, required for JOSS thin client, not found in environment binaries." & CrLf &
						   "Expecting " & karmaFile.fileName & " on " & cnApp.cnComputerName & ".", 
						   "Fatal Start Up Error for " & cc.appName, 48);
				cnApp.cnTerminate();
	
			else
				cc.cnWriteLog(cc.CnLogComment, "Thin client does not have KARMA.DLL in its binaries path (information only)", null);
			endif;
		endif;																													// PAR 619
	endif;

	karmaFile.usePresentationFileSystem := false;					// target app server or fat client directories
	if cnApp.cnOSPlatformIsWindows() then
		karmaFile.fileName 	:= self.binPathAppServer & "/karma.dll";
		
	elseif cnApp.cnOSPlatformIsUnix() then
		karmaFile.fileName	:= cnApp.cnGetPath(null, self.environmentId, null, CN_C_LIB, true) & "/libkarma.so"; 
	endif;

	if not karmaFile.isAvailable then
		cc.cnWriteLog(cc.CnLogErrors, "Fatal startup error : file " & karmaFile.fileName & " not found on " & cnApp.cnComputerNameAppServer & ".", null);
		if not cnApp.cnIsServerApp then
			str	:= "File KARMA.DLL not found in environment binaries directory.";
			if cnApp.cnOSPlatformIsUnix then
				str	:= "File 'libkarma.so' not found in environment 'lib' directory.";
			endif;
			
			if processApp.applicationType = processApp.ApplicationType_GUI then
				cnApp.msgBox(str & CrLf & "Expecting " & karmaFile.fileName & " on " & cnApp.cnComputerNameAppServer & ".", 
				  	  	   "Fatal Start Up Error for " & cc.appName, 48);
			endif;
		endif;
		
		cnApp.cnTerminate();
	endif;
	
	if process.isUsingThinClient then
		str := "App server is using KARMA library version ";
		
	else
		str := "Process is using KARMA library version ";
	endif;

	cc.cnWriteLog(cc.CnLogComment, str & karmaFile.cnGetFileVersionAppServer & " at " & karmaFile.fileName, null);
	
	if not self.checkDllType(karmaFile) then
		str		:= "Fatal start up error : wrong DLL version in " & karmaFile.fileName & " on " & cnApp.cnComputerNameAppServer;
		if processApp.applicationType = processApp.ApplicationType_GUI then
			cnApp.msgBox(str, "Fatal Error", 48);
		endif;
		
		cc.cnWriteLog(cc.CnLogErrors, str, null);
		cnApp.cnTerminate();
	endif; 		
	
	create cem transient;
	runningAsService := cem.emIsService();
	if runningAsService then
		cc.cnWriteLog(cc.CnLogComment, "Process is running as a service : further CardSchema output to JADE interpreter window will be suppressed.", null);
		cc.setLogToScreen(false);
		cc.setIsService(true);
		
	else
		str	:= "Process does not appear to be running as a service.";
		if processApp.applicationType <> processApp.ApplicationType_GUI then
			cc.cnWriteLog(cc.CnLogComment, "WARNING : " & str, null);
			
		else
			cc.cnWriteLog(cc.CnLogComment, str, null);
		endif;	 
	endif;
	
	//////   Initialization file housekeeping for 3.1 / JADE 6.1 upgrade : remove mismatch DLL specification  //////////////////
	
	iniFileName		:= cnApp.getIniFileNameAppServer();
	section			:= "JadeClient";
	key				:= "InitializationHandlerLibrary";
	str				:= processApp.getProfileStringAppServer(iniFileName, section, key, null).toLower;
	if str = "mismatch" then
		// only change if we're using JadeAdmin and deploy regime 2 - these require EnableAutoUpdate to be true
		if processApp.getProfileStringAppServer(iniFileName, "JadeAutoUpdate", "EnableAutoUpdate", null).toLower = true.String then
			processApp.setProfileStringAppServer(iniFileName, section, key, "jomsupp");
		endif;
	endif;
	
	//////   Set up CnRoot singleton : note that this is done even when KarmaControl=false  ///// 
	
	root := CnRoot.firstInstance;
	if root = null then
		if cnApp.cnDatabaseSubrole = SDS_SubroleRelational then			// relational population service node
			if rpsStorageMode = jdba.RpsStorageMode_WorkingSet then
				cc.cnWriteLog(cc.CnLogErrors, ">>>> RPS node can't find CnRoot instance in Working Set", null);
				cc.cnWriteLog(cc.CnLogErrors, ">>>> JADECare managed applications are not supported in this mode!", null);
				app.cnTerminate();
			endif;
			
			if rpsStorageMode = jdba.RpsStorageMode_Full then
				cc.cnWriteLog(cc.CnLogErrors, ">>>> RPS node can't find CnRoot instance in Full Extent", null);
				cc.cnWriteLog(cc.CnLogErrors, ">>>> Ensure that KCCMgr has executed on SDS Primary and reclone database", null);
				app.cnTerminate();
			endif;

			if rpsStorageMode = jdba.RpsStorageMode_MappedExtent then
				cc.cnWriteLog(cc.CnLogErrors, ">>>> RPS node can't find CnRoot persistent instance in Mapped Extent", null);
				root := CnRoot.firstSharedTransientInstance();
				if root = null then
					cc.cnWriteLog(cc.CnLogErrors, ">>>> RPS node can't find CnRoot sharedTransient instance", null);
					if node.isServerNode() then
						cc.cnWriteLog(cc.CnLogErrors, ">>>> Running in server node but unable to start until KCCMgr is running", null);
					
					else
						cc.cnWriteLog(cc.CnLogErrors, ">>>> Options: ", null);
						cc.cnWriteLog(cc.CnLogErrors, ">>>>          - execute application in database server node;  or", null); 
						cc.cnWriteLog(cc.CnLogErrors, ">>>>          - define CnRoot and CnLockTarget as Mapped Classes in schema '" & rpsSchemaName & 
															"' RPS Mappings '" & rpsMappingName & "'; or", null);
						cc.cnWriteLog(cc.CnLogErrors, ">>>>          - do not activate KarmaControl in this application", null);
					endif;

					app.cnTerminate();
				endif;


				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " obtained CnRoot shared transient", null);
			
			else
				cc.cnWriteLog(cc.CnLogErrors, ">>>> RPS node can't find CnRoot instance in this Unknown Extent (" & rpsStorageMode.String & ")", null);
				cc.cnWriteLog(cc.CnLogErrors, ">>>> Ensure that KCCMgr has executed on SDS Primary and reclone database", null);
				app.cnTerminate();
			endif;
		endif;

		if root = null then
			glob	:= GCardSchema.firstInstance;
			exclusiveLock(glob);							// single thread thru this next bit - only want one root object
			root	:= CnRoot.firstInstance;
			if root = null then
				if not process.isInTransactionState() then																		// PAR 600
					beginTransaction;																							// PAR 600
					iSetXnState := true;																						// PAR 600
				endif;																											// PAR 600
				
				create root;
				if iSetXnState then																								// PAR 600
					commitTransaction;																							// PAR 600
					iSetXnState := false;																						// PAR 600
				endif;																											// PAR 600
				
			else
				unlock(glob);	
			endif;
		endif;
	endif;

	statsInterval	:= processApp.getProfileStringAppServer(processApp.getIniFileNameAppServer, "JSMStats", "TranStatsInterval", "0").Integer;
	if not cc.karmaControl then
		if cc.appName.cnStartsWithJoss()	 or
	       cc.appName.cnStartsWithKarma()	 then
			cc.cnWriteLog(cc.CnLogErrors, ">>>> Ini file option [Karma] KarmaControl must be set to 'true' for JSM/JSA applications .... terminating.", null);
			cnApp.cnTerminate();
		
		elseif cc.appName = CN_KCCMGR and 
		       statsInterval = null then
			cc.cnWriteLog(cc.CnLogErrors, ">>>> Ini file option [Karma] KarmaControl must be set to 'true' for KCCMgr when [JSMStats] TranStatsInterval=0 .... terminating.", null);
			cnApp.cnTerminate();
		endif;
	endif;
	
	cnApp.setMyCnRoot(root);
	app.setMyCnRoot(root);			// ensure package application context matches
	
	if self.isMultiUserCapable() 		or 																						// PAR 6732
	   cc.appName = CN_KCCMGR 			or 
	   cc.appName = CN_KCNODECONTROL 	then			
		establishNodeControl();								// PAR 230 : don't start KCNodeControl in single user except for KCCMgr.
		
	else
		cc.cnWriteLog(cc.CnLogComment, "Running singleUser mode : node sampling control app (KCNodeControl) won't be established.", null);
	endif;											
	
	ignoreKarmaControl := app.cnGetCardSchemaVersion().cnMarkRelease() < 34 		and
							(osArchitecture = Node.Architecture_64Big_Endian 	or					// temporary for JADE 6.3 64-bit only until release of 3.4 CardSchema
							 osArchitecture = Node.Architecture_64Little_Endian);					// temporary for JADE 6.3 64-bit only
	if not cc.karmaControl or
	   ignoreKarmaControl  then
		self.tranStatsInterval	:= statsInterval;
		// as non-managed environment may still want to execute KCCMgr for stats collection, we need to define MasterEnvironmentId
		self.masterEnvironmentId	:=  cnApp.cnGetProfileStringServer("AppEnvironment", "MasterEnvironmentId", self.environmentId).toUpper;
		if ignoreKarmaControl then
			cc.cnWriteLog(cc.CnLogComment, "Karma Application Management unavailable for JADE 6.3 64-bit release.", null);
			cc.setKarmaControl(false);
			
		else  // not karmaControl
			cc.cnWriteLog(cc.CnLogComment, "Karma Application Management is NOT active.", null);
		endif;
		
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " TranStatsInterval=" & tranStatsInterval.String & " for this process.", null);
		if statsInterval > null then
			beginTimer(tranStatsInterval * 1000, Timer_OneShot, self.Tran_Stats_Timer);
			if cc.appName = CN_KCCMGR then																						// PAR 977
				app.startApplication(CN_CARDSCHEMA, CN_KCSTATSCOLLECTOR);														// PAR 977
			endif;																												// PAR 977
			
			if cc.appName = CN_KCSTATSCOLLECTOR then																			// PAR 977
				create tranData transient;						// this is the object that temporarily caches all stats for the application
				self.myTransactionData	:= tranData;			// prior to sending them to JSM (if managed) for storage in the database.
				self.setUpTranLogFile();
				
			else
				create cnproc transient;						// in client, used for temporary statistics store.
				cnproc.setMyProcess(process);					// This assignment really only for debug at present
				self.setMyCnProcess(cnproc);
			endif;
		endif;
    	   	
		if cc.appName <> CN_KCONLINEBACKUPWORKER 		and 
		   cc.appName <> CN_KCVERIFYJOURNAL 	 		and
		   cc.appName <> CN_KCONLINEPARTITIONWORKER 	 and
		   signonUsage <> process.SignOn_Usage_OdbcLogin and	
		   signonUsage <> process.SignOn_Usage_ReadOnly then	// can't update when db is in archive mode or if readonly or odbclogin
			if not process.isInTransactionState() then																			// PAR 600
				beginTransaction;																								// PAR 600
				iSetXnState := true;																							// PAR 600
			endif;																												// PAR 600

			process.adminInfo 	:= cc.appName;					// so other apps can use this
			if process.userInfo = null then
				process.userInfo := cc.appName;					// retained for consistency with prior version, not now used by CardSchema
			endif;
			if iSetXnState then																									// PAR 600
				commitTransaction;																								// PAR 600
				iSetXnState := false;																							// PAR 600
			endif;																												// PAR 600
		endif;
		
		return;												// Non-managed apps exit here
	endif;

	///////////////////////////////////////////////   KarmaControl is ACTIVE   /////////////////////////////////////////////////////////////

    result	:= getProcessId(pid);
    if result <> 0 then
    	cc.cnWriteLog(cc.CnLogErrors, "CnKarmaCntrl::getProcessId had unexpected error, result=" & result.String, null);
    endif;
    
    cc.cnWriteLog(cc.CnLogComment, "Karma Application Management is ACTIVE for this app : operating system PID=" & pid.String &
    							   ", node name=" & node.name & ".", null);
    proc := Process.firstInstance.Process;
    if proc.adminInfo = self.System_Stopping then
    	cc.cnWriteLog(cc.CnLogComment, "System is stopping ... application will be terminated.", null);
    	if processApp.applicationType = processApp.ApplicationType_GUI then
	    	create frm;
	    	frm.message 	:= "Sorry, but this application's database server is in the process of being shut down." & CrLf & 
	    						"The system is not currently available.";
	    	frm.delay		:= 5;
	    	frm.denyStartup	:= true;
	    	frm.show;
	    	frm.refreshNow;
	    	return;

		else
			cnApp.cnTerminate();
	    endif;
    endif;
    
    cc.cnWriteLog(cc.CnLogComment, "Application is armed for system shut down :  event type = " & cc.systemShutDownEvent.String, null);
    
	create clusterInfo transient;							// CnClusterInfo singelton lasts for life of JADE application
	cnApp.setMyCnClusterInfo(clusterInfo);
	if clusterInfo.virtualMachineName <> null then
		cc.cnWriteLog(cc.CnLogComment, "Node appears to be a cluster resource : virtualMachineName=" & clusterInfo.virtualMachineName, null);
	else
		cc.cnWriteLog(cc.CnLogComment, "Node is not currently a cluster resource.", null);
	endif;
	
	if system.getDatabaseRole <> SDS_RoleUndefined then
		self.masterEnvironmentId	:= cnApp.cnGetProfileStringServer("AppEnvironment", "MasterEnvironmentId", null).toUpper;
		if masterEnvironmentId = null then								// use primary environment id instead
			cc.cnWriteLog(cc.CnLogErrors, ">>>>>>  MasterEnvironmentId not defined in [AppEnvironment] section of database server's ini file. " & 
										  "This MUST be supplied : application terminating now <<<<<<<", null);
			cnApp.cnTerminate();
		endif;
		
	else
		self.masterEnvironmentId	:=  cnApp.cnGetProfileStringServer("AppEnvironment", "MasterEnvironmentId", self.environmentId).toUpper;
	endif;
	
	cc.cnWriteLog(cc.CnLogComment, "Master environment id=" & self.masterEnvironmentId.toUpper &", local environment id=" & self.environmentId, null);
	if cc.appName = CN_KCCMGR and																								// PAR 635 - only if managed service
	   cc.karmaControl        then
		resultStr := self.zCheckJadeAutoUpdateRequired();																		// JSM PAR 6732
		if resultStr <> CN_OK then																								// JSM PAR 6732
			cc.cnWriteLog(cc.CnLogErrors, resultStr, null);																		// JSM PAR 6732
			executeWhen not Cn_Ignore_JadeAutoUpdate;																			// JSM PAR 6732
			cnApp.cnTerminate();																								// JSM PAR 6732
			endExecuteWhen;																										// JSM PAR 6732
		endif;
	endif;
	
	if cc.appName = CN_KCCMGR 		or 
	   cc.appName = CN_JOSSCOMMSMGR then
		if system.getDatabaseRole() = SDS_RoleSecondary then
			cc.cnWriteLog(cc.CnLogComment, "CnRoot not updated with cluster details : system is SDS secondary.", null);
			
		elseif runningAsService and processApp.isMultiUser() then		// store database server's cluster details in Root :
			if not process.isInTransactionState() then																			// PAR 600
				beginTransaction;																								// PAR 600
				iSetXnState := true;																							// PAR 600
			endif;																												// PAR 600

			//															// This is so that when KCCMgr is run as a single-user
			root.loadClusterInfo(clusterInfo);							// service (backups), he can still report cluster info.
			if iSetXnState then																									// PAR 600
				commitTransaction;																								// PAR 600
				iSetXnState := false;																							// PAR 600
			endif;																												// PAR 600
			
		else
			cc.cnWriteLog(cc.CnLogComment, "CnRoot not updated with cluster details : emIsService=" & runningAsService.String &
										   ", app.isMultiUser=" & processApp.isMultiUser().String, null);
			if root.virtualMachineName <> null and not root.possibleHosts.includes(cnApp.cnComputerName.toUpper) then
				foreach str2 in root.possibleHosts do
					str	:= str & str2 & " ";
				endforeach;
				
				cc.cnWriteLog(cc.CnLogErrors, "CnRoot indicates that this environment has previously been clustered, but current host (" & 
				  		   					  cnApp.cnComputerName.toUpper & ") is not one of the possible hosts (" & str & ") : ", null);
				cc.cnWriteLog(cc.CnLogErrors, "This suggests that the database has been relocated or refreshed. Now wiping old cluster info.", null);
				if not process.isInTransactionState() then																		// PAR 600
					beginTransaction;																							// PAR 600
					iSetXnState := true;																						// PAR 600
				endif;																											// PAR 600

				root.clearClusterInfo();
				if iSetXnState then																								// PAR 600
					commitTransaction;																							// PAR 600
					iSetXnState := false;																						// PAR 600
				endif;																											// PAR 600
			endif;  
		endif;					 
	endif;													

	////  Now if the client is running on its own binaries, check that binaries version		///////
	////  control file matches server version control file.									///////
	////  First determine where the binaries are ......										///////
	
	//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : computer='" & app.cnComputerName & "', serverComputer=" & cc.myTransientGlobal.cnGetServerComputerName &
	//			      "', clientPath='" & app.cnStandardizePathName(app.getJadeInstallDirAppServer) & "', serverPath='" &
	//			      cc.myTransientGlobal.cnGetServerInstallDir() & "'", null);

	if self.driveLetter = "\" then		//  part of UNC name or Linux OS
		if cnApp.cnComputerName = cc.myTransientGlobal.cnGetServerComputerName and
		   self.binPathAppServer.toLower() = cc.myTransientGlobal.cnGetServerInstallDir.toLower() then	// new condition for 2.8
			clientOnServer := true;												
			cc.cnWriteLog(cc.CnLogComment, "Client is using same binaries as database server, " &
									       "so won't perform version control checks.", null);
										   
		else
			array := self.binPathAppServer.cnGetTokensUsingTruthSet("\/");
            if array[1].toLower <> cc.myTransientGlobal.cnGetServerComputerName.toLower then
				cc.cnWriteLog(cc.CnLogErrors, "Unexpected condition : binaries path not pointing to server or own disk. " &
											  "Path=" & self.binPathAppServer, null);
				if cnApp.cnApplicationType = cnApp.ApplicationType_GUI then
					cnApp.msgBox("Unexpected condition : binaries path not pointing to server or own disk." & CrLf &
							   "This is not a permitted configuration for CardSchema.", "Setup Error", 48);
				endif;
				
				delete array;
				cnApp.cnTerminate();
			endif;
		endif;

	elseif cnApp.cnComputerName = cc.myTransientGlobal.cnGetServerComputerName and
		   cnApp.cnStandardizePathName(cnApp.getJadeInstallDirAppServer).toLower = cc.myTransientGlobal.cnGetServerInstallDir.toLower then	// PAR 238
		clientOnServer := true;
		cc.cnWriteLog(cc.CnLogComment, "Client is on server computer and is using server binaries, " &
									   "so won't perform version control checks.", null);

	elseif clientHasKarmaDll then
		result := cnApp.cnGetDriveMapping(self.binPath[1] & ":", mapname, errText);
		if result = 0 then														// drive is mapped to server
			clientOnServer := true;
			cc.cnWriteLog(cc.CnLogComment, "Client appears to be using server binaries via mapped share, " & 
						  				   "so won't perform version control checks.", null);

		elseif result <> 2250 then												// 2250 is local drive
			str	:= "Problem with getDriveMapping function, result=" & result.String & " : " & errText;
			if self.binPath[1:2] = "\\" and process.isUsingThinClient and result = 1200 then
				cc.cnWriteLog(cc.CnLogErrors, str, null);
			else											
				cc.cnWriteLog(cc.CnLogErrors, str & " : terminating.", null);
				cnApp.cnTerminate();
			endif;	
		endif;
	endif;


	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	result := self.getAddressInfo(ipaddress, fqdn);
	if result <> 0 then
		str := "App=" & cc.appName & ", proc.user=" & process.userCode &
			   ": error for IP address '" & ipaddress & "' in CnKarmaCntrl::getAddressInfo, result=" & result.String;
		cc.cnWriteLog(cc.CnLogErrors, str , null);
		cnApp.msgBox("Application program error on start up : contact your help desk " &
				    "or developer." & CrLf & str & CrLf & Lf &
				    "Note that this application cannot be run in SingleUser mode : attempting to " &
				    "run this way is a possible cause of your problem.",
				    "Fatal Startup Error", 0);
		cnApp.cnTerminate();
	endif;
	
	// 														// Note that for any client that runs on server's host, this
 	//														// returns localhost/127.0.0.1.  Karma/JossCommsMgr will fix      
 	//														// in CnMessage::receiveMsg by substituting correct address if 
 	//														// necessary.  These address properties of CnKarmaCntrl are
 	//														// also updated in CnKarmaTcpConnection::openNotify and 
 	//														// JossTcpConnection::openNotify/listenNotify.
 	self.setLocalIpAddress(ipaddress);
 	if fqdn <> null then
 		self.setLocalFQDN(fqdn);
 	else
 		self.setLocalFQDN(cnApp.cnComputerNameAppServer);		// no DNS
 	endif;
	 	
 	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " fqdn=" & fqdn & ", self.localFQDN=" & self.localFQDN & ", ip=" & ipaddress, null);

  	if cc.appName = CN_KCCMGR then
 		create dba transient;									// JadeDataBaseAdmin singelton lasts for life of JADE application
 		cnApp.setMyDba(dba);
 		beginNotification(dba, dba.LogTransferEvent, 0, 0);		// set up for log transfer notifications
 		create sdsDba transient;								// CnSDSDatabaseAdmin object for SDS operations, monitoring etc,
		sdsDba.initializeKCCMgr();										// but we use it for non-SDS systems too
		
	elseif cc.appName = CN_KCSDSCHECKS then																						// PAR 964
		create sdsDba transient;																								// PAR 964
		sdsDba.initializeKCSDSChecks();																							// PAR 964
 	endif;
 	
 	if cc.clientTranStats 		and 
	   cc.appName <> CN_KCCMGR 	then
		create cnproc transient;					// in client, used for temporary statistics store.
		cnproc.setMyProcess(process);				// This assignment really only for debug at present
		self.setMyCnProcess(cnproc);

		if cc.appName = CN_JOSSCOMMSMGR 	or 
		   cc.appName = CN_KARMACOMMSMGR 	then
			cnproc.setProcessId(cnGetInstanceId(process));
			cnproc.setClientTranStats(true);
		endif;
		
		beginNotification(process, Cn_Tran_Stats_Timer_Change, 0, 0); 		
	endif;

	self.beginNotification(process, Cn_Launch_Application_Process, 0, 0);														// PAR 963
	self.beginNotification(process, CN_COMPACT_TRANSIENT_FILE, Response_Continuous, null);										// PAR 1014
	////////  Now set up for non-manangement apps   //////////////

 	if cc.appName <> CN_KCCMGR 			and
	   cc.appName <> CN_KARMACOMMSMGR	and
	   cc.appName <> CN_JOSSCOMMSMGR 	then
		if cnApp.cnSystemType = CN_SYSTEMTYPE_JSA and																			// PAR 6732
		   cc.appName = CN_KARMABATCHINTERFACE	  and																			// PAR 6732
		   not self.isMultiUserCapable() 		  then																			// PAR 6732
 			str := "Application is not multi-user capable : can't start JSA background client in this mode";					// PAR 6732
 			cc.cnWriteLog(cc.CnLogComment, str, null);
 			return;
 		endif;

        if cnApp.cnSystemType = CN_SYSTEMTYPE_USER	then																		// PAR 6732
			if cc.appName = CN_KCDUMMY      or																					// PAR 6732
			   cc.appName = CN_KCBATCH		then																				// PAR 6732
				if not self.isMultiUserCapable() then																			// PAR 6732
					str := "Application is not multi-user capable : can't start background client in this mode";				// PAR 6732
					cc.cnWriteLog(cc.CnLogComment, str, null);
					return;
				endif;																											// PAR 6732
			endif;																												// PAR 6732
        endif;																													// PAR 6732

		if cnApp.cnSystemType = CN_SYSTEMTYPE_JSM or																			// PAR 6732
		   cnApp.cnSystemType = CN_SYSTEMTYPE_JSA then																			// PAR 6732
			if cc.appName[1:5] <> CN_KARMA 		and 																			// PAR 6732
			   cc.appName[1:2] <> "KC" 			and 																			// PAR 6732
			   cc.appName <> CN_KCNODECONTROL 	then	// probably developer testing own clients								// PAR 6732
				if not self.isMultiUserCapable() then	 																		// PAR 6732
					str := "Application is not multi-user capable : can't start Karma/Joss background client in this mode";		// PAR 6732
					cc.cnWriteLog(cc.CnLogComment, str, null);
					return;
				endif;																											// PAR 6732
			endif;																												// PAR 6732
 		endif;																													// PAR 6732

		if cnApp.cnSystemType = CN_SYSTEMTYPE_JSM then
	   		self.findBackgroundCommsMgr(CN_JOSSCOMMSMGR);	
			
	   	elseif cnApp.cnSystemType = CN_SYSTEMTYPE_JSA then
	   		self.findBackgroundCommsMgr(CN_KARMACOMMSMGR);
			
	   	elseif cnApp.cnSystemType = CN_SYSTEMTYPE_USER then
			if self.isMultiUserCapable() then																					// PAR 1060
				self.findBackgroundCommsMgr(CN_KCCMGR);			// we don't get past here if not found i.e. can't run apps	
			
			else																												// PAR 1060
				cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " singleUser application, background client not required.", null);	// PAR 1060
			endif;																												// PAR 1060
			
		else
        	cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " went looking for background client, didn't find valid branch.", null);
		endif;

		beginNotification(process, Cn_Message_To_Client, 0, 0);
		beginNotification(process, Cn_Session_Open_Advice_Request, 0, 0);		
		beginNotification(process, cnApp.myCnCntrl.Cn_Control_Command, 0, 0);

		///////  Now send the session open advice message   /////////
		if not cnApp.cnUsedActivateMethod then				// constructor called directly from app, rather than use app::activateKarmaControl
        	self.issueSessionOpenAdvice();
			if node.isApplicationServer() then
				self.getAndSendSSLDetails();
			endif;
		endif;
	endif;
	
	if cc.appName <> CN_KCONLINEBACKUPWORKER 		and 
	   cc.appName <> CN_KCVERIFYJOURNAL 	 		and
	   cc.appName <> CN_KCONLINEPARTITIONWORKER 	and
	   signonUsage <> process.SignOn_Usage_OdbcLogin and	
	   signonUsage <> process.SignOn_Usage_ReadOnly then	// can't update when db is in archive mode or if readonly or odbclogin
		if not process.isInTransactionState() then																				// PAR 600
			on SystemException do app.cnGenericExceptionHandler(exception, Cn_DatabaseLockedForReorganize, null, lockedForReorg);// PAR 1007
			beginTransaction;																									// PAR 600
			if not lockedForReorg then																							// PAR 1007
				iSetXnState := true;																							// PAR 600
			endif;
		endif;																													// PAR 600
		
		if not lockedForReorg then																								// PAR 1007
			process.adminInfo 	 := cc.appName;				
			if process.userInfo = null then
				process.userInfo := cc.appName;				// behaviour consistency with prior versions of CardSchema, but
			endif;											// no longer used by CardSchema
			if iSetXnState then																									// PAR 600
				commitTransaction;																								// PAR 600
				iSetXnState := false;																							// PAR 600
			endif;																												// PAR 600
		endif;																													// PAR 1007
	endif;
	
	if cc.appName = CN_KCSTATSCOLLECTOR 	or 				// changed 3.8.09, was KCCMgr										// PAR 977
	   cc.appName = CN_JOSSSTATSCOLLECTOR 	or 				// changed 3.8.06, was JossCommsMgr
	   cc.appName = CN_KARMACOMMSMGR 		then
		self.setUpTranLogFile();
		create tranData transient;						// this is the object that temporarily caches all stats for the application
		self.myTransactionData	:= tranData;			// prior to sending them to JSM for storage in the database.
	endif;
epilog
	delete resultsArray;
	delete file;
	delete karmaFile;
	delete tcFile;
	delete appServerFile;
	delete sdsDba2;
	delete jdoNode;
	delete jdoProcess;
	delete cem;
	delete applArray;
	delete array;
end;
}
decodeTransactionStatsHeader
{
decodeTransactionStatsHeader(pUserInfo 			: Binary;
							 pComputerName,
							 pComputerNameNode,																					// PAR 980
							 pNetworkAddress,
							 pUserName,
							 pAppName			: String output;
							 pNodeStats			: Boolean output) : Integer;

vars
	len,
	pos				: Integer;
begin
	pos := 1;
	// computer name (can be thinclient workstation)
	len := pUserInfo[pos:4].Integer;
	pos := pos + 4;
	pComputerName := pUserInfo[pos:len].ansiToString();
	pos := pos + len;
	
	// node computer name																										// PAR 980
	len := pUserInfo[pos:4].Integer;																							// PAR 980
	pos := pos + 4;																												// PAR 980
	pComputerNameNode := pUserInfo[pos:len].ansiToString();																		// PAR 980
	pos := pos + len;																											// PAR 980

	// network address (can be IPv4 or IPv6)
	len := pUserInfo[pos:4].Integer;
	pos := pos + 4;
	pNetworkAddress := pUserInfo[pos:len].ansiToString();
	pos := pos + len;
	
	// user name
	len := pUserInfo[pos:4].Integer;
	pos := pos + 4;
	pUserName := pUserInfo[pos:len].ansiToString();
	pos := pos + len;
	
	// application name
	len := pUserInfo[pos:4].Integer;
	pos := pos + 4;
	pAppName := pUserInfo[pos:len].ansiToString();
	pos := pos + len;
	
	// node statistics
	pNodeStats := pUserInfo[pos:1].ansiToString().Character.Boolean;
	pos := pos + 1;
	return pos;
end;
}
delete
{
delete() updating;

vars
	cc : CnCntrl;
begin
	cc := app.myCnCntrl;
	if cc <> null 				and 
	   cc.clientTranStats 		and 
	   cc.appName <> CN_KCCMGR 	then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " deleting CnKarmaCntrl, send outstanding transaction stats packet", null);
		self.handleTranStatsRequestEvent();
	endif;

 	endNotificationForSubscriber(self);
/*	code coverage
	if cc <> null and cc.karmaControl then
		self.executeJadeProfiler(false);
	endif;
*/
end;
}
deleteFile
{
deleteFile(fileName : String) : Boolean;

vars
	int,
	result		: Integer;
	
	cc			: CnCntrl;

	errortext,
	str			: String;
	
	cem			: CnExternalMethods;
	
	file		: File;
begin
 	cc := app.myCnCntrl;

	create file transient;
	result	:= file.emDeleteFile(fileName);
    str		:= "Delete of " & fileName;

	if result = null then 
 		cc.cnWriteLog(cc.CnLogDiag, str & " was successful", null); 	
 		return true;
	endif;
	
	create cem transient;
	int	:= cem.emGetErrorText(result, errortext, 127);
	if int <> 0 then
		cc.cnWriteLog(cc.CnLogErrors, "CnExternalMethods::emGetErrorText got error result=" & int.String, null);
	endif;
	
	str := str & " not done, result=" & result.String & ":" & errortext;
	cc.cnWriteLog(cc.CnLogErrors, str, null); 
	return false;
epilog
	delete cem;
	delete file;
end;
}
displayClientStartupProgress
{
displayClientStartupProgress(schemaName, backgroundClientName : String; labeldata : String) : Process updating;

vars
	frm 				: KCMLoading;
	proc 				: Process;
	retry 				: Integer;
	kccMgrStartDelay 	: Integer;
	cc					: CnCntrl;
	cnApp				: CardSchema;
begin
	cnApp := process.getProcessApp().CardSchema;
	if cnApp.cnForeignApp then								// for VB apps
		return getClientProcessObject(backgroundClientName);
	endif;

	cc 			 	 := cnApp.myCnCntrl;
	kccMgrStartDelay := app.getProfileStringAppServer(app.getIniFileNameAppServer, "Karma", "KCCMgrStartDelay", "45").Integer;

	if not cnApp.cnIsServerApp 										and
	   not cc.suppressManagementDialogs 							and
	   cnApp.cnApplicationType <> app.ApplicationType_Non_GUI 		and
	   cnApp.cnApplicationType <> app.ApplicationType_Non_GUI_Web	and
	   cnApp.cnApplicationType <> app.ApplicationType_SilverLight	and															// PAR 1083
	   cnApp.cnApplicationType <> app.ApplicationType_Non_GUI_Rest	and															// PAR 1083
	   cnApp.cnApplicationType <> app.ApplicationType_Rest_Services	then														// PAR 1083
		create frm;
		frm.left 	:= 25;
		frm.top 	:= 40;

		if cnApp.name = "Karma" then
			frm.laClientName.caption := "JADECare Systems Agent background client -";
			
		elseif cnApp.name = "Joss" then
			frm.laClientName.caption := "JADECare Systems Manager background client -";
		endif;

		if labeldata <> null then
			frm.label1.caption := labeldata;
		endif;

		frm.show;
		frm.pgBar.partsInJob := kccMgrStartDelay;				// set up progress bar
		frm.refreshNow;
	endif;

	cc.cnWriteLog(cc.CnLogDiag, "Waiting for KCCMgr to start : KCCMgrStartDelay=" & kccMgrStartDelay.String, null);

	while retry < kccMgrStartDelay do
		if frm <> null then
			frm.pgBar.partsDone := retry;
		endif;
		
		process.sleep(1000);								// allow time for KCCMgr to start											
		proc := self.getBackgroundCommsMgrProcess(schemaName, backgroundClientName);
		if proc <> null then
			return proc;
		endif;

		retry := retry + 1;
	endwhile;

epilog
	if frm <> null then
		frm.unloadForm;
	endif;
end;
}
dumpNodeClient
{
dumpNodeClient() clientExecution;

vars
	cc	: CnCntrl;
	
	oid	: String;
begin
	cc := app.myCnCntrl;
	oid :=  node.getOidStringForObject(node);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " forcing processdump of client node " & oid & "....", null);
	node.processDump();
epilog
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & "  completed processdump of client node " & oid, null);
end;
}
dumpNodeServer
{
dumpNodeServer() serverExecution;

vars
	cc	: CnCntrl;
	
	oid	: String;
begin
	cc := app.myCnCntrl;
	oid :=  node.getOidStringForObject(node);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " forcing processdump of server node " & oid & "....", null);
	node.processDump();
epilog
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & "  completed processdump of server node " & oid, null);
end;
}
establishNodeControl
{
establishNodeControl();

constants
	Max_Attempts	: Integer	= 30;
vars
	root			: CnRoot;
	
	nodeControl		: CnNodeControl;
	
	hadError,
	lockAcquired	: Boolean;
	
	lockAttempts,
	retryTimeMs		: Integer;
	
	cc				: CnCntrl;
begin
	cc		:= app.myCnCntrl;
	retryTimeMs := cc.lockRetryTime;
	if retryTimeMs = null then
		retryTimeMs := 60 * 1000;
	endif;
	
	root	:= app.myCnRoot;
	
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, null, hadError);
	nodeControl	:= CnNodeControl.firstSharedTransientInstance();

	if nodeControl = null then
		// single thread by locking CnRoot singleton while setting up node control shared transient (node singleton)
		// We could lock Node here instead of CnRoot, but JADE gets a bit sniffy if we do this
		lockAcquired := false;
		lockAttempts := null;
		while not lockAcquired and lockAttempts < Max_Attempts do
			lockAttempts := lockAttempts + 1;
			lockAcquired := self.tryLock(root, Exclusive_Lock, Transaction_Duration, retryTimeMs);
			if lockAcquired then
				break;
			endif;
			
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " attempt #" & lockAttempts.String & " to exclusiveLock root object failed after " & (retryTimeMs div 1000).String & "secs", null); 
		endwhile;
		
		if not lockAcquired then
			app.cnRaiseNormalException(Cn_General_Error, root.String, Max_Attempts.String & " attempts to lock CnRoot singleton failed", false);
		endif;
		
		nodeControl	:= CnNodeControl.firstSharedTransientInstance();
		if nodeControl = null then
			beginTransientTransaction;
			create nodeControl sharedTransient;
			cc.setMyNodeControl(nodeControl);		// sets up the manual collection
			commitTransientTransaction;
		
		
		else	// ensure the reference on CnCntrl is defined																	// PAR 712
			beginTransientTransaction;																							// PAR 712
			cc.setMyNodeControl(nodeControl);		// sets up the manual collection											// PAR 712
			commitTransientTransaction;																							// PAR 712
		endif;			
		
		unlock(root);

	else
		beginTransientTransaction;
		cc.setMyNodeControl(nodeControl);		// sets up the manual collection
		commitTransientTransaction;
	endif;
	
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : " & nodeControl.String & " shared transient hooked OK, number of registered processes in this node " &
											cc.myNodeControl.allNodeControlCnCntrlArray.size().String & ".", null);
	if app.name <> CN_KCNODECONTROL then 
		// we force all processes in this node to single-thread through the following logic by locking the
		// shared transient while we check if KCNodeControl is required and whether to start it up
		lockAcquired := false;
		lockAttempts := null;
		while lockAttempts < Max_Attempts do
			lockAttempts := lockAttempts + 1;
			lockAcquired := self.tryLock(nodeControl, Exclusive_Lock, Transaction_Duration, retryTimeMs);
			if lockAcquired then
				break;
			endif;
			
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " attempt #" & lockAttempts.String & " to exclusiveLock CnNodeControl singleton object failed after " & (retryTimeMs div 1000).String & "secs", null); 
		endwhile;
		
		if not lockAcquired then
			app.cnRaiseNormalException(Cn_General_Error, nodeControl.String, Max_Attempts.String & " attempts to lock CnNodeControl shared transient singleton failed", false);
		endif;
	
		nodeControl.establishNodeControlProcess();		// start KCNodeControl if required
	endif;
epilog
	unlock(root);
	unlock(nodeControl);
end;
}
executeJadeProfiler
{
executeJadeProfiler(pRestart : Boolean) updating;

vars
	cc		: CnCntrl;
	
	ff 		: FileFolder;
	
	date	: Date;
	
	time	: Time;
begin
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " profiling function is disabled", null);
	return;
	
	
	create ff transient;
	ff.fileName := cc.logPath & "/profiler";
	if not ff.isAvailable() then
		ff.make();
	endif;
	
	if self.myJadeProfiler = null then
		create self.myJadeProfiler transient;
	
	else
		self.myJadeProfiler.reportCodeCoverage();
	endif;
		
	self.myJadeProfiler.codeCoverageFileName := ff.fileName & "/" & 
													cc.appName & "." & 
													app.cnGetInstanceId(process).String & "_" & 
													date.userFormat($CnCCYYMMDD_ns) & "_" &
													time.userFormat($CnHHMMSS_ns) & ".ccd";
	self.myJadeProfiler.startCodeCoverage();
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " started code coverage, restart timer=" & pRestart.String & " ...", null);
	if pRestart then
		if cc.appName = CN_JOSS then
			self.beginTimer(5 * 60 * 1000, Timer_OneShot, 123456);
		
		else
			self.beginTimer(60 * 60 * 1000, Timer_OneShot, 123456);
		endif;
	endif;
epilog
	delete ff;
end;
}
fileExceptionHandler
{
fileExceptionHandler(exObj : FileException) : Integer updating;

vars
	cc			: CnCntrl;
	
	obj			: Object;
	
	canResume	: Boolean;
	
	max,
	try			: Integer;
	
	excFileName	: String;
begin
	cc 	:= app.myCnCntrl;
	obj	:= exObj.file;
	excFileName := "<unknown>";
	if obj <> null then
		if obj.isKindOf(File) then											// detour for JADE PAR 40003
			excFileName := obj.File.fileName;
		
		elseif obj.isKindOf(FileFolder) then								// detour for JADE PAR 40003
			excFileName := "Dir " & obj.FileFolder.fileName;
		endif;
	endif;

	canResume 	:= exObj.resumable;
	max			:= self.fileMaxRetries;
	try			:= self.fileRetryNo;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " resumable=" & canResume.String & 
																", fileMaxRetries=" & max.String &
																", fileRetryNo=" & try.String, null);
	
	try := try + 1;
	self.setHadFileException(true);
	self.setExceptionFileName(excFileName);
	self.setExceptionErrorCode(exObj.errorCode);
	self.setExceptionText(exObj.text);
	self.setFileRetryNo(try);
	
	if canResume 		and
	   max = null		and 
	   try < 21			then		// i.e. fileMaxRetries not specified
		return Ex_Resume_Next;
	endif;
		
	if canResume		and 
	   max > null		and 
	   try < max 		then		// fileMaxRetries was specified
		return Ex_Resume_Next;
	endif;

	self.setFileRetryNo(null);
 	return Ex_Pass_Back;
end;
}
findBackgroundCommsMgr
{
findBackgroundCommsMgr(pBackgroundClientName : String) updating;

vars
	cnApp			: CardSchema;

	cc				: CnCntrl;

	root			: CnRoot;

	proc 			: Process;

	count,
	retry		 	: Integer;
	
	kccMgrStartDelay,
	result, 
	resultString,
	schemaName,
	starter,
	str				: String;	
begin
	//  First, we look for the systems management background client for this application process.
	//  If not found, then start the background client, i.e. KCCMgr, KarmaCommsMgr, or JossCommsMgr.
	cnApp 	:= app.cnGetCardSchemaApp(true);
	cc 		:= cnApp.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, cc.appName & " now looking for background client communications manager '" & pBackgroundClientName & "'.", null);
	root	:= cnApp.myCnRoot;
	if self.environmentId.toLower().cnContains("joss") 	and 
	   system.getDatabaseRole() = SDS_RoleSecondary 	then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " JossCommsMgr background client not required as JSM running in secondary mode", null);
		return;
	endif;

	if root.isSharedTransient() and cnApp.cnIsRPSNode() then
		if root.myKCCMgrProcess <> null then
			return;
		endif;

		cc.cnWriteLog(cc.CnLogErrors, "RPS Node : KCCMgr not running : can't run application : will terminate.", null);
		app.cnTerminate();
	endif;
	
	if pBackgroundClientName = CN_JOSSCOMMSMGR or
	   pBackgroundClientName = CN_KARMACOMMSMGR then
		schemaName	:= CN_JOSSCONTROL;
		
	else
		schemaName	:= CN_CARDSCHEMA;
	endif;

 	proc 	:= self.getBackgroundCommsMgrProcess(schemaName, pBackgroundClientName);
	if proc = null then																											// JSM PAR 5083
		if pBackgroundClientName = CN_KARMACOMMSMGR then																		// JSM PAR 5083
			schemaName	:= CN_JOSS;																								// JSM PAR 5083
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & 																// JSM PAR 5083
							" unable to locate KarmaCommsMgr under schema JossControl, try checking schema Joss...", null);		// JSM PAR 5083
			proc 	:= self.getBackgroundCommsMgrProcess(schemaName, pBackgroundClientName);									// JSM PAR 5083
			if proc = null then																									// JSM PAR 5083
				schemaName	:= CN_JOSSCONTROL;																					// JSM PAR 5083
			endif;																												// JSM PAR 5083
		endif;																													// JSM PAR 5083
	endif;																														// JSM PAR 5083
	
    if proc = null then						// haven't found background client's process object
		if self.masterEnvironmentId.toLower[1:6] = "cnwjsm" then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " " & pBackgroundClientName & " not expected to be running for " & self.masterEnvironmentId, null);
			return;
		endif;
    	//
      	//  First, check that someone else isn't already starting the background client
      	//
      	cc.cnWriteLog(cc.CnLogComment, "Checking that background client is running (" & pBackgroundClientName & ")...", null);
      	while not tryLock(root, Exclusive_Lock, Transaction_Duration, 100) do
			count := count + 1;
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " failed to obtain CnRoot lock, count = " & count.String & ", retry in 5 seconds", null);
			process.sleep(5000);
		endwhile;
		
      	proc := self.getBackgroundCommsMgrProcess(schemaName, pBackgroundClientName & " Starter");
		unlock(root);
		if proc = null then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " no background process running", null);
		
		else
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " found background process : " & proc.String, null);
		endif;
		
		if app.isValidObject(proc) then							// someone else has already started the background client
			proc := self.displayClientStartupProgress(schemaName, pBackgroundClientName, null);	// hang on this until the background client is running	
			cc.cnWriteLog(cc.CnLogComment, "Background client is now running OK.", null);
	    	self.myKarmaCommsMgrProcess := proc;
			return;
		endif;

		cc.setLockForProcess(schemaName, pBackgroundClientName & " Starter", true, true);																		// we will have to start the background client
		result := cc.myTransientGlobal.cnStartBackgroundClient();				// server method.
		if result <> CN_OK then
			str	:= "Couldn't initiate " & pBackgroundClientName & " : bad result from application starter : result=" & 
				   result & " : " & resultString & CrLf & "Application will terminate.";
			if cnApp.cnApplicationType = app.ApplicationType_GUI then
				app.msgBox(str, "Start Up Error", 0);
			endif;
			
			cc.cnWriteLog(cc.CnLogErrors, "ERROR : " & str, null);
			app.cnTerminate(); 
		endif;                      												// app start failed

		proc 	:= self.displayClientStartupProgress(schemaName, pBackgroundClientName, null);	// use default form caption
		cc.cnWriteLog(cc.CnLogComment, "Background client is now running OK.  Unlocking starter's CnLockTarget object...", null);
		cc.setLockForProcess(schemaName, pBackgroundClientName & " Starter", false, true);
	endif;

    if proc <> null then
    	self.myKarmaCommsMgrProcess := proc;

	else																				// shouldn't normally happen
    	kccMgrStartDelay := app.getProfileStringAppServer(app.getIniFileNameAppServer, "Karma", "KCCMgrStartDelay", "45");
    	cc := app.myCnCntrl;
    	cc.cnWriteLog(cc.CnLogErrors, pBackgroundClientName & " failed to start after " & kccMgrStartDelay & " seconds - " &
    								  "application will be terminated.", null);
    	if cnApp.cnApplicationType = app.ApplicationType_GUI then
	    	app.msgBox(pBackgroundClientName & " Background Communications Manager failed to start after " & kccMgrStartDelay & " seconds - " &
	    				CrLf & Tab & "    Your application will be terminated." & CrLf & Tab &
	    				"Try again or contact your help desk", cc.appName & " Startup Problem", 0);
	    endif;
		
    	app.cnTerminate();
    endif; 
end;
}
getAddressInfo
{
getAddressInfo(ipAddress : String output; fqdn : String output) : Integer updating;

vars
	cc 			: CnCntrl;
	
	errStr,
	errorText,
	extra,
	localhostIp	: String;

	buildNumber,
	i, 
	iResult,
	majVer,
	minVer,
	osId,
	platformId	: Integer;
	
	cem			: CnExternalMethods;
begin
	cc 			:= app.myCnCntrl;
	ipAddress 	:= self.networkAddressNode;		// if thin client this gets app server's address, which is what we want
	////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//self.zSetupTcpTransportDetails(ipaddress);
	localhostIp := "127.0.0.1";
	if ipAddress.cnContains(":") then
		self.v6IpAddress := ipAddress;
		localhostIp := "::1";
	endif;
	
	if ipAddress.toLower() = "localhost" then	// detour for JADE PAR 25419 when using shared memory RPC
		ipAddress	:= localhostIp;
		fqdn		:= "localhost";
		return null;
	endif;		

	if ipAddress = null then					// may be using shared memory transport
		ipAddress 	:= localhostIp;
		fqdn 		:= "localhost";

		if app.cnIsServerApp then
			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " serverapp has set ipAddress to " &
					  	localhostIp & " (localhost) - no process.networkAddress (yet).", null);

		elseif not app.isMultiUser then
			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " app has set ipAddress to " & 
					  	localhostIp & " (localhost) - no process.networkAddress : assumed SingleUser Mode", null);

		else
			cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " WARNING : app is multi-user yet ipAddress is null : " &
									      "assuming " & localhostIp & " (localhost).", null);
		endif;
		
		return null;
	endif;

	create cem transient;
	iResult 	:= cem.emGetHostByAddress(ipAddress, fqdn);		// result = 0 means OK
	if iResult = null then
		return null;
	endif;
	
	if iResult > 50000 then
		iResult := iResult - 50000;								// karma.dll adds 50000 to the error code sometimes
	endif;

	if iResult = 11004 then										// DNS and WINS not working 
		return null;
	endif;

	i := cem.emGetErrorText(iResult, errorText, 300);
	errStr := method.cnGetMethodName() & " got error=" & iResult.String & " : ";
	if i = 0 then
		errStr := errStr & errorText;
	else
		errStr := errStr & "unknown error - ::emGetErrorText error=" & i.String;
	endif;

	cc.cnWriteLog(cc.CnLogErrors, errStr, null);
	return iResult;
epilog
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " ipAddress=" & ipAddress & ", fqdn=" & fqdn, null);
	delete cem;
end;
}
getAndSendSSLDetails
{
getAndSendSSLDetails() updating;
/*
	This method should only be invoked after checking that the node is an application server.
*/

vars
	cc						: CnCntrl;
	
	cnNodeControl			: CnNodeControl;
	
	func					: CnIniFileAgent;
	
	sslCiphers				: StringArray;
	
	certAuthFileResident,
	certFileResident,
	rpcEncryptionEnabled	: Boolean;
	
	certAuthFileExpiry,
	certFileExpiry			: Date;
	
	certAuthFileName,
	certAuthFileSubject,
	certFileName,
	certFileSubject,
	iniFile,
	sslMethodName,
	sslSecurePort			: String;
begin
	cc	:= app.myCnCntrl;
	cnNodeControl := cc.myNodeControl;
	if cnNodeControl.allNodeControlCnCntrlArray.first() <> cc.myNodeControlCnCntrl then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " number of registered processes executing in node = " & 
															cnNodeControl.allNodeControlCnCntrlArray.size().String & ", this process is not first registered", null);
		return;
	endif;

	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " number of registered processes executing in node = " & 
														cnNodeControl.allNodeControlCnCntrlArray.size().String & ", this process is first registered, send SSL details", null);
	iniFile := app.getIniFileNameAppServer();		// get ini file for this node

	create sslCiphers transient;
	create func transient;
	func.iniFileName := iniFile;
	func.getSSLDetails(rpcEncryptionEnabled,
						certFileResident,
						certAuthFileResident,
						sslSecurePort,
						certFileName,
						certFileSubject,
						certAuthFileName,
						certAuthFileSubject,
						sslMethodName,
						certFileExpiry,
						certAuthFileExpiry,
						sslCiphers);
						
	self.zIssueSSLAdvice(rpcEncryptionEnabled,
						 sslSecurePort,
						 certFileName,
						 certFileResident,
						 certFileSubject,
						 certFileExpiry,
						 certAuthFileName,
						 certAuthFileResident,
						 certAuthFileSubject,
						 certAuthFileExpiry,
						 sslMethodName,
						 sslCiphers);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " rpcEncryptionEnabled=" & rpcEncryptionEnabled.String &
														", sslSecurePort=" & sslSecurePort &
														", certFileName=" & certFileName &
														", certFileResident=" & certFileResident.String &
														", certFileSubject=" & certFileSubject &
														", certFileExpiry=" & certFileExpiry.String &
														", certAuthFileName=" & certAuthFileName &
														", certAuthFileResident=" & certAuthFileResident.String &
														", certAuthFileSubject=" & certAuthFileSubject &
														", certAuthFileExpiry=" & certAuthFileExpiry.String &
														", sslMethodName=" & sslMethodName, null);
epilog
	delete func;
	delete sslCiphers;
end;
}
getBackgroundCommsMgrProcess
{
getBackgroundCommsMgrProcess(pSchemaName,
							 pBackgroundClientName : String) : Process;

vars
	root	: CnRoot;

	cc		: CnCntrl;
	
	proc	: Process;
	
	locked	: Boolean;
	
	try		: Integer;
begin
	cc	:= app.cnGetCardSchemaApp(true).myCnCntrl;
	root := app.myCnRoot;
	on LockException do app.cnGenericExceptionHandler(exception, Cn_ObjectLocked, root.allLockTargets, locked);
	
	while true do
		try := try + 1;
		locked := false;
		proc := cc.getProcessForLock(pSchemaName, pBackgroundClientName, true);
		if not locked then
			break;
		endif;
		
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " try #" & try.String & " to find " & pSchemaName & "::" & pBackgroundClientName & " failed on lock contention, retrying...", null);
		process.sleep(1000);
	endwhile;
	
	return proc;
end;
}
getBinariesInfo
{
getBinariesInfo(pNames 			: HugeStringArray input; 
				pVersions,
				pMD5Hashes		: StringArray input; 
				pModifyTimes 	: TimeStampArray input; 
				pFileTypes 		: CharacterArray input) updating;

vars
	cc			: CnCntrl;

	dbFile		: DbFile;

	file		: File;

	ff 			: FileFolder;
	
	fn			: FileNode;

	jdba		: JadeDatabaseAdmin;
	
	dbFiles		: DbFileArray;

	foundBin	: Boolean;
	
	r,
	m,
	p,
	c			: Integer;
	
	binDir,
	info,
	md5Hash,
	result,
	simpleName,
	suffix,
	version		: String;
begin
	//   This method updates the input arrays with names, versions and modify times (GMT) for all DLLs, EXEs and .eng files
	//   in the current binaries directory.  Intended initially for use only by KCCMgr.
	binDir := app.getJadeInstallDirAppServer();
	binDir.replaceChar("\", "/");
	create ff transient;
	ff.fileName	:= binDir;
	cc			:= app.myCnCntrl;
	
	foreach fn in ff.files do
		if not fn.isKindOf(File) then
			continue;
		endif;
		
		file		:= fn.File;
		file.mode	:= file.Mode_Input;					// in case it's readonly
		suffix		:= file.cnGetSuffix().toLower;
		if suffix = "bin" then
			foundBin := true;
			continue;
		endif;
		
		version	:= null;
		if suffix = "exe" or 
		   suffix = "dll" or 
		   suffix = "eng" or
		   (app.cnOSPlatformIsUnix and (suffix = "sh" or suffix = null))		then
			if not file.isAvailable() then
				continue;
			endif;
			
			result := file.emFileVersionInfo(file.fileName, "FileVersion", info);
			if result = CN_OK then
				version	:= info;
				version.replaceChar(",", ".");
					
			else
				cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " File " & file.fileName & " : " & result, null);
			endif;

			version := version.cnFormatVersion(m, r, c, p)[1:30];
			file.cnGetMD5Hash(md5Hash);
			pNames.add(file.cnGetSimpleFileName.toLower);
			pVersions.add(version);
			pModifyTimes.add(file.lastModified.cnGMT);
			pMD5Hashes.add(md5Hash);
			if pFileTypes <> null then
				pFileTypes.add(CN_FILETYPE_BINARY);
			endif;
		endif;
	endforeach;
	
	if not foundBin then
		return;
	endif;
	
	// get info regardinging system files
    create jdba transient;
    create dbFiles transient;

    jdba.getDbFiles(DbFile.Kind_System, dbFiles);

    foreach dbFile in dbFiles do
		if dbFile.getFileStatus() = dbFile.Status_Offline then
			continue;
		endif;
		
		simpleName := dbFile.getName() & ".bin";
		file.fileName := binDir & "/" & simpleName;
		if not file.isAvailable() then
			continue;
		endif;
		
        dbFile.getPatchVersion(m, r, c, p);
		version := m.String & "." & r.String & "." & c.String & "." & p.String;
		file.cnGetMD5Hash(md5Hash);
		pNames.add(simpleName);
		pVersions.add(version.cnFormatVersion(m, r, c, p)[1:30]);
		pModifyTimes.add(file.lastModified.cnGMT);
		pMD5Hashes.add(md5Hash);
		if pFileTypes <> null then
			pFileTypes.add(CN_FILETYPE_BINARY);
		endif;
    endforeach;
	
epilog
	delete ff;
	delete jdba;
	delete dbFiles;
end;
}
getCallStackPosition
{
getCallStackPosition() : Integer;

vars
 	ps	: ProcessStackArray;
begin
	create ps transient;
	process.currentStack(ps);
	
	if node.isServerNode and process.node <> node then			// we are serverExecution
		return ps.size - 2 + 10000;
	else
		return ps.size - 2;
	endif;
	
epilog
	if ps <> null then
		ps.purge();
		delete ps;
	endif;
end;
}
getClientProcessObject
{
getClientProcessObject(clientname : String) : Process updating;

vars
	proc 				: Process;
	retry 				: Integer;
	kccMgrStartDelay 	: Integer;
	cc					: CnCntrl;
begin
	cc				 := process.getProcessApp().CardSchema.myCnCntrl;
	kccMgrStartDelay := app.getProfileStringAppServer(app.getIniFileNameAppServer, "Karma", "KCCMgrStartDelay", "45").Integer;

	while retry < kccMgrStartDelay do
		process.sleep(1000);								// allow time for KCCMgr to start											
		proc := cc.myTransientGlobal.cnGetUserProcess(clientname, false);
		if proc <> null then
			return proc;
		endif;

		retry := retry + 1;
	endwhile;
end;
}
getEnvironmentId
{
getEnvironmentId(pPath : String) : String;

vars
	posn	: Integer;

	env_id	: String;
begin
	posn 	:= 1;
	pPath.scanUntil(CN_BACK_SLASH, posn);					// get past drive letter part
	posn	:= posn + 1;
	env_id 	:= pPath.scanUntil(CN_BACK_SLASH, posn);		
	return env_id;
end;
}
getFileRoot
{
getFileRoot() : String;			// returns disk drive + environment id

vars
	str		: String;
	fileroot: String;
	posn	: Integer;	
begin
	str := app.cnStandardizePathName(app.getJadeInstallDirAppServer);
	posn := 1;
	fileroot := str.cnGetToken(posn, "/") & "/" & str.cnGetToken(posn, "/");			
 	return fileroot;
end;
}
getHostForAddress
{
getHostForAddress(ipAddress : String; fqdn : String output) : String;

vars
	i,
	iResult 	: Integer;
	
	cc			: CnCntrl;

	errStr,
	errorText	: String;
	
	cem			: CnExternalMethods;
begin	
	cc			:= app.myCnCntrl;
	create cem transient;
	iResult 	:= cem.emGetHostByAddress(ipAddress, fqdn);				// result = 0 means OK
	if iResult = null then
		return CN_OK;
	endif;
	
	if iResult > 50000 then
		iResult := iResult - 50000;								// karma.dll adds 50000 to the error code sometimes
	endif;

	i := cem.emGetErrorText(iResult, errorText, 300);
	errStr := method.cnGetMethodName() & " emGetHostByAddress result=" & iResult.String & " getting FQDN for IP Address '" & ipAddress & "' : ";
	if i = null then
		errStr := errStr & errorText;
		
	else
		errStr := errStr & "unknown error getting error text - ::emGetErrorText error=" & i.String;
	endif;

	cc.cnWriteLog(cc.CnLogErrors, errStr, null);
	
/*	// if we get an error from emGetHostByAddress of 11004, that means we haven't been able to resolve
	// the IP Address to a Fully Qualified Domain Name. Rather than return a null fqdn (with potential
	// downstream effects), return the error result.
	
	// following 3 lines moved from up above so as to derive the Windows error text.
	if iResult = 11004 then										// DNS and WINS not working 
		return null;
	endif;
*/
	return errStr;
epilog
	delete cem;
end;
}
getLibrariesInfo
{
getLibrariesInfo(pNames 		: HugeStringArray input; 
				 pVersions 		: StringArray input; 
				 pModifyTimes 	: TimeStampArray input; 
				 pFileTypes 	: CharacterArray input) updating;

vars
	ff 			: FileFolder;
	fn			: FileNode;
	file		: File;
	suffix		: String;
	version		: String;
	info		: String;
	result		: String;
	cc			: CnCntrl;
	pos, spos	: Integer;
	str			: String;
	path		: String;
	r,m,p,c		: Integer;
begin
	//   This method updates the input arrays with names, versions and modify times (GMT) for all libraries files
	//   in the current libraries directory.  Intended initially for use only by Unix.
	
	create ff transient;
	str			:= app.getJadeInstallDirAppServer().toLower;
	str.replaceChar("\", "/");
	spos		:= 1;
	pos			:= str.pos("/bin", spos);
	path		:= str[1:pos] & "lib";
	ff.fileName	:= path;
	cc			:= app.myCnCntrl;

	
	foreach fn in ff.files do
		if fn.isKindOf(File) then
			file		:= fn.File;
			file.mode	:= file.Mode_Input;					// in case it's readonly
			suffix		:= file.cnGetSuffix().toLower;
			if suffix = "so" then
				if file.isAvailable then
					result := file.emFileVersionInfo(file.fileName, "FileVersion", info);
					if result = CN_OK then
						version	:= info;
					else
						version	:= null;
						cc.cnWriteLog(cc.CnLogErrors, "File " & file.fileName & " in CnKarmaCntrl::getLibrariesInfo : " & result, null);
					endif;
			
				else
					cc.cnWriteLog(cc.CnLogErrors, "File " & file.fileName & " in CnKarmaCntrl::getLibrariesInfo not available.", null);
					version	:= "File not available";
				endif;
				
				pNames.add(file.cnGetSimpleFileName.toLower);
				version := version.cnFormatVersion(m, r, c, p)[1:30];
				pVersions.add(version);
				pModifyTimes.add(file.lastModified.cnGMT);
				if pFileTypes <> null then
					pFileTypes.add(CN_FILETYPE_LIBRARY);
				endif;
			endif;
		endif;
	endforeach;
	
epilog
	delete ff;
end;
}
getMessageClass
{
getMessageClass(pMessageClassName : String) : Class;

vars
	index	: Integer;
begin
	index := self.messageNameArray.indexOf(pMessageClassName);
	if index = null then
		return null;
	endif;
	
	return messageClassArray[index];
end;
}
getReadOnlySchemaPath
{
getReadOnlySchemaPath() : String updating;

vars
 	filename	: String;
begin
	filename := app.getIniFileNameAppServer;	
	return app.getProfileStringAppServer(filename, "JadeClient", "ReadOnlySchemaPath", null);
end;
}
getSystemStatistics
{
getSystemStatistics() : Binary updating;

vars
	ss	: CnServerStatistics;
begin
	ss	:= self.myCnServerStatistics;
	return ss.getStatsSummary;
end;
}
getThinClientVersions
{
getThinClientVersions(c_bin, c_misc, n_bin, n_misc : TimeStamp output);

vars
	ff					: FileFolder;
	file				: File;
	cc					: CnCntrl;
	
begin
	//   Gets thin client version control file info from app server directories.
	
	cc := app.myCnCntrl;
	
	create ff transient;
	
	ff.usePresentationFileSystem	:= false;
	
	if app.cnComputerNameAppServer = cc.myTransientGlobal.cnGetServerComputerName then	// app server on same machine as db server
		ff.fileName	:= driveLetter & ":/" & self.masterEnvironmentId & "/client/thinclient";
	else	   
		ff.fileName	:= driveLetter & ":/" & self.masterEnvironmentId & "/thinclient";
	endif;
	
	if not ff.isAvailable then
		return;																			// no thin client files on this machine
	endif;

	create file transient;
	file.mode				:= file.Mode_Input;
	file.usePresentationFileSystem 	:= false;

	file.fileName			:= ff.fileName & "/c_bin/" & self.masterEnvironmentId & "_tc_bin_full.exe";
	if file.isAvailable then
		c_bin				:= file.lastModified.cnGMT;
	else
		file.fileName		:= ff.fileName & "/c_bin/" & self.masterEnvironmentId & "_tc_bin_full.rar";
		if file.isAvailable then
			c_bin			:= file.lastModified.cnGMT;
		else
			cc.cnWriteLog(cc.CnLogComment, "WARNING : Thin client directory found, but file " & file.fileName & " not found.", null);
		endif;
	endif;

	file.fileName	:= ff.fileName & "/c_misc/" & self.masterEnvironmentId & "_tc_misc_full.exe";
	if file.isAvailable then
		c_misc		:= file.lastModified.cnGMT;
	else
		file.fileName		:= ff.fileName & "/c_misc/" & self.masterEnvironmentId & "_tc_misc_full.rar";
		if file.isAvailable then
			c_misc			:= file.lastModified.cnGMT;
		else
			cc.cnWriteLog(cc.CnLogComment, "WARNING : Thin client directory found, but file " & file.fileName & " not found.", null);
		endif;
	endif;

	file.fileName	:= ff.fileName & "/n_bin/" & self.masterEnvironmentId & "_tc_bin_full.rar";
	if file.isAvailable then
		n_bin		:= file.lastModified.cnGMT;
	endif;
	
	file.fileName	:= ff.fileName & "/n_misc/" & self.masterEnvironmentId & "_tc_misc_full.rar";
	if file.isAvailable then
		n_misc		:= file.lastModified.cnGMT;
	endif;

epilog
	delete ff;
	delete file;
end;
}
getTransactionStatsHeader
{
getTransactionStatsHeader() : Binary;

vars
	cc					: CnCntrl;
	
	appName,
	computerName,
	computerNameNode,																											// PAR 980
	networkAddr,
	sampleStats,
	userName			: Binary;
begin
	cc := app.myCnCntrl;
	sampleStats	:= cnAnsiBinary((cc.myNodeControl <> null and cc.myNodeControl.sampleProcessStats).Character);
	
	// convert all strings into binary so that when we
	// define lengths into the binary as well, this takes 
	// into account whether ANSI or Unicode.
	appName			:= cnAnsiBinary(cc.appName);
	computerName 	:= cnAnsiBinary(app.cnComputerName);
	computerNameNode:= cnAnsiBinary(app.cnComputerNameAppServer());																// PAR 980
	networkAddr		:= cnAnsiBinary(self.networkAddressProcess);
	userName		:= cnAnsiBinary(app.userName);
	return 	computerName.length().Binary 		&
			computerName						&
			computerNameNode.length().Binary 	&																				// PAR 980
			computerNameNode					&																				// PAR 980
			networkAddr.length().Binary			&
			networkAddr							&
			userName.length().Binary			&
			userName							&
			appName.length().Binary				&
			appName								&
			sampleStats;
end;
}
handleTranStatsRequestEvent
{
handleTranStatsRequestEvent() updating;

vars
	cc				: CnCntrl;

	cnproc			: CnProcess;
	
	tranStatsArray	: CnStatisticsSampleBinaryArray;
	
	sampleStats		: Boolean;
	
	bin,
	binHeader,
	binTemp			: Binary;
	
	d1				: Decimal[23];
	
	indx,
	hdrLength,
	len,
	packetNo,
	pos,
	posStart,
	size		: Integer;
	
	str			: String;
begin
	cc := app.myCnCntrl;
	cnproc	:= self.myCnProcess;						// transaction statistics and JOM stats 
	if cnproc = null then
		return;											// KarmaControl=false
	endif;

	size	:= cnproc.tranStats.size();
	if size = null then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " no transaction stats pending", null);
		return;
	endif;

	binHeader   := self.getTransactionStatsHeader();
    hdrLength   := binHeader.length();
	indx 		:= 1;
	len			:= hdrLength + (size * 66);
	bin[len]	:= 0.Integer;								// preallocate memory, for performance
	bin			:= binHeader;
	posStart 	:= hdrLength + 1;							// no need to cater for ANSI vs Unicode as header content converted to ANSI
	packetNo	:= 1;
	pos			:= posStart;
	tranStatsArray	:= cnproc.tranStats;
	foreach binTemp in tranStatsArray do
		len				:= binTemp[1:4].Integer;
		bin[pos : len] 	:= binTemp;
		pos				:= pos + len;
		if pos > self.Max_TranStats_Length then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " accumulated statistics " &
										  "exceeded 48K limit : sending packet #" & packetNo.String, null);
			process.causeEvent(Cn_Tran_Stats_Submission, true, bin); 	// subscribed to by KCCMgr, KarmaCommsMgr, JossCommsMgr only
			bin	:= binHeader;
			pos := posStart;
			packetNo := packetNo + 1;
		endif;	
	endforeach;

	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " sending statistics packet #" & packetNo.String, null);
	process.causeEvent(Cn_Tran_Stats_Submission, true, bin); 		// subscribed to by KCCMgr, KarmaCommsMgr, JossCommsMgr only
	cnproc.tranStats.clear();
	cnproc.setTransStatsLength(null);
end;
}
initiateUpgradeForAppServer
{
initiateUpgradeForAppServer() updating;

vars
	frm			: CnMsgForm;
	commandline	: String;
	result		: Integer;
	cc			: CnCntrl;
begin
	//	This method designed to be called by JADE thin client when the binaries or misc files
	//  on the app server are out-of-sync with the database server.
	//
	cc := app.myCnCntrl;
	create frm;
   	frm.message 		:= "Your application server is shutting down for an automatic software upgrade." & CrLf & 
   					   "Please try again in a few minutes.";
   	frm.delay			:= 5;
   	frm.dontTerminate	:= true;		// normally this form self-unloads after delay - we want to control this here
   	frm.show;
   	frm.refreshNow;
   	process.sleep(5000);

  	if node.createExternalProcess(binPath, "schemacp.exe ", null, null, false, false, result) = 0 then
		cc.cnWriteLog(cc.CnLogComment, "SCHEMACP.EXE successfully initiated ...... terminating JADE.EXE now.", null);
	else
		cc.cnWriteLog(cc.CnLogComment, "SCHEMACP.EXE initiation failed ...... terminating JADE.EXE now.", null);	
	endif;
end;
}
isMultiUserCapable
{
isMultiUserCapable() : Boolean;
/*
	Purpose :
	
	With JADE 2018 there are now two modes that permit thinclient access (ie is multi-user capable) and that is:
	- Database server (jadrap) with one or more application servers (jadapp)
	- Application server (jadapp) running in single user mode
*/
vars
	processApp	: Application;
begin
	processApp := process.getProcessApp();
	if processApp.isMultiUser() then
		// jadrap is running
		return true;
	endif;
	
	// if not multi-user but is an application server then we are still multi-user capable as we can handle mutiple thin-client connections
	return node.isApplicationServer();
end;
}
isSingleUserAppServer
{
isSingleUserAppServer() : Boolean;

vars
	processApp	: Application;
begin
	processApp := process.getProcessApp();
	if processApp.isMultiUser() then
		return false;
	endif;
	
	return node.isApplicationServer();
end;
}
issueKCCMgrSessionOpenAdvice
{
issueKCCMgrSessionOpenAdvice(tcp : CnKarmaTcpConnection input; machine : CnMachine; cnproc : CnProcess) updating;

vars
	ci						: CnClusterInfo;
	
	cc						: CnCntrl;

	cem						: CnExternalMethods;

	msg, 
	tmsg					: CnMessage;
	
	root					: CnRoot;

	newmsg					: CnSessionOpenAdvice;

	schema					: Schema;
	
	sdsDba					: CnSDSDatabaseAdmin;

	encryptionEnabled,
	encryptionMasterKeyVerified,
	runningAsService		: Boolean;

	len,
	pid,
	role,
	rpsStorageMode,
	rpsTransitionHaltCode,
	trackingStoppedReason	: Integer;

	pc, 
	rc, 
	tc, 
	pdb						: Integer64;

	alertMasterEnvIdTruncated,
	rpsMappingName,
	schemaName,
	str, 
	str2,
	sysType					: String;

	cbin, 
	cmisc,
	nbin, 
	nmisc					: TimeStamp;

begin
	cc		:= app.myCnCntrl;
	root	:= app.myCnRoot;
	self.getProcessId(pid);
	encryptionEnabled := system.isDatabaseEncryptionEnabled();
	if encryptionEnabled then
		encryptionMasterKeyVerified := system.verifyDbEncryptionMasterKey();
	endif;
	
	create cem transient;
	runningAsService := cem.emIsService();

	create msg;
   	msg.buildHeader(msg.Advice, msg.Session_Open, null, machine.clientFQDN, machine.ipAddress, cc.KCCMgr_Process, cc.JossCommsMgr_Process, tmsg);	
   	newmsg	:= tmsg.CnSessionOpenAdvice;
   	newmsg.setProcessId(cnproc.processId);
   	newmsg.setAppName(cnproc.myCnApp.appName);
	newmsg.setAppSchemaName(cnproc.myCnApp.appSchemaName);
   	newmsg.setEnvironmentId(self.environmentId);
   	newmsg.setManagedEnvironmentName(self.environmentId);
   	newmsg.setServerHostFQDN(null);						// Karma fixes this up before sending to Joss
   	newmsg.setProtocolVersion(newmsg.Current_Protocol_Version);
   	newmsg.setCurrentClientVersions(machine.currentClientSchemaVersion,
   									machine.currentClientBinVersion,
   								    machine.currentClientMiscVersion);
    newmsg.setNextClientVersions(machine.nextClientSchemaVersion,
    							 machine.nextClientBinVersion,
    							 machine.nextClientMiscVersion);
    newmsg.setCardSchemaVersion(app.cnGetCardSchemaVersion[1:10]);
   	newmsg.setJadeVersion(app.cnGetJadeVersion().cnMarkReleaseCutString());
   	newmsg.setupLicenceDetails();
    newmsg.setTimestamp(cnproc.startTime);
    newmsg.setOsPID(pid);
    self.getThinClientVersions(cbin, cmisc, nbin, nmisc);
    newmsg.setCurrentThinClientVersions(cbin, cmisc);
    newmsg.setNextThinClientVersions(nbin, nmisc);

    node.getCacheSizes64(pc, tc, rc);
    newmsg.setClientPersistentCache(pc);
	newmsg.setClientTransientCache(tc);
	newmsg.setClientMethodCache(null);

	node.cnGetServerCacheSizes(pc, tc, rc, pdb);
	newmsg.setServerRemoteTransientCache(rc);
	newmsg.setServerTransientCache(tc);
	newmsg.setServerPersistentCache(pc);
	newmsg.setServerDatabaseCache(pdb);

    newmsg.setIsServerApp(node.isServerNode);
    newmsg.setIsMultiUser(app.isMultiUser);
    newmsg.setApplicationVersion();
    newmsg.setProductionMode(app.productionMode);
    newmsg.setComputerName(app.cnComputerName);
	newmsg.setDistributionNode(app.cnDistributionNode);
	newmsg.setDistributionProcess(app.cnDistributionProcess);
	newmsg.setProcessSignOnTime(process.signOnTime.cnGMT);
	newmsg.setEncryptionEnabled(encryptionEnabled);
	newmsg.setIsSingleUserApplicationServer(app.myCnKarmaCntrl.isSingleUserAppServer());										// JSM PAR 6732
	newmsg.setEncryptionMasterKeyVerified(encryptionMasterKeyVerified);
    if cc.myNodeControl <> null then
   	 	newmsg.setNodeId(cc.myNodeControl.nodeId);
    	newmsg.setNodeType(cc.myNodeControl.nodeType);
    endif;
     
    if app.isUnicode then
    	newmsg.setPlatformType(1);
    else
    	newmsg.setPlatformType(0);
    endif;
     
    schema	:= rootSchema.getSchema("JadeSchema");
    sysType	:= "DEVELOPMENT";
    if schema = null then
     	newmsg.setDeploymentSystem(true);
		sysType	:= "DEPLOYMENT";
	endif;
	
	cc.cnWriteLog(cc.CnLogComment, "System is a " & sysType & " system, productionMode=" & app.productionMode.String, null);
	
    newmsg.setBinDriveLetter(app.getJadeInstallDir[1].toUpper);
    newmsg.setLogPath(cc.dbLogPath);
    
	role	:= system.getDatabaseRole;
	newmsg.setDatabaseRole(role);
	// check if master environment id is greater than 9 characters
	len := self.masterEnvironmentId.length();
	if len > Cn_Max_EnvironmentName_Length then																					// JSM PAR 7586
		str := self.masterEnvironmentId[1:Cn_Max_EnvironmentName_Length];														// JSM PAR 7586
		newmsg.setMasterEnvironmentId(str);
		alertMasterEnvIdTruncated := "JADE Environment " & self.environmentId &
									" on " & self.localFQDN & 
									" ini file setup error" & CrLf & CrLf &
									"[AppEnvironment] MasterEnvironmentId item has a length " & len.String &
									", maximum length allowed for JADECare Managed environment is " & Cn_Max_EnvironmentName_Length.String & "." & CrLf &	// JSM PAR 7586
									"Actual value='" & self.masterEnvironmentId & "'" & CrLf &
									"Truncated value='" & str & "'";
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " " & str, null);
		
	else
		newmsg.setMasterEnvironmentId(self.masterEnvironmentId);
	endif;
	
	if role <> SDS_RoleUndefined then
		sdsDba	:= app.myCnSDSDbAdmin;
		newmsg.setSdsEnvironmentId(sdsDba.sdsEnvironmentId);		
	endif;	
       
    if role = SDS_RoleSecondary then
       	//
       	// Can't use CnRoot stored stuff : it applies to the primary.  Note that this will work only when system
       	// is running as a JAWS service.  We won't send this message (see later below) if we are a secondary and not a service.
       	//
       	ci	:= app.myCnClusterInfo;
       	newmsg.setClusterDetails(ci.virtualMachineName, ci.clusterName, ci.clusterGroup, ci.preferredHost, ci.possibleHosts); 
       	if ci.virtualMachineName <> null then
        	str	:= "Cluster details : virtualMachine=" & ci.virtualMachineName & 
        		   ", clusterName=" & ci.clusterName &
				   ", clusterGroup=" & ci.clusterGroup &
        		   ", preferredHost=" & ci.preferredHost &
        		   ", possibleHosts=";
        	foreach str2 in ci.possibleHosts do
        		str	:= str & str2 & " ";
        	endforeach;
        	
        	str	:= str & ". System is SDS secondary.";
        	
        else
        	str	:= "JADE environment (SDS secondary) is not on a cluster (virtualMachineName is null).";
        endif;
		
		newmsg.setDatabaseSubrole(system.getDatabaseSubrole);
		sdsDba.getRPSParameters(schemaName, rpsMappingName, rpsStorageMode);		// 3.2
		newmsg.setRpsStorageMode(rpsStorageMode);									// 3.2
		if app.isMultiUser then
			newmsg.setSdsTracking(sdsDba.getTracking(trackingStoppedReason, rpsTransitionHaltCode));
			newmsg.setSdsLastErrorCode(sdsDba.getLastErrorCode);
			newmsg.setSdsTrackingDisabled(sdsDba.getTrackingDisabled);
			newmsg.setSdsConnectionState(sdsDba.getConnectionState);
		endif;
		
	else
       	// Get the cluster info from CnRoot : this covers the situation where the system is being run on the 
       	// desktop and we can't access JAWS information about the cluster.
       	//
	    newmsg.setClusterDetails(root.virtualMachineName, root.clusterName, root.clusterGroup, root.preferredHost, root.possibleHosts);
        if root.virtualMachineName <> null then
        	str	:= "Cluster details : virtualMachine=" & root.virtualMachineName & 
        			", clusterName=" & root.clusterName &
					", clusterGroup=" & root.clusterGroup &
        			", preferredHost=" & root.preferredHost &
        			", possibleHosts=";
        	foreach str2 in root.possibleHosts do
        		str	:= str & str2 & " ";
        	endforeach;
        else
        	str	:= "JADE environment is not on a cluster (virtualMachineName is null).";
        endif;
	endif;
	
   	cc.cnWriteLog(cc.CnLogDiag, str, null);
	
	if runningAsService 			or
	   role <> SDS_RoleSecondary	then									// if not a service, don't return nameFromCommandLine
		newmsg.setNameFromCommandLine(cc.nameFromCommandLine);
		newmsg.setV6IpAddress(self.v6IpAddress);
   		newmsg.sendMessage(tcp);
		
		self.sendBinaryDetails(tcp, machine);
		self.sendPingReplyAdvice(cc.appSchemaName, cc.appName, null, true, app.actualTime);		// Send SDS info
	
	else
   		//
   		//  Don't send the SessionOpenAdvice when running SDS secondary on the desktop, 
   		//  because this could unravel all the cluster setup, if any, in JSA and JSM for
   		//  this JADE environment, with unpredictable results.
   		//
   		cc.cnWriteLog(cc.CnLogErrors, ">>>> WARNING : System is SDS secondary, not running as JAWS service. " & 
   								      "Cannot determine cluster details so will NOT send SessionOpenAdvice. <<<<", null);
	endif;
	
	if alertMasterEnvIdTruncated <> null then
		app.cnRaiseAlert("Master environment id setup error",
						
						 alertMasterEnvIdTruncated,
						 "N",
						 app.actualTime(),
						 app.name,
						 self.localFQDN,
						 self.networkAddressNode);
	endif;
epilog
   	delete newmsg;
   	delete msg; 
	delete cem;
end;
}
issueSessionOpenAdvice
{
issueSessionOpenAdvice() updating;

vars
	msg 				: CnMessage;
	newmsg				: CnMessage;
	tmsg				: CnSessionOpenAdvice;
	cc					: CnCntrl;
	pid					: Integer;
	iResult				: Integer;
	kc					: CnKarmaCntrl;
	c_binver			: TimeStamp;
	c_miscver			: TimeStamp;
	n_binver			: TimeStamp;
	n_miscver			: TimeStamp;
	pc, rc, tc			: Integer64;
	pdb					: Integer64;
	ci					: CnClusterInfo;
	maxLocalProcessStr	: String;
	compname			: String;																								// PAR 619
begin
	cc := app.myCnCntrl;
	kc := app.myCnKarmaCntrl;
	iResult := kc.getProcessId(pid);
	if iResult <> 0 then
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " had problem getting thread pid : " &
									  "result=" & iResult.String, null);
	endif;

	if process.isUsingThinClient then
		compname := app.cnComputerName();																						// PAR 619
		self.setThinClientComputerName(compname);																				// PAR 619
		self.setThinClientComputerIpAddress(self.networkAddressProcess);
	endif;

 	create msg;
	cc.cnWriteLog(cc.CnLogConnect, method.cnGetMethodName() & " proc.userCode=" & process.userCode &
						": now sending session open msg to background client", null);

	msg.createNewMsg(msg.Advice, msg.Session_Open, localFQDN, localIpAddress, cc.KCCMgr_Process, cc.JossCommsMgr_Process, newmsg);
	tmsg	:= newmsg.CnSessionOpenAdvice;
	tmsg.setThinClientComputerIpAddress(self.thinClientComputerIpAddress);
	tmsg.setThinClientComputerName(self.thinClientComputerName);
	tmsg.setOsPID(pid);

    getThinClientVersions(c_binver, c_miscver, n_binver, n_miscver);
    tmsg.setCurrentThinClientVersions(c_binver, c_miscver);
    tmsg.setNextThinClientVersions(n_binver, n_miscver);

    node.getCacheSizes64(pc, tc, rc);
	tmsg.setClientPersistentCache(pc);
	tmsg.setClientTransientCache(tc);
	tmsg.setClientMethodCache(null);

	node.cnGetServerCacheSizes(pc, tc, rc, pdb);
	tmsg.setServerRemoteTransientCache(rc);
	tmsg.setServerTransientCache(tc);
	tmsg.setServerPersistentCache(pc);
	tmsg.setServerDatabaseCache(pdb);

	tmsg.setIsServerApp(node.isServerNode);
	tmsg.setIsMultiUser(app.isMultiUser);
	tmsg.setClientTranStats(cc.clientTranStats);
	tmsg.setApplicationVersion();
	tmsg.setCreatorMethod(method.name);
	tmsg.setComputerName(app.cnComputerNameAppServer);
	tmsg.setDistributionNode(app.cnDistributionNode);
	tmsg.setDistributionProcess(app.cnDistributionProcess);
	tmsg.setProcessSignOnTime(process.signOnTime.cnGMT);
	if cc.myNodeControl <> null then
		tmsg.setNodeId(cc.myNodeControl.nodeId);
		tmsg.setNodeType(cc.myNodeControl.nodeType);
	endif;

	if app.isUnicode then					// this was previously just in KCCMgr SOA, but added here so
    	tmsg.setPlatformType(1);			// that any SOA can create the Master Env object.
		
    else
    	tmsg.setPlatformType(0);
    endif;
	
	if node.isServerNode then				// PAR 3092
		tmsg.setLogPath(cc.dbLogPath);		// PAR 3092
	
	else									// PAR 3092
		tmsg.setLogPath(cc.logPath);		// PAR 3092
	endif;
	
	tmsg.setBinDriveLetter(app.getJadeInstallDirAppServer[1]);
	create ci transient;					// CnClusterInfo
    tmsg.setClusterDetails(ci.virtualMachineName, ci.clusterName, ci. clusterGroup, ci.preferredHost, ci.possibleHosts);
    if ci.virtualMachineName = null then
    	cc.cnWriteLog(cc.CnLogDiag, "Node is not running in a cluster (virtualMachineName is null).", null);
    endif;
	
	tmsg.sendMessage(null); 							// tcp parameter will be null
	
	if cc.appName = CN_KCNODECONTROL and cc.logPathError then
		app.cnRaiseJossAlert(Cn_Karma_Alert,
						 	"Incomplete initialization file setup for environment " & kc.environmentId.toUpper & " on " & node.cnGetComputerName,
				     	 	"Initialization file '" & app.getIniFileNameAppServer & "' has [CardLog] LogPath=" &
				     	 	 cc.logPath & ", or LogPath is not defined.",
				     	 	"N",
				     	 	app.actualTime,
				     	 	cc.appName,
				     	 	kc.managedEnvironmentName,																			// JSM PAR 8367
				     	 	node.cnGetComputerName,
				     	 	kc.networkAddressNode,  //	PAR 441 node.networkAddress,
				     	 	kc.myParentTcp);	
	endif;
	
	if cc.appName <> CN_KCCMGR then
		maxLocalProcessStr := app.getProfileStringAppServer(app.getIniFileName(), "JadeClient", "MaxLocalProcesses", null).toLower();
		if Cn_Debug_NodeProcessMonitoring then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " NODE_MONITOR maxLocalProcesses=" & maxLocalProcessStr, null);
		endif;
		
		if maxLocalProcessStr <> null then
			node.causeEvent(CN_REGISTER_MAXLOCALPROCESSES, true, maxLocalProcessStr.Integer);
		endif;
	endif;
epilog
	delete ci;
	delete msg;
	delete tmsg;
end;
}
moveFile
{
moveFile(sourceFile, destFile : String) : Boolean;

vars
	result	: Integer;
	kc		: CnKarmaCntrl;	
	cc		: CnCntrl;
	int, i	: Integer;
	str		: String;
	errortext : String;
	file	: File;
	cem			: CnExternalMethods;
begin
	cc 		:= app.myCnCntrl;
	create file transient;
	result 	:= file.emMoveFileEx(sourceFile, destFile, 1);		// 1 = Overwrite
    str		:= "Move of " & sourceFile & " to " & destFile;

	if result = null then 
 		cc.cnWriteLog(cc.CnLogDiag, str & " was successful", null); 	
 		return true;
	endif;

	create cem transient;
	int	:= cem.emGetErrorText(result, errortext, 127);
	if int <> 0 then
		cc.cnWriteLog(cc.CnLogErrors, "CnExternalMethods::emGetErrorText got error result=" & int.String, null);
	endif;

	str := str & " not done : result=" & result.String & ":" & errortext;
	cc.cnWriteLog(cc.CnLogErrors, str, null); 
	return false;
epilog
	delete cem;
	delete file;
end;
}
moveFileEx
{
moveFileEx(sourceFile, destFile : String; errText : String output) : Boolean;

vars
	result	: Integer;
	kc		: CnKarmaCntrl;	
	cc		: CnCntrl;
	int, i	: Integer;
	str		: String;
	errortext : String;
	file	: File;
	cem			: CnExternalMethods;
begin
	//
	//  Method is similar to ::moveFile, but returns errText as an ouput parameter.
	//  Added for CardSchema 3.1.....15 Dec 04 RWM
	// 
	cc 		:= app.myCnCntrl;
	create file transient;
	result 	:= file.emMoveFileEx(sourceFile, destFile, 1);		// 1 = Overwrite
    str		:= "Move of " & sourceFile & " to " & destFile;

	if result = null then 
		errText		:= str & " was successful.";
 		cc.cnWriteLog(cc.CnLogDiag, errText, null); 	
 		return true;
	endif;
	
	create cem transient;
	int	:= cem.emGetErrorText(result, errortext, 127);
	if int <> 0 then
		cc.cnWriteLog(cc.CnLogErrors, "CnExternalMethods::emGetErrorText got error result=" & int.String, null);
	endif;

	str := str & " not done : result=" & result.String & ":" & errortext;
	cc.cnWriteLog(cc.CnLogErrors, str, null); 
	return false;
epilog
	delete cem;
	delete file;
end;
}
removeFile
{
removeFile(filename : String) updating;

vars
 	file 	: File;
 	cc		: CnCntrl;
begin
	cc := app.myCnCntrl;

	create file transient;
	file.fileName := filename;
	if file.isAvailable then
		file.purge;
		cc.cnWriteLog(cc.CnLogComment, "File " & filename & " removed.", null);
	else
		cc.cnWriteLog(cc.CnLogComment, "File " & filename & " not removed - not found.", null);	
	endif;

epilog
	delete file;
end;
}
renameFile
{
renameFile(fileName, newFileName : String; override : Boolean) : String updating;

vars
	file	: File;
	newfile	: File;
begin
	//  This method renames the selected file.  If override is false and newFileName already
	//  exists, or if fileName doesn't exist then returns error, else returns OK.

	create file transient;
	file.fileName := fileName;
	if not file.isAvailable then
		return "Rename failed : file " & fileName & " not found.";
	endif;

	create newfile transient;
	newfile.fileName := newFileName;
	if newfile.isAvailable then
		if override then
			newfile.purge;
		else
			return "Rename failed : new file name (" & newFileName & ") already exists.";	
		endif;
	endif;

	file.rename(newFileName);
	return CN_OK;
epilog
	delete file;
	delete newfile;
end;
}
requestCacheStatistics
{
requestCacheStatistics();

vars
	nod		: Node;
	obj		: Object;
	prc		: Process;
	error	: Boolean;
	cc		: CnCntrl;
begin
	cc	:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : will now request nodes to submit cache statistics ....", null);
   	system.causeEvent(Cn_Cache_Stats_Request, true, 0);
   	cc.cnWriteLog(cc.CnLogDiag, "Cn_Cache_Stats_Request event has been caused on System object.", null);
end;
}
sdsExceptionHandler
{
sdsExceptionHandler(pExObj : Exception; pObj : Object) : Integer;

vars
	cc			: CnCntrl;
	errorCode	: Integer;
	sd			: CnStackDump;
begin
	cc	:= app.myCnCntrl;
	errorCode := pExObj.errorCode;
	if errorCode <> JErr_SdsNotInitialized 			and			// 3201
	   errorCode <> Cn_RequestedPropertyNotDefined 	then		// 1011
		return Ex_Pass_Back;
	endif;

	create sd transient;
	if errorCode = JErr_SdsNotInitialized then					// SDS not initialized
		cc.cnWriteLog(cc.CnLogErrors, "UE 3201 - SDS not initialized - discarding current action.", null);
		sd.dumpCallStack(true, true);
		abortTransaction;
		return Ex_Abort_Action;
	endif;
	
	if errorCode = Cn_RequestedPropertyNotDefined and pExObj.errorObject = pObj then
		cc.cnWriteLog(cc.CnLogErrors, "UE 1011 - property not valid for type : " & pExObj.errorObject.String & " - discarding current action.", null);
		sd.dumpCallStack(true, true);
		abortTransaction;
		return Ex_Abort_Action;
	endif;
	
	return Ex_Pass_Back;
epilog
	delete sd;
end;
}
sdsGetConnectionStateString
{
sdsGetConnectionStateString(state : Integer) : String;

vars

begin
	if state = SDS_Connected then
		return "Connected";
	elseif state = SDS_Disconnected then
		return "Disconnected";
	else
		return "Unknown (" & state.String & ")";
	endif;		
end;
}
sdsGetStateString
{
sdsGetStateString(state : Integer) : String;

vars

begin
	if state = SDS_StateCatchingUp then
		return "Catching Up";
		
	elseif state = SDS_StateDisconnected then
		return "Disconnected";

	elseif state = SDS_StateReorging then
		return "Reorging";

	elseif state = SDS_StateSynchronized then
		return "Synchronized";
		
	elseif state = SDS_StateTrackingHalted then
		return "Trancking Halted";

	elseif state = SDS_StateTransferHalted then
		return "Transfer Halted";
		
	else
		return "Unknown state : " & state.String;
	endif;
end;
}
sdsGetTrackingString
{
sdsGetTrackingString(trackingDisabled : Boolean) : String;

vars

begin
	if trackingDisabled then
		return "Tracking Disabled";
	else
		return "Tracking Enabled";
	endif;
end;
}
sendBinaryDetails
{
sendBinaryDetails(pTcp : CnKarmaTcpConnection input; pMachine : CnMachine);

vars
	msg,
	newmsg		: CnMessage;
	
	fda			: CnFileDetailsAdvice;
	
	kc			: CnKarmaCntrl;
	
	cc			: CnCntrl;
begin
	kc := app.myCnKarmaCntrl;
	cc := app.myCnCntrl;
	
	// send binary info
	create msg;
	msg.createNewMsg(msg.Advice, msg.File_Details_Advice, pMachine.clientFQDN, pMachine.ipAddress, cc.KCCMgr_Process, cc.JossCommsMgr_Process, newmsg);
	fda := newmsg.CnFileDetailsAdvice;
	fda.setAdviceType(fda.Advice_Type_FileDet_BinVer);
	kc.getBinariesInfo(fda.fileNameArray, 
					   fda.fileVersionArray,
					   fda.fileMD5HashArray,
					   fda.fileModifiedArray,
					   fda.fileTypeArray);
	fda.sendMessage(pTcp);
epilog
	delete msg;
	delete newmsg;
end;
}
sendOrStoreTranStats
{
sendOrStoreTranStats(pValue : Binary) : String updating;

/*		Note that this method gets reimplemented in the Joss schema

		PAR 977.	Previously this method was invoked by KCCMgr and was able to send STATADV messages over 48KB
					to JSA and JSM. 
					
					As of 3.8.09 and PAR 977, this method now creates shared transients so as to be able to ship
					details of greater than 48KB which KCCMgr turns into a STATADV message to JSA and then JSM.
*/

vars
	cc			: CnCntrl;
	
 	transStats	: CnTransactionStatistics;
begin
	cc			:= app.myCnCntrl;
	beginTransientTransaction;
	create transStats sharedTransient;
	transStats.setData(pValue);
	transStats.setDataLength(pValue.length);
	commitTransientTransaction;
	transStats.causeEvent(CN_SEND_TRANSACTIONSTATISTICS, true, null);
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " caused CN_SEND_TRANSACTIONSTATISTICS on sharedTransient " & transStats.String, null);
	return CN_OK;
end;
}
sendPingReplyAdvice
{
sendPingReplyAdvice(pSchemaName, pAppName : String; pProcessId : Integer; pUnsolicited : Boolean; pTimeStamp : TimeStamp) updating;

vars
	cc				: CnCntrl;
	
	tmsg, 
	newmsg			: CnMessage;
	
	msg				: CnPingReplyAdvice;

	isKCCMgr		: Boolean;

	dest			: String;
begin
	//////////////////////////////////////////////////////////////////////
	//
	//  This method is used for two purposes:
	//
	//	a.  To reply to CnPingCmd messages
	//	b.  To generate unsolicited status updates to JSM for SDS systems (KCCMgr only)
	//
	//////////////////////////////////////////////////////////////////////

	cc	:= app.myCnCntrl;
	isKCCMgr	:= (pAppName = CN_KCCMGR);
	if isKCCMgr then
		dest := cc.JossCommsMgr_Process;

	else
		dest := cc.KarmaCommsMgr_Process;
	endif;

	create tmsg;		
	tmsg.createNewMsg(tmsg.Advice, tmsg.Ping_Reply, localFQDN, localIpAddress, cc.Application_Process, dest, newmsg);
	msg		:= newmsg.CnPingReplyAdvice;
	msg.setTimestamp(pTimeStamp);
	msg.setManagedEnvironmentName(managedEnvironmentName);
	msg.setAppName(pAppName);
	msg.setAppSchemaName(pSchemaName);
	msg.setIsMultiUser(app.isMultiUser);
	
	if not pUnsolicited then
		msg.setProcessId(pProcessId);
		cc.cnWriteLog(cc.CnLogDiag, "Now replying to ping timed at " & pTimeStamp.String & ", appName=" & pAppName, null);
	endif;
	
	if isKCCMgr then
		self.zDoKCCMgrFunctions(msg);
	endif;
			
	newmsg.sendMessage(self.myParentTcp);
epilog
	delete tmsg;
	delete msg;
end;
}
setBinPath
{
setBinPath(path : String) updating;

vars

begin
	if path[path.length :1] = "/" then
		self.binPath := path[1:path.length-1];
	else
		self.binPath := path;
	endif;
end;
}
setBinPathAppServer
{
setBinPathAppServer(path : String) updating;

vars

begin
 	self.binPathAppServer := path;
end;
}
setClientFileAccessMode
{
setClientFileAccessMode(mode : Integer) updating;

vars

begin
   	self.clientFileAccessMode := mode;
end;
}
setClientRequiresMisc
{
setClientRequiresMisc(set : Boolean) updating;

vars

begin
	self.clientRequiresMisc := set;
end;
}
setDbPath
{
setDbPath(path : String) updating;

vars
	len	: Integer;
	
	str	: String;
begin
	str := path;
	str.replaceChar(CN_SLASH, CN_BACK_SLASH);
	len := str.length();
	if path[len :1] = CN_BACK_SLASH then
		len := len - 1;
		str  := str[1:len];
	endif;
	
	self.dbPath := str;
end;
}
setDriveLetter
{
setDriveLetter() updating;

vars

begin
	self.driveLetter := app.getJadeInstallDirAppServer[1:1];
end;
}
setEnvironmentId
{
setEnvironmentId() updating;

vars
	str			: String;

	env_id		: String;
	
	maxLength,
	posn 		: Integer;
	
	cc			: CnCntrl;
	
	osType		: String;
	
	processApp	: Application;
	
	cnApp		: CardSchema;
begin
	processApp := process.getProcessApp();
	if processApp.isKindOf(CardSchema) then			// importing schema is sub-schema of CardSchema
		cnApp := processApp.CardSchema;
	
	else
		cnApp := app;
	endif;
	
	posn 		:= 1;
	env_id		:= self.getEnvironmentId(processApp.dbPath);
	
	osType		:= "Windows";
	maxLength	:= Cn_Max_EnvironmentName_Length;																				// JSM PAR 7586
	cc 			:= cnApp.myCnCntrl;

	if cc.karmaControl then
		if env_id.length() > maxLength then
			str	:= "Environment id (" & env_id & ") is overlength - JADECare Systems Management standard specifies maximum length=" &
					maxLength.String & " for " & osType & " operating systems";
			cc.cnWriteLog(cc.CnLogErrors, "FATAL ERROR : " & str & ", when KarmaControl=true in .ini file.", null);
			if processApp.applicationType = processApp.ApplicationType_GUI then
				app.msgBox(str,																									// JSM PAR 7586
						   "Fatal Startup Error", 48);
			endif;
			
			cnApp.cnTerminate();
		endif;
	
	else
		maxLength := self.environmentId.maxLength;																				// PAR 633
		if env_id.length() > maxLength then																						// PAR 633
			cc.cnWriteLog(cc.CnLogComment, "WARNING : environment id exceeds " & maxLength.String & 							// PAR 633
											" bytes, environment id truncated....", null);										// PAR 633
		endif;																													// PAR 633
	endif;																														// PAR 633

 	self.environmentId := env_id[1:maxLength];																					// PAR 633, JSM PAR 7586
end;
}
setExceptionErrorCode
{
setExceptionErrorCode(code : Integer) updating;

vars

begin
 	self.exceptionErrorCode := code;
end;
}
setExceptionFileName
{
setExceptionFileName(str : String) updating;

vars

begin
	self.exceptionFileName := app.cnStandardizePathName(str);
end;
}
setExceptionText
{
setExceptionText(text : String) updating;

vars

begin
 	self.exceptionText := text;
end;
}
setFileMaxRetries
{
setFileMaxRetries(retries : Integer) updating;

vars

begin
	self.fileMaxRetries	:= retries;
end;
}
setFileRetryInterval
{
setFileRetryInterval(pValue : Integer) updating;

vars

begin
	self.fileRetryInterval := pValue;
end;
}
setFileRetryNo
{
setFileRetryNo(retry : Integer) updating;

vars

begin
   	fileRetryNo := retry;
end;
}
setForm
{
setForm(frm : Form) updating;

vars

begin
	self.form := frm;
end;
}
setHadFileException
{
setHadFileException(set : Boolean) updating;

vars

begin
 	self.hadFileException := set;
end;
}
setJossFQDN
{
setJossFQDN(fqdn : String) updating;

vars

begin
 	self.jossFQDN := fqdn;
end;
}
setLocalFQDN
{
setLocalFQDN(fqdn : String) updating;

vars

begin
 	self.localFQDN := fqdn;
end;
}
setLocalIpAddress
{
setLocalIpAddress(addr : String) updating;

vars

begin
  	self.localIpAddress := addr;
end;
}
setManagedEnvironmentName
{
setManagedEnvironmentName(name : String) updating;

vars

begin
 	self.managedEnvironmentName := name;
end;
}
setMyCnProcess
{
setMyCnProcess(cnproc : CnProcess) updating;

vars

begin
	self.myCnProcess := cnproc;
end;
}
setMyKarmaCommsMgrProcess
{
setMyKarmaCommsMgrProcess(proc : Process) updating;

vars

begin
  	self.myKarmaCommsMgrProcess := proc;
end;
}
setMyParentTcp
{
setMyParentTcp(tcp : CnKarmaTcpConnection) updating;

vars

begin
 	self.myParentTcp := tcp;
end;
}
setNetworkAddressNode
{
setNetworkAddressNode(pAddress : String) updating;

vars

begin
	self.networkAddressNode := pAddress;
end;
}
setNetworkAddressProcess
{
setNetworkAddressProcess(pAddress : String) updating;

vars

begin
	self.networkAddressProcess := pAddress;
end;
}
setThinClientComputerIpAddress
{
setThinClientComputerIpAddress(pIpAddress : String) updating;

vars
	cc : CnCntrl;
begin
	if pIpAddress = null then
		self.thinClientComputerIpAddress := "SharedMemory";
		
	else
		self.thinClientComputerIpAddress := pIpAddress;
	endif;
end;
}
setThinClientComputerName
{
setThinClientComputerName(name : String) updating;

vars

begin
 	self.thinClientComputerName := name;
end;
}
setTranStatsAlertTimeStamp
{
setTranStatsAlertTimeStamp(pValue : TimeStamp) updating;

vars

begin
	self.tranStatsAlertTimeStamp := pValue;
end;
}
setTranStatsInterval
{
setTranStatsInterval(int : Integer) updating;

vars

begin
	self.tranStatsInterval := int;
end;
}
setUpTranLogFile
{
setUpTranLogFile() updating;

vars
	file	: CnFile;
	
	cc		: CnCntrl;
	
	date	: Date;
	
	sd		: CnStackDump;
begin
	cc	:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " starting...", null);
  	create file;
   	file.fileName 		:= cc.logPath & "/cn_tranlog_" & date.cnUserFormat($CnCCYYMMDD_ns) & ".csv"; 
    file.mode			:= file.Mode_Append;
    file.shareMode		:= file.Share_Read;
    file.kind			:= file.Kind_ANSI;
    file.currentDate	:= date;
    app.myCnTranLogFile	:= file;
    
    if not file.isAvailable then								// set up headings
    	self.setUpTranLogHeadings(file);
    endif;
epilog
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " myTranLogFile " & file.getOidString(), null);
end;
}
setUpTranLogHeadings
{
setUpTranLogHeadings(file : CnFile) updating;

vars
	line	: String;
begin
	line	:= "Date" 				& CN_COMMA &
			   "Time" 				& CN_COMMA &
			   "Computer"			& CN_COMMA &
			   "Server"				& CN_COMMA &																				// PAR 980
			   "IP Address"			& CN_COMMA &
			   "App Name"			& CN_COMMA &
			   "User"				& CN_COMMA &
			   "Tran Id"			& CN_COMMA &
			   "Elapsed (msecs)"	& CN_COMMA &
			   "CPU (msecs)"		& CN_COMMA &
   			   "DB Tran Id" 		& CN_COMMA &
			   "Proc Id" 			& CN_COMMA &
			   "Error?"				& CN_COMMA &
			   "GetObjs"			& CN_COMMA &
			   "LockObjs"			& CN_COMMA &
			   "Unlocks"			& CN_COMMA &
			   "Creates"			& CN_COMMA &
			   "Updates"			& CN_COMMA &
			   "Deletes"			& CN_COMMA &
			   "Commits"			& CN_COMMA &
			   "Events"				& CN_COMMA &
			   "Server Executions"  	& CN_COMMA &
			   "Server Execution Time"  & CN_COMMA &
			   "LockQ Time"			& CN_COMMA &
			   "TC AppServer Msgs"	& CN_COMMA &	
			   "TC AppServer Bytes"	& CN_COMMA &
			   "TC Client Msgs"		& CN_COMMA &
			   "TC Client Bytes" 	& CN_COMMA &
			   "TC Net Time"		& CN_COMMA &
			   "Perceived Response" & CN_COMMA &
   			   "Level";

			   
	file.writeLine(line);
	file.writeLine(" ");	 
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;


vars
	cc			: CnCntrl;
	
	cnDba		: CnJadeDatabaseAdmin;

	kc			: CnKarmaCntrl;
	
	reorging	: Boolean;
begin
	kc := app.myCnKarmaCntrl;
	cc := app.myCnCntrl;

	if eventTag = self.Tran_Stats_Timer then						// this was changed for 2.9 to work autonomously from JSA
//		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " Tran_Stats_Timer event has occurred in CnKarmaCntrl.", null);
		if cc.appName = CN_KCSTATSCOLLECTOR then					
			self.captureSystemStatistics;					// captures and stores JOM stats for period
			self.myTransactionData.sendTranStatsToKarma();	// Now we send the consolidated results to Karma.
			self.requestCacheStatistics();					// tell selected process for each node to get cache stats
		
		else												// we are a client process
			self.handleTranStatsRequestEvent();
		endif;
		
		return;
	endif;
	
	if eventTag = Cn_SendDbDetails_Timer then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " sending database details to JSM...", null);
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_DatabaseLockedForReorganize, null, reorging);
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_DatabaseFileLockedForReorg, null, reorging);
		create cnDba transient;
		cnDba.getDatabaseDetailsSendAdvice();
		if reorging then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " database or files locked for reorganization, set up retry...", null);
			self.beginTimer(Cn_SendDbDetails_TimeReorg, Timer_OneShot, Cn_SendDbDetails_Timer);
			
		else
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " set timer for 24 hours time...", null);
			self.beginTimer(Cn_SendDbDetails_TimeDaily, Timer_OneShot, Cn_SendDbDetails_Timer);
		endif;
		
		return;
	endif;

/*	code coverage
	if eventTag = 123456 then
		self.executeJadeProfiler(true);
		return;
	endif;
*/	
	cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " unknown eventTag " & eventTag.String & ", ignored.", null);
epilog							
	delete cnDba;
	if eventTag = self.Tran_Stats_Timer then																									
		if self.tranStatsInterval > null then
			self.beginTimer(self.tranStatsInterval * 1000, Timer_OneShot, self.Tran_Stats_Timer);
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : Tran_Stats_Timer event has been processed : restarting timer, interval=" & self.tranStatsInterval.String & " secs ...", null);
			
		else
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : Tran_Stats_Timer now stopped : interval is zero.", null);
		endif;
	endif;
end;
}
userNotification
{
userNotification(eventType: Integer; theObject: Object; eventTag: Integer; userInfo: Any) updating;

vars
	cnApp			: CardSchema;

	cc 				: CnCntrl;
	
	jnode,
	jnode2			: CnJadeNode;
	
	jprocess,
	jprocess2		: CnJadeProcess;

	msg				: CnMessage;
	
	frm				: CnMsgForm;

	cnproc			: CnProcess;

	xnode			: Node;

	obj				: Object;

	proc			: Process;

	objSet			: ObjectSet;
	
	badObject,
	error			: Boolean;
	
	d1				: Decimal [23];																								// PAR 1014

	delay,
	option,
	pos,
	procId,
	remaining,
	result			: Integer;
	
	application,
	command,
	constName,
	message,
	schema,
	sourcecomputer	: String;		
	str				: String;

	now				: TimeStamp;
begin
	cnApp := app.cnGetCardSchemaApp(true);
	cc := cnApp.myCnCntrl;

	if eventType 	= Cn_Session_Open_Advice_Request then
		constName	:= "Cn_Session_Open_Advice_Request"; 
	
	elseif eventType = Cn_Tran_Stats_Request then
		constName	:= "Cn_Tran_Stats_Request";

	elseif eventType = Cn_Tran_Stats_Timer_Change then
		constName	:= "Cn_Tran_Stats_Timer_Change";

	elseif eventType = Cn_Tran_Stats_Submission then
		constName	:= "Cn_Tran_Stats_Submission";
		
	elseif eventType = Cn_Message_To_Client then
		constName	:= "Cn_Message_to_Client";
		
	elseif eventType = Cn_Launch_Application_Process then
		constName	:= "Cn_Launch_Application";
		
	elseif eventType = cc.Cn_Control_Command then
		constName	:= "cc.Cn_Control_Command";
		
	elseif eventType = CN_WRITE_SERVER_LOG then
		constName	:= "CN_WRITE_SERVER_LOG";
		
	elseif eventType = JadeDatabaseAdmin.LogTransferEvent then
		constName	:= "JadeDatabaseAdmin.LogTransferEvent";
		
	elseif eventType = CN_HEARTBEAT then
		constName	:= "Heartbeat Event";
		
	elseif eventType = Cn_Launch_Application_Node then
		constName	:= "Cn_Launch_Application_Node";
		
	elseif eventType = Cn_SOA_UserPatches_Alert then
		constName	:= "SOA Userpatches Alert";

	elseif eventType = Cn_Analyze_Transients then
		constName	:= "Cn_Analyze_Transients";
	
		// only will occur in KCCMgr application
	elseif eventType = CN_REPORT_LOCKEXCEPTION then
		constName	:= "Report LockException";
		
	elseif eventType = CN_SEND_TRANSACTIONSTATISTICS then
		constName	:= "CN_SEND_TRANSACTIONSTATISTICS";
		
	elseif eventType = CN_COMPACT_TRANSIENT_FILE then																			// PAR 1014
		constName	:= "CN_COMPACT_TRANSIENT_FILE";																				// PAR 1014
		
	else
		constName	:= "<unknown>";
	endif;
	
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " eventType=" & eventType.String & " (" &
								constName & "), userInfo=" & userInfo.Binary.ansiToString, null);

	//////////////////////////////   Log to Server  ////////////////////////////////////////////////
	
	if eventType = CN_SEND_TRANSACTIONSTATISTICS then																			// PAR 977
		self.zForwardTransactionStatistics(theObject);																			// PAR 977
		return;																													// PAR 977
	endif;																														// PAR 977
	
	if eventType = CN_WRITE_SERVER_LOG then								// Only KCCMgr subscribes to this
		cc.cnWriteLog(cc.CnLogComment, userInfo.String, null);
		return;
	endif;
	
	if eventType = CN_COMPACT_TRANSIENT_FILE then																				// PAR 1014
		d1 := app.relativeMachineTime();																						// PAR 1014
		cc.cnWriteLog(cc.CnLogComment, "Started compaction of transient file...", null);										// PAR 1014
		process.compactTransientFile();																							// PAR 1014
		cc.cnWriteLog(cc.CnLogComment, "Completed compaction of transient file, " & d1.cnGetElapsedTimeString(), null);			// PAR 1014
	endif;																														// PAR 1014

	//////////////////////////////   SOA User Patches Alert  ///////////////////////////////////////////
	if eventType = Cn_SOA_UserPatches_Alert then						// Only KCCMgr subscribes to this
		cc.cnWriteLog(cc.CnLogComment, "User patches size exceeded 0.6MB : " & userInfo.String, null);
		app.cnRaiseJossAlert(Cn_Karma_Alert,
							"User patches string exceeded 0.6MB for " & self.environmentId.toUpper(),
							"The user patches string exceeds 0.6MB (actual=" & userInfo.String & "). " &
							"As this has the potential to cause registration with JSA to fail, these details are no longer being sent. " &
							"When convenient, script needs to execute CardSchema::CnUtility::resetUserAppliedPatchesAll to clear this history.",
							"N",
							app.actualTime,
							cnApp.name,
							self.managedEnvironmentName,																		// JSM PAR 8367
							self.jossFQDN,
							self.localIpAddress,
							self.myParentTcp);
		return;
	endif;
	
	////////////////////////////////////////////  Transaction Stats  //////////////////////////////////////////////////
	
	if eventType = Cn_Tran_Stats_Timer_Change then		// 55000262	
		self.tranStatsInterval	:= userInfo.Integer;	// set new delay value
		if not self.getTimerStatus(Tran_Stats_Timer, option, remaining) then		// timer not currently running
			if self.tranStatsInterval > null then
				beginTimer(self.tranStatsInterval * 1000, Timer_OneShot, self.Tran_Stats_Timer);
			endif;
		endif;											// otherwise timer gets stopped or changed at next timer event	
		
		if self.tranStatsInterval = null 	and																					// PAR 977
		   cc.appName = CN_KCSTATSCOLLECTOR then																				// PAR 977
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " transaction stats interval changed to zero, terminating...", null);	// PAR 977
			app.cnTerminate();																									// PAR 977
		endif;																													// PAR 977
		
		return;
 	endif;  
 	
	if eventType = Cn_Tran_Stats_Submission then		// 55000261		// only KCCMgr receives this, from clients
		self.myTransactionData.handleTranStatsSubmissionEvent(userInfo);
    	return;
	endif;
	
	////////////////  KCCMgr requested to pass start application request to first registered process ///////////////
	if eventType = Cn_Launch_Application_Node then
		xnode := theObject.Node;
		on SystemException do app.cnHandleNullOrInvObjectRef(exception, null, badObject);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " search for node with pid=" & xnode.osID.String, null);
		foreach jnode in app.myCnKarmaCntrl.allCnJadeNodes do
			if jnode.osID = xnode.osID then
				jnode2 := jnode;
				break;
			endif;
		endforeach;
		
		if jnode2 = null then
			str := "Start application request failed as node with PID " & xnode.osID.String & " not found";
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & str, null);
			xnode.causeEvent(Cn_Launch_Application_Reply, true, str);
			return;
		endif;
		
		foreach jprocess in jnode2.allCnJadeProcesses do
			if jprocess.notRegistered then
				continue;
			endif;
			
			jprocess2 := jprocess;
			break;
		endforeach;
		
		if jprocess2 = null then
			str := "Start application request failed as unable to find registered process in node PID " & xnode.osID.String;
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & str, null);
			xnode.causeEvent(Cn_Launch_Application_Reply, true, str);
			return;
		endif;
		
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " search for process with oid instance " & jprocess2.processId.String, null);
		create objSet transient;
		xnode.processes.copy(objSet);
		foreach obj in objSet do
			if cnGetInstanceId(obj) = jprocess2.processId then
				proc := obj.Process;
				break;
			endif;
		endforeach;
		
		if proc = null then
			str := "Start application request failed as unable to find registered process instance " & 
						jprocess2.processId.String & " in node PID " & xnode.osID.String;
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & str, null);
			xnode.causeEvent(Cn_Launch_Application_Reply, true, str);
			return;
		endif;
		
		proc.causeEvent(Cn_Launch_Application_Process, true, userInfo);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " KCCMgr passed on start application request (userInfo '" & userInfo.String & ") to process " & proc.getObjectStringForObject(proc), null);
		return;
	endif;
	
	//////////////////////////  Process has been requested to start application in this node ///////////////
	if eventType = Cn_Launch_Application_Process then
		pos := 1;
		schema := userInfo.String.scanUntil(CN_COMMA, pos);
		application := userInfo.String[pos+1:end];
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " requested start of application '" & application & "' of schema '" & schema & "'", null);
		proc := app.startApplication(schema, application);																		// PAR 963
		if app.isValidObject(proc) then																							// PAR 963
			node.causeEvent(Cn_Launch_Application_Reply, true, CN_OK);															// PAR 963

		else																													// PAR 963
			node.causeEvent(Cn_Launch_Application_Reply, true, "Process failed to start, check jommsg.log");					// PAR 963
		endif;																													// PAR 963
		return;
	endif;
	/////////////////////////  Log Transfer Event   //////////////////////////////////////////////////////////

	if cnApp.name = CN_KCCMGR and eventType = JadeDatabaseAdmin.LogTransferEvent then
		cc.cnWriteLog(cc.CnLogComment, "Database transaction log #" & userInfo.Integer.String & " has been released.", null);
		//
		//  Future code to go here to copy off the log
		//
		return;
	endif;

	/////////////////////////  Session Open Advice Request  //////////////////////////////////////////////////

	if eventType = Cn_Session_Open_Advice_Request then		// KCCMgr requests session status of clients
		cc.cnWriteLog(cc.CnLogConnect, "Process.userCode=" & process.userCode &
							": now sending session open msg to KCCMgr at KCCMgr's request", null);
		self.issueSessionOpenAdvice();
		if node.isApplicationServer() then
			self.getAndSendSSLDetails();
		endif;
		return;
	endif;

	/////////////////////////////  Message to Client  ///////////////////////////////////////////////////////////////

	if eventType = Cn_Message_To_Client then
		cc.cnWriteLog(cc.CnLogDiag, "Cn_Message_To_Client event : got message from Karma, buffer=" & userInfo.String, null);
		create msg;
		msg.receiveMsg(userInfo.Binary, process, 0);
		return;
	endif;

	////////////////////////////  Process Control Command or Message  ///////////////////////////////////////////////

	if eventType = cc.Cn_Control_Command and cnApp.name <> CN_KCCMGR then
		str	:= userInfo.String;
		if cnApp.name = CN_JADERPSDATAPUMP then			// need to be able to also handle user-defined datapump, refer to JADE #48943
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & CN_JADERPSDATAPUMP & " ignoring all ControlCommands : " & str, null);
			return;
		endif;
		
		cc.cnWriteLog(cc.CnLogDiag, "Cn_Control_Command event : buffer=" & str, null);
		pos := 1;
		command 		:= str.getNextToken(pos);
		sourcecomputer 	:= str.getNextToken(pos);
		delay			:= str.getNextToken(pos).Integer;

		if  command = CnMessage.System_Shut_Down_Msg then
			//
			if	cnApp.cnApplicationType = app.ApplicationType_GUI and not cc.suppressManagementDialogs then
				message				:= str[pos : end];
				create frm;
				frm.message 		:= message;
				frm.delay			:= delay;
				frm.sourceComputer 	:= sourcecomputer;
				frm.show;
				return;
			endif;
				
			cc.cnWriteLog(cc.CnLogComment, "System shut down warning '" & str[pos: end] & "' received, but " &
						  "message not displayed - either not a GUI application or SuppressManagementDialogs=true.", null);
			return;

		elseif command = "MSGM" and cnApp.cnApplicationType <> app.ApplicationType_Web_Enabled	and	
			   not cnApp.cnApplicationType = app.ApplicationType_Non_GUI	and 
			   not cnApp.cnIsServerApp 									then 
			message	:= str[pos : end];
			app.msgBox(message, "Message From " & sourcecomputer, 48);	// modal msg box, but exclude web clients

		elseif command = CnMessage.Quit_Client then					// controlled shut down
			cc.cnWriteLog(cc.CnLogComment, "Client QUIT command received.  If no modal dialogs exist, I will terminate now.", null);
			app.cnTerminate();

		elseif command = CnMessage.Kill_Client then					// this is unconditional, to terminate clients sittimg on modal dialog
        	cc.cnWriteLog(cc.CnLogComment, "KCCMgr has told me to kill myself....attempting to comply.....", null);

        	result := getProcessId(procId);
            if result = 0 then
            	result := killProcess(procId);

            	if result <> 0 then
            		cc.cnWriteLog(cc.CnLogErrors, "Couldn't kill myself, result=" & result.String, null);
            	endif;

            	return;

            else
            	cc.cnWriteLog(cc.CnLogErrors, "Kill myself failed : couldn't get my own process id, result = " & result.String, null);
            endif;	

		else
			cc.cnWriteLog(cc.CnLogErrors, "Unrecognised command type '" & command & "' ... ignored", null);
		endif;
		
		return;
	endif;
	
	////////////////////////////////////  Heartbeat event from app to KCCMgr  //////////////////////////////////
	
	if eventType = CN_HEARTBEAT then
		proc	:= theObject.Process;
		on SystemException do app.cnHandleNullOrInvObjectRef(exception, proc, error);
		cnproc	:= allCnProcesses[app.cnGetInstanceId(proc)];
		if error then
			return;
		endif;
		on SystemException do null;
		
		if cnproc <> null then
			cnproc.setHeartbeatTimestamp(now);
		endif;
	
		return;
	endif;
	
	if eventType = Cn_Analyze_Transients then
		self.zAnalyzeTransients();
	endif;
	
	if eventType = CN_REPORT_LOCKEXCEPTION then
		self.zReportLockException(theObject, userInfo);
	endif;
epilog
	delete objSet;
	delete msg;
end;
}
zAnalyzeTransients
{
zAnalyzeTransients() protected;

constants
	VERSION		: String	= ", Version 1";
	MIN_SIZE	: Integer64	= 2000000;
vars
	file		: File;
	
	procNode	: Node;

	d1			: Decimal[23];
	
	fileLength	: Integer64;

	analysis,
	str			: String;
	
	ts			: TimeStamp;
	
	cc			: CnCntrl;
begin
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & ".....", null);
	d1 := app.relativeMachineTime();
	
	create file transient;
	file.usePresentationFileSystem := false;
	file.fileName := app.myCnCntrl.logPath & 
						"/transient_analysis_" &
						ts.date().cnUserFormat($CnCCYYMMDD_ns) & "_" &
						ts.time().cnUserFormat($CnHHMMSS_ns) & "_node" & 
						self.cnGetInstanceId(node).String & 
						"_process" & 
						self.cnGetInstanceId(process).String &
						".txt";
	file.mode := file.Mode_Output;
	file.open();
	str := "Created " & ts.String & VERSION;
	file.writeLine(str);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & str, null);
	fileLength := process.getTransientFileLength();
	str := process.getOidString() & 
			" in node " & node.osID.String & " " & node.name & 
			" file " & process.getTransientFileName() & " length=" & fileLength.cnConvertToByteString();
	file.writeLine(str);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & str, null);
	str := "Process schema=" & process.schema.name & 
						", app=" & process.persistentApp.name;
	file.writeLine(str);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & str, null);
	if fileLength < MIN_SIZE then
		str := "Transient size is less than " & MIN_SIZE.cnConvertToByteString() & ", no analysis done.";
		file.writeLine(str);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & str, null);
		app.cnCheckForTransients();
		return;
	endif;

	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " executing process.analyzeTransientFileUsage...", null);
	analysis := process.analyzeTransientFileUsage();
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " completed execution of process.analyzeTransientFileUsage", null);
	str := "Transient Analysis : length=" & analysis.length().String & ", " & d1.cnGetElapsedTimeString();
	file.writeLine(str);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & str, null);
	file.writeLine(analysis);
	
/*	Look at parsing the analysis string and expanding the 
	class numbers into meaningful SchemaName::ClassName values
	
	Note that the following RootSchema class numbers equate to classes not visible in RootSchema
	85	CollectionBlock
	86	ListBlock
	87	BtreeBlock
	88	DictBlock
	89	SetBlock
	90	JadeDataBlock
	91	ArrayBlock
*/
	
	app.cnCheckForTransients();
epilog
	str := "Process is in exception state = " & process.isInExceptionState().String;
	file.writeLine(str);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & str, null);
	file.close();
	delete file;
end;
}
zBuildTransactionStatsHeader
{
zBuildTransactionStatsHeader() : Binary protected;

vars
	cc			: CnCntrl;
	
	sampleStats	: Boolean;
	
	appName,
	computerName,
	networkAddr,
	userName	: Binary;
begin
	cc := app.myCnCntrl;
	if cc.myNodeControl <> null then
		sampleStats	:= cc.myNodeControl.sampleProcessStats;
	endif;
	
	// convert all strings into binary so that when we
	// define lengths into the binary as well, this takes 
	// into account whether ANSI or Unicode.
	appName			:= cc.appName.Binary;
	computerName 	:= app.cnComputerName.Binary;
	networkAddr		:= self.networkAddressProcess.Binary;
	userName		:= app.userName.Binary;
	return 	computerName.length().Binary 	&
			computerName.Binary 			&
			networkAddr.length().Binary		&
			networkAddr.Binary				&
			userName.length().Binary		&
			userName.Binary					&
			appName.length().Binary			&
			appName.Binary					&
			sampleStats.Character.Binary;
end;
}
zCheckJadeAutoUpdateRequired
{
zCheckJadeAutoUpdateRequired() : String protected;
/*
	Purpose:
	
	Check that [JadeAutoUpdate] section is defined correctly for JADECare Managed Environments
*/
constants
	ErrorTrailer		: String	= "This MUST be defined for a JADECare managed environment : application terminating now <<<<<<<";
vars
	processApp			: Application;

	cnApp				: CardSchema;
	
	cc					: CnCntrl;
	
	kc					: CnKarmaCntrl;
	
	file				: File;
	
	cfgDir,
	cfgName,
	iniParameter,
	iniParameterError,
	iniValue			: String;
begin
	cc					:= app.myCnCntrl;
	kc					:= app.myCnKarmaCntrl;
	processApp 			:= process.getProcessApp();
	if processApp.isKindOf(CardSchema) then
		cnApp 			:= processApp.CardSchema;
	
	else
		cnApp 			:= app;
	endif;
	
	iniParameter 		:= "[" & CN_JADEAUTOUPDATE & "] " & CN_ENABLE_AUTO_UPDATE;
	iniParameterError 	:= ">>>>>>  " & iniParameter;
	iniValue := cnApp.cnGetProfileStringServer(CN_JADEAUTOUPDATE, CN_ENABLE_AUTO_UPDATE, null).toLower();
	cc.cnWriteLog(cc.CnLogComment, iniParameter & "='" & iniValue & "' specified in database ini file", null);
	if iniValue <> true.String then
		return iniParameterError & " either not defined or set to false in database server's ini file. " & ErrorTrailer;
	endif;
	
	cfgDir := cnApp.cnGetProfileStringServer(CN_JADEAUTOUPDATE, CN_BASEDIRECTORY, null).trimBlanks();
	if cfgDir = null then
		iniParameterError := ">>>>>>  [" & CN_JADEAUTOUPDATE & "] " & CN_BASEDIRECTORY;
		return iniParameterError & " not defined in database server's ini file. " & ErrorTrailer;
	endif;
	
	cfgDir.replaceChar("\", "/");
	if cfgDir[cfgDir.length()] = "/" then				// drop trailing '/' from directory name
		cfgDir := cfgDir[1:cfgDir.length() - 1];
	endif;
	
	cfgName := cnApp.cnGetProfileStringServer(CN_JADEAUTOUPDATE, CN_CURRENTCONFIGURATION, null).trimBlanks();
	if cfgName = null then
		iniParameterError := ">>>>>>  [" & CN_JADEAUTOUPDATE & "] " & CN_CURRENTCONFIGURATION;
		return iniParameterError & " not defined in database server's ini file. " & ErrorTrailer;
	endif;
	
	create file transient;
	file.fileName := cfgDir & "/" & cfgName;
	file.mode 	  := file.Mode_Input;
	if file.isAvailable() then
		cc.cnWriteLog(cc.CnLogComment, "Configuration file '" & file.fileName & " confirmed as resident.", null);
		return CN_OK;
	endif;
	
	return ">>>>>>  Configuration file '" & file.fileName & " is not resident. " & ErrorTrailer;
end;
}
zCheckMappedExtentClasses
{
zCheckMappedExtentClasses(pRPSMappingName : String) subschemaHidden, protected, final;

vars
	cc			: CnCntrl;
	
	mapped		: Boolean;
	
	className	: String;
begin
	cc := app.myCnCntrl;
	
	className := CnRoot.name;
	mapped := self.zClassInMappedExtent(className, pRPSMappingName);
	cc.cnWriteLog(cc.CnLogComment, className & " mapped=" & mapped.String, null);
	
	className := CnLockTarget.name;
	mapped := self.zClassInMappedExtent(className, pRPSMappingName);
	cc.cnWriteLog(cc.CnLogComment, className & " mapped=" & mapped.String, null);
end;
}
zClassInMappedExtent
{
zClassInMappedExtent(pClassName, pRPSMappingName : String) : Boolean subschemaHidden, protected, final;

vars
	cls			: Class;
	
	obj			: Object;
	
	objSet		: ObjectSet;
	
	rv			: RelationalView;
begin
	create objSet transient;
	cls := currentSchema.getClass(pClassName);
	cls.getRpsMappingRefs(objSet);
	foreach obj in objSet do
		rv := obj.RelationalView;
		if rv.name = pRPSMappingName then
			return true;
		endif;
	endforeach;
	
	return false;
epilog
	delete objSet;
end;
}
zDoKCCMgrFunctions
{
zDoKCCMgrFunctions(pMsg	: CnPingReplyAdvice) updating, protected;

vars
	msg 				: CnPingReplyAdvice;
	
	dba					: CnSDSDatabaseAdmin;
	
	jdo					: JadeDynamicObject;
	
	str					: String;
	
	reason,
	role,
	syncMode			: Integer;
	
	hadSDSError,
	hadMethodError,
	hadPropertyError	: Boolean;
	
	cc					: CnCntrl;
begin
	cc := app.myCnCntrl;
	if not app.isMultiUser then
		cc.cnWriteLog(cc.CnLogDiag, "KCCMgr in singleUser mode : no SDS info will be included in PingReply.", null);
		return;
	endif;
	
	msg := pMsg;
	
	role	:= system.getDatabaseRole;
	if role = SDS_RoleUndefined then
		cc.cnWriteLog(cc.CnLogDiag, "KCCMgr is not SDS system : no SDS info will be included in PingReply.", null);
		return;
	endif;
	
	create jdo transient;
	on Exception do app.cnGenericExceptionHandler(exception, JErr_SdsNotInitialized, null, hadSDSError);
	on Exception do app.cnGenericExceptionHandler(exception, Cn_RequestedPropertyNotDefined, jdo, hadPropertyError);
	on Exception do app.cnGenericExceptionHandler(exception, Cn_RequestedMethodNotDefined, jdo, hadMethodError);
	
	dba			:= app.myCnSDSDbAdmin;
	dba.sdsGetMyServerInfo(jdo);
	if hadSDSError and not self.sdsAlertIssued then
		if app.myCnSDSDbAdmin.inTakeoverState then																				// PAR 1045
			if app.myCnSDSDbAdmin.hostileTakeover then																			// PAR 1045
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " hostile takeover in progress", null);					// PAR 1045
			
			else																												// PAR 1045
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " negotiated takeover in progress", null);				// PAR 1045
			endif;																												// PAR 1045
			
			return;																												// PAR 1045
		endif;																													// PAR 1045
	
		self.sdsAlertIssued := true;
		if role = SDS_RolePrimary then
			str := "SDS Primary";
		
		else
			str := "SDS Secondary";
		endif;
		
		cc.cnWriteLog (CnCntrl.CnLogDiag, method.cnGetMethodName() & " Exception 3201 - SDS not initialized, database role = " & str & ", continuing", null);
		app.cnRaiseJossAlert(Cn_Karma_Alert,
								"Possible SDS problem in " & managedEnvironmentName & " on " & self.localFQDN,
								"Database role = " & str & " and SDS has not initialized." & CrLf &
								"Possible restore/refresh error where role has not been cleared and " &
								"ini file has not defined SDS parameters.",
								"N",
								app.actualTime(),
								cc.appName,
								self.managedEnvironmentName,																	// JSM PAR 8367
								self.localFQDN,
								self.localIpAddress,
								null);
		return;
	endif;
		
	msg.myName			:= jdo.getPropertyValue("myName").String;
	msg.databaseRole	:= role;
	
	if role = SDS_RolePrimary then				// primary		
		msg.connectedSecondaryServers	:= jdo.getPropertyValue("connectedSecondaryServers").Integer;
		return;
	endif;
	
	syncMode						:= jdo.getPropertyValue("syncMode").Integer;
	msg.connectionCheckInterval		:= jdo.getPropertyValue("connectionCheckInterval").Integer;
	msg.connectionState				:= jdo.getPropertyValue("connectionState").Integer;
	msg.databaseSubrole				:= jdo.getPropertyValue("subrole").Integer;			
	msg.reconnectInterval			:= jdo.getPropertyValue("reconnectInterval").Integer;
	msg.reorgStatus					:= jdo.getPropertyValue("reorgStatus").Integer;
	msg.state						:= jdo.getPropertyValue("state").Integer;
	msg.syncMode					:= syncMode;
	msg.sdsTrackingDisabled			:= jdo.getPropertyValue("trackingDisabled").Boolean;
	msg.sdsTracking					:= jdo.getPropertyValue("tracking").Boolean;
	reason							:= jdo.getPropertyValue("reasonTrackingStopped").Integer;
	msg.sdsTrackingStoppedReason	:= reason;
	msg.sdsLastErrorCode			:= jdo.getPropertyValue("lastErrorCode").Integer;
	
	if syncMode = SDS_BlockWrite then
		msg.latestReplayedAuditTimeStamp	:= jdo.getPropertyValue("latestReplayedAuditTimeStamp").TimeStamp;   
		msg.latestStableAuditTimeStamp		:= jdo.getPropertyValue("latestStableAuditTimeStamp").TimeStamp;	  
	endif;	
	
	msg.lastReplayJournalNumber		:= jdo.getPropertyValue("lastReplayJournalNumber").Integer;
	msg.lastReplayJournalTimeStamp	:= jdo.getPropertyValue("lastReplayJournalTimeStamp").TimeStamp;
	msg.latestReadyJournalNumber	:= jdo.getPropertyValue("latestReadyJournalNumber").Integer;
	msg.latestReadyJournalTimeStamp	:= jdo.getPropertyValue("latestReadyJournalTimeStamp").TimeStamp;
	
	if app.cnDatabaseSubrole = SDS_SubroleRelational then
		msg.rpsWorkers				:= jdo.getPropertyValue("rpsWorkers").Integer;
		if reason = SDS_ReasonRpsReorgHalt then
			msg.rpsTransitionHaltCode := jdo.getPropertyValue("rpsTransitionHaltCode").Integer;
		
		else
			msg.rpsTransitionHaltCode := -1;
		endif;
	endif;
	
	jdo.clear();
	dba.sdsGetPrimaryInfo(jdo);	
	self.setDbPath(jdo.getPropertyValue("dbPath").String);
	if self.dbPath = null then
		msg.primaryHostName			:= "N/A";				// not connected yet
		msg.primaryServerName		:= "N/A";

	else
		msg.primaryHostName			:= jdo.getPropertyValue("hostName").String;
		msg.primaryServerName		:= self.getEnvironmentId(dbPath);
	endif;
epilog
	delete jdo;
end;
}
zForwardTransactionStatistics
{
zForwardTransactionStatistics(pObject: Object) updating;

vars
	cc			: CnCntrl;
	
	tranStats	: CnTransactionStatistics;
begin
	cc		:= app.myCnCntrl;
	if not pObject.isKindOf(CnTransactionStatistics) then
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " unexpected object " & app.getClassForObject(pObject).name & ", ignored...", null);
		return;
	endif;
	
	tranStats := pObject.CnTransactionStatistics;
	tranStats.sendTranStats();
end;
}
zIssueSSLAdvice
{
zIssueSSLAdvice(pRPCEncryptionEnabled	: Boolean;
				pSSLSecurePort			: String;
				pCertFileName			: String;
				pCertFileResident		: Boolean;
				pCertFileSubject		: String;
				pCertFileExpiry			: Date;
				pCertAuthFileName		: String;
				pCertAuthFileResident	: Boolean;
				pCertAuthFileSubject	: String;
				pCertAuthFileExpiry		: Date;
				pSSLMethodName			: String;
				pSSLCiphers				: StringArray);

vars
	cc		: CnCntrl;

	kc		: CnKarmaCntrl;

	newmsg,
	tmsg	: CnMessage;
	
	msg		: CnSSLAdvice;
begin
	cc := app.myCnCntrl;
	kc := app.myCnKarmaCntrl;
	create tmsg transient;
	tmsg.createNewMsg(tmsg.Advice,
					  tmsg.SSL_Advice,
					  kc.localFQDN,
					  kc.localIpAddress,
					  cc.KCCMgr_Process,
					  cc.JossCommsMgr_Process,
					  newmsg);
					  
	msg		:= newmsg.CnSSLAdvice;
	msg.setNodeId(cc.myNodeControl.nodeId);
	msg.setRPCEncryptionEnabled(pRPCEncryptionEnabled);
	msg.setSSLSecurePort(pSSLSecurePort);
	msg.setSSLCertificateAuthDetail(pCertAuthFileName, 
									pCertAuthFileResident, 
									pCertAuthFileSubject, 
									pCertAuthFileExpiry);
	msg.setSSLCertificateFileDetail(pCertFileName, 
									pCertFileResident, 
									pCertFileSubject, 
									pCertFileExpiry);
	msg.setSSLMethodName(pSSLMethodName);
	pSSLCiphers.copy(msg.sslCipherNames);
	msg.sendMessage(null);
epilog
	delete tmsg;
	delete newmsg;
end;
}
zReportLockException
{
zReportLockException(pObject : Object; pUserInfo : Any) protected;

vars
	cc		: CnCntrl;
	
	file	: File;
begin
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & pObject.String & " : " & pUserInfo.String, null);
	create file transient;
	file.fileName := cc.logPath & "/lock_exceptions.csv";
	file.mode := file.Mode_Input;
	if file.isAvailable() then
		file.mode := file.Mode_Append;
	
	else
		file.mode := file.Mode_Output;
		file.writeLine("This file contains instances of lock exceptions incurred");
		file.writeLine("which were successfully retried by the global lock");
		file.writeLine("exception handler (CardSchema::cnGlobalLockExceptionHandler)");
		file.writeLine(null);
		file.writeLine("Date" 				& CN_COMMA &
						"Time"				& CN_COMMA &
						"Application"		& CN_COMMA &
						"Instance"			& CN_COMMA &
						"Usercode"			& CN_COMMA &
						"Node"				& CN_COMMA &
						"Lock Target"		& CN_COMMA &
						"Lock Type"			& CN_COMMA &
						"Method"			& CN_COMMA &
						"Source Line"		& CN_COMMA &
						"Code Position"		& CN_COMMA &
						"Lock Attempts" 	& CN_COMMA &
						"Contended Time" 	& CN_COMMA &
						"Lock Owners"	 	& CN_COMMA &
						"Owner Details");
	endif;
	
	file.writeLine(pUserInfo.String);
	file.close();
epilog
	delete file;
end;
}
zSetupMessagingClassDetails
{
zSetupMessagingClassDetails() updating, protected;

vars
	cls			: Class;
	
	subClasses	: ClassColl;
	
	index		: Integer;
begin
	create subClasses transient;
	cls := CnMessage;
	
	cls.allSubclasses(subClasses);
	cls.allSubclassesInSubschemas(subClasses);
	
	foreach cls in subClasses do
		if cls.name = "CnAdvice" or
		   cls.name = "CnCommand" then
			continue;
		endif;
		
		index := index + 1;
		self.messageClassArray.add(cls);
		self.messageNameArray.add(cls.name);
	endforeach;
epilog
	delete subClasses;
end;
}
zSetupTcpTransportDetails
{
zSetupTcpTransportDetails():Integer protected;

/* 
	This method is called from CnKarmaCntrl::create(). The purpose of this method is to examine the application
	ini file to determine the RPC transport being used. This information will determine what localhost value we
	use and how JSM will display IP information to the user.
	
	We will use the same constants as introduced in JADE 7. We can do away with these constants and use the JADE
	ones once JSM & JSA start running on JADE 7.
*/

constants
	ProtocolFamilyTcpIPv4	= 0;
	ProtocolFamilyTcpIPv6	= 1;
	ProtocolFamilyTcpIPAny	= -1;
vars
	cc			: CnCntrl;

	usesIPv4,
	usesIPv6	: Boolean;
	
	iniFile,
	transport	: String;
	
	tokenArray	: CnStringArray;
	
	int			: Integer;
begin
	cc			:= app.myCnCntrl;
	iniFile		:= app.getIniFileName();
	create tokenArray transient;

	if node.isServerNode then
		// ### SERVER ####
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : inspecting " & CN_JADESERVER & " " & CN_NETWORKSPECIFICATION & " entries for TcpIp protocol definition(s) ...", null);
		foreach int in 1 to 99 do
			transport := app.getProfileString(iniFile, CN_JADESERVER, CN_NETWORKSPECIFICATION & int.String, null);
			if transport = null then
				break;
			endif;
			tokenArray.cnGetTokens(transport, ",", false);
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : found NetworkSpecification" & int.String & " using " & tokenArray[1], null);
			
			if tokenArray[1].toLower()		= "tcpip"		or
			   tokenArray[1].toLower()		= "tcpipany"	then	// both transports are supported
				usesIPv4 := true;
				usesIPv6 := true;
			
			elseif tokenArray[1].toLower()	= "tcpipv4"		then
				usesIPv4 := true;									// explicitly set to use IPv4
			
			elseif tokenArray[1].toLower()	= "tcpipv6"		then
				usesIPv6 := true;									// explicitly set to use IPv6
			endif;
			tokenArray.purge();
			
			if usesIPv4 and usesIPv6 then							// here we can break early, if both protocols are being used the no need to check remaining NetworkSpecification entries
				break;
			endif;
		endforeach;
	
	elseif node.isApplicationServer then
		// ### APPSERVER ####
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : inspecting " & CN_JADEAPPSERVER & " " & CN_APPSERVER & " entry for TcpIp protocol definition ...", null);
		transport := app.getProfileString(iniFile, CN_JADEAPPSERVER, CN_APPSERVER, null);
		if transport <> null then
			tokenArray.cnGetTokens(transport, ",", false);
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : found NetworkSpecification" & int.String & " using " & tokenArray[1], null);
			
			if tokenArray[1].toLower() = "tcpip" 	or
			   tokenArray[1].toLower() = "tcpipany"	then			// both transports are supported
				usesIPv4 := true;
				usesIPv6 := true;
			else
				usesIPv4 := (tokenArray[1].toLower() = "tcpipv4");	// explicitly set to use IPv4
				usesIPv6 := (tokenArray[1].toLower() = "tcpipv6");	// explicitly set to use IPv6
			endif;
		else
			usesIPv4 := true;										// if no 'AppServer' is found then it defaults to ProtocolFamilyTcpIPAny (JADE 7 Release Info)
			usesIPv6 := true;
		endif;
		
	else
		// ### CLIENT ###
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : inspecting " & CN_JADECLIENT & " " & CN_SERVERNODESPECIFICATIONS & " entry for TcpIp protocol definition ...", null);
		transport := app.getProfileString(iniFile, CN_JADECLIENT, CN_SERVERNODESPECIFICATIONS, null);
		if transport <> null then
			tokenArray.cnGetTokens(transport, ",", false);
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : found NetworkSpecification" & int.String & " using " & tokenArray[1], null);
			
			if tokenArray[1].toLower() = "tcpip" 	or
			   tokenArray[1].toLower() = "tcpipany"	then			// both transports are supported
				usesIPv4 := true;
				usesIPv6 := true;
			else
				usesIPv4 := (tokenArray[1].toLower() = "tcpipv4");	// explicitly set to use IPv4
				usesIPv6 := (tokenArray[1].toLower() = "tcpipv6");	// explicitly set to use IPv6
			endif;
		endif;
	endif;

	if usesIPv4 and usesIPv6 then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : both TcpIpv4 and TcpIpV6 protocols are present ...", null);
		return ProtocolFamilyTcpIPAny;
	
	elseif usesIPv4 then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : only the TcpIpv4 protocol is present ...", null);
		return ProtocolFamilyTcpIPv4;
	
	elseif usesIPv6 then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : only the TcpIpv6 protocol is present ...", null);
		return ProtocolFamilyTcpIPv6;
	endif;
epilog
	delete tokenArray;
end;
}
	externalMethodSources
callMethodWith1Param
{
callMethodWith1Param(
			receiver: Object; 
			methodName: String; 
			param1: Any) is "emCallMethod" in "karma" protected, number = 1054;
}
emShellExecute
{
emShellExecute(
			hwnd: Integer; 
			operation: String; 
			fileName: String; 
			parameters: String; 
			directory: String; 
			showHow: Integer): Integer is "emShellExecute" in "karma" number = 1060;
}
getProcessId
{
getProcessId(procId: Integer output): Integer is "emGetProcessId" in "karma" number = 1061;
}
killProcess
{
killProcess(procId: Integer): Integer is "emKillProcess" in "karma" number = 1063;
}
	)
	CnLdap (
	jadeMethodSources
cnCurrentTimeInMilliseconds
{
cnCurrentTimeInMilliseconds():Integer;

vars

	now:Time;
	nowTs:TimeStamp;

begin

	now := nowTs.time;
	return (now.hour * 3600000) + (now.minute * 60000) + (now.second * 1000) + now.milliSecond;
end;
}
cnRaiseLdapException
{
cnRaiseLdapException(pErrorCode:Integer; pErrorItem:String; pExErrorText:String) updating;

vars

	exObj:CnLdapException;

begin

	create exObj;
	exObj.setErrorObject(self);   
	exObj.cnSetErrorCode(pErrorCode);
	exObj.cnSetErrorItem(pErrorItem);
	exObj.cnSetExtendedErrorText(pExErrorText);
	raise exObj;

end;
}
cnScopeToInteger
{
cnScopeToInteger(pScopeString:String):Integer;

vars

begin

	if pScopeString = "Base" then return 0;
	elseif pScopeString = "One Level" then return 1;
	elseif pScopeString = "Subtree" then return 2;
	else return null;
	endif;

end;
}
cnScopeToString
{
cnScopeToString(pScope:Integer):String;

vars

begin

	if pScope = 0 then return "Base";
	elseif pScope = 1 then return "One Level";
	elseif pScope = 2 then return "Subtree";
	else return null;
	endif;

end;
}
	)
	CnLdapAttribute (
	jadeMethodSources
cnAsString
{
cnAsString():String updating;

// Gets all the attribute values and builds an LDIF-format string

vars

	value, resultString:String;

begin

	while self.cnGetNextStringAsLDIF(value) do
			resultString:= resultString & value & CrLf;			//Get string values 
	endwhile;
	while self.cnGetNextBinaryAsShortLDIF(value) do		//Get binary values 
			resultString:= resultString & value & CrLf;
	endwhile;		

	return resultString;	

end;
}
cnAttributeIsBinary
{
cnAttributeIsBinary(pName : String) : Boolean;

vars
	lowerCaseName	: String;
begin
	lowerCaseName := pName.toLower();
	return (lowerCaseName = "jpegphoto" or lowerCaseName = "audio" or lowerCaseName = "userpassword");
end;
}
cnBase64Decode
{
cnBase64Decode(pMessage: String input; pDecodedMessage: Binary output) : Integer updating;

// This method takes a Base64-encoded string (pMessage), and decodes it into a binary buffer (pDecodedMessage).

// A Base64-encoded message contains characters from the following alphabet:
// ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
// The message may also contain line breaks (CrLf) inserted by the Base64 encoding algorithm; these are ignored by the decoder, as are
// any characters that are not in the Base64 alphabet.

// Each character in the message has a corresponding 6-bit value from 0 thru 63:
//	-	A thru Z = 0 thru 25
//	-	a thru z = 26 thru 51
//	-	0 thru 9 = 52 thru 61
//	-	+        = 62
// 	-	/		 = 63

// The decoding is as follows:

//  - Take each group of four ASCII characters from the input stream
//  - For each character, find its corresponding 6-bit code
// 	- Make a 24-bit word out of the four 6-bit codes
// 	- Split each 24-bit word into three octets, and write the octets sequentially into the binary buffer.

// If the message ends with one equals sign (=), then the last word has only 16 bits.
// If the message ends with two equals signs, then the last word has only 8 bits.

// Return an integer of 0 if no errors are found, or 1 if the format of the buffer is invalid.

// Refer to RFC 2045 (www.oac.uci.edu/indiv/ehood/MIME/2045/rfc2045.html [pages 17 thru 19]) for a description of Base64 encoding.

// Author: Robin Arzoni, JADE Systems Group

constants

	Zero_Errors 	= 	0;
	Invalid_Format 	= 	1;
	MaskThird8Bits 	=	#000000FF;
    MaskSecond8Bits = 	#0000FF00;
    MaskFirst8Bits 	= 	#00FF0000;

vars

	validCharacter:Boolean;
	char:Character;
	nextInByte, nextOutByte, characterCount, groupOf24Bits, first, second, third, code:Integer;

begin

     nextInByte := 0;
     nextOutByte := 1;

     while nextInByte <= pMessage.length do
	     groupOf24Bits := 0;
	     characterCount := 0;
	     while characterCount < 4 and nextInByte < pMessage.length do

	        	nextInByte := nextInByte + 1;
	        	char := pMessage[nextInByte].Character;
				if char = "=" then
					 break;              					//Found a pad character: end of message
				endif;

				code := char.Integer;
				validCharacter := true;						//Assume character is in the Base64 alphabet

				if char >= "A" and char <= "Z" then
					code := code - 65;						//Calculate decode value (A thru Z yields 0 thru 25)
				elseif char >= "a" and char <= "z" then
					code := code - 71;						//Calculate decode value (a thru z yields 26 thru 51)
				elseif char >= "0" and char <= "9" then
					code := code + 4;						//Calculate decode value (0 thru 9 yields 52 thru 61)
				elseif char = "+" then
					code := 62;								//Decode value of + is 62
				elseif char = "/" then
					code := 63;								//Decode value of / is 63
				else	
                   	validCharacter := false;
				endif;

	 	    	if validCharacter then
	 	    		groupOf24Bits := groupOf24Bits * 64;
	 	    		groupOf24Bits := groupOf24Bits.bitOr(code);
	 	    		characterCount := characterCount + 1;
	 	    	endif;	
		endwhile;

		if characterCount = 0 then
		//End of message, and there were no pad characters (=)
			break;

		elseif char = "=" and nextInByte < pMessage.length then
			nextInByte := nextInByte + 1;
			char := pMessage[nextInByte];
			if char = "=" and nextInByte = pMessage.length then

			//Found two pad characters at end of message.
			//This means that the final octet of the message is in groupOf24Bits, but has to be shifted left to the correct position.

				groupOf24Bits := groupOf24Bits * 64;		
				groupOf24Bits := groupOf24Bits * 64;

				first := groupOf24Bits.bitAnd(MaskFirst8Bits);
				first := first div 2 ^ 16;

		        pDecodedMessage[nextOutByte] := first;

     		else
     			return Invalid_Format;
     		endif;	
		    break;

		elseif pMessage[nextInByte] = "=" and nextInByte = pMessage.length then

		//Found one pad character at end of message.
		//This means that the two final octets of the message are in groupOf24Bits, but they have to be shifted left to the correct position.

			groupOf24Bits := groupOf24Bits * 64;

			first := groupOf24Bits.bitAnd(MaskFirst8Bits);
			first := first div 2 ^ 16;

	        pDecodedMessage[nextOutByte] := first;
	        nextOutByte := nextOutByte + 1;

			second := groupOf24Bits.bitAnd(MaskSecond8Bits);
			second := second div 2 ^ 8;

			pDecodedMessage[nextOutByte] := second;
	        break;
		else

			//We haven't reached the end of the message yet: divide the 24 bits into three octets, and send them to the output stream.

			first := groupOf24Bits.bitAnd(MaskFirst8Bits);
			first := first div 2 ^ 16;

			second := groupOf24Bits.bitAnd(MaskSecond8Bits);
			second := second div 2 ^ 8;

			third := groupOf24Bits.bitAnd(MaskThird8Bits);

	        pDecodedMessage[nextOutByte] := first;
	        nextOutByte := nextOutByte + 1;
	        pDecodedMessage[nextOutByte] := second;
			nextOutByte := nextOutByte + 1;
			pDecodedMessage[nextOutByte] := third;
			nextOutByte := nextOutByte + 1;	        

        endif;
        process.sleep(2);
    endwhile;

    return Zero_Errors;
end;
}
cnBase64Encode
{
cnBase64Encode(pMessage: Binary input) : String updating;

/* This method takes a binary buffer, and encodes it into an ASCII string, using the Base64 encoding technique defined in RFC 1521.

 Base64 encoding allows 8-bit data to be converted, so that it can be transmitted over a protocol that allows only 7-bit characters.
 Base64 also gives enhanced privacy, if the source data is standard ASCII text, as the message is no longer in clear text when it is
 sent over the wire. Base64 is almost identical to Privacy Enhanced Mail encoding (RFC 1421).

 The encoding is as follows:
 Take each group of three octets, so that we have 24 bits; divide each 24-bit group into four 6-bit groups; use the integer represented
 by each 6-bit group as an index into a table, and extract the corresponding ASCII character from that table; insert the ASCII character
 into the output stream.

 Some sections of this code could be broken into further methods, but calling them would probably be more inefficient than executing the code
 in-line.

 Note: If a binary is being encoded by being passed to this method on a block-by-block basis, then each block except the last one must
 be a multiple of three bytes in length. */ 

constants

	MaskFirst6Bits = 	#00FC0000;
    MaskSecond6Bits = 	#0003F000;
    MaskThird6Bits = 	#00000FC0;
    MaskFourth6Bits = 	#0000003F;
    Base64Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

vars
	firstChar, secondChar, thirdChar, fourthChar:Character;
	nextInByte, nextOutByte, characterCount, groupOf24Bits, first, second, third, fourth, thisLineLength:Integer;
	originalLength:Integer;
	startTime, endTime:Real;
    encodedMessage:String;
begin

     startTime := cnCurrentTimeInMilliseconds;
     originalLength := pMessage.length;

     nextInByte := 0;
     nextOutByte := 1;

     while nextInByte <= pMessage.length do
	     characterCount := 0;
	     groupOf24Bits := 0;
	     while characterCount < 3 and nextInByte < pMessage.length do
	        	nextInByte := nextInByte + 1;
	        	groupOf24Bits := groupOf24Bits * 256;
	 	    	groupOf24Bits := groupOf24Bits.bitOr(pMessage[nextInByte].Integer);
	 	    	characterCount := characterCount + 1;
		endwhile;

		if characterCount = 3 then

			//Not the end of the message yet

			fourth := groupOf24Bits.bitAnd(MaskFourth6Bits);

			third := groupOf24Bits.bitAnd(MaskThird6Bits);
			third := third div 64;

			second := groupOf24Bits.bitAnd(MaskSecond6Bits);
			second := second div 64 ^ 2;

			first := groupOf24Bits.bitAnd(MaskFirst6Bits);
			first := first div 64 ^ 3;
			first := first.bitAnd(MaskFourth6Bits);	

	  		firstChar := Base64Table[first + 1];
	       	secondChar := Base64Table[second + 1];
	       	thirdChar := Base64Table[third + 1];
	       	fourthChar := Base64Table[fourth + 1];

	  		/*Lines are not allowed to be more than 76 characters in length for SMTP transmission, so 73 is the last valid position
	  		 for inserting a four-character group*/
	  		if thisLineLength > 73 then
				encodedMessage[nextOutByte] := Cr.Character;
				nextOutByte := nextOutByte + 1;
				encodedMessage[nextOutByte] := Lf.Character;
				nextOutByte := nextOutByte + 1;
				thisLineLength := 0;
			endif;	

			encodedMessage[nextOutByte] := firstChar;
			encodedMessage[nextOutByte + 1] := secondChar;
			encodedMessage[nextOutByte + 2] := thirdChar;
			encodedMessage[nextOutByte + 3] := fourthChar;
			nextOutByte := nextOutByte + 4;
			thisLineLength := thisLineLength + 4;

		elseif characterCount = 0 then
			//End of message, and the number of octets was exactly divisible by three
			break;

		elseif characterCount = 1 then
			//End of message, and we need to insert two pad characters

			groupOf24Bits := groupOf24Bits * 256;
			groupOf24Bits := groupOf24Bits * 256;

			second := groupOf24Bits.bitAnd(MaskSecond6Bits);
			second := second div 64 ^ 2;

			first := groupOf24Bits.bitAnd(MaskFirst6Bits);
			first := first div 64 ^ 3;
			first := first.bitAnd(MaskFourth6Bits);	

	  		firstChar := Base64Table[first + 1];
	       	secondChar := Base64Table[second + 1];
	       	thirdChar := "=".Character;
	       	fourthChar := "=".Character;

	  		//Lines are not allowed to be more than 76 characters in length, so 73 is the last valid position for inserting a four-character group
	  		if thisLineLength > 73 then
				encodedMessage[nextOutByte] := Cr.Character;
				nextOutByte := nextOutByte + 1;
				encodedMessage[nextOutByte] := Lf.Character;
				nextOutByte := nextOutByte + 1;
			endif;	

			encodedMessage[nextOutByte] := firstChar;
			encodedMessage[nextOutByte + 1] := secondChar;
			encodedMessage[nextOutByte + 2] := thirdChar;
			encodedMessage[nextOutByte + 3] := fourthChar;
	        break;

		else
		//End of message, and we need to insert one pad character

			groupOf24Bits := groupOf24Bits * 256;

			third := groupOf24Bits.bitAnd(MaskThird6Bits);
			third := third div 64;

			second := groupOf24Bits.bitAnd(MaskSecond6Bits);
			second := second div 64 ^ 2;

			first := groupOf24Bits.bitAnd(MaskFirst6Bits);
			first := first div 64 ^ 3;
			first := first.bitAnd(MaskFourth6Bits);	

	  		firstChar := Base64Table[first + 1];
	       	secondChar := Base64Table[second + 1];
	       	thirdChar := Base64Table[third + 1];
	       	fourthChar := "=".Character;

	  		//Lines are not allowed to be more than 76 characters in length, so 73 is the last valid position for inserting a four-character group
	  		if thisLineLength > 73 then
				encodedMessage[nextOutByte] := Cr.Character;
				nextOutByte := nextOutByte + 1;
				encodedMessage[nextOutByte] := Lf.Character;
				nextOutByte := nextOutByte + 1;
			endif;	

			encodedMessage[nextOutByte] := firstChar;
			encodedMessage[nextOutByte + 1] := secondChar;
			encodedMessage[nextOutByte + 2] := thirdChar;
			encodedMessage[nextOutByte + 3] := fourthChar;
	        break;

        endif;
        process.sleep(2);
        //write "Message Length = " & encodedMessage.length.String & ", Next Out Byte = " & nextOutByte.String & ", Original Length = " & originalLength.String & ", Time = " & ((currentTimeInMilliseconds - startTime)/1000).String;
    endwhile;

    endTime := cnCurrentTimeInMilliseconds;

    return encodedMessage;
end;
}
cnCloneSelf
{
cnCloneSelf(pTransient:Boolean):CnLdapAttribute updating;

// Clones an attribute

vars

	attribute, cloneAttribute:CnLdapAttribute;
	binary, cloneBinary:CnLdapBinary;

begin

	cloneAttribute := self.cloneSelf(pTransient);
	foreach binary in self.allBinaryValues do
		cloneBinary := binary.cloneSelf(pTransient);
		cloneBinary.cnSetMyAttribute(cloneAttribute);
	endforeach;	
	return cloneAttribute;

end;
}
cnGetNextBinary
{
cnGetNextBinary(binaryValue:Binary output):Boolean updating;

// Gets the next binary value of this attribute, if one exists

vars

	ldapBinary:CnLdapBinary;
begin
	if self.binaryIterator = null then
		self.binaryIterator := self.allBinaryValues.createIterator();
	endif;

	if self.binaryIterator.next(ldapBinary) then
		binaryValue := ldapBinary.binaryValue;
		return true;
	endif;

	return false;
end;
}
cnGetNextBinaryAsLDIF
{
cnGetNextBinaryAsLDIF(ldifValue:String output):Boolean updating;

// Gets the next binary value for this attribute, and encodes it into a Base64 string.

constants

	BlockLength = 1512;		//Note that the blocklength must always be a multiple of 3
vars

	b:Binary;
	ldapBinary:CnLdapBinary;
	s:String;
	p:Integer;
begin
	if self.binaryIterator = null then
		self.binaryIterator := self.allBinaryValues.createIterator();
	endif;

	if self.binaryIterator.next(ldapBinary) then
		if ldapBinary.length = 0 then
			ldifValue := self.name & "::";
			return true;
		else
			ldifValue := self.name & ":: ";
			p := 1;

			//We do the Base64 encode block-by-block, as this is much faster than doing it on the whole binary at once
			while p <= ldapBinary.length do
				b := ldapBinary.binaryValue[p:BlockLength];
				s := cnBase64Encode(b);

				if (not p = 1) and (not s.length = 0) and
					(ldifValue.length mod 76 <> 0 or ldifValue.length mod 75 <> 0 or ldifValue.length mod 74 <> 0) then 
					ldifValue := ldifValue & CrLf;
				endif;
				ldifValue := ldifValue & s;

				p := p + BlockLength;
			endwhile;	
			return true;
		endif;	
	else
		return false;
	endif;			 	 

end;
}
cnGetNextBinaryAsShortLDIF
{
cnGetNextBinaryAsShortLDIF(ldifValue:String output):Boolean updating;

// Gets the first ten bytes of the next binary value for this attribute, and encodes them into a Base64 string.

vars

	ldapBinary:CnLdapBinary;
	shortBinary:Binary;
begin
	if self.binaryIterator = null then
		self.binaryIterator := self.allBinaryValues.createIterator();
	endif;

	if self.binaryIterator.next(ldapBinary) then
		if ldapBinary.length = 0 then
			ldifValue := self.name & "::";
			return true;
		else	
			shortBinary := ldapBinary.binaryValue[1:10];	//Just encode 10 bytes of binary
			ldifValue := self.name & ":: " & cnBase64Encode(shortBinary) & " ... (Display truncated: actual length = " & ldapBinary.binaryValue.length.String & ")";
			return true;
		endif;	
	else
		return false;
	endif;			 	 

end;
}
cnGetNextString
{
cnGetNextString(stringValue:String output):Boolean updating;

// Gets the next string value for this attribute, if one exists.

vars

begin
	if self.stringIterator = null then
		self.stringIterator := self.allStringValues.createIterator();
	endif;

	return self.stringIterator.next(stringValue);
end;
}
cnGetNextStringAsLDIF
{
cnGetNextStringAsLDIF(stringValue:String output):Boolean updating;

// Gets the next string value for this attribute, if one exists, and returns it in LDIF format.

vars
	
begin
	if self.stringIterator = null then
		self.stringIterator := self.allStringValues.createIterator();
	endif;

	if self.stringIterator.next(stringValue) then
		if stringValue = "" then
			stringValue := self.name & ":" & stringValue;
		else
			stringValue := self.name & ": " & stringValue;
		endif;	
		return true;
	else
		return false;
	endif;			 	 

end;
}
cnGetPreviousBinary
{
cnGetPreviousBinary(binaryValue:Binary output):Boolean updating;

// Gets the previous binary value of this attribute, if one exists

vars

	ldapBinary	: CnLdapBinary;
begin
	if self.binaryIterator = null then
		self.binaryIterator := self.allBinaryValues.createIterator();
	endif;

	if self.binaryIterator.back(ldapBinary) then
		binaryValue := ldapBinary.binaryValue;
		return true;
	else
		return false;
	endif;			 	 

end;
}
cnGetPreviousBinaryAsLDIF
{
cnGetPreviousBinaryAsLDIF(ldifValue:String output):Boolean updating;

// Gets the previous binary value for this attribute, and encodes it into a Base64 string.

constants

	BlockLength = 1512;		//Note that the blocklength must always be a multiple of 3
vars

	b:Binary;
	ldapBinary:CnLdapBinary;
	s:String;
	p:Integer;
begin
	if self.binaryIterator = null then
		self.binaryIterator := self.allBinaryValues.createIterator();
	endif;

	if self.binaryIterator.back(ldapBinary) then
		if ldapBinary.length = 0 then
			ldifValue := self.name & "::";
			return true;
		else
			ldifValue := self.name & ":: ";
			p := 1;

			//We do the Base64 encode block-by-block, as this is much faster than doing it on the whole binary at once
			while p <= ldapBinary.length do
				b := ldapBinary.binaryValue[p:BlockLength];
				s := cnBase64Encode(b);

				if (not p = 1) and (not s.length = 0) and
					(ldifValue.length mod 76 <> 0 or ldifValue.length mod 75 <> 0 or ldifValue.length mod 74 <> 0) then 
					ldifValue := ldifValue & CrLf;
				endif;
				ldifValue := ldifValue & s;

				p := p + BlockLength;
			endwhile;	
			return true;
		endif;	
	else
		return false;
	endif;			 	 

end;
}
cnGetPreviousBinaryAsShortLDIF
{
cnGetPreviousBinaryAsShortLDIF(ldifValue:String output):Boolean updating;

// Gets the first ten bytes of the previous binary value for this attribute, and encodes them into a Base64 string.

vars

	ldapBinary	: CnLdapBinary;
	shortBinary	: Binary;
begin
	if self.binaryIterator = null then
		self.binaryIterator := self.allBinaryValues.createIterator();
	endif;

	if self.binaryIterator.back(ldapBinary) then
		if ldapBinary.length = 0 then
			ldifValue := self.name & "::";
			return true;
		else	
			shortBinary := ldapBinary.binaryValue[1:10];	//Just encode 10 bytes of binary
			ldifValue := self.name & ":: " & cnBase64Encode(shortBinary) & " ... (Display truncated: actual length = " & ldapBinary.binaryValue.length.String & ")";
			return true;
		endif;	
	else
		return false;
	endif;			 	 

end;
}
cnGetPreviousString
{
cnGetPreviousString(stringValue:String output):Boolean updating;

// Gets the previous string value for this attribute, if one exists.

vars
	
begin
	if self.stringIterator = null then
		self.stringIterator := self.allStringValues.createIterator();
	endif;

	return self.stringIterator.back(stringValue);
end;
}
cnGetPreviousStringAsLDIF
{
cnGetPreviousStringAsLDIF(stringValue:String output):Boolean updating;

// Gets the previous string value for this attribute, if one exists, and returns it in LDIF format.

vars
	
begin
	if self.stringIterator = null then
		self.stringIterator := self.allStringValues.createIterator();
	endif;

	if self.stringIterator.back(stringValue) then
		if stringValue = "" then
			stringValue := self.name & ":" & stringValue;
		else
			stringValue := self.name & ": " & stringValue;
		endif;	
		return true;
	else
		return false;
	endif;			 	 

end;
}
cnResetBinaryIterator
{
cnResetBinaryIterator() updating;

// Resets the iterator for this attribute's binary values.

vars

begin
	if self.binaryIterator = null then
		self.binaryIterator := self.allBinaryValues.createIterator();
	endif;

	self.binaryIterator.reset();
end;
}
cnResetStringIterator
{
cnResetStringIterator() updating;

// Resets the iterator for this attribute's string values.

vars

begin
	if self.stringIterator = null then
		self.stringIterator := self.allStringValues.createIterator();
	endif;

	self.stringIterator.reset();
end;
}
cnSetModifyOperator
{
cnSetModifyOperator(pOp:Integer) updating;

vars

begin

	modifyOperator := pOp;

end;
}
cnSetMyEntry
{
cnSetMyEntry(pEntry:CnLdapEntry) updating;

vars

begin
	myEntry := pEntry;
end;
}
cnSetName
{
cnSetName(pName:String) updating;

//V2 21.01.2000 Changes for case sensitivity

vars

	syntaxObj		:	CnLdapSyntax;

	syntaxPos		: Integer;
	
	lowerCaseName	: String;
begin

	if pName = null then
 		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
 							 "Invalid Attribute Name",
 							 "The attribute name supplied with " & method.name & " is a null value");
 	endif;

	self.name := pName;									//V2 Set name property, preserving case
	lowerCaseName := pName.toLower();

	//If a syntax object exists, look up the syntax type in its attributeNameList. Otherwise, use the hard-coded default.
	syntaxObj := app.myCnLdapSyntax;  					//V2
	if syntaxObj = null then
		if self.cnAttributeIsBinary(lowerCaseName) then  //V2 All lower case
			cnSetSyntax("bin");
		endif;
		
	else
		syntaxPos := syntaxObj.attributeNameList.indexOf(lowerCaseName);  //V2 
		if syntaxPos > 0 then
			cnSetSyntax(syntaxObj.attributeSyntaxList[syntaxPos]);
		endif;
	endif;
	
	if syntax = "bin" then
		cnSetModifyOperator(modifyOperator.bitOr(CnLdapEntry.LDAP_MOD_BVALUES)); //See comments in create method
	endif;					
end;
}
cnSetSyntax
{
cnSetSyntax(pSyntax:String) updating;
//V2 21.01.2000 Force syntax to lower-case
vars

begin

      //User can change syntax of attribute if default not correct 

      if pSyntax.length = 0 then
		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR, "Syntax string empty in " & method.getName, "Attribute Syntax type must be a string between 1 and 3 characters in length");
	  endif;

      if pSyntax.length > 3 then
      	cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR, "String " & pSyntax & " too long", "Attribute Syntax name must not be longer than three characters");
      	return;
      else
      	syntax := pSyntax.toLower;		//V2
      endif;		

end;
}
create
{
create() updating;

vars

begin
	cnSetSyntax("cis");		//Default syntax is "Case Ignore String".
								//If necessary this will be changed when cnSetName is called.

		/* We set the modifyOperator to REPLACE as the default. This is to cater for the case where the user does a
		search, and then does a modify, using an entry returned by the search as input to the modify. If this happens, then 
		all the values returned by the search are simply replaced on the server: that is, the end effect is as if nothing happened.

		When the attribute name is set (cnSetName), the syntax is set, and if the syntax is "bin", the binary values bit
		(128) is ORd into the modifyOperator. This prepares us for the "search then modify" scenario where a binary value would
		be modified. */
	cnSetModifyOperator(CnLdapEntry.LDAP_MOD_REPLACE);								

end;
}
delete
{
delete() updating;

vars

begin
	delete self.binaryIterator;
	delete self.stringIterator;
end;
}
isBinary
{
isBinary(set: Boolean; _value: Boolean io) mapping;

vars

begin

	if not set then 
		_value := (not self.allBinaryValues.isEmpty());
	endif;	 

end;
}
isNull
{
isNull(set: Boolean; _value: Boolean io) mapping;

vars

begin

	if not set then 
		_value := self.allBinaryValues.isEmpty() and self.allStringValues.isEmpty();
	endif;	 

end;
}
isString
{
isString(set: Boolean; _value: Boolean io) mapping;

vars

begin

	if not set then 
		_value := (not self.allStringValues.isEmpty());
	endif;	 

end;
}
	)
	CnLdapBinary (
	jadeMethodSources
cnGetBinaryValue
{
cnGetBinaryValue():Binary;

vars

begin

	return binaryValue;

end;
}
cnSetBinaryValue
{
cnSetBinaryValue(pBinary:Binary) updating;

vars

begin

	binaryValue := pBinary;

end;
}
cnSetMyAttribute
{
cnSetMyAttribute(pAttribute:CnLdapAttribute) updating;

vars

begin

	myAttribute := pAttribute;

end;
}
length
{
length(set: Boolean; value: Integer io) mapping;

vars

begin

	if not set then
		value := binaryValue.length;
	endif;	

end;
}
	)
	CnLdapConnection (
	jadeMethodSources
cnAbandonReadAsync
{
cnAbandonReadAsync(pEntry:CnLdapEntry input) updating;

//Abandons an asynchronous read

vars

	result		: Integer;
	x			: Integer;
	badObject	: Boolean;
begin
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, pEntry, badObject);
	x := pEntry.edition;
    if badObject then
 		self.cnRaiseLdapException(CN_LDAP_INVALID_ENTRY_OBJECT,
								"Invalid Entry Object",
								"The entry object supplied to " & method.name & " is not a valid object");
 	endif;

    result := self.zEAbandonA(self.ldapHandle, pEntry.myReadAsyncSearchObject.msgID, null, null);	//Abandon async operation identified by pMsgID

    if result <> LDAP_SUCCESS then
		cnRaiseLdapException(CN_LDAP_ERROR_BASE + self.errorCode, "Error occurred calling cn_ldap_abandon_ext", self.errorString);
	endif;

	delete pEntry.myReadAsyncSearchObject;										//Delete the search object and original entry and attributes
   	pEntry.cnSetMyReadAsyncSearchObject(null);
end;
}
cnAbandonSearchAsync
{
cnAbandonSearchAsync(pSearch:CnLdapSearch io) updating;

//Abandons an asynchronous search

vars

	result	: Integer;
	x			: Integer;
	badObject	: Boolean;
begin
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, pSearch, badObject);
	x := pSearch.edition;
    if badObject then
 		self.cnRaiseLdapException(CN_LDAP_INVALID_SEARCH_OBJECT,
								"Invalid Search Object",
								"The search object supplied to " & method.name & " is not a valid object");
 	endif;

    result := self.zEAbandonA(self.ldapHandle, pSearch.msgID, null, null);	//Abandon async operation identified by pMsgID

    if result <> LDAP_SUCCESS then
		cnRaiseLdapException(CN_LDAP_ERROR_BASE + self.errorCode, "Error occurred calling cn_ldap_abandon_ext", self.errorString);
	endif;

	pSearch.cnSetMsgID(0);											//MsgID no longer valid after abandon
end;
}
cnAddEntry
{
cnAddEntry(pEntry:CnLdapEntry input) updating;

// Adds a new entry to the LDAP server

vars

	result	: Integer;
	x			: Integer;
	badObject	: Boolean;
begin
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, pEntry, badObject);
	x := pEntry.edition;
    if badObject then
 		cnRaiseLdapException(CN_LDAP_INVALID_ENTRY_OBJECT,
 							 "Invalid Entry Object",
 							 "The entry object supplied with the 'Add' function is not a valid object");
 	endif;

	on SystemException do app.cnHandleNullOrInvObjectRef(exception, pEntry.allAttributes, badObject);
	x := pEntry.allAttributes.edition;
    if badObject then
 		cnRaiseLdapException(CN_LDAP_INVALID_ATTR_ARRAY,
 							 "Invalid Attribute Array",
 							 "The attribute array supplied with the 'Add' function is not a valid object");
 	endif;

    result := self.zEAddEntry(self.ldapHandle, pEntry.dn, pEntry.allAttributes, null, null);

    if result <> LDAP_SUCCESS then
		cnRaiseLdapException(CN_LDAP_ERROR_BASE + result, "Add Entry failed", self.errorString);
	endif;

	zLdapLog(CnCntrl.CnLogDiag, "LDAP Entry " & pEntry.dn & " added to server " & self.host);

end;
}
cnClearSearchAttributes
{
cnClearSearchAttributes() updating;

vars

begin

	self.searchAttributeList.clear;

end;
}
cnClearSortAttributes
{
cnClearSortAttributes() updating;

vars

begin

	self.sortAttributeList.clear();
	self.sortAttributeMulti.clear();
	self.sortAttributeNumeric.clear();
	self.sortAttributeSize.clear();
	self.sortRequired := false;
end;
}
cnClose
{
cnClose() updating;

// Unbinds from the LDAP server

vars

	result:Integer;

begin

	result := self.zEUnbindS(self.ldapHandle);
	if result <> LDAP_SUCCESS then
		self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + result, "Unbind error", self.errorString);
		return;
	endif;

    //Handle is not valid after unbind completes, so clear it
    self.cnSetLdapHandle(null);			
	self.zLdapLog(CnCntrl.CnLogDiag, "Unbind successful");
end;
}
cnCompare
{
cnCompare(pDn:String; pAttributeName:String; pValue:Any):Boolean updating;

// Compares a value with an attribute value on the LDAP server

vars

	binary:Binary;
	result:Integer;

begin

	if pDn = null then
 		self.cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
								"Invalid DN",
								"The DN supplied with " & method.name & " is a null value");
 	endif;

 	if pAttributeName = null then
 		self.cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
								"Invalid Attribute Name",
								"The attribute name supplied with " & method.name & " is a null value");
 	endif;

	binary := pValue.Binary;	

	result := self.zECompare(self.ldapHandle, pDn, pAttributeName, binary, null, null);

	if result <> LDAP_COMPARE_TRUE and result <> LDAP_COMPARE_FALSE then
		self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + result, "Compare failed", self.errorString);
		
	else	
		if result = LDAP_COMPARE_TRUE then
			return true;
			
		else
			return false;
		endif;		
	endif;	
end;
}
cnDeleteEntry
{
cnDeleteEntry(pDn:String) updating;

// Deletes an entry from the LDAP server

vars

	result:Integer;

begin

    //Note: if pDn is null, this error will be reported by LDAP anyway, so don't need to check for it here. 
    result := self.zEDeleteEntry(self.ldapHandle, pDn, null, null);

    if result <> LDAP_SUCCESS then
		self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + result, "Delete Entry failed", self.errorString);
	endif;

	self.zLdapLog(CnCntrl.CnLogDiag, "LDAP Entry " & pDn & " deleted from server " & self.host);

end;
}
cnISearchAsync
{
cnISearchAsync(pURLSearch:Boolean; pURL:CnLdapURL; pBase:String; pFilter:String; pSearch:CnLdapSearch io) updating;

//"Internal" async search serving both URL-based and parameter-driven search

vars

	msgID, timelimit, sizelimit, result, mode, sortSize, attrsOnly:Integer;
	start, finish:Real;
	x			: Integer;
	badObject	: Boolean;
begin
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, pSearch, badObject);
	x := pSearch.edition;
    if badObject then
 		self.cnRaiseLdapException(CN_LDAP_INVALID_SEARCH_OBJECT, "Invalid Search Object", "The search object is not a valid object");
 	endif;

 	attrsOnly := -1; timelimit := -1; sizelimit := -1;

 	//If search constraints exist for the search object, use them instead of the default ones
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, pSearch.mySearchConstraints, badObject);
	x := pSearch.mySearchConstraints.edition;
    if badObject then
		if pSearch.mySearchConstraints.timeLimit <> -1 then
			timelimit := pSearch.mySearchConstraints.timeLimit;
		endif;	
		
		if pSearch.mySearchConstraints.maxResults <> -1 then
			sizelimit := pSearch.mySearchConstraints.maxResults;
		endif;	
 		
		//mode := pSearch.mySearchConstraints.mode;      		//Mode is 'Entries' for the moment, until we implement referrals
 		if pSearch.mySearchConstraints.attrsOnly <> -1 then
 			attrsOnly := pSearch.mySearchConstraints.attrsOnly;
 		endif;	
 	endif;

	if timelimit = -1 then
		timelimit := self.mySearchConstraints.timeLimit;		//Insert session default
	endif;	
	
	if sizelimit = -1 then
		sizelimit := self.mySearchConstraints.maxResults;		//Insert session default
	endif;	
	
	mode := self.mySearchConstraints.mode;						//Mode is 'Entries' for the moment, until we implement referrals
 	if attrsOnly = -1 then
 		attrsOnly := self.mySearchConstraints.attrsOnly;		//Insert session default
 	endif;

 	if not badObject then
		pSearch.mySearchConstraints.cnSetTimeLimit(timelimit);
		pSearch.mySearchConstraints.cnSetMaxResults(sizelimit);
		pSearch.mySearchConstraints.cnSetAttrsOnly(attrsOnly);
	endif;

	if not pURLSearch then	//If searching with user-supplied parameters

		self.zLdapLog(CnCntrl.CnLogDiag, "Starting search (" & pBase & '/' & self.cnScopeToString(scope) & "/" & pFilter & ")");
		result := self.zESearchA(self.ldapHandle,
								 pBase,
								 self.scope,
								 pFilter,
								 self.searchAttributeList,
								 attrsOnly.Boolean,
								 null,							//Server Controls (not yet implemented)
								 null,                        	//Client Controls (not yet implemented)
								 timelimit,
								 sizelimit,
								 msgID);

	 else					//If searching via a URL

		result := pURL.cnEURLCheck(pURL.url);		//Check that URL is an LDAP URL
		if result.Boolean = false then
 			cnRaiseLdapException(CN_LDAP_INVALID_URL, "Invalid LDAP URL", "The URL supplied to the async search function is not a valid LDAP URL");
 		endif;	

		zLdapLog(CnCntrl.CnLogDiag, "Starting search via URL (" & pURL.url & ")");

		msgID := self.zEURLSearchA(self.ldapHandle,
									pURL.url,
									attrsOnly);
		if msgID = -1 then
			self.cnRaiseLdapException(CN_LDAP_GENERAL_ERROR, "Async URL Search Failed", "cnEURLSearchA returned an error");
		endif;
		
		result := LDAP_SUCCESS;	 
	endif;

	if result <> LDAP_SUCCESS then
		self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + result, "Search failed", self.errorString);
	endif;

	pSearch.cnSetMyLdapConnection(self);
	pSearch.cnSetAttrsOnly(attrsOnly);							//Record whether attrsOnly specified for this search
	pSearch.cnSetMsgID(msgID);									//The MsgID identifies this async search

end;
}
cnModifyEntry
{
cnModifyEntry(pEntry:CnLdapEntry input) updating;

// Modifies a directory entry on the LDAP server

vars

	result	: Integer;
	x			: Integer;
	badObject	: Boolean;
begin
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, pEntry, badObject);
	x := pEntry.edition;
    if badObject then
 		self.cnRaiseLdapException(CN_LDAP_INVALID_ENTRY_OBJECT,
								 "Invalid Entry Object",
								 "The entry object supplied with the 'Modify' function is not a valid object");
 	endif;

	on SystemException do app.cnHandleNullOrInvObjectRef(exception, pEntry.allAttributes, badObject);
	x := pEntry.allAttributes.edition;
    if badObject then
 		self.cnRaiseLdapException(CN_LDAP_INVALID_ATTR_ARRAY,
								 "Invalid Attribute Array",
								 "The attribute array supplied with the 'Modify' function is not a valid object");
 	endif;

    result := self.zEModifyEntry(self.ldapHandle, pEntry.dn, pEntry.allAttributes, null, null);

    if result <> LDAP_SUCCESS then
		self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + result, "Modify Entry failed", self.errorString);
	endif;

	self.zLdapLog(CnCntrl.CnLogDiag, "LDAP Entry " & pEntry.dn & " modified on server " & self.host);

end;
}
cnOpen
{
cnOpen(pHost:String; pDn:String; pPassword:String) updating;

// Initialises an LDAP connection and binds to the server.

vars

	handle	: MemoryAddress;
	
	result	:Integer;
begin

	if self.ldapHandle <> null then
		self.cnRaiseLdapException(CN_LDAP_CONNECTION_EXISTS, "Connection Already Open", "There is already an open connection for this CnLdapConnection object");
	endif;

	//Check hostname is present
	if pHost = null then
		self.cnRaiseLdapException(CN_LDAP_INVALID_HOST, "Hostname missing", "You must specify a hostname");
	endif;

	//Check hostname not too long
	if pHost.length > 254 then
		self.cnRaiseLdapException(CN_LDAP_INVALID_HOST, "Hostname too long", "Max hostname length is 254");
	endif;

	//Set hostname in ldap object
	self.cnSetHost(pHost);

	//Default port was set when CnLdapConnection object created, but could have been changed since by the user

	if port = null then
		self.cnRaiseLdapException(CN_LDAP_INVALID_PORT, "Port missing", "You must specify a port number (normally 389");
	endif;

	if self.protocolVersion <> 2 and self.protocolVersion <> 3 then
		self.cnRaiseLdapException(CN_LDAP_INVALID_VERSION, "Incorrect version", "Protocol version must be 2 or 3");
	endif;

	//Now initialise the connection.
	if ssl = 0 then
		self.zLdapLog(CnCntrl.CnLogDiag, "About to call cnEInit on host " & pHost & ", port " & port.String);
		handle := self.zEInit(); 	 	//Non-SSL init

	elseif ssl.bitAnd(SSL_SERVER_AUTH) <> null then
        //Note that if the user wants to use a port other than 389, he has to set it himself.
        //cnESSLInit gets the current host and port properties from the CnLdapConnection object.
        handle := self.zESSLInit();						//Do SSL init and get connection handle
    endif;

    //At this point, we have initialised the connection (non-SSL or SSL), and have the connection handle
    if handle = null then
    	if ssl = 0 then
    		self.cnRaiseLdapException(CN_LDAP_OPEN_ERROR, "Init failed", "Error returned by cnEInit");
			
    	else
			self.cnRaiseLdapException(CN_LDAP_OPEN_ERROR, "SSL Init failed", "Error returned by cnESSLInit");
		endif;	 
		
    else
    	self.zLdapLog(CnCntrl.CnLogDiag, "Init successful");
    	//Set ldap handle in ldap object
    	self.cnSetLdapHandle(handle);

    	//Tell ldap server which protocol version to use
    	result := self.zESetOption(handle, LDAP_OPT_PROTOCOL_VERSION, protocolVersion);
    	if result <> LDAP_SUCCESS then
    		self.cnRaiseLdapException(CN_LDAP_INVALID_VERSION, "Error setting option", "Could not set protocol version to " & protocolVersion.String);
    	endif;

		result := self.zESetOption(handle, LDAP_OPT_TIMELIMIT, self.mySearchConstraints.timeLimit);
		if result <> LDAP_SUCCESS then
    		self.cnRaiseLdapException(CN_LDAP_OPTION_ERROR, "Error setting option", "Could not set session timelimit option");
    	endif;

    	result := self.zESetOption(handle, LDAP_OPT_SIZELIMIT, self.mySearchConstraints.maxResults);
		if result <> LDAP_SUCCESS then
    		self.cnRaiseLdapException(CN_LDAP_OPTION_ERROR, "Error setting option", "Could not set session sizelimit option");
    	endif;

		if initWithoutBind = true then
			self.zLdapLog(CnCntrl.CnLogDiag, "Init without bind requested: No authentication will be attempted");
			return;
		endif;

		//Authenticate (bind) to server
		result := self.zESimpleBindS(handle, pDn, pPassword);
        if result <> LDAP_SUCCESS then
     		self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + result, "Authentication failed", self.errorString);
     	endif;
		
		self.zLdapLog(CnCntrl.CnLogDiag, "Bind successful");
    endif;		

end;
}
cnPollReadAsync
{
cnPollReadAsync(pEntry : CnLdapEntry io):Integer updating;

// Polls the LDAP server to see if results are available from an async read

vars
	referrals, 
	searchResults,
	serverCntrls	: MemoryAddress;
	
	parseReply,
	resultReply		: Integer;
	
	cloneAttribute, 
	attribute		: CnLdapAttribute;
	
	entry			: CnLdapEntry;
	
	search			: CnLdapSearch;
	
	x				: Integer;
	
	badObject		: Boolean;
begin
	//Used after async read to poll for results

	on SystemException do app.cnHandleNullOrInvObjectRef(exception, pEntry, badObject);
	x := pEntry.edition;
    if badObject then
 		self.cnRaiseLdapException(CN_LDAP_INVALID_ENTRY_OBJECT, "Invalid Entry Object in " & method.name, "The entry object is not a valid object");
 	endif;

	search := pEntry.myReadAsyncSearchObject;	// This is the search object we created in cnReadAsync to perform the async search

	//Retrieval type should always be LDAP_MSG_ONE. Poll timeout is 0 unless explicitly changed by user in search object
	resultReply := self.zEResult(self.ldapHandle, search.msgID, search.asyncRetrievalType, search.asyncPollTimeout, searchResults);

	if resultReply = 0 then
		return NO_DATA_YET;						//No results available yet
	endif;
	
	if resultReply = -1 then
		self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + self.errorCode, "Error in " & method.name, self.errorString);

	elseif resultReply > 0 then

		if resultReply = LDAP_RES_SEARCH_ENTRY then
			self.zGetAllEntries(searchResults, search);

			if search.cnGetNextEntry(entry) then
				pEntry.cnSetDn(entry.dn);
				foreach attribute in entry.allAttributes do
					cloneAttribute := attribute.cnCloneSelf(true);
					cloneAttribute.cnSetMyEntry(pEntry);
				endforeach;

				//Free the search result memory
				self.zEMsgFree(searchResults);								
				if self.errorCode <> 0 then
					self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + errorCode, "Error freeing search memory", self.errorString);
				endif;
				
				return ENTRY_AVAILABLE;							//Tell the user that pEntry can be processed
			endif;

			self.cnRaiseLdapException(CN_LDAP_GENERAL_ERROR, "Unexpected Result in " & method.name, "cnGetNextEntry did not return an entry");
		endif;	

		if resultReply <> LDAP_RES_SEARCH_RESULT then
			return resultReply;								//Caters for LDAP return codes that we don't yet support
		endif;
		
		parseReply := self.zEParseResult(self.ldapHandle, searchResults, referrals, serverCntrls, 0);
		if parseReply <> LDAP_SUCCESS then
			self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + self.errorCode, "Error occurred while parsing final search results in " & method.name, self.errorString);
		endif;
		
		if self.errorCode <> LDAP_SUCCESS and self.errorCode <> LDAP_NO_SUCH_OBJECT then
			self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + self.errorCode, "Error occurred during search", self.errorString);
		endif;

		delete search;										//Delete the search object and original entry and attributes
		pEntry.cnSetMyReadAsyncSearchObject(null);

		return NO_MORE_ENTRIES;
	endif;

	self.cnRaiseLdapException(resultReply, "Invalid Result", "Unexpected or unsupported result returned from ldap_result (" & method.name & ")");
end;
}
cnPollSearchAsync
{
cnPollSearchAsync(pSearch:CnLdapSearch io):Integer updating;

// Polls the LDAP server to see if results are available from an async search

vars
	referrals,
	searchResults,
	serverCntrls		: MemoryAddress;
	
	resultReply, 
	parseReply,
	x					: Integer;
	
	badObject			: Boolean;
begin
	//Used after async search to poll for results

	on SystemException do app.cnHandleNullOrInvObjectRef(exception, pSearch, badObject);
	x := pSearch.edition;
    if badObject then
 		self.cnRaiseLdapException(CN_LDAP_INVALID_SEARCH_OBJECT, "Invalid Search Object in " & method.name, "The search object is not a valid object");
 	endif;

	resultReply := self.zEResult(self.ldapHandle, pSearch.msgID, pSearch.asyncRetrievalType, pSearch.asyncPollTimeout, searchResults);
	if resultReply = 0 then
		return NO_DATA_YET;					//No results available yet
	endif;
	
	if resultReply = -1 then
		self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + self.errorCode, "Error in " & method.name, self.errorString);
	endif;

	if resultReply = 0 then
		self.cnRaiseLdapException(resultReply, "Invalid Result", "Unexpected or unsupported result returned from ldap_result (" & method.name & ")");
	endif;
	
	pSearch.cnResetIterator;
	self.zGetAllEntries(searchResults, pSearch);

	/*Only set iterator to latest entry if getting all entries one at a time.
	When getting all entries at once in async mode, it's equivalent to a synchronous search, so
	we just leave the iterator positioned at the start of allEntries. */

	if resultReply = LDAP_RES_SEARCH_ENTRY then
		pSearch.iterator.startAtIndex(pSearch.entryCount);
		return ENTRY_AVAILABLE;
	endif;	

	if resultReply <> LDAP_RES_SEARCH_RESULT then
		return resultReply;								//Caters for LDAP return codes that we don't yet support
	endif;
	
	//Sort temporarily abandoned: doesn't work with async searches. Question posted to Netscape newsgroup 3.8.99.
	//Sort the entries, if the user requested this
	/*if self.sortAttributeList.size > 0 then
		cnSortEntries(searchResults);
	endif;*/

	parseReply := zEParseResult(ldapHandle, searchResults, referrals, serverCntrls, 1);
	if parseReply <> LDAP_SUCCESS then
		self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + self.errorCode, "Error occurred while parsing final search results in " & method.name, self.errorString);
	endif;
	
	if self.errorCode <> LDAP_SUCCESS then
		self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + self.errorCode, "Error occurred during search", self.errorString);
	endif;

	if pSearch.asyncRetrievalType = LDAP_MSG_ONE then
		return NO_MORE_ENTRIES;
	endif;
	
	if pSearch.asyncRetrievalType = LDAP_MSG_ALL or pSearch.asyncRetrievalType = LDAP_MSG_RECEIVED then
		return ALL_ENTRIES_AVAILABLE;	
	endif;	
	
	return resultReply;	
end;
}
cnRead
{
cnRead(pDn:String; pEntry:CnLdapEntry io) updating;

//Synchronous base search: this retrieves a single entry

vars
	attribute, 
	cloneAttribute	: CnLdapAttribute;
	
	entry, 
	cloneEntry		: CnLdapEntry;
	
	search			: CnLdapSearch;
	
	badObject		: Boolean;
	
	keepScope,
	x				: Integer;
begin
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, pEntry, badObject);
	x := pEntry.edition;
    if badObject then
 		cnRaiseLdapException(CN_LDAP_INVALID_ENTRY_OBJECT,
 							 "Invalid Entry Object",
 							 "The entry object supplied to " & method.name & " is not a valid object");
 	endif;

 	create search;
 	keepScope := self.scope;							//Save current scope setting
 	self.cnSetScope(LDAP_SCOPE_BASE);					//Set scope to BASE to get single entry
 	self.cnSearch(pDn, DEFAULT_FILTER, search);			//Do the search
 	self.cnSetScope(keepScope);							//Restore the 'current' scope

 	if search.entryCount <> 0 then
 		if search.cnGetNextEntry(entry) then
			pEntry.cnSetDn(entry.dn);
			foreach attribute in entry.allAttributes do
				cloneAttribute := attribute.cnCloneSelf(true);
				cloneAttribute.cnSetMyEntry(pEntry);
			endforeach;	
 		endif;	 	
    endif;
epilog
    delete search;										//Delete the search object and original entry and attributes
end;
}
cnReadAsync
{
cnReadAsync(pDn:String; pEntry:CnLdapEntry io) updating;

//Asynchronous base search: this retrieves a single entry

vars
	attribute, 
	cloneAttribute	: CnLdapAttribute;
	
	entry, 
	cloneEntry		: CnLdapEntry;
	
	search			: CnLdapSearch;
	
	badObject		: Boolean;

	keepScope,
	x				: Integer;
begin
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, pEntry, badObject);
	x := pEntry.edition;
    if badObject then
 		cnRaiseLdapException(CN_LDAP_INVALID_ENTRY_OBJECT,
 							 "Invalid Entry Object",
 							 "The entry object supplied to " & method.name & " is not a valid object");
 	endif;

 	create search;
 	keepScope := self.scope;							//Save current scope setting
 	self.cnSetScope(LDAP_SCOPE_BASE);					//Set scope to BASE to get single entry
 	self.cnSearchAsync(pDn, DEFAULT_FILTER, search);	//Start the search
 	self.cnSetScope(keepScope);							//Restore the 'current' scope
 	pEntry.cnSetMyReadAsyncSearchObject(search);		//Need to ref the search object so we can recover the MsgId later
end;
}
cnRemoveSearchAttribute
{
cnRemoveSearchAttribute(pAttribute:String) updating;

vars

	i:Integer;

begin

	i := self.searchAttributeList.indexOf(pAttribute);
	if i > 0 then
		self.searchAttributeList.removeAt(i);
	endif;	

end;
}
cnRemoveSortAttribute
{
cnRemoveSortAttribute(pAttribute:String) updating;

vars

	i:Integer;

begin

	i := self.sortAttributeList.indexOf(pAttribute);
	if i > null then
		self.sortAttributeList.removeAt(i);
		self.sortAttributeMulti.removeAt(i);
		self.sortAttributeNumeric.removeAt(i);
		self.sortAttributeSize.removeAt(i);
	endif;	

	self.sortRequired := not self.sortAttributeList.isEmpty();
end;
}
cnRenameEntry
{
cnRenameEntry(pDn:String; pNewRdn:String; pNewParent:String; pDeleteOldRdn:Boolean) updating;

// Renames a directory entry

vars

	result, deleteOldRdn:Integer;

begin

	if pDn = null then
 		self.cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
 							 "Invalid DN",
 							 "The DN supplied with " & method.name & " is a null value");
 	endif;

 	if pNewRdn = null then
 		self.cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
 							 "Invalid RDN",
 							 "The new RDN supplied with " & method.name & " is a null value");
 	endif;

	if pDeleteOldRdn = false then
		deleteOldRdn := 0;
		
	else
		deleteOldRdn := 1;
	endif;

	result := self.zERenameEntry(self.ldapHandle, pDn, pNewRdn, pNewParent, deleteOldRdn, null, null);

	if result <> LDAP_SUCCESS then
		self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + result, "Rename Entry Failed", self.errorString);
	endif;	
end;
}
cnSearch
{
cnSearch(pBase:String; pFilter:String; pSearch:CnLdapSearch io) updating;

//Synchronous search

vars

begin
	self.zISearch(false, null, pBase, pFilter, pSearch);
end;
}
cnSearchAsync
{
cnSearchAsync(pBase:String; pFilter:String; pSearch:CnLdapSearch io) updating;

//Asynchronous search

vars

begin

	cnISearchAsync(false, null, pBase, pFilter, pSearch);

end;
}
cnSetAttrsOnly
{
cnSetAttrsOnly(pFlag:Integer) updating;

vars

begin

	self.mySearchConstraints.cnSetAttrsOnly(pFlag);

end;
}
cnSetHost
{
cnSetHost(pHost:String) updating;

vars

begin

	host := pHost;

end;
}
cnSetInitWithoutBind
{
cnSetInitWithoutBind(pInitWithoutBind:Boolean) updating;

vars

begin

	initWithoutBind := pInitWithoutBind;

end;
}
cnSetLdapHandle
{
cnSetLdapHandle(pHandle : MemoryAddress) updating;

vars

begin
	self.ldapHandle := pHandle;
end;
}
cnSetLoggingRequired
{
cnSetLoggingRequired(pLogFlag:Boolean) updating;

vars

begin

	loggingRequired := pLogFlag;

end;
}
cnSetMaxResults
{
cnSetMaxResults(pMax:Integer) updating;

vars

begin

	self.mySearchConstraints.cnSetMaxResults(pMax);

end;
}
cnSetMySearchConstraints
{
cnSetMySearchConstraints(pConstraints:CnLdapConstraints) updating;

vars

begin

	mySearchConstraints := pConstraints;

end;
}
cnSetOldSortStyle
{
cnSetOldSortStyle(pBool : Boolean) updating;

vars

begin
	self.oldSortStyle := pBool;
end;
}
cnSetPort
{
cnSetPort(pPort:Integer) updating;

vars

begin

	port := pPort;

end;
}
cnSetProtocolVersion
{
cnSetProtocolVersion(pVersion:Integer) updating;

vars

begin

	protocolVersion := pVersion;

end;
}
cnSetScope
{
cnSetScope(pScope:Integer) updating;

vars

begin

	scope := pScope;

end;
}
cnSetSearchAttribute
{
cnSetSearchAttribute(pAttribute:String) updating;

vars

begin
	self.searchAttributeList.add(pAttribute.toLower);

end;
}
cnSetSearchAttributes
{
cnSetSearchAttributes(pAttributes:String; pDelimiters:String) updating;

vars
	sa			: CnStringArray;
	
	stripSpaces	: Boolean;
	
	reply		: Integer;
    
	copyString,
	s			: String;
begin
    if pAttributes.length() = null then
		return;
	endif;
	
	create sa transient;
	copyString 	:= pAttributes;
	stripSpaces := (pDelimiters.pos(CN_SPACE, 1) = null);		
	reply := copyString.cnUnbust(pDelimiters, sa, stripSpaces);
	if reply <> null then
		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
						 "Invalid Parameter",
						 "One of the parameters supplied to " & method.name & " is invalid");
	endif;

	foreach s in sa do
		self.searchAttributeList.add(s.toLower());
	endforeach;
epilog
	delete sa;
end;
}
cnSetSortAttribute
{
cnSetSortAttribute(pAttribute:String) updating;

vars
	ldapAttr	: CnLdapAttribute;
begin
	create ldapAttr transient;
	if ldapAttr.cnAttributeIsBinary(pAttribute) then
 		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
 							 "Invalid Sort Parameter",
 							 "Sort parameter '" & pAttribute & "' may not be Binary");
	endif;

	self.sortAttributeList.add(pAttribute.toLower);
	self.sortAttributeMulti.add(false);					// default : attribute has single value
	self.sortAttributeNumeric.add(true);				// default : attribute is alphanumeric
	self.sortAttributeSize.add(null);					// default : attribute is null length
	self.sortRequired := true;
epilog
	delete ldapAttr;
end;
}
cnSetSortAttributes
{
cnSetSortAttributes(pAttributes:String;pDelimiters:String) updating;

constants
	Space = " ";
vars
	stripSpaces		: Boolean;
	
	sa				: CnStringArray;
	
	reply			: Integer;
	
    copyString,
	s				: String;
	
	ldapAttr		: CnLdapAttribute;
begin
	if pAttributes = null then
		return;
	endif;
	
	create sa transient;
	copyString := pAttributes;
	if pDelimiters.pos(Space,1) = 0 then
		stripSpaces := true;
		
	else
		stripSpaces := false;
	endif;		
	
	reply := copyString.cnUnbust(pDelimiters, sa, stripSpaces);

	if reply <> 0 then
		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
						 "Invalid Parameter",
						 "One of the parameters supplied to " & method.name & " is invalid");
	endif;

	create ldapAttr transient;
	
	foreach s in sa do
		if ldapAttr.cnAttributeIsBinary(s) then
			cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
								 "Invalid Sort Parameter",
								 "Sort parameter '" & s & "' may not be Binary");
		endif;	

		self.sortAttributeList.add(s.toLower());
		self.sortAttributeMulti.add(false);					// default : attribute has single value
		self.sortAttributeNumeric.add(true);				// default : attribute is alphanumeric
		self.sortAttributeSize.add(null);					// default : attribute is null length
		self.sortRequired := true;
	endforeach;
epilog
	delete sa;
	delete ldapAttr;
end;
}
cnSetSsl
{
cnSetSsl(pSsl:Integer) updating;

vars

begin

	ssl := pSsl;

end;
}
cnSetTimeLimit
{
cnSetTimeLimit(pLimit:Integer) updating;

vars

begin

	self.mySearchConstraints.cnSetTimeLimit(pLimit);

end;
}
cnURLSearch
{
cnURLSearch(pURL:CnLdapURL; pSearch:CnLdapSearch io) updating;

//Synchronous search via URL

vars

begin

 	zISearch(true, pURL, null, null, pSearch);

end;
}
cnURLSearchAsync
{
cnURLSearchAsync(pURL:CnLdapURL; pSearch:CnLdapSearch io) updating;

//Asynchronous search via URL

vars

begin

 	cnISearchAsync(true, pURL, null, null, pSearch);

end;
}
create
{
create() updating;

vars
	constraints	: CnLdapConstraints;
	
	iniFile		: String;
begin
	self.cnSetPort(389);								//Set default non-SSL port
    self.cnSetSsl(0);									//Default is 'Don't use SSL'
    self.cnSetScope(LDAP_SCOPE_SUBTREE);				//Default scope is for a subtree search
    self.cnSetProtocolVersion(2);						//Default protocol version is 2
														//NB: Default is NOT to specify a list of attributes - so we leave attributeList as null
    //Create default session constraints
    create constraints;									// CnLdapConstraints singleton is deleted as part of CnLdapConnection delete (automatic inverse .myLdapConnection)
    constraints.cnSetTimeLimit(30);						//Default wait limit for a search is 30 seconds
    constraints.cnSetMaxResults(LDAP_NO_LIMIT);			//Return unlimited number of results
    constraints.cnSetAttrsOnly(CN_LDAP_ATTRS_VALUES);	//Return attribute values as well as attribute names
    constraints.cnSetMyLdapConnection(self);
    constraints.cnSetMode(CN_LDAP_ENTRIES);				//Extract only entries from the search results

    create tempStringValues transient;					//Ditto for string values
    create tempAttributeArray transient;				//Ditto for attribute names

    iniFile := app.getIniFileName();
	/*Set up logging parameter. Default logging is false. If ini file specifies true, then logging will proceed as per the logging
	 parameters in the ini file's CardLog section. */
	self.cnSetLoggingRequired(app.getProfileString(iniFile, "LDAPClient", "Logging", "false").Boolean);
end;
}
delete
{
delete() updating;

//V2	14.03.01	Close connection if it's still open

vars

begin
	if self.ldapHandle <> null then	//V2
		self.cnClose;				//V2
	endif;							//V2

	self.interimEntryArray.purge();				// MFJ 14/7/2010
	
	delete self.tempStringValues;
	delete self.tempAttributeArray;
end;
}
zGetAllAttributes
{
zGetAllAttributes(pEntryMessage : MemoryAddress input; pEntryObject : CnLdapEntry input) updating, protected;

// Fetches all the attributes and attribute values for a directory entry from the LDAP server

vars
	attribute		: CnLdapAttribute;
	
	attCount,
	i,
	index,
	len,
	oldSz,
	sortAttrCount,
	sz				: Integer;
	
	attributeName,
	str				: String;
	
	numeric,
	oldNumeric		: Boolean;
begin
    self.tempAttributeArray.clear;
    attCount := self.zEAllAttributes(self.ldapHandle, pEntryMessage, self.tempAttributeArray);
    if self.errorCode <> null then
    	self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + self.errorCode, "API Interface Error(cn_ldap_all_attributes)", self.errorString);
    endif;

//	self.attributesToPurge.clear();
	
    foreach attributeName in self.tempAttributeArray do
        create attribute;								// CnLdapAttribute transients deleted when CnLdapEntry deleted (automatic inverse on .myEntry)
        attribute.cnSetName(attributeName);				// also sets attribute.syntax item (derived from name)
/*		if not self.searchAttributeList.includes(attributeName.toLower()) then
			self.attributesToPurge.add(attribute);
		endif;
*/		
        attribute.cnSetMyEntry(pEntryObject);	//This builds the allAttributes collection in the entry object

        if attribute.syntax = "bin" then
        	self.zGetBinaryValues(pEntryMessage, attribute);
			continue;
		endif;

		// remainder is for string values
		self.tempStringValues.clear();
		self.zEStringValues(self.ldapHandle, pEntryMessage, attribute.name, self.tempStringValues);
		if self.errorCode <> null then
			self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + self.errorCode, "API Interface Error", "cn_ldap_get_values returned an error");
		endif;
		
		self.tempStringValues.copy(attribute.allStringValues);
		if not self.sortRequired then
			continue;
		endif;
		
		if self.oldSortStyle then
			continue;
		endif;
		
		index := self.sortAttributeList.indexOf(attributeName.toLower());
		if index = null then
			continue;
		endif;
		
		sortAttrCount := sortAttrCount + 1;
		sz := self.tempStringValues.size();
		if sz > 1 then
			self.sortAttributeMulti[index] := true;
			self.sortAttributeSize[index]  := null;
			self.sortAttributeNumeric[index] := false;
			continue;
		endif;
			
		// if we've found one entity that is multi-valued then all are multi-valued
		if self.sortAttributeMulti[index] then
			continue;
		endif;

		// work out if numeric or not as we need to pad these out with leading zeros
		// also work out max-length so keys are padded with spaces or zeros depending on numeric or not
		oldSz := self.sortAttributeSize[index];
		oldNumeric := self.sortAttributeNumeric[index];
		str := self.tempStringValues.first();
		len := str.length();
		if len > oldSz then
			self.sortAttributeSize[index] := len;
		endif;
		
		// check numeric
		if oldNumeric then
			numeric := true;
			foreach i in 1 to len do
				if not str[i].isNumeric then
					numeric := false;
					break;
				endif;
			endforeach;
			
			numeric := oldNumeric and numeric;
			if oldNumeric <> numeric then
				self.sortAttributeNumeric[index] := numeric;
			endif;
		endif;
		
	endforeach;
epilog
	if self.sortRequired and sortAttrCount = null then
		self.zLdapLog(CnCntrl.CnLogComment, "No sort attributes returned, no sorting done");
		self.sortRequired := false;
	endif;
end;
}
zGetAllEntries
{
zGetAllEntries(pSearchResults : MemoryAddress input; pUserSearch : CnLdapSearch io) updating, protected;

// Fetches all the directory entries that resulted from a search

vars
	entry				: CnLdapEntry;
	
	entryMessage		: MemoryAddress;
	
	numberOfEntries, 
	count, 
	attributeMessage	: Integer;
		
	dn					: String;
	
	addRef				: Boolean;
	
	cc					: CnCntrl;
begin
	//Now build array of entries found during search
    numberOfEntries := self.zECountEntries(self.ldapHandle, pSearchResults);
    if numberOfEntries = -1 then
		self.cnRaiseLdapException(CN_LDAP_GENERAL_ERROR, "API Interface Error", "cn_ldap_count_entries returned -1");
    endif;

    count := numberOfEntries;
	self.zLdapLog(CnCntrl.CnLogDiag, "Number of entries found " & count.String);
    pUserSearch.cnSetEntryCount(numberOfEntries);

    while count > null do
    	if count = numberOfEntries then
			self.zLdapLog(CnCntrl.CnLogDiag, "Calling 'cn_ldap_first_entry' firstArg=0x" & self.ldapHandle.cnToHex() &
											", secondArg=0x" & pSearchResults.cnToHex());
        	entryMessage := self.zEFirstEntry(self.ldapHandle, pSearchResults);
						
        else
			self.zLdapLog(CnCntrl.CnLogDiag, "Calling 'cn_ldap_next_entry' firstArg=0x" & self.ldapHandle.cnToHex() &
											", secondArg=0x" & entryMessage.cnToHex());
        	entryMessage := self.zENextEntry(self.ldapHandle, entryMessage);
        endif;

      	if entryMessage = null then			//No more entries found
			self.zLdapLog(CnCntrl.CnLogDiag, "result returned = null");
      		return;
      	endif;

      	//Found an entry - so create an entry object		
    	create entry;						// CnLdapEntry transients deleted when CnLdapSearch object deleted (auto inverse on .mySearchObject)
		self.zLdapLog(CnCntrl.CnLogDiag, "Calling 'cn_ldap_get_dn' firstArg=0x" & self.ldapHandle.cnToHex() &
								", secondArg=0x" & entryMessage.cnToHex());
    	dn := self.zEGetDn(self.ldapHandle, entryMessage);
    	if dn = null then
    		self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + self.errorCode, "API Interface Error (cn_ldap_get_dn)", self.errorString);
    	endif;

		self.zLdapLog(CnCntrl.CnLogDiag, "dn='" & dn & "'");	
    	entry.cnSetDn(dn);
    	//Get attribute names and values
    	self.zGetAllAttributes(entryMessage, entry); 

		// Only add inverse reference if oldSort required or if no sorting required. 
		// If not, then the CnLdapSearch ref is added as part of sort.
		if self.sortRequired then
			if self.oldSortStyle then
				entry.cnSetMySearchObject(pUserSearch);
			
			else
				self.interimEntryArray.add(entry);
			endif;
			
		else
			entry.cnSetMySearchObject(pUserSearch);
		endif;

		cc := app.myCnCntrl;
/*		if entry.mySearchObject = null then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & entry.String & " dn=" & dn & " searchObject <null>", null);
		
		else
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & entry.String & " dn=" & dn & " searchObject=" & entry.mySearchObject.String, null);
		endif;
*/		
        count := count - 1;
        process.sleep(1);
    endwhile;
end;
}
zGetBinaryValues
{
zGetBinaryValues(pEntryMessage : MemoryAddress; pAttribute:CnLdapAttribute input) updating, protected;

// Fetches all the binary values of an attribute from the LDAP server

vars

	binaryValue		: Binary;
	
	ldapBinary		: CnLdapBinary;
	
	pointer			: MemoryAddress;
	
	count, 
	index			: Integer;

begin

	//Find out how many binary values there are for this attribute

	count := self.zECountBinaryValues(self.ldapHandle, pEntryMessage, pAttribute.name, pointer);
	if errorCode <> null then
		self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + errorCode, "API Interface Error", "cn_ldap_count_binary_values returned an error");
	endif;	

	if count > 0 then				
		//Fetch binary values and build ldapBinary objects
		while count > index do
			binaryValue := self.zEFetchBinaryValue(pointer, index);
        	create ldapBinary;
        	ldapBinary.cnSetBinaryValue(binaryValue);
        	ldapBinary.cnSetMyAttribute(pAttribute);
        	index := index + 1;
    	endwhile;

    	//Free up memory in LDAP API
    	self.zEValueFreeLen(pointer);
    endif;	    
end;
}
zISearch
{
zISearch(pURLSearch:Boolean; pURL:CnLdapURL; pBase:String; pFilter:String; pSearch:CnLdapSearch io) updating, protected;

//"Internal" search serving both URL-based and parameter-driven search

vars
	constraints			: CnLdapConstraints;

	searchResults		: MemoryAddress;
	
	timelimit, 
	sizelimit, 
	result, 
	mode, 
	sortSize, 
	attrsOnly			: Integer;
	
	start, 
	finish				: Real;
	
	interimSearchAttrs	: CnStringArray;
	
	str					: String;
	
	x					: Integer;
	
	badObject			: Boolean;
	
	ldapEntry			: CnLdapEntry;
begin
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectNotFound, null, badObject);
	if pSearch <> null then
		x := pSearch.edition;
	endif;
	
	if pSearch = null or badObject then
 		self.cnRaiseLdapException(CN_LDAP_INVALID_SEARCH_OBJECT, "Invalid Search Object", "The search object is not a valid object");
 	endif;

	attrsOnly := -1; timelimit := -1; sizelimit := -1;
	if self.loggingRequired then
		self.zLdapLog(CnCntrl.CnLogDiag, method.cnGetMethodName() & " iterimEntryArray.size=" & self.interimEntryArray.size().String);
		foreach ldapEntry in self.interimEntryArray do
			self.zLdapLog(CnCntrl.CnLogDiag, method.cnGetMethodName() & " " & ldapEntry.String & " dn=" & ldapEntry.dn);
		endforeach;
	endif;
	
	self.interimEntryArray.clear();
//	self.interimEntryArray.purge();		// MFJ 14/7/2010
	
	//If search constraints exist for the search object, use them instead of the default ones
	constraints := pSearch.mySearchConstraints;
	if constraints <> null then
		x := constraints.edition;
		if badObject then
			constraints := null;
		endif;
	endif;

	// pop stack on exception handlers
	on SystemException do null;
	
	if constraints <> null then
		if constraints.timeLimit <> -1 then
			timelimit := constraints.timeLimit;
		endif;	
		
		if constraints.maxResults <> -1 then
			sizelimit := constraints.maxResults;
		endif;	
 		//mode := pSearch.mySearchConstraints.mode;      		//Mode is 'Entries' for the moment, until we implement referrals
 		if constraints.attrsOnly <> -1 then
 			attrsOnly := constraints.attrsOnly;
 		endif;	
 	endif;

	if timelimit = -1 then
		timelimit := self.mySearchConstraints.timeLimit;		//Insert session default
	endif;	
	
	if sizelimit = -1 then
		sizelimit := self.mySearchConstraints.maxResults;		//Insert session default
	endif;	

	mode := self.mySearchConstraints.mode;						//Mode is 'Entries' for the moment, until we implement referrals
 	if attrsOnly = -1 then
 		attrsOnly := self.mySearchConstraints.attrsOnly;		//Insert session default
 	endif;

	if constraints <> null then
		constraints.cnSetTimeLimit(timelimit);
		constraints.cnSetMaxResults(sizelimit);
		constraints.cnSetAttrsOnly(attrsOnly);
	endif;

	if not pURLSearch then								//If searching with user-supplied parameters
		create interimSearchAttrs transient;
		self.searchAttributeList.copy(interimSearchAttrs);
		foreach str in self.sortAttributeList do		// if search attr don't include sort attr, force them to be included
			if not interimSearchAttrs.includes(str) then
				interimSearchAttrs.add(str);
			endif;
		endforeach;
		
		self.zLdapLog(CnCntrl.CnLogDiag, "Starting search (" & pBase & '/' & cnScopeToString(scope) & "/" & pFilter & ")");
		start := cnCurrentTimeInMilliseconds;
		result := self.zESearchS(self.ldapHandle,
								 pBase,
								 self.scope,
								 pFilter,
								 interimSearchAttrs,
								 attrsOnly.Boolean,
								 null,							//Server Controls (not yet implemented)
								 null,                        	//Client Controls (not yet implemented)
								 timelimit,
								 sizelimit,
								 searchResults);

	 else					//If searching via a URL

		result := pURL.cnEURLCheck(pURL.url);		//Check that URL is an LDAP URL
		if result.Boolean = false then
 			self.cnRaiseLdapException(CN_LDAP_INVALID_URL, "Invalid LDAP URL", "The URL supplied to the search function is not a valid LDAP URL");
 		endif;	

		self.zLdapLog(CnCntrl.CnLogDiag, "Starting search via URL (" & pURL.url & ")");
		start := cnCurrentTimeInMilliseconds;
		result := self.zEURLSearchS(self.ldapHandle,
									 pURL.url,
									 attrsOnly,
									 searchResults);

	endif;

	finish := self.cnCurrentTimeInMilliseconds;
	self.zLdapLog(CnCntrl.CnLogDiag, "Result=" & result.String & ", Search Time in API = " & ((finish - start)/1000).String & " seconds");

	if result <> LDAP_SUCCESS then
		if result = LDAP_NO_SUCH_OBJECT then
           pSearch.cnSetEntryCount(0);
		   
        elseif result <> 4 then
			self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + result, "Search failed", self.errorString);
		endif;	
	endif;

	pSearch.cnSetMyLdapConnection(self);

	pSearch.cnSetAttrsOnly(attrsOnly);	//Record whether attrsOnly specified for this search

	if mode = CN_LDAP_ENTRIES then	
		self.zLdapLog(CnCntrl.CnLogDiag, method.cnGetMethodName() & " mode=CN_LDAP_ENTRIES, oldSortStyle=" & self.oldSortStyle.String &
							", sortRequired=" & self.sortRequired.String);
	endif;
	
	if mode = CN_LDAP_ENTRIES and result <> LDAP_NO_SUCH_OBJECT then

		//If client-side sorting required, do it now, before building entry objects and freeing up the search result memory
		if self.oldSortStyle and self.sortRequired then
			self.zSortEntriesOld(searchResults);
		endif;		

		//Build the entries and their attributes
		self.zGetAllEntries(searchResults, pSearch);

		//Free the search result memory
		self.zEMsgFree(searchResults);								
		if self.errorCode <> 0 then
			self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + errorCode, "Error freeing search memory", self.errorString);
		endif;

		if not self.oldSortStyle and self.sortRequired then
			self.zSortEntries(pSearch);
		endif;		
		
//		self.attributesToPurge.purge();
	endif;	
epilog
	delete interimSearchAttrs;
end;
}
zLdapLog
{
zLdapLog(pEntryType : Integer; pMessage : String) protected;

// Writes a message to the CardSchema log

vars

begin
	if self.loggingRequired and app.myCnCntrl <> null then
		app.myCnCntrl.cnWriteLog(pEntryType, pMessage, null);
	endif;	

end;
}
zSortEntries
{
zSortEntries(pSearch : CnLdapSearch) protected;

vars
	ldapEntry		: CnLdapEntry;
	
	ldapAttribute	: CnLdapAttribute;
	
	dynaDict		: DynaDictionary;
	
	iter,
	iterMulti,
	iterNumeric,
	iterSize		: Iterator;
	
	attr,
	key,
	str				: String;
	
	numeric,
	multi			: Boolean;

	count,
	index,
	keyLength,
	max,
	sz				: Integer;
	
	primType		: PrimType;
	
	keyArray		: HugeStringArray;
begin
	if self.interimEntryArray.isEmpty() then
		return;
	endif;
	
	max := self.sortAttributeList.size();
	
	create dynaDict transient;
	dynaDict.setMembership(CnLdapEntry);
	// set up dyna dict keys based on derived lengths
	foreach index in 1 to max do
		if self.sortAttributeMulti[index] then
			str := "multi String";
			primType := String;
			keyLength := 200;

		else
			str := "String";
			primType := String;
			keyLength := self.sortAttributeSize[index];
			if self.sortAttributeNumeric[index] then
				str := "Integer String";
				primType := String;
			endif;
		endif;
		
		dynaDict.addExternalKey(primType, keyLength, false, false);
	endforeach;
	
	dynaDict.endKeys(true);
	
	create keyArray transient;
	foreach ldapEntry in self.interimEntryArray do
    	//Get attribute names and values
		count := count + 1;
		keyArray.clear();
		index := null;
    	foreach attr in self.sortAttributeList do
			index := index + 1;
			ldapAttribute := ldapEntry.cnGetAttribute(attr);
			if ldapAttribute = null then
				keyArray.atPut(index, null);
				continue;
			endif;
			
			if self.sortAttributeMulti[index] then
				foreach str in ldapAttribute.allStringValues do
					key := key & str;
				endforeach;
				
				key := key[1:255];
				keyArray.atPut(index, key);
				continue;
			endif;
			
			sz := self.sortAttributeSize[index];
			key := ldapAttribute.allStringValues.first;
			if self.sortAttributeNumeric[index] then
				key := key.padLeadingZeros(sz);
			
			else
				key := key.padBlanks(sz);
			endif;
			
			key := key[1:255];
			keyArray.atPut(index, key);
		endforeach;
		
		if max = 1 then
			dynaDict.putAtKey(keyArray[1], ldapEntry);
		
		elseif max = 2 then
			dynaDict.putAtKey(keyArray[1], keyArray[2], ldapEntry);

		elseif max = 3 then
			dynaDict.putAtKey(keyArray[1], keyArray[2], keyArray[3], ldapEntry);
			
		elseif max = 4 then
			dynaDict.putAtKey(keyArray[1], keyArray[2], keyArray[3], keyArray[4], ldapEntry);
			
		elseif max = 5 then
			dynaDict.putAtKey(keyArray[1], keyArray[2], keyArray[3], keyArray[4], keyArray[5], ldapEntry);
			
		elseif max = 6 then
			dynaDict.putAtKey(keyArray[1], keyArray[2], keyArray[3], keyArray[4], keyArray[5], keyArray[6], ldapEntry);
		endif;
	endforeach;
	
	iter := dynaDict.createIterator();
	while iter.next(ldapEntry) do
		ldapEntry.cnSetMySearchObject(pSearch);
	endwhile;
epilog
	delete iter;
	delete iterMulti;
	delete iterNumeric;
	delete iterSize;
	delete dynaDict;
	delete keyArray;
end;
}
zSortEntriesOld
{
zSortEntriesOld(pSearchResults : MemoryAddress io) updating, protected;

vars

	sortSize, result:Integer;

begin

	sortSize := self.sortAttributeList.size;
	if sortSize = 1 then
		result := self.zESortEntries(self.ldapHandle, pSearchResults, self.sortAttributeList.first, "strcmp");
		if result <> LDAP_SUCCESS then
			self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + self.errorCode, "Error occurred while sorting entries", self.errorString);
		endif;
		
		return;
	endif;
		
	if sortSize > 1 then
		result := self.zEMultiSortEntries(self.ldapHandle, pSearchResults, self.sortAttributeList, "strcmp");
		if result <> LDAP_SUCCESS then
			self.cnRaiseLdapException(CN_LDAP_ERROR_BASE + self.errorCode, "Error occurred while sorting entries", self.errorString);
		endif;		
	endif;

end;
}
	externalMethodSources
zEAbandonA
{
zEAbandonA(
			pHandle: MemoryAddress; 
			pMsgID: Integer; 
			pServerCtrls: Integer; 
			pClientCtrls: Integer): Integer is "cn_ldap_abandon_ext" in "cnldap" number = 1048, protected;
}
zEAddEntry
{
zEAddEntry(
			pHandle: MemoryAddress; 
			pDn: String; 
			pAttributeArray: CnLdapAttributeDict; 
			pServerCtrls: Integer; 
			pClientCtrls: Integer): Integer is "cn_ldap_add_ext_s" in "cnldap" number = 1049, protected;
}
zEAllAttributes
{
zEAllAttributes(
			pHandle			: MemoryAddress; 
			pEntryMessage	: MemoryAddress; 
			pAttributeArray	: CnStringArray io): Integer is "cn_ldap_all_attributes" in "cnldap" number = 1050, protected;
}
zECompare
{
zECompare(
			pHandle: MemoryAddress; 
			pDn: String; 
			pAttributeName: String; 
			pValue: Binary; 
			pServerCtrls: Integer; 
			pClientCtrls: Integer): Integer is "cn_ldap_compare_ext_s" in "cnldap" updating, number = 1051, protected;
}
zECountBinaryValues
{
zECountBinaryValues(
			pHandle			: MemoryAddress; 
			pEntryMessage	: MemoryAddress; 
			pAttName		: String; 
			pPointer		: MemoryAddress output): Integer is "cn_ldap_count_binary_values" in "cnldap" updating, number = 1052, protected;
}
zECountEntries
{
zECountEntries(
			pHandle: MemoryAddress; 
			pSearchResults: MemoryAddress): Integer is "cn_ldap_count_entries" in "cnldap" number = 1053, protected;
}
zEDeleteEntry
{
zEDeleteEntry(
			pHandle			: MemoryAddress; 
			pDn				: String; 
			pServerCtrls	: Integer; 
			pClientCtrls	: Integer): Integer is "cn_ldap_delete_ext_s" in "cnldap" updating, number = 1054, protected;
}
zEFetchBinaryValue
{
zEFetchBinaryValue(
			pPointer	: MemoryAddress; 
			pIndex		: Integer): Binary is "cn_ldap_fetch_binary_value" in "cnldap" updating, number = 1055, protected;
}
zEFirstEntry
{
zEFirstEntry(
			pHandle			: MemoryAddress; 
			pSearchResults	: MemoryAddress): MemoryAddress is "cn_ldap_first_entry" in "cnldap" number = 1056, protected;
}
zEGetDn
{
zEGetDn(
			pHandle	: MemoryAddress; 
			pEntry	: MemoryAddress): String is "cn_ldap_get_dn" in "cnldap" updating, number = 1057, protected;
}
zEInit
{
zEInit(): MemoryAddress is "cn_ldap_init" in "cnldap" updating, number = 1058, protected;
}
zEModifyEntry
{
zEModifyEntry(
			pHandle: MemoryAddress; 
			pDn: String; 
			pAttributeArray: CnLdapAttributeDict; 
			pServerCtrls: Integer; 
			pClientCtrls: Integer): Integer is "cn_ldap_modify_ext_s" in "cnldap" number = 1059, protected;
}
zEMsgFree
{
zEMsgFree(pSearchResults: MemoryAddress): Integer is "cn_ldap_msgfree" in "cnldap" updating, number = 1060, protected;
}
zEMultiSortEntries
{
zEMultiSortEntries(
			pHandle				: MemoryAddress; 
			pSearchResults		: MemoryAddress io; 
			pAttributeList		: CnStringArray; 
			pRoutine			: String): Integer is "cn_ldap_multisort_entries" in "cnldap" updating, number = 1061, protected;
}
zENextEntry
{
zENextEntry(
			pHandle			: MemoryAddress; 
			pSearchResults	: MemoryAddress): MemoryAddress is "cn_ldap_next_entry" in "cnldap" number = 1062, protected;
}
zEParseResult
{
zEParseResult(
			pHandle			: MemoryAddress; 
			pSearchResults	: MemoryAddress io; 
			pReferrals		: MemoryAddress io; 
			pServerCntrls	: MemoryAddress io; 
			pFreeit			: Integer): Integer is "cn_ldap_parse_result" in "cnldap" updating, number = 1063, protected;
}
zERenameEntry
{
zERenameEntry(
			pHandle			: MemoryAddress; 
			pDn				: String; 
			pNewRdn			: String; 
			pNewParent		: String; 
			pDeleteOldRdn	: Integer; 
			pServerCtrls	: Integer; 
			pClientCtrls	: Integer): Integer is "cn_ldap_rename_s" in "cnldap" updating, number = 1064, protected;
}
zEResult
{
zEResult(
			pHandle			: MemoryAddress; 
			pMsgID			: Integer; 
			pAll			: Integer; 
			pTimeout		: Integer; 
			pSearchResults	: MemoryAddress io): Integer is "cn_ldap_result" in "cnldap" updating, number = 1065, protected;
}
zESSLClientInit
{
zESSLClientInit(
			pCertDbPath: String; 
			pCertDbHandle: Integer): Integer is "cn_ldapssl_client_init" in "cnldap" number = 1066, protected;
}
zESSLInit
{
zESSLInit(): MemoryAddress is "cn_ldapssl_init" in "cnldap" updating, number = 1067, protected;
}
zESearchA
{
zESearchA(
			pHandle: MemoryAddress; 
			pBase: String; 
			pScope: Integer; 
			pFilter: String; 
			pAttrs: CnStringArray; 
			attrsOnly: Boolean; 
			serverCtrls: Integer; 
			clientCtrls: Integer; 
			pTimeout: Integer; 
			pSizeLimit: Integer; 
			pMsgID: Integer io): Integer is "cn_ldap_search_ext" in "cnldap" updating, number = 1068, protected;
}
zESearchS
{
zESearchS(
			pHandle			: MemoryAddress; 
			pBase			: String; 
			pScope			: Integer; 
			pFilter			: String; 
			pAttrs			: CnStringArray; 
			attrsOnly		: Boolean; 
			serverCtrls		: Integer; 
			clientCtrls		: Integer; 
			pTimeout		: Integer; 
			pSizeLimit		: Integer; 
			pSearchResults	: MemoryAddress io): Integer is "cn_ldap_search_ext_s" in "cnldap" updating, number = 1069, protected;
}
zESetOption
{
zESetOption(
			pHandle: MemoryAddress; 
			pOption: Integer; 
			pValue: Any): Integer is "cn_ldap_set_option" in "cnldap" updating, number = 1070, protected;
}
zESimpleBindS
{
zESimpleBindS(
			pHandle: MemoryAddress; 
			pDn: String; 
			pPassword: String): Integer is "cn_ldap_simpleBind_s" in "cnldap" number = 1071, protected;
}
zESortEntries
{
zESortEntries(
			pHandle			: MemoryAddress; 
			pSearchResults	: MemoryAddress io; 
			pAttribute		: String; 
			pRoutine		: String): Integer is "cn_ldap_sort_entries" in "cnldap" updating, number = 1072, protected;
}
zEStringValues
{
zEStringValues(
			pHandle				: MemoryAddress; 
			pEntryMessage		: MemoryAddress; 
			pAttName			: String; 
			pAttributeValues	: HugeStringArray io): Integer is "cn_ldap_get_values" in "cnldap" number = 1073, protected;
}
zEURLSearchA
{
zEURLSearchA(
			pHandle: MemoryAddress; 
			pURL: String; 
			attrsOnly: Integer): Integer is "cn_ldap_url_search" in "cnldap" updating, number = 1074, protected;
}
zEURLSearchS
{
zEURLSearchS(
			pHandle			: MemoryAddress; 
			pURL			: String; 
			attrsOnly		: Integer; 
			pSearchResults	: MemoryAddress io): Integer is "cn_ldap_url_search_s" in "cnldap" updating, number = 1075, protected;
}
zEUnbindS
{
zEUnbindS(pHandle: MemoryAddress): Integer is "cn_ldap_unbind_s" in "cnldap" number = 1076, protected;
}
zEValueFreeLen
{
zEValueFreeLen(pPointer: MemoryAddress): Integer is "cn_ldap_value_free_len" in "cnldap" number = 1077, protected;
}
	)
	CnLdapConstraints (
	jadeMethodSources
cnSetAttrsOnly
{
cnSetAttrsOnly(pFlag:Integer) updating;

vars

begin

	attrsOnly := pFlag;

end;
}
cnSetMaxResults
{
cnSetMaxResults(pMax:Integer) updating;

vars

begin

	maxResults := pMax;

end;
}
cnSetMode
{
cnSetMode(pMode:Integer) updating;

vars

begin

	mode := pMode;

end;
}
cnSetMyLdapConnection
{
cnSetMyLdapConnection(pLdap:CnLdapConnection) updating;

vars

begin

	myLdapConnection := pLdap;

end;
}
cnSetMySearchObject
{
cnSetMySearchObject(pSearch:CnLdapSearch) updating;

vars

begin

	mySearchObject := pSearch;

end;
}
cnSetTimeLimit
{
cnSetTimeLimit(pLimit:Integer) updating;

vars

begin

	timeLimit := pLimit;

end;
}
create
{
create() updating;

vars
	cc 	: CnCntrl;
begin
	cc := app.myCnCntrl;
	
	cnSetMode(CN_LDAP_ENTRIES);			//At present we only look for entries, not referrals

    /*Deliberately set these properties to illegal values so we can tell when starting a search whether the user
      altered them or not. If they've been altered, we use the altered value rather than the default. */

    cnSetAttrsOnly(-1);
    cnSetMaxResults(-1);
    cnSetTimeLimit(-1);
end;
}
	)
	CnLdapEntry (
	jadeMethodSources
cnAddAttribute
{
cnAddAttribute(pAttributeName:String; pValue:Any) updating;

// Adds an attribute to an entry object in preparation for adding the entry to the LDAP server

vars

	attribute:CnLdapAttribute;
	ldapBinary:CnLdapBinary;
	value:Any;

begin

	if pAttributeName = null then
 		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
 							 "Invalid Attribute Name",
 							 "The attribute name supplied with " & method.name & " is a null value");
 	endif;

    value := pValue;

    attribute := allAttributes.getAtKey(pAttributeName);	//Dictionary is case-insensitive
    if attribute = null then
		create attribute;
		attribute.cnSetName(pAttributeName);
		attribute.cnSetMyEntry(self);
	endif;

	//Attributes must be supplied in the format that corresponds to their 'syntax' attribute.
	if value <> null then
		if (attribute.syntax = "bin") and (not value.isKindOf(Binary)) or
			(not attribute.syntax = "bin") and value.isKindOf(Binary) 	then
			cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
 							 "Invalid Modify Operation",
 							 "The " & attribute.name & " data type is incompatible with syntax " & attribute.syntax);
 		endif;					 
 	endif;

	if value <> null or
		(value.isKindOf(String) and value.String = '') or
		(value.isKindOf(Binary) and value.Binary = null) then

		if value = null then
			if attribute.syntax <> "bin" then
				value := "";
			endif;
		endif;

		if attribute.syntax <> "bin" then
			attribute.allStringValues.add(value.String);
		else
			create ldapBinary;
			ldapBinary.cnSetBinaryValue(value.Binary);
			ldapBinary.cnSetMyAttribute(attribute);
		endif;
	endif;	

end;
}
cnAddDelimitedAttribute
{
cnAddDelimitedAttribute(pAttributeName:String; pValues:String; pDelimiters:String) updating;

vars

	attribute:CnLdapAttribute;
	sa:CnStringArray;
    reply:Integer;
    copyString,s:String;

begin

    if pAttributeName = null then
 		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
 							 "Invalid Attribute Name",
 							 "The attribute name supplied with " & method.name & " is a null value");
 	endif;

    create sa transient;
    create attribute;
    attribute.cnSetName(pAttributeName);

    if pValues = null then
    	attribute.allStringValues.add("");
    else	
    	copyString := pValues;
		reply := copyString.cnUnbust(pDelimiters, sa, false);

        if reply <> 0 then
 			cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
 							 "Invalid Parameter",
 							 "One of the parameters supplied to " & method.name & " is invalid");
 		endif;

   		sa.copy(attribute.allStringValues);
	endif;			
	attribute.cnSetMyEntry(self);
epilog
	delete sa;
end;
}
cnAddMultiAttribute
{
cnAddMultiAttribute(pAttributeName:String; pValues:Array input) updating;
//V2 07.02.2000 Handle different types of array correctly (casting to an array type appears to truncate the array contents)

// Adds multiple string values to an attribute

vars

	attribute:CnLdapAttribute;

begin

	if pAttributeName = null then
 		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
 							 "Invalid Attribute Name",
 							 "The attribute name supplied with " & method.name & " is a null value");
 	endif;

	if pValues = null then
		cnRaiseLdapException(CN_LDAP_INVALID_ATTR_ARRAY,
 							 "Invalid Array",
 							 "The array supplied with " & method.name & " is not a valid object");
 	endif;

 	if (not pValues.isKindOf(StringArray)) and (not pValues.isKindOf(HugeStringArray)) then
 		cnRaiseLdapException(CN_LDAP_INVALID_ATTR_ARRAY,
 							 "Invalid Array",
 							 "The array supplied with " & method.name & " is the wrong type");
 	endif;

	create attribute;
	attribute.cnSetName(pAttributeName);

	pValues.copy(attribute.allStringValues);  	//V2

	attribute.cnSetMyEntry(self);
end;
}
cnAsLDIF
{
cnAsLDIF():String updating;

// Returns the LDIF-formatted attribute names and values in this entry. Binary values are encoded as Base64 strings.

vars

	value:String;

begin

 	value := cnConvertToLDIF(false);		//Show that we require long binary LDIFs
 	self.cnResetIterator;
 	return value;			

end;
}
cnAsString
{
cnAsString():String updating;

/* Returns an LDIF-formatted string representing the attribute values in this entry. Binary values have only their first ten bytes
	Base64-encoded, so this method is not suitable for building data for input to an LDAP server; it should only be used for building
	a display string - for example, when displaying the contents of a directory entry. */

vars

	value:String;

begin

 	value := cnConvertToLDIF(true);	//Set flag to indicate short binary LDIFs required
 	self.cnResetIterator;
 	return value;			

end;
}
cnClearAttribute
{
cnClearAttribute(pAttributeName:String);
// Clears an attribute's values based on it's name property.
// This should be called before cnModifyAttribute when doing an LDAP_MOD_REPLACE of an
// exisiting entry to clear out the current attribute values.
// Failure to do this will result in any new values being added to existing ones.

vars
	attribute : CnLdapAttribute;
begin

	attribute := allAttributes.getAtKey(pAttributeName);
	if attribute <> null then
		if attribute.syntax <> "bin" then
			attribute.allStringValues.clear;
		else
			attribute.allBinaryValues.purge;
		endif;
	endif;		
end;
}
cnCloneSelf
{
cnCloneSelf(pTransient:Boolean):CnLdapEntry updating;

// Clones an entry object

vars

	attribute, cloneAttribute:CnLdapAttribute;
	cloneEntry:CnLdapEntry;

begin

	cloneEntry := self.cloneSelf(pTransient);
	foreach attribute in self.allAttributes do
		cloneAttribute := attribute.cnCloneSelf(pTransient);
		cloneAttribute.cnSetMyEntry(cloneEntry);
	endforeach;	
	return cloneEntry;

end;
}
cnConvertToLDIF
{
cnConvertToLDIF(pShortFlag:Boolean):String updating;

// Internal method called by cnAsLDIF and cnAsString.
vars


	attrsOnly:Boolean;
	attribute:CnLdapAttribute;
	value, returnString:String;
begin
 	//If the entry was created as a result of a search, check whether 'attrsOnly' was specified on that search
 	if app.isValidObject(mySearchObject) then
 		attrsOnly := mySearchObject.attrsOnly.Boolean;
 	endif;

 	//Return entire entry as an LDIF record
 	returnString := "dn: " & self.dn & CrLf;
 	self.cnResetIterator;
 	foreach attribute in self.allAttributes do
 		attribute.cnResetStringIterator;
        attribute.cnResetBinaryIterator;

        if attrsOnly = true then
        	returnString := returnString & attribute.name & CrLf;
        elseif attribute.isNull then
        	if attribute.syntax <> "bin" then
        		returnString := returnString & attribute.name & ":" & CrLf;
        	else
        		returnString := returnString & attribute.name & "::" & CrLf;
        	endif;				
        else	
	 		while attribute.cnGetNextStringAsLDIF(value) do
	 			returnString := returnString & value & CrLf;
	 		endwhile;

	 		if pShortFlag = true then
	 			while attribute.cnGetNextBinaryAsShortLDIF(value) do
	 				returnString := returnString & value & CrLf;
	 			endwhile;
	 		else
	 			while attribute.cnGetNextBinaryAsLDIF(value) do
	 				returnString := returnString & value & CrLf;
	 			endwhile;
	 		endif;	
	 	endif;
	 	attribute.cnResetStringIterator;
        attribute.cnResetBinaryIterator;	
 	endforeach;
 	return returnString;			

end;
}
cnGetAllAttributeValues
{
cnGetAllAttributeValues(pAttributeName:String; pArray:Any io) updating;

vars

	attribute:CnLdapAttribute;
	ldapBinary:CnLdapBinary;
	value:Any;
begin
	/*This method returns all the values of the attribute. Depending on whether the attribute values are strings or
	  binaries, the values will be returned as string arrays or CnLdapBinary arrays. The array supplied by the user
	  must be compatible with the type of data to be returned. */

	if pAttributeName = null then
 		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
 							 "Invalid Attribute Name",
 							 "The attribute name supplied with " & method.name & " is a null value");
 	endif;

 	if (pArray = null) or
 		((not pArray.isKindOf(StringArray)) and
 		(not pArray.isKindOf(HugeStringArray)) and
 		(not pArray.isKindOf(CnLdapBinaryArray))) then
 		cnRaiseLdapException(CN_LDAP_INVALID_ATTR_ARRAY,
 							 "Invalid Array",
 							 "The array supplied with " & method.name & " is the wrong type, or non-existent");
 	endif;

	attribute := allAttributes.getAtKey(pAttributeName);	//Dictionary is case-insensitive
	if attribute = null then
		return;
	else
		attribute.cnResetStringIterator();
		while attribute.cnGetNextString(value) do
			if pArray.isKindOf(CnStringArray) then
				pArray.CnStringArray.add(value.String);
			elseif pArray.isKindOf(StringArray) then
				pArray.StringArray.add(value.String);
			elseif pArray.isKindOf(HugeStringArray) then
				pArray.HugeStringArray.add(value.String);
			else
				cnRaiseLdapException(CN_LDAP_INVALID_ATTR_ARRAY,
 							 "Invalid Array",
 							 "The array supplied with " & method.name & " is not compatible with the attribute value");			
			endif;	
		endwhile;	

		if attribute.allBinaryValues.size > 0 then
			if pArray.isKindOf(CnLdapBinaryArray) then
				attribute.allBinaryValues.copy(pArray.CnLdapBinaryArray);
			else
				cnRaiseLdapException(CN_LDAP_INVALID_ATTR_ARRAY,
 							 "Invalid Array",
 							 "The array supplied with " & method.name & " is not compatible with the attribute value");
 			endif;				 	
		endif;	
	endif;				

end;
}
cnGetAttribute
{
cnGetAttribute(pAttributeName:String):CnLdapAttribute;
// Returns an attribute object based on its name property

vars

begin

	return allAttributes.getAtKey(pAttributeName);	//Dictionary is case-insensitive

end;
}
cnGetAttributeValue
{
cnGetAttributeValue(pAttributeName:String):Any updating;

vars

	attribute:CnLdapAttribute;
	value:Any;

begin

	/* Returns the first value of the attribute named in the parameter.
	Caution: this only returns the FIRST attribute value. There may be several. This is only useful when you know the attribute
	only has one value.*/

	if pAttributeName = null then
 		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
 							 "Invalid Attribute Name",
 							 "The attribute name supplied with " & method.name & " is a null value");
 	endif;

	attribute := allAttributes.getAtKey(pAttributeName);	//Dictionary is case-insensitive
	if attribute = null then
		return null;
	endif;
	
	if attribute.allStringValues.size > 0 then
		return attribute.allStringValues[1];
	endif;
		
	if attribute.allBinaryValues.size > 0 then
		return attribute.allBinaryValues[1].binaryValue;
	endif;

	return null;
end;
}
cnGetNextAttribute
{
cnGetNextAttribute(pAttribute:CnLdapAttribute output):Boolean updating;

// Returns the next attribute for this entry

vars

begin
	if self.iterator = null then
		self.iterator := self.allAttributes.createIterator();
	endif;

	return self.iterator.next(pAttribute);
end;
}
cnGetPreviousAttribute
{
cnGetPreviousAttribute(pAttribute:CnLdapAttribute output):Boolean updating;

// Returns the previous attribute for this entry

vars

begin
	if self.iterator = null then
		self.iterator := self.allAttributes.createIterator();
	endif;

	return self.iterator.back(pAttribute);
end;
}
cnHasAttribute
{
cnHasAttribute(pAttributeName:String):Boolean;

vars

begin

	return allAttributes[pAttributeName] <> null;	//Dictionary is case-insensitive

end;
}
cnModifyAttribute
{
cnModifyAttribute(pAttributeName:String; pValue:Any; pOp:Integer) updating;

// When performing an LDAP_MOD_REPLACE after reading an entry from ldap you should call cnClearAttribute
// first to clear any currently held, otherwise this method will append to any existing attribute values.
//V2 21.01.2000 Changes for case sensitivity 

constants

	BitMask = 3;
vars

	attribute:CnLdapAttribute;
	ldapBinary:CnLdapBinary;
	opCode:Integer;
	value:Any;
	attributeName:String;	//V2

begin

	if pAttributeName = null then
 		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
 							 "Invalid Attribute Name",
 							 "The attribute name supplied with " & method.name & " is a null value");
 	endif;

 	if pOp <> LDAP_MOD_ADD and pOp <> LDAP_MOD_DELETE and pOp <> LDAP_MOD_REPLACE then
 		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
 							 "Invalid Modify Operation",
 							 "The modify operator supplied with " & method.name & " is invalid");
 	endif;

    value := pValue;
    opCode := pOp;
    attributeName := pAttributeName.toLower;		//V2

	/*For any one attribute, we create a new attribute object for each type of modify request. 
	For example, if the user is adding, replacing and deleting values for "jpegphoto", then three attribute 
	objects are created for "jpegphoto", and all the values to be added are associated with the object that has the LDAP_MOD_ADD
	modifyOperator.*/  

	foreach attribute in self.allAttributes where attribute.name.toLower = attributeName do	//V2
		if attribute.modifyOperator.bitAnd(BitMask) = pOp then		//Binary attributes have 128 ORd into the modifyOperator: remove it before comparison
			break;
		else
			attribute := null;
		endif;
	endforeach;

	if attribute = null or attribute.name.toLower <> attributeName then	//V2 No object exists for this attribute: so create it
		create attribute;
		attribute.cnSetName(pAttributeName);						//Preserve case when setting name
		attribute.cnSetMyEntry(self);
	endif;	

	//Attributes must be supplied in the format that corresponds to their 'syntax' attribute.
	if value <> null then
		if (attribute.syntax = "bin") and (not value.isKindOf(Binary)) or
			(not attribute.syntax = "bin") and value.isKindOf(Binary) 	then
			cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
 							 "Invalid Modify Operation",
 							 "The " & attribute.name & " data type is incompatible with syntax " & attribute.syntax);
 		endif;					 
 	endif;

	//The dll needs to know whether to delete string or binary values, so if syntax is "bin", we OR the LDAP_MOD_BVALUES
	//bit into the opCode.

	if value <> null or
		(value.isKindOf(String) and value.String = '') or
		(value.isKindOf(Binary) and value.Binary = null) then

			if value = null then
				if attribute.syntax <> "bin" then
					value := "";
				endif;
			endif;			

			if attribute.syntax <> "bin" then
				attribute.allStringValues.add(value.String);
			else
				create ldapBinary;
				ldapBinary.cnSetBinaryValue(value.Binary);
				ldapBinary.cnSetMyAttribute(attribute);
			endif;	
	endif;

	if attribute.syntax = "bin" then
		opCode := opCode.bitOr(LDAP_MOD_BVALUES);
	endif;	

	attribute.cnSetModifyOperator(opCode);

end;
}
cnResetIterator
{
cnResetIterator() updating;

vars

begin
	if self.iterator = null then
		self.iterator := self.allAttributes.createIterator();
	endif;

	self.iterator.reset();

end;
}
cnSetDn
{
cnSetDn(pDn:String) updating;

vars

begin

	dn := pDn;

end;
}
cnSetMyReadAsyncSearchObject
{
cnSetMyReadAsyncSearchObject(pSearch:CnLdapSearch) updating;

vars

begin

	myReadAsyncSearchObject := pSearch;

end;
}
cnSetMySearchObject
{
cnSetMySearchObject(pSearch:CnLdapSearch) updating;

vars

begin
	mySearchObject := pSearch;
end;
}
delete
{
delete() updating;

vars
	cc 	: CnCntrl;
begin
	self.allAttributes.purge();
	delete self.iterator;
end;
}
	)
	CnLdapSearch (
	jadeMethodSources
cnGetEntry
{
cnGetEntry(pDn:String):CnLdapEntry;

// Returns an entry object based on its DN

vars
	entry	: CnLdapEntry;
begin
	foreach entry in self.allEntries do
		if entry.dn = pDn then
			return entry;
		endif;
	endforeach;
	
	return null;
end;
}
cnGetNextEntry
{
cnGetNextEntry(pEntry:CnLdapEntry output):Boolean updating;

vars

begin
	if self.iterator = null then
		self.iterator := self.allEntries.createIterator;
	endif;

	return self.iterator.next(pEntry);
end;
}
cnGetPreviousEntry
{
cnGetPreviousEntry(pEntry:CnLdapEntry output):Boolean updating;

vars

begin
	if self.iterator = null then
		self.iterator := self.allEntries.createIterator;
	endif;

	return self.iterator.back(pEntry);
end;
}
cnResetIterator
{
cnResetIterator() updating;

vars

begin
	if self.iterator = null then
		self.iterator := self.allEntries.createIterator();
	endif;

	self.iterator.reset();
end;
}
cnSetAsyncPollTimeout
{
cnSetAsyncPollTimeout(pTimeout:Integer) updating;

vars

begin

	asyncPollTimeout := pTimeout;

end;
}
cnSetAsyncRetrievalType
{
cnSetAsyncRetrievalType(pType:Integer) updating;

vars

begin

	asyncRetrievalType := pType;

end;
}
cnSetAttrsOnly
{
cnSetAttrsOnly(pAttrsOnly:Integer) updating;

vars

begin

	attrsOnly := pAttrsOnly;

end;
}
cnSetEntryCount
{
cnSetEntryCount(pEntryCount:Integer) updating;

vars

begin

	entryCount := entryCount + pEntryCount;

end;
}
cnSetMsgID
{
cnSetMsgID(pID:Integer) updating;

vars

begin

	msgID := pID;

end;
}
cnSetMyLdapConnection
{
cnSetMyLdapConnection(pLdapConnection:CnLdapConnection) updating;

vars

begin

	myLdapConnection := pLdapConnection;	

end;
}
delete
{
delete() updating;

vars

begin
	delete self.iterator;
end;
}
	)
	CnLdapSyntax (
	jadeMethodSources
cnGetSyntax
{
cnGetSyntax(pAttributeName:String):String;

vars

	syntaxPos:Integer;

begin

	syntaxPos := attributeNameList.indexOf(pAttributeName.toLower);
	if syntaxPos > 0 then
		return attributeSyntaxList[syntaxPos];
	else
		return null;
	endif;		 

end;
}
cnModify
{
cnModify(pAttributeName:String; pSyntax:String) updating;
//V2 21.01.2000 Force syntax to lower case
vars

	syntaxPos:Integer;
	attributeName, syntax:String; 			//V2

begin

	if pAttributeName = null then
		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR, "Attribute name empty in " & method.getName, "Attribute name required");
	endif;

	if pSyntax.length = 0 then
		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR, "Syntax string empty in " & method.getName, "Attribute Syntax type must be a string between 1 and 3 characters in length");
	endif;

	if pSyntax.length > 3 then
		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR, "String " & pSyntax & " too long", "Attribute Syntax type must not be longer than three characters");
	endif;

	attributeName := pAttributeName.toLower;		//V2
	syntax := pSyntax.toLower;						//V2
	syntaxPos := attributeNameList.indexOf(attributeName);	//V2
	if syntaxPos > 0 then
		attributeSyntaxList[syntaxPos] := syntax;	//V2
	else
		attributeNameList.add(attributeName);		//V2
		attributeSyntaxList.add(syntax);			//V2	
	endif;	

end;
}
cnRemove
{
cnRemove(pAttributeName:String) updating;

vars

	syntaxPos:Integer;

begin

	if pAttributeName = null then
		cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR, "Attribute name empty in " & method.getName, "Attribute name required");
	endif;

	syntaxPos := attributeNameList.indexOf(pAttributeName.toLower);
	if syntaxPos > 0 then
		attributeNameList.removeAt(syntaxPos);		//Delete the name
		attributeSyntaxList.removeAt(syntaxPos);	//Delete the syntax type
	endif;	

end;
}
create
{
create() updating;
//V2 21.01.2000 Set reference to new syntax object in app.myCnLdapSyntax. We no longer use firstProcessTransientInstance.
vars


begin

	//Any attributes added to this list must be in lower-case
	attributeNameList.add("jpegphoto");
	attributeSyntaxList.add("bin");
	attributeNameList.add("audio");
	attributeSyntaxList.add("bin");
	attributeNameList.add("userpassword");
	attributeSyntaxList.add("bin");

	/* Set the app.myCnLdapSyntax ref to point to this new CnLdapSyntax object.
	  If a CnLdapSyntax object was created previously (and therefore referenced by app.myCnLdapSyntax),
	  it will no longer be referenced by app.myCnLdapSyntax, but it is not deleted. */

	app.myCnLdapSyntax := self;				//V2
end;
}
	)
	CnLdapURL (
	jadeMethodSources
cnClearSearchAttributes
{
cnClearSearchAttributes() updating;

vars

begin

		self.searchAttributeList.clear;

end;
}
cnDecodeURL
{
cnDecodeURL() updating;

// Takes the url property of this object, decodes it into its components, and writes them to the remaining properties
vars

	result:Integer;

begin

	result := cnEURLCheck(url);		//Check that URL is an LDAP URL
	if result.Boolean = false then
 		cnRaiseLdapException(CN_LDAP_INVALID_URL, "Invalid LDAP URL", "The URL supplied to " & method.name & " is not a valid LDAP URL");
 	endif;

 	result := cnEURLParse(url, host, port, baseDn, searchAttributeList, scope, filter, ssl);
 	if result <> LDAP_SUCCESS then
 		if self.errorCode = CN_LDAP_URL_ERR_NOTLDAP then
 			self.errorString := 'URL does not begin with "ldap://"';
 		elseif self.errorCode = CN_LDAP_URL_ERR_NODN then
 			self.errorString := 'URL has no DN (required)';
 		elseif self.errorCode = CN_LDAP_URL_ERR_BADSCOPE then
 			self.errorString := 'URL scope string is invalid';
 		elseif self.errorCode = CN_LDAP_URL_ERR_MEM then
 			self.errorString := 'Cannot allocate memory space';
 		elseif self.errorCode = CN_LDAP_URL_ERR_PARAM then
 			self.errorString := 'Bad parameter to an URL function';
 		endif;		
 		cnRaiseLdapException(CN_LDAP_URL_ERROR_BASE + self.errorCode, "URL Parse Failed", self.errorString);
 	endif;

 	/*API does not set default port if left unspecified in URL (although it does set a default filter of objectclass=*).
 	We'll set the default port ourselves. */
 	if self.port = 0 then
 		if ssl = 0 then
 			self.cnSetPort(LDAP_PORT);
 		elseif ssl = SSL_SERVER_AUTH then
 			self.cnSetPort(LDAPS_PORT);
 		endif;
 	endif;				

end;
}
cnEncodeURL
{
cnEncodeURL() updating;

// Generates a URL string from the object properties

vars

	i:Integer;
	urlString:String;
	filterString:String;
	scopeString:String;
	attributeString:String;

begin

	urlString := "ldap";
	if ssl = SSL_SERVER_AUTH then
		urlString := urlString & "s";
	endif;

	urlString := urlString & "://";
	urlString := urlString & host;
	if port <> 0 and 
		((ssl = 0 and port <> LDAP_PORT) or (ssl = SSL_SERVER_AUTH and port <> LDAPS_PORT)) then
		urlString := urlString & ":" & port.String;
	endif;
	urlString := urlString & "/" & baseDn;

	if filter <> null then
		filterString := "?" & filter;
		scopeString := "?";
		attributeString := "?";
	endif;

	if scope <> 0 then
		scopeString := "?" & cnGetScopeText(scope);
		attributeString := "?";
	endif;

	if not searchAttributeList.isEmpty() then						
		i := 1;
		attributeString := "?";
		while i <= searchAttributeList.size do
			attributeString := attributeString & searchAttributeList[i];
			if i < searchAttributeList.size then
				attributeString := attributeString & ",";
			endif;
			i := i + 1;
		endwhile;
	endif;

	urlString := urlString & attributeString & scopeString & filterString;
	cnSetURL(urlString);																									

end;
}
cnGetScopeText
{
cnGetScopeText(pScope:Integer):String;

vars

begin

	if pScope = 0 then
		return "base";
	elseif pScope = 1 then
		return "one";
	elseif pScope = 2 then
		return "sub";
	endif;			

end;
}
cnRemoveSearchAttribute
{
cnRemoveSearchAttribute(pAttribute:String) updating;

vars

	i:Integer;

begin

	i := self.searchAttributeList.indexOf(pAttribute);
	if i > 0 then
		self.searchAttributeList.removeAt(i);
	endif;	

end;
}
cnSetBaseDn
{
cnSetBaseDn(pBaseDn:String) updating;

vars

begin

	baseDn := pBaseDn;

end;
}
cnSetFilter
{
cnSetFilter(pFilter:String) updating;

vars

begin

	filter := pFilter;

end;
}
cnSetHost
{
cnSetHost(pHost:String) updating;

vars

begin

	host := pHost;

end;
}
cnSetPort
{
cnSetPort(pPort:Integer) updating;

vars

begin

	port := pPort;

end;
}
cnSetScope
{
cnSetScope(pScope:Integer) updating;

vars

begin

	scope := pScope;

end;
}
cnSetSearchAttribute
{
cnSetSearchAttribute(pAttribute:String) updating;

vars

begin

		self.searchAttributeList.add(pAttribute.toLower);

end;
}
cnSetSearchAttributes
{
cnSetSearchAttributes(pAttributes:String; pDelimiters:String) updating;

constants

	Space = " ";

vars

	stripSpaces:Boolean;
	sa:CnStringArray;
	reply:Integer;
    copyString,s:String;

begin

    if pAttributes.length > 0 then
    	create sa transient;
    	copyString := pAttributes;
    	if pDelimiters.pos(Space,1) = 0 then
    		stripSpaces := true;
    	else
    		stripSpaces := false;
    	endif;		
    	reply := copyString.cnUnbust(pDelimiters, sa, stripSpaces);

        if reply <> 0 then
 			cnRaiseLdapException(CN_LDAP_PARAMETER_ERROR,
 							 "Invalid Parameter",
 							 "One of the parameters supplied to " & method.name & " is invalid");
 		endif;

    	foreach s in sa do
			self.searchAttributeList.add(s.toLower);
		endforeach;
		delete sa;
 	endif;

end;
}
cnSetSsl
{
cnSetSsl(pSsl:Integer) updating;

vars

begin

	ssl := pSsl;

end;
}
cnSetURL
{
cnSetURL(pUrl:String) updating;

vars

begin

	url := pUrl;

end;
}
create
{
create() updating;

vars

begin

	create searchAttributeList transient;

end;
}
delete
{
delete() updating;

vars

begin

	delete searchAttributeList;

end;
}
	externalMethodSources
cnEURLCheck
{
cnEURLCheck(url: String): Integer is "cn_ldap_is_ldap_url" in "cnldap" number = 1017;
}
cnEURLParse
{
cnEURLParse(
			pUrl: String; 
			rHost: String io; 
			rPort: Integer io; 
			rDn: String io; 
			rSearchAttributeList: CnStringArray io; 
			rScope: Integer io; 
			rFilter: String io; 
			rOptions: Integer io): Integer is "cn_ldap_url_parse" in "cnldap" updating, number = 1018;
}
	)
	CnMIME (
	jadeMethodSources
deleteFileObject
{
deleteFileObject() updating;

vars
	objDeleted	: Boolean;
begin
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectDeleted, self.fileObject, objDeleted);
	delete self.fileObject;

end;
}
setContentType
{
setContentType(pContentType: String) updating;

vars

begin

	contentType := pContentType;

end;
}
setFileObject
{
setFileObject(pFile: File) updating;

vars

begin

	fileObject := pFile;

end;
}
	)
	CnSmtpInline (
	jadeMethodSources
create
{
create() updating;

vars

begin

	htmlEmbedType	:=	IMG;	//Default is IMG (image)

end;
}
	)
	CnMachine (
	jadeMethodSources
setClientFQDN
{
setClientFQDN(fqdn : String) updating;

vars

begin
 	self.clientFQDN := fqdn;
end;
}
setCurrentClientVersions
{
setCurrentClientVersions(schemaver, binver, miscver : TimeStamp) updating;

vars

begin
	self.currentClientSchemaVersion := schemaver;
	self.currentClientBinVersion	:= binver;
	self.currentClientMiscVersion	:= miscver;
end;
}
setIpAddress
{
setIpAddress(ipaddr : String) updating;

vars

begin
 	self.ipAddress := ipaddr;
end;
}
setIsActive
{
setIsActive(set : Boolean) updating;

vars

begin
 	self.isActive := set;
end;
}
setMyKarmaCntrl
{
setMyKarmaCntrl(kc : CnKarmaCntrl) updating;

vars

begin
 	self.myKarmaCntrl := kc;
end;
}
setNextClientVersions
{
setNextClientVersions(schemaver, binver, miscver : TimeStamp) updating;

vars

begin
	self.nextClientSchemaVersion 	:= schemaver;
	self.nextClientBinVersion		:= binver;
	self.nextClientMiscVersion		:= miscver;
end;
}
	)
	CnMessage (
	jadeMethodSources
assembleMsg
{
assembleMsg() : Binary updating;

vars
	bin 			: Binary;
	
	cc				: CnCntrl;
	
	pv				: Integer;
	
	processAppName	: String;
begin
	cc	:= app.myCnCntrl;
	processAppName := cc.appName;
	cc.cnWriteLog(cc.CnLogMsgAssemble, method.cnGetMethodName() & " : Protocol version=" & protocolVersion.String & 			// PAR 6782
															", architecture=" & architectureRemote.String &
															", msgType=" & msgType &
															", msgClass=" & msgClass, null); 
	
	if self.protocolVersion > 12 then
		bin	:= protocolVersion.setByteOrderRemote(0).Binary;		// network byte order
	else
		bin	:= protocolVersion.Binary;
	endif;
	
	bin	:= bin 									&	
		   cnAnsiBinary(msgType)				&
		   cnAnsiBinary(msgClass.padBlanks(8))	;

	if self.protocolVersion > 12 then
		bin	:= bin & architectureRemote.setByteOrderRemote(0).Binary;
	endif;
			
	bin	:=  bin 										&		
			msgNo.Binary								&
			cnAnsiBinary(sourceProcessType.padBlanks(3))&
			cnAnsiBinary(destProcessType.padBlanks(3));
			
	if self.protocolVersion > 22 then										// 3.7 
		bin :=	bin											&				// 3.7 
				appName.length().Binary						&				// 3.7 
				cnAnsiBinary(appName)						&				// 3.7 
				appSchemaName.length().Binary				&				// 3.7 
				cnAnsiBinary(appSchemaName)					&				// 3.7 
				managedEnvironmentName.length().Binary		&				// 3.7 
				cnAnsiBinary(managedEnvironmentName)		&				// 3.7 
				environmentId.length().Binary				&				// 3.7 
				cnAnsiBinary(environmentId)					&				// 3.7 
				cnAnsiBinary(driveLetter.padBlanks(1))		&				// 3.7 
				clientIpAddress.length().Binary				&				// 3.7 
				cnAnsiBinary(clientIpAddress);								// 3.7 

	else
		bin := bin &
				cnAnsiBinary(appName.padBlanks(30));
		if self.protocolVersion > 19 then
			bin := bin & 
					cnAnsiBinary(appSchemaName.padBlanks(30));
		endif;
		
		bin := bin & 
				cnAnsiBinary(managedEnvironmentName.padBlanks(30))		&
				cnAnsiBinary(environmentId.padBlanks(9))	&
				cnAnsiBinary(driveLetter.padBlanks(1))		&
				cnAnsiBinary(clientIpAddress.padBlanks(15));
	endif;
	
	if self.protocolVersion < 3 or
	  (self.isKindOf(CnCommand) and
	   app.cnSystemType = CN_SYSTEMTYPE_JSM and
	   processAppName <> CN_JOSSCOMMSMGR		and
	   processAppName <> "JossFileTransferMgr"	and							// 2.9
	   processAppName <> "JossMessageHandler1"  and
	   msgClass       <> "SCRPTCMD"				and
	   msgClass		  <> "TASKCMD")				then						// any thread that assembles the binary for transmission to JSA must be listed here
		if self.protocolVersion > 22 then
			bin :=	bin									&					// 3.7 
					serverHostIpAddress.length().Binary	&					// 3.7 
					cnAnsiBinary(serverHostIpAddress);						// 3.7 
					
		else
			bin := bin & cnAnsiBinary(serverHostIpAddress.padBlanks(15));
		endif;
	endif;

	if self.protocolVersion > 22 then										// 3.7
		bin := bin 										&					// 3.7
				clientFQDN.length().Binary				&					// 3.7
				cnAnsiBinary(clientFQDN);									// 3.7

	else
		bin := bin & cnAnsiBinary(clientFQDN.padBlanks(64));
	endif;

	if self.protocolVersion < 3	or
	   self.protocolVersion > 8 or			// re-activated use in 2.7
	  (self.isKindOf(CnCommand) 			and
	   app.cnSystemType = CN_SYSTEMTYPE_JSM and 
	   processAppName <> CN_JOSSCOMMSMGR)			then
		if self.protocolVersion > 22 then										// 3.7
			bin := bin 										&					// 3.7
					serverHostFQDN.length().Binary			&					// 3.7
					cnAnsiBinary(serverHostFQDN);								// 3.7
	
		else
			bin := bin & cnAnsiBinary(serverHostFQDN.padBlanks(64));
		endif;
	endif;

	bin :=	bin 									&
			processId.Binary 						&
			cnAnsiBinary(msgParam1.padBlanks(2))	&
			cnAnsiBinary(msgParam2.padBlanks(2))	&
			cnAnsiBinary(msgParam3.padBlanks(2))	&
			cnAnsiBinary(notFinalBlock.Character);
	if self.protocolVersion > 29 then											// 3.8.04
		// change 'errorCode' from two byte string to Integer					// 3.8.04
		bin	:= bin &															// 3.8.04
				self.errorCode.Binary;											// 3.8.04
				
	else																		// 3.8.04
		bin := bin &															// 3.8.04
			cnAnsiBinary(self.errorCode.String[1:2].padBlanks(2));				// 3.8.04
	endif;																		// 3.8.04
			
 	if self.protocolVersion > 10 then			// 2.8
 		bin	:= bin & cnAnsiBinary(self.computerName.padBlanks(20));
 	endif;

	return bin;
epilog
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " bin.length=" & bin.length().String, null);
end;
}
attachField
{
attachField(bin : Binary io; field : Binary);

vars
	cc		: CnCntrl;
 	
	len,
	posn 	: Integer;
begin
	cc		:= app.myCnCntrl;
	posn 	:= bin.length + 1;
	len		:= field.length();
	bin[posn : len] := field;
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " [" & posn.String & ":" & len.String & "] " & field.String, null);
end;
}
buildHeader
{
buildHeader(msgtype 			: String;
		    msgclass 			: String;
		    serverhostfqdn 		: String; 
		    clientfqdn 			: String;
		    clientipaddress		: String; 
		    sourceprocesstype 	: String;
		    destprocesstype		: String; 
		    msg 				: CnMessage output ) : String updating;

vars
	class 	: Class;
	cc 		: CnCntrl;
	kc		: CnKarmaCntrl;
	cname	: String;
	maxlen	: Integer;
begin
	if msgtype <> "A" and
 	   msgtype <> "C" and
 	   msgtype <> "M" then
 	   	return "Invalid value specified for msgType in " & method.cnGetMethodName();
 	endif;

	cc	:= app.myCnCntrl;
    kc  := app.myCnKarmaCntrl;
	
//  class	:= currentSchema.getClass(getClassName(msgtype, msgclass));
    class	:= kc.getMessageClass(self.getClassName(msgtype, msgclass));
    if class = null then
		return "Unknown message class in " & method.cnGetMethodName() & ", type=" & msgtype & ", name=" & msgclass;
	endif;
	
    create msg as class;
    msg.msgType 			:= msgtype;
    msg.msgClass 			:= msgclass;
    //
    // -----------------  Message Protocol Version  --------------------------------------
    //
   	msg.setProtocolVersion(Current_Protocol_Version);			// default, may be adjusted by subclasses or subschemas
   	//
   	//	See text for Current_Protocol_Version for history
   	//
   	// -----------------------------------------------------------------------------------
   	//
    msg.msgNo 				:= 1;								// no use made of this
    msg.architectureRemote	:= app.cnOSArchitecture;
    msg.notFinalBlock 		:= false;
	msg.serverHostFQDN		:= serverhostfqdn;    
    msg.clientIpAddress 	:= clientipaddress;
    msg.clientFQDN			:= clientfqdn.toLower;
    msg.sourceProcessType	:= sourceprocesstype;
    msg.destProcessType		:= destprocesstype;
    msg.driveLetter			:= kc.driveLetter;
	cname					:= app.cnComputerNameAppServer;
	maxlen					:= msg.computerName.maxLength;
	
	if cname.length > maxlen then						// patch for 'unobtainable' computer name scenario
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " got overlength computerName '" & cname & "' : will be truncated.", null);
		msg.computerName	:= cname[1 : maxlen];
		
	else
		msg.computerName	:= cname;
	endif;
	
	if app.cnAppAlias <> null then
		msg.appName			:= app.cnAppAlias;
		
	else
	    msg.appName 		:= cc.appName;
	endif;
	
	msg.appSchemaName	:= cc.appSchemaName;
	msg.environmentId	:= kc.masterEnvironmentId[1:Cn_Max_EnvironmentName_Length];												// JSM PAR 7586
    return CN_OK;
end;
}
buildMsg
{
buildMsg() : String updating;

vars

begin
	return CN_OK;					
end;
}
byteOrderDate
{
byteOrderDate(bin : Binary) : Date;

vars
	
begin
	if app.cnOSArchitecture = architectureRemote then
		return bin.Date;
	else 
		return bin.Date.setByteOrderLocal(architectureRemote);
	endif;	
end;
}
byteOrderDecimal
{
byteOrderDecimal(bin : Binary) : Decimal;

vars
	
begin
	if app.cnOSArchitecture = architectureRemote then
		return bin.Decimal;
	endif;

	return bin.Decimal.setByteOrderLocal(architectureRemote);
end;
}
byteOrderInteger
{
byteOrderInteger(bin : Binary) : Integer;

vars

begin
	if app.cnOSArchitecture = architectureRemote then
		return bin.Integer;
	else 
		return bin.Integer.setByteOrderLocal(architectureRemote);
	endif;	
end;
}
byteOrderInteger64
{
byteOrderInteger64(bin : Binary) : Integer64;

vars

begin
	if app.cnOSArchitecture = architectureRemote then
		return bin.Integer64;
	else 
		return bin.Integer64.setByteOrderLocal(architectureRemote);
	endif;	
end;
}
byteOrderReal
{
byteOrderReal(bin : Binary) : Real;

vars
	
begin
	if app.cnOSArchitecture = architectureRemote then
		return bin.Real;
	else 
		return bin.Real.setByteOrderLocal(architectureRemote);
	endif;	
end;
}
byteOrderTime
{
byteOrderTime(bin : Binary) : Time;

vars
	
begin
	if app.cnOSArchitecture = architectureRemote then
		return bin.Time;
	else 
		return bin.Time.setByteOrderLocal(architectureRemote);
	endif;	
end;
}
byteOrderTimeStamp
{
byteOrderTimeStamp(bin : Binary) : TimeStamp;

vars
	
begin
	if app.cnOSArchitecture = architectureRemote then
		return bin.TimeStamp;
	else 
		return bin.TimeStamp.setByteOrderLocal(architectureRemote);
	endif;	
end;
}
createNewMsg
{
createNewMsg(msgtype 	: String;
             msgclass 	: String;
             clientfqdn : String;
             clientipaddress 	: String;
             sourceprocesstype 	: String;
             destprocesstype	: String;
             msg : CnMessage output ) : String updating;

vars
	kc			: CnKarmaCntrl;

  	result 		: String;
begin
	kc	:= app.myCnKarmaCntrl;
	result := self.buildHeader(msgtype, msgclass, kc.localFQDN, clientfqdn, clientipaddress, sourceprocesstype, destprocesstype,msg);
	if result <> CN_OK then
		return result;
	endif;

    if not msg.isKindOf(CnSessionCloseAdvice) then 
	    msg.processId := app.cnGetInstanceId(process);	// get OID instance number as unique process id
	endif;

    msg.buildMsg();
    return CN_OK;
end;
}
forwardMsg
{
forwardMsg() updating;			

vars
 	cc			: CnCntrl;

 	kc			: CnKarmaCntrl;
 	
	cnmachine	: CnMachine;
 
	cnprocess 	: CnProcess;
	
	proc		: Process;

 	buf			: Binary;

	badObject,
 	fwd_done	: Boolean;
begin
    cc := app.myCnCntrl;
    kc := app.myCnKarmaCntrl;

	if self.msgType <> Command then
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & "  for non-Command : msg class was " & self.class.name, null);
		return;
	endif;
	
	//
	// we are passing message from KCCMgr to app client
	//
	cc.cnWriteLog(cc.CnLogTransmit, method.cnGetMethodName() & " command, clientFQDN=" & self.clientFQDN & 						// PAR 6782
														" destProcessType=" & self.destProcessType & 
														", dest app=" & self.appName & 
														", processId=" & self.processId.String, null);

	cnmachine := kc.allMachines[self.clientFQDN];
	if cnmachine = null then
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " couldn't find CnMachine for FQDN=" & self.clientFQDN &
															" - assume/try for localhost....", null);
		cnmachine := kc.allMachines['localhost'];
	endif;

	if cnmachine = null then
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " ERROR : couldn't find CnMachine for FQDN=" & self.clientFQDN, null);	
		return;
	endif;
	
	buf	:= self.assembleMsg;

	on SystemException do handleProcessException(exception);		// in case the process we are forwarding to
																	// has gone away
	if self.processId > null then
		cnprocess := cnmachine.allProcesses[self.processId];
		on SystemException do app.cnHandleNullOrInvObjectRef(exception, null, badObject);
		proc := cnprocess.myProcess;
		proc.edition;		// force reference to process object
		if not badObject then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " causing Cn_Message_To_Client event on process, id=" & self.processId.String, null);	// PAR 6782
			proc.causeEvent(Cn_Message_To_Client, true, buf);
			fwd_done := true;
		endif;
	endif;

	if not fwd_done then										// no process Id ? so broadcast it 
		foreach cnprocess in cnmachine.allProcesses do
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " broadcast causing Cn_Message_To_Client event on process, id=" & 						// PAR 6782
										cnGetInstanceId(cnprocess.myProcess).String, null);
			cnprocess.myProcess.causeEvent(Cn_Message_To_Client, true, buf);
		endforeach;
	endif;
end;
}
getCardSchemaProtocolVersion
{
getCardSchemaProtocolVersion(pVersion : String) : Integer;
/*
	This obtains the class constant text for Current_Protocol_Version and decomposes it looking
	for a match on the version detail input.
	
	This allows the constant to continue to be maintained as documentation but also be used
	to derive the protocol version for a specific CardSchema release.
*/
vars
	cls				: Class;
	
	constantDict	: ConstantNDict;
	
	constant		: Constant;	
	
	str,
	ver,
	versionInfo		: String;

	csVersion,
	inputVersion,
	len,
	pos,
	posEnd,
	posStart,
	pv				: Integer;
begin
	inputVersion := pVersion.cnMarkReleaseCut();
	cls := self.class();
	create constantDict transient;
	cls.getConstants(constantDict);
	constant := constantDict["Current_Protocol_Version"];
	if constant = null then
		app.cnRaiseNormalException(Cn_Edit_Error, "CnMessage.Current_Protocol_Version", "Constant Current_Protocol_Version expected", false);
		return null;
	endif;
	
	str := constant.text;
	pos := 1;
	pos := str.pos("<version>", pos);
	posStart := str.pos(CrLf, pos) + 2;
	posEnd   := str.pos("/version>", pos) - 1;
	versionInfo := str[posStart:posEnd-posStart];
	
	len := versionInfo.length();
	pos := 1;
	while pos <> null do
		pv := versionInfo.scanUntil(CN_SPACE, pos).Integer;
		versionInfo.scanWhile(CN_SPACE, pos);					// scan to hyphen
		versionInfo.scanUntil(CN_SPACE, pos); 					// scan over hyphen
		versionInfo.scanWhile(CN_SPACE, pos);					// scan to version
		ver := versionInfo.scanUntil(CN_SPACE & Tab, pos);		// scan past version
		versionInfo.scanUntil(CrLf, pos);						// scan to end of line
		versionInfo.scanUntil("0123456789", pos);				// scan to next numeric which should be protocol version or null
		csVersion := ver.cnMarkReleaseCut();
		if inputVersion >= csVersion then
			return pv;
		endif;
	endwhile;
	
	return null;
epilog
	delete constantDict;
end;
}
getClassName
{
getClassName(pMsgType : String; pMsgClass : String) : String;

vars
	cc : CnCntrl;
begin
	cc	:= app.myCnCntrl;
/*	self.zDebug(method, "pMsgType=" & pMsgType & ", pMsgClass=" & pMsgClass &
		", cnSystemType=" & app.cnSystemType.String &
		", currentSchema.name=" & currentSchema.name);
*/
	/////////////  Pinging stuff   ////////////////////////////////////////////////

	if pMsgType = Advice and pMsgClass = Ping_Reply then
		if cc.appName = CN_JOSSCOMMSMGR 	or 
		   cc.appName = CN_KARMACOMMSMGR	then
			return "PingReplyAdvice";
		endif;
		
		return CnPingReplyAdvice.name;
	endif;
	
	if pMsgType = Command and pMsgClass = Ping_Command then
		if cc.appName = CN_KARMACOMMSMGR 	or 
		   cc.appName = CN_JOSSCOMMSMGR 	then
			return "PingCmd";
		endif;	

		return CnPingCmd.name;
	endif; 
	
	if pMsgType = Command and pMsgClass = Control_Command then
		if cc.appName = CN_KARMACOMMSMGR 		or 
		   cc.appName = "KarmaInstallMgr" 		or
		   cc.appName = "KarmaBackupMgr"  		or 
		   cc.appName = CN_JOSSCOMMSMGR			or
		   cc.appName = "JossGeneralEventMgr"	then
			return "ControlCmd";
		else
			return CnControlCmd.name;
		endif;
	endif; 
	
	/////////////   Client application or KCCMgr   ////////////////////////////

	if  app.cnSystemType = 0 or 					// not JSM or JSA
		currentSchema.name = CN_CARDSCHEMA  then
		if pMsgType = Advice then
			if pMsgClass 	= Session_Open then
				return CnSessionOpenAdvice.name;
			elseif pMsgClass = Session_Close then
				return CnSessionCloseAdvice.name;
			elseif pMsgClass	= Schema_Copy_Complete then
				return CnSchemaCopyCompleteAdvice.name;
			elseif pMsgClass = Trap_Advice then
				return CnTrapAdvice.name;
			elseif pMsgClass = Statistics_Advice then
				return CnStatisticsAdvice.name;
			elseif pMsgClass = Backup_Advice then
				return CnBackupAdvice.name;
			elseif pMsgClass = Control_Advice then
				return CnControlAdvice.name;
			elseif pMsgClass = Exception_Advice then
				return CnExceptionAdvice.name;
			elseif pMsgClass = Node_Stats_Advice then
				return CnNodeStatsAdvice.name;
			elseif pMsgClass = SDS_Advice then
				return CnSDSAdvice.name;
			elseif pMsgClass = Compact_Advice then
				return CnCompactAdvice.name;
			elseif pMsgClass = File_Details_Advice then
				return CnFileDetailsAdvice.name;
			elseif pMsgClass = SSL_Advice then
				return CnSSLAdvice.name;
			elseif pMsgClass = Execute_Advice then
				return CnExecuteAdvice.name;
			endif;
		endif;	

		if pMsgType = Command then
			if pMsgClass		= Schema_Copy_Command then
				return CnSchemaCopyCmd.name;
			elseif pMsgClass = Backup_Command then
				return CnBackupCmd.name;
			elseif pMsgClass = SDS_Command then
				return CnSDSCmd.name;
			elseif pMsgClass = Compact_Command then
				return CnCompactCmd.name;
			elseif pMsgClass = Execute_Command then
				return CnExecuteCmd.name;
			endif;
		endif;

	else    /////////////////////  Karma / Joss  /////////////////////////////////
			// must define as literals below as classes are in sub-schema of CardSchema
	   if pMsgType = Advice then
	 		if pMsgClass = Session_Open then
	 			return "SessionOpenAdvice";
	 		elseif pMsgClass = Session_Close then
	 			return "SessionCloseAdvice";
	 		elseif pMsgClass = Server_Down then
	 			return "ServerDownAdvice";
	 		elseif pMsgClass = Schema_Copy_Complete then
				return "CnSchemaCopyCompleteAdvice";
			elseif pMsgClass = Trap_Advice then
				return "TrapAdvice" ;
			elseif pMsgClass = Watch_Advice then
			    return "WatchAdvice" ;
			elseif pMsgClass = Process_Advice then
				return "ProcAdvice" ;
			elseif pMsgClass = Thread_Advice then
				return "ThreadAdvice" ;
			elseif pMsgClass = Install_Advice then
				return "InstallAdvice";
			elseif pMsgClass = FTP_Progress_Advice then
				return "FtpProgressAdvice";
			elseif pMsgClass = Control_Advice then
				return "ControlAdvice";
			elseif pMsgClass = Karma_Control_Advice then
				return "KarmaControlAdvice";
			elseif pMsgClass = Statistics_Advice then
				return "StatisticsAdvice";
			elseif pMsgClass = Monitor_Advice then
				return "MonitorAdvice";
			elseif pMsgClass = Backup_Advice then
				return "BackupAdvice";
		    elseif pMsgClass = Exception_Advice then
		    	return "ExceptionAdvice";
		    elseif pMsgClass = Node_Stats_Advice then
		    	return "NodeStatsAdvice";
		    elseif pMsgClass = Restore_Advice then
		    	return "RestoreAdvice";
		    elseif pMsgClass = Restore_Refresh_Advice then
		    	return "RestoreRefreshAdvice";
		    elseif pMsgClass = Compact_Advice then
		    	return "CompactAdvice";
		    elseif pMsgClass = SDS_Advice then
		    	return "SDSAdvice";
		    elseif pMsgClass = JSA_File_Transfer_Advice then
		    	return "JSAFileTransferAdvice";
		    elseif pMsgClass = File_Details_Advice then
		    	return "FileDetailsAdvice";
		    elseif pMsgClass = SSL_Advice then
		    	return "SSLAdvice";
			elseif pMsgClass = ODBC_Advice then
				return "ODBCAdvice";
			elseif pMsgClass = Script_Advice then
				return "ScriptAdvice";
			elseif pMsgClass = Task_Advice then
				return "TaskAdvice";
			elseif pMsgClass = Discovery_Advice then
				return "DiscoveryAdvice";
			elseif pMsgClass = Application_Monitoring_Advice then
				return "ApplicationMonitoringAdvice";
	 		elseif pMsgClass = Advisory_Advice then																	// NFS 7414
				return "AdvisoryAdvice";																			// NFS 7414
			elseif pMsgClass = Execute_Advice then
				return"ExecuteAdvice";
			elseif pMsgClass = Windows_Update_Advice then
				return"WindowsUpdateAdvice";
			endif;

	 	elseif pMsgType = Command then
	 		if pMsgClass = Schema_Copy_Command then
	 			return "SchemaCopyCmd";
			elseif pMsgClass = Alert_Def_Command then
	 			return "AlertDefCmd" ;
	 		elseif pMsgClass = Alert_Ctl_Command then
	 			return "AlertCtlCmd" ;
	 		elseif pMsgClass = Watch_Command then
	 			return "WatchCmd" ;
	 		elseif pMsgClass = Process_Command then
	 			return "ProcCmd" ;
	 		elseif pMsgClass = Thread_Command then
	 			return "ThreadCmd" ;
	 		elseif pMsgClass = Install_Command then
	 			return "InstallCmd";
	 		elseif pMsgClass = Glb_Param_Cmd then
	 			return "GlbParamCmd";
	 		elseif pMsgClass = Karma_Control_Command then
	 			return "KarmaControlCmd";
	 		elseif pMsgClass = Monitor_Command then
	 			return "MonitorCmd";
	 		elseif pMsgClass = Backup_Command then
	 			return "BackupCmd";
		    elseif pMsgClass = Backup_Spec_Command then
		    	return "BackupSpecCmd";
		    elseif pMsgClass = Restore_Command then
		    	return "RestoreCmd";
		    elseif pMsgClass = Restore_Refresh_Command then
		    	return "RestoreRefreshCmd";
		    elseif pMsgClass = Compact_Command then
		    	return "CompactCmd";
		    elseif pMsgClass = SDS_Command then
		    	return "SDSCmd";
		    elseif pMsgClass = JSA_File_Transfer_Command then
		    	return "JSAFileTransferCmd";
		    elseif pMsgClass = File_Details_Command then
		    	return "FileDetailsCmd";
			elseif pMsgClass = ODBC_Command then
				return "ODBCCmd";
			elseif pMsgClass = Execute_Command then
				return "ExecuteCmd";
			elseif pMsgClass = Windows_Update_Command then
				return "WindowsUpdateCmd";
	 		endif;
	 	endif;
	endif;

    cc := app.myCnCntrl;
    cc.cnWriteLog(cc.CnLogProgramError, "<<<< PROGRAM ERROR : unknown msg class in CnMessage::getClassName : " &
    										 ", pMsgType=" & pMsgType & ", class=" &  pMsgClass & ", classlength=" & 
    										 pMsgClass.length.String, null);
	app.cnRaiseNormalException(Cn_Edit_Error,
								"MsG Type/Class",
								"Unknown msg class in " & method.cnGetMethodName() & " : , pMsgType=" & pMsgType & ", class=" &  pMsgClass,
								false);
end;
}
getField
{
getField(bin : Binary; len : Integer) : Binary updating;

vars
	cc		: CnCntrl;
	
	oldPos	: Integer;
	
 	b 		: Binary;
begin
//	cc		:= app.myCnCntrl;
	oldPos	:= pos;
	if len = null then
		return null;
	endif;
	
	
	b 		:= bin[pos:len];
	pos 	:= pos + len;
	return b;
//epilog
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " [" & oldPos.String & ":" & len.String & "] " & b.String, null);
end;
}
handleProcessException
{
handleProcessException(exObj : SystemException) : Integer;

vars
	cc : CnCntrl;
begin
	if exObj.errorCode = 4 and app.cnGetClassForObject(exObj.errorObject) = Process then
		cc := app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogErrors, "Object " & app.cnGetClassAndOid(exObj.errorObject) &
					  " is no longer valid : message forward will be aborted.", null);
		abortTransaction;
		return Ex_Abort_Action;

	else
		return Ex_Pass_Back;
	endif;		
end;
}
isKCCMgrToProcessMsg
{
isKCCMgrToProcessMsg(pClassMsg : Class) : Boolean;

vars
	cc		: CnCntrl;
begin
	cc		:= app.myCnCntrl;
	if cc.appName <> CN_KCCMGR then
		return false;
	endif;
	
	return (pClassMsg = CnPingCmd 	or
			pClassMsg = CnBackupCmd	or
			pClassMsg = CnControlCmd	or
			pClassMsg = CnSDSCmd 	or
			pClassMsg = CnCompactCmd or
			pClassMsg = CnExecuteCmd);
end;
}
loadMsg
{
loadMsg(buf : Binary) updating;

vars
	cc 			: CnCntrl;

	len,
	int,	
	tcpState	: Integer;
	
	badObject	: Boolean;
	
	env			: String;
begin
	cc 	:= app.myCnCntrl;
	pos := 1;
	self.protocolVersion	:= getField(buf, 4).Integer;
	if self.protocolVersion > 255 then													// indicates that bytes have been flipped to network byte order (bigendian)
		protocolVersion 	:= protocolVersion.setByteOrderLocal(0);					// 0 = network byte order
	endif;
	
	self.msgType			:= getField(buf, 1).ansiToString();
	self.msgClass			:= getField(buf, 8).ansiToString().trimRight();

	// from 3.7.03 we expect the release to always be protocol version 12 or later (CardSchema 3.0 or later)
	int					:= getField(buf, 4).Integer;
	architectureRemote	:= int.setByteOrderLocal(0);								//  Convert from network byte order
	cc.cnWriteLog(cc.CnLogMsgLoad, method.cnGetMethodName() & " protocolVersion=" & self.protocolVersion.String & 				// PAR 6782
														   ", msgType=" & self.msgType & 
														   ", msgClass=" & self.msgClass & 
														   ", oid=" & self.getObjectStringForObject(self) & 
														   ", int=" & int.String & 
														   ", archRemote=" & architectureRemote.String & 
														   ", local=" & app.cnOSArchitecture.String, null);
	self.msgNo				:= byteOrderInteger(getField(buf, 4));
	self.sourceProcessType	:= getField(buf, 3).ansiToString();
	self.destProcessType	:= getField(buf, 3).ansiToString();
	if self.protocolVersion > 22 then													// 3.7
		len 						:= byteOrderInteger(getField(buf, 4));					// 3.7
		self.appName				:= getField(buf, len).ansiToString();					// 3.7
		len 						:= byteOrderInteger(getField(buf, 4));					// 3.7
		self.appSchemaName			:= getField(buf, len).ansiToString();					// 3.7
		len 						:= byteOrderInteger(getField(buf, 4));					// 3.7
		self.managedEnvironmentName	:= getField(buf, len).ansiToString();					// 3.7
		len 						:= byteOrderInteger(getField(buf, 4));					// 3.7
		self.environmentId			:= getField(buf, len).ansiToString();					// 3.7
		self.driveLetter			:= getField(buf, 1).ansiToString();						// 3.7
		len 						:= byteOrderInteger(getField(buf, 4));					// 3.7
		self.clientIpAddress		:= getField(buf, len).ansiToString();					// 3.7 supports IPv6 addresses
		
	else
		self.appName				:= getField(buf, 30).ansiToString().trimRight();
		if self.protocolVersion > 19 then													// CardSchema 3.5 or later
			self.appSchemaName		:= getField(buf, 30).ansiToString().trimRight();
		
		else
			self.appSchemaName	:= null;
		endif;
		
		self.managedEnvironmentName	:= getField(buf, 30).ansiToString().trimRight();
		self.environmentId			:= getField(buf, 9).ansiToString().trimRight();
		self.driveLetter			:= getField(buf, 1).ansiToString();
		self.clientIpAddress		:= getField(buf, 15).ansiToString().trimRight();
	endif;
	
	if self.protocolVersion = 0 then
 		cc.cnWriteLog(cc.CnLogErrors, "WARNING >>>>>>>>> Message has no protocol version : " &
 		              			      "this can cause unexpected results <<<<<<<<", null);
 	endif;
	
	if self.isKindOf(CnBackupCmd) 		and 
	   cc.appName = CN_JOSSCOMMSMGR 	and 
	   cc.appName = self.appName	   	then
		self.pos := self.pos + 15;														// serverHostIpAddress de-implemented after version 1, in CardSchema v.2.1.01
		
	elseif self.isKindOf(CnCommand) 	and 
	   cc.appName = CN_JOSSCOMMSMGR 	and 
	   cc.appName <> self.appName 		then
		if self.protocolVersion > 22 then // release 3.7 or greater
			len := byteOrderInteger(getField(buf, 4));
			self.serverHostIpAddress := getField(buf, len).ansiToString();				// 3.7 supports IPv6 addresses
			
		else
			self.serverHostIpAddress := getField(buf, 15).ansiToString().trimRight();
		endif;
	endif;

	if self.protocolVersion > 22 then													// 3.7
		len 				:= byteOrderInteger(getField(buf, 4));						// 3.7
		self.clientFQDN		:= getField(buf, len).ansiToString().toLower();				// 3.7
		
	else
		self.clientFQDN			:= getField(buf, 64).ansiToString().trimRight().toLower();
	endif;

	if self.isKindOf(CnBackupCmd) 		and 
	   cc.appName = CN_JOSSCOMMSMGR 	and 
	   cc.appName = self.appName		then		
		self.pos := self.pos + 64;														// serverHostFQDN de-implemented after version 1, in CardSchema v.2.1.01
																						// but reimplemented in CardSchema 2.7.07 for protocol version 9
	
	elseif self.protocolVersion > 8 	or
	    (self.isKindOf(CnCommand) 		and 
		 cc.appName = CN_JOSSCOMMSMGR 	and 
		 cc.appName <> self.appName)	then
		if self.protocolVersion > 22 then												// 3.7
			len 				:= byteOrderInteger(getField(buf, 4));					// 3.7
			self.serverHostFQDN	:= getField(buf, len).ansiToString();					// 3.7
			
		else
			self.serverHostFQDN := getField(buf, 64).ansiToString().trimRight();
		endif;
	endif;

	// as from CardSchema 3.7.03, disallow messaging from CardSchema releases prior to 3.3
	if app.name[1:4] = CN_JOSS then
		env := "JSM";
	
	else
		env := "JSA";
	endif;
	
 	if self.protocolVersion < 17 then													// before 3.3 CardSchema
		app.cnRaiseJossAlert(Cn_Karma_Alert,
							"Received message with illegal protocol version from " & self.environmentId,
							env & " received message from " & self.environmentId & " application " & self.appName & 
							" which contained a protocol version less than " & env & " can handle." & CrLf &
							"This usually indicates that a early version of CardSchema is in-use " &
							" which is not supported by this release of " & env & "." & CrLf & 
							env & " protocol version = " & self.Current_Protocol_Version.String & CrLf &
							self.environmentId & " protocol version = " & self.protocolVersion.String & CrLf & CrLf &
							"Suggested action: Load a CardSchema release compatible with JSM / JSA",
							"N",
							app.actualTime(),
							self.appName,
							self.managedEnvironmentName,																		// JSM PAR 8367
							self.clientFQDN,
							self.clientIpAddress,
							self.myTcp.CnKarmaTcpConnection);
 		app.cnRaiseNormalException(Cn_General_Error, 
									method.cnGetMethodName(), 
									"Received message has illegal protocol version " & self.protocolVersion.String & " from " & self.environmentId, 
									false);
	endif;

 	if self.protocolVersion > self.Current_Protocol_Version then
		app.cnRaiseJossAlert(Cn_Karma_Alert,											// PAR 414 - issue alert and then dump
							"Received message with illegal protocol version from " & self.environmentId,
							env & " received message from " & self.environmentId & " application " & self.appName & 
							" which contained a protocol version greater than " & env & " can handle." & CrLf &
							"This usually indicates that a later version of CardSchema is in-use " &
							" which is not supported by this release of " & env & "." & CrLf & 
							env & " protocol version = " & self.Current_Protocol_Version.String & CrLf &
							self.environmentId & " protocol version = " & self.protocolVersion.String & CrLf & CrLf &
							"Suggested action: Upgrade JSM / JSA or load CardSchema release compatible with JSM / JSA",
							"N",
							app.actualTime(),
							self.appName,
							self.managedEnvironmentName,																		// JSM PAR 8367
							self.clientFQDN,
							self.clientIpAddress,
							self.myTcp.CnKarmaTcpConnection);
 		app.cnRaiseNormalException(Cn_General_Error, 
									method.cnGetMethodName(), 
									"Received message has illegal protocol version " & self.protocolVersion.String & " from " & self.environmentId, 
									false);
	endif;

	on SystemException do app.cnHandleNullOrInvObjectRef(exception, self.myTcp, badObject);
	tcpState := self.myTcp.state;
	
	if not badObject and self.myTcp.state = 2 then	// only update these properties if still connected (3.0 patch),
		//															// to avoid null serverHostFQDN when connection breaks after msg received
		// this following sequence was all revised for 2.7
		//
		self.serverHostIpAddress	:= self.myTcp.remoteIpAddress;
		if self.serverHostFQDN = null then
			if self.appName = CN_KARMACOMMSMGR then
				self.hostAlias 		:= self.clientFQDN;									// because in 2.6 serverFQDN is null
			endif;	
			
		else
			self.hostAlias			:= self.serverHostFQDN;	
		endif;		
		
		self.serverHostFQDN			:= self.myTcp.remoteName;
	endif;

	self.processId			:= byteOrderInteger(getField(buf, 4));
	self.msgParam1			:= getField(buf, 2).ansiToString().trimRight();
	self.msgParam2			:= getField(buf, 2).ansiToString().trimRight();
	self.msgParam3			:= getField(buf, 2).ansiToString().trimRight();
	self.notFinalBlock		:= getField(buf, 1).ansiToString().Character.Boolean;
	if self.protocolVersion > 29 then												// 3.8.04
		self.errorCode		:= byteOrderInteger(getField(buf, 4));					// 3.8.04
	
	else																			// 3.8.04
		self.errorCode		:= getField(buf, 2).ansiToString().trimRight().Integer;
	endif;																			// 3.8.04
	
 	if self.protocolVersion > 10 then	
 		computerName		:= getField(buf, 20).ansiToString().trimRight();
 	endif;
	
/*	self.zDebug(method, 
					"msgType=" & self.msgType &
					", msgClass= " & self.msgClass &
					", msgNo=" & self.msgNo.String &
					", sourceProcessType=" & self.sourceProcessType &
					", destProcessType=" & self.destProcessType &
					", appName=" & self.appName &
					", serverName=" & self.serverName &
					", environmentId=" & self.environmentId &
					", driveLetter=" & self.driveLetter &
					", clientIpAddress=" & self.clientIpAddress);
*/
epilog
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " end of method, pos=" & self.pos.String, null);
end;
}
processMsg
{
processMsg(proc : Process) : String updating;

vars
	cc : CnCntrl;
begin
 	return CN_OK;
end;
}
receiveMsg
{
receiveMsg(buf : Binary; proc : Process; eventType : Integer) updating;

vars
 	class,
	classMsg			: Class;

 	cc 					: CnCntrl;
 
	msg 				: CnMessage;
 	
	kc 					: CnKarmaCntrl;
 	
	tcp 				: CnKarmaTcpConnection;
 	
	processMsgRequired	: Boolean;
	
 	len,
 	sPos,
 	tag					: Integer;
	
 	fqdn,
 	ipAddress,
 	msgtype,
 	msgclass,
 	result,
 	shortFQDN			: String;
begin
	msgtype		:= buf[5:1].ansiToString;				// These MUST stay here.  New header attributes should
	msgclass	:= buf[6:8].ansiToString.trimRight;		// be added AFTER msgclass.

	cc := app.myCnCntrl;
	kc := app.myCnKarmaCntrl;

//	class := currentSchema.getClass(getClassName(msgtype, msgclass));		
	class := kc.getMessageClass(self.getClassName(msgtype, msgclass));		
	if class = null then                           	// shouldn't happen
		tag	:= cnStartTransaction(msgclass & "_<unknown>::" & method.name);
		cc.cnWriteLog(cc.CnLogProgramError, cc.appName & 
						   " encountered unknown message class in CnMessage::receiveMsg, class=" & msgclass, null);
		return;
	endif;
	
	if currentSchema.name = CN_JOSS then
		tag	:= cnStartTransaction(class.name & "::" & method.name);
	endif;
	
	create msg as class;
	msg.myTcp				:= self.myTcp;			
	msg.loadMsg(buf);

	///////////////  ADVICE i.e. msg from client or server to Joss  ////////////////

	if msgtype = Advice then

		if cc.appName = CN_JOSSCOMMSMGR and msg.myTcp <> null then		
			// 
			//  This is a message from outside Joss i.e. not a notification, so set up the
			//  originator id fields, partly overriding whatever the originator put in there. 
			//  The serverHostFQDN, IP address and hostAlias are set up already in ::loadMsg. 
			//
			ipAddress	:= msg.myTcp.remoteIpAddress;
			fqdn		:= msg.myTcp.remoteName;					// from DNS
			sPos		:= 1;
			shortFQDN	:= fqdn.scanUntil(CN_PERIOD, sPos).toLower;		
			len			:= shortFQDN.length;
			msg.setClientAlias(msg.clientFQDN);						// save client FQDN for Machine object's alias in JSM

			if msg.clientFQDN = msg.hostAlias 				or
			   msg.clientFQDN = null						or	
			   msg.clientFQDN[1 : len].toLower = shortFQDN 	then	// this message is from a client app running
				msg.setClientFQDN(fqdn);							// on the server machine.  Added for 2.7 to
				msg.setClientIpAddress(ipAddress);					// avoid duplicate Machine objects for serverhosts, 
			endif;													// when managed server has local DNS........RWM
		endif;				

		if eventType = Cn_Message_From_Client or cc.appName = CN_KARMACOMMSMGR then
			//  
			//  Fix up messages that arrived as notifications i.e. from clients : these may be incompletely formed
			//
			if cc.appName = CN_JOSSCOMMSMGR 	or 
			   cc.appName = CN_KARMACOMMSMGR 	or 
			   cc.appName = CN_KCCMGR 			then
				if cc.appName = CN_KARMACOMMSMGR then
					cc.cnWriteLog(cc.CnLogReceive, method.cnGetMethodName() & " msg.serverHostFQDN was " & msg.serverHostFQDN & ", is " & kc.localFQDN &		// PAR 6782
																	    ", msg.setServerHostIpAddress was " & msg.serverHostIpAddress & ", is " & kc.localIpAddress, null);
					msg.setServerHostFQDN(kc.localFQDN);		// gets changed to 'local' host while in KarmaCommsMgr
					msg.setServerHostIpAddress(kc.localIpAddress);
					
				elseif msg.serverHostFQDN = null 						or 
				   msg.serverHostFQDN.toLower()[1:9] = "localhost" 	then
					cc.cnWriteLog(cc.CnLogReceive, method.cnGetMethodName() & " msg.serverHostFQDN was " & msg.serverHostFQDN & ", is " & kc.localFQDN &		// PAR 6782
																	    ", msg.setServerHostIpAddress was " & msg.serverHostIpAddress & ", is " & kc.localIpAddress, null);
					msg.serverHostFQDN 		:= kc.localFQDN;	
					msg.serverHostIpAddress := kc.localIpAddress;      
				endif;														

				if msg.clientFQDN = "localhost" then
					msg.clientFQDN 		:= kc.localFQDN;
					msg.clientIpAddress := kc.localIpAddress;
				endif;

				if msg.managedEnvironmentName = null then
					msg.managedEnvironmentName := msg.environmentId;		// changed for 3.0
				endif;
			endif;

			if msg.appName = "KarmaInstallMgr" then					// don't process it .... just send it to Joss
				tcp := null;
				tcp := kc.myParentTcp;
				if tcp = null then
					cc.cnWriteLog(cc.CnLogDiag, "Had null parent tcp object ref in CnMessage::receiveMsg" &
								  " ... can't forward to Joss", null);	
					return;
				endif;

				msg.sendMessage(tcp);
				return;
			endif;
		endif; 
		
		//																////////////////////////////////////////
		result := msg.processMsg(proc);			//   < < < < < < <     	// <<< process the message, here ! <<<
		//																////////////////////////////////////////
		if result <> CN_OK then											// shouldn't happen
			cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " - transaction aborted : bad result from ::processMsg : " &
						  "class=" & msg.class.name & ", result=" & result, null);
			abortTransaction;
		endif;
		
		if cc.appName = CN_KCCMGR or (cc.appName = CN_KARMACOMMSMGR and msg.destProcessType <> cc.KarmaCommsMgr_Process) then
			tcp	:= null;
			tcp := kc.myParentTcp;
			if tcp = null then
				cc.cnWriteLog(cc.CnLogDiag, cc.appName &
					 " had null parent tcp object ref in CnMessage::receiveMsg ... can't forward to Karma/Joss", null);
			else
				if cc.appName = CN_KCCMGR then
					msg.setManagedEnvironmentName(tcp.managedEnvironmentName);
				endif;
				
				msg.sendMessage(tcp);							// forward the message to Karma or Joss 
			endif;
		endif;
	endif;														// end of ADVICE message processing

	/////////////////////  COMMAND i.e. message from Joss or Karma to client /////////////////////////////////////////

	if msgtype = Command then
		if cc.appName = CN_JOSSCOMMSMGR then
			if msg.destProcessType <> cc.JossCommsMgr_Process and msg.destProcessType <> cc.Joss_Foreground_Process then
				msg.forwardMsg();						// handled in Joss schema	

			elseif msg.destProcessType = cc.JossCommsMgr_Process then
				cc.cnWriteLog(cc.CnLogComment, "In CnMessage::receiveMsg, got command with destProcess=JossCommsMgr " &
							  "(myself - will process) : data=" & buf.String, null);
				processMsgRequired := true;

			else
				cc.cnWriteLog(cc.CnLogErrors, "<<< ERROR >>> in CnMessage::receiveMsg, got command with destProcess=" & 
							  msg.destProcessType & " : unexpected situation, cannot forward or send, data=" & buf.String, null);	
			endif;

		elseif cc.appName = CN_KCCMGR then
			classMsg := msg.class();
			if msg.destProcessType = cc.Application_Process and
			   classMsg <> CnPingCmd						then
				msg.forwardMsg();									// forward to application client														
					
			else
				processMsgRequired := self.isKCCMgrToProcessMsg(classMsg);
				if not processMsgRequired then
					cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " got command with destProcess=" &
													msg.destProcessType & " : invalid destination, " & classMsg.name & " message not sent <<<<<<", null);
				endif;
			endif;

		else																// KarmaCommsMgr or any app client		
			//
			//  You must always code processMsg in your xxxxCmd class, for Karma (in schema Joss) or for
			//  KCCMgr (in schema CardSchema).  This is to allow KarmaCommsMgr to do any required processing
			//  before forwarding the message to KCCMgr
			//
			processMsgRequired := true;										
		endif;

		if processMsgRequired then
			result := msg.processMsg(proc);				
			if result <> CN_OK then											// shouldn't happen
				abortTransaction;
				cc.cnWriteLog(cc.CnLogProgramError, ": Bad result from CnMessage::processMsg processing command" &
									": result=" & result, null);
			endif;
		endif;
	endif;

	cc.cnWriteLog(cc.CnLogReceive, method.cnGetMethodName() & " : receipt and processing of " & msg.String & " completed - will delete.", null);	// PAR 6782
epilog
	if currentSchema.name = CN_JOSS then
		cnEndTransactionEx(tag);
	endif;
	
	delete msg;
end;
}
sendMessage
{
sendMessage(pTcp : CnKarmaTcpConnection input) updating;

vars
	cc 			: CnCntrl;

	kc			: CnKarmaCntrl;
	
	tcp			: CnKarmaTcpConnection;
	
	cnmach		: CnMachine;
	
	cnproc		: CnProcess;
	
	commsProc,
	proc		: Process;

	binMsg 		: Binary;

	badObject,
	fwd_done	: Boolean;
	
	logType,																													// PAR 6782
	tcpState,
	x			: Integer;

	msgclass,
	processAppName,
	str			: String;
begin
	cc 				:= app.myCnCntrl;
	processAppName	:= cc.appName;					// this is the process application name (if using packages the name is different).
	kc	    		:= app.myCnKarmaCntrl;
	tcp				:= pTcp;
	if processAppName = CN_KCCMGR			and																					// PAR 833
	   tcp <> null 							and																					// PAR 833
	   tcp.managedEnvironmentName = null 	then																				// PAR 833
		cc.cnWriteLog(cc.CnLogProgramError, method.cnGetMethodName() & " comms process yet to send SessionOpenAdvice" &			// PAR 833
																		" - ignoring message", null);							// PAR 833
		return;																													// PAR 833
	endif;																														// PAR 833

	///////  If we need to do any fixup, must do it here before assembleMsg   /////////////

    if self.msgType = Advice then 
		logType		:= cc.CnLogReceive;																							// PAR 6782
		if self.managedEnvironmentName = null then							
			self.managedEnvironmentName := kc.environmentId;
		endif;
		
//		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : serverName in msg is now set to " & self.serverName, null);

		if processAppName = CN_KARMACOMMSMGR then
			self.serverHostFQDN 		:= kc.localFQDN;
			self.serverHostIpAddress	:= kc.localIpAddress;

			if self.clientFQDN = 'localhost' then						// process running on same box as Karma, 
				self.clientFQDN 		:= kc.localFQDN;				// e.g. KCCMgr
				self.clientIpAddress	:= kc.localIpAddress;			
			endif;	
        endif;
	endif;

	if self.msgType = Command then
		logType		:= cc.CnLogTransmit;																						// PAR 6872
		if processAppName = CN_JOSSCOMMSMGR or 
		   processAppName = CN_KARMACOMMSMGR then
			if tcp = null then
				self.protocolVersion := Current_Protocol_Version;

			else
//				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : msg.protocolVersion=" & self.protocolVersion.String & ", tcp.PV=" & tcp.protocolVersion.String, null);
				if (tcp.protocolVersion <> self.protocolVersion and tcp.protocolVersion <> null) or self.protocolVersion = null then
					self.protocolVersion := tcp.protocolVersion;				// set protocol to something that the downstream
				endif;															// entity (KarmaCommsMgr or KCCMgr) can understand
			endif;
		endif;
	endif;	 

	////////  Now assemble the message string and send it   ///////////////////
	
	binMsg 	:= self.assembleMsg();											// assembleMsg is sensitive to protocolVersion
	msgclass := binMsg[6:8].ansiToString.trimRight();
	
	if msgclass = CnMessage.JSA_File_Transfer_Advice then
		cc.cnWriteLog(logType, method.cnGetMethodName() & " msgclass=" & self.class.name & 
					   " : sending buffer not displayed, length=" & binMsg.length().String, null);
	
	else
		cc.cnWriteLog(logType, method.cnGetMethodName() & " msgclass=" & self.class.name & 
						   " : sending buffer=" & binMsg.cnAnsiToString(binMsg.length), null);
	endif;
//	cc.cnWriteLog(cc.CnLogDiag, "CnMessage::sendMessage : Buffer dump=" & binMsg.display, null);
//	write "dump=" & binMsg.display;

	/////////////////////////////////   Advices /////////////////////////////////////////////////////////

	if self.msgType = Advice then					// implies that message is going App==>Karma==>Joss

		if processAppName = CN_KARMACOMMSMGR 	or
		   processAppName = CN_KCCMGR 			then	

			// We are one of the three types of background clients.  Specifically, we are
			// KarmaCommsMgr or KCCMgr.
			
			if processAppName = CN_KCCMGR and tcp = null then
				tcp	:= kc.myParentTcp;
			endif;			
			
			on SystemException do app.cnHandleNullOrInvObjectRef(exception, tcp, badObject);
			tcpState := tcp.state;
	        if badObject then										
	           	cc.cnWriteLog(cc.CnLogProgramError, method.cnGetMethodName() & " had null or invalid tcp object ..... giving up", null);
	        	cc.cnWriteLog(cc.CnLogProgramError,	method.cnGetMethodName() & " discarded msg buf=" & binMsg.String, null);
	            return;
	        endif;
	        
			if tcpState = 2 then
	        	tcp.cnWrite(binMsg, tcp.myReceiver);
				
	        else
	        	cc.cnWriteLog(logType, method.cnGetMethodName() & " parent tcp state=" & tcpState.String & ", message send to Karma/Joss not done", tcp);	// PAR 6782
	        endif;

		elseif processAppName = CN_JOSSCOMMSMGR then
			cc.cnWriteLog(cc.CnLogProgramError, method.cnGetMethodName() & " : erroneously asked to send " & self.class.name, tcp);
			return;

		elseif cc.karmaControl then																								// PAR 1038
			//  This must be an end user application client, so we send the message as a 
		   	//  notification to the Karma Client Comms Mgr (or Joss/KarmaCommsMgr for Joss & Karma).
		   	//  If the background client isn't listening (i.e. not there) then these simply get lost.

	     	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " now causing Cn_Message_From_Client event (msg length " & binMsg.length.userNumberFormat($CnWholeNumbers) & ")", null);	// PAR 6782
		   	process.causeEvent(Cn_Message_From_Client, true, binMsg);
		
		else																													// PAR 1038
	     	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " KarmaControl=false; ignore cause event of Cn_Message_From_Client", null);	// PAR 1038
		endif;	
	endif;

	/////////////////////////////////////   Commands  //////////////////////////////////////////////////

	if self.msgType = Command then

		if (app.cnSystemType = CN_SYSTEMTYPE_JSM and processAppName <> CN_JOSSCOMMSMGR) 	or
		   (app.cnSystemType = CN_SYSTEMTYPE_JSA and processAppName <> CN_KARMACOMMSMGR)	then 					

			on SystemException do app.cnHandleNullOrInvObjectRef(exception, kc.myKarmaCommsMgrProcess, badObject);
			badObject := false;
			commsProc := kc.myKarmaCommsMgrProcess;
			str := commsProc.persistentApp.name;
			if badObject then
				if app.cnSystemType = CN_SYSTEMTYPE_JSM then
					str := CN_JOSSCOMMSMGR;
				
				else
					str := CN_KARMACOMMSMGR;
				endif;
				
				commsProc := cc.getProcessForLock(CN_JOSSCONTROL, str, false);
				kc.setMyKarmaCommsMgrProcess(commsProc);
				badObject := false;
			endif;
			
			str := commsProc.persistentApp.name;
			if badObject or (str <> CN_JOSSCOMMSMGR and str <> CN_KARMACOMMSMGR) then
				cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " can't send message from client because background client isn't running ..... ", null); 
				if process.isInTransactionState() then
					abortTransaction;
				endif;

				if processAppName = CN_JOSS or 
				   processAppName = CN_KARMA then
					app.msgBox("Transaction cannot be completed, because the background client is not running, badObject=" & badObject.String & ", str=" & str, "Error", 48);
				endif;
				
				return;
			endif;

			cc.cnWriteLog(logType, method.cnGetMethodName() & " now causing Cn_Message_From_Client event", null);   
			kc.myKarmaCommsMgrProcess.causeEvent(Cn_Message_From_Client, true, binMsg);  

		elseif processAppName = CN_JOSSCOMMSMGR 	or 
		       processAppName = CN_KARMACOMMSMGR 	then							// Joss/Karma background clients
			//
			if processAppName 		= CN_JOSSCOMMSMGR 			and 
			   self.destProcessType = cc.JossCommsMgr_Process 	then	// occasionally, send message to myself
				cc.cnWriteLog(logType, method.cnGetMethodName() & " now causing Cn_Message_From_Client event to myself...", null);   
				process.causeEvent(Cn_Message_From_Client, true, binMsg); 
				
			elseif processAppName = CN_KARMACOMMSMGR 					and 
			       self.appName[1:5] = CN_KARMA 						and 
				   self.destProcessType = cc.Karma_Application_Process 	then
				cnproc	:= null;
				cnproc	:= kc.allCnProcesses[self.processId];
				if cnproc <> null then
					cc.cnWriteLog(logType, method.cnGetMethodName() & " now causing Cn_Message_To_Client event", null); 
					cnproc.myProcess.causeEvent(Cn_Message_To_Client, true, binMsg);
					
				else
					cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " couldn't find CnProcess object for " & self.appName & "/" &
												self.processId.String & " : message discarded.", null);
				endif; 	 
				
			else
				on SystemException do app.cnHandleNullOrInvObjectRef(exception, tcp, badObject);
				tcpState := tcp.state;
				if badObject then										
					cc.cnWriteLog(cc.CnLogProgramError, method.cnGetMethodName() & " had null or invalid tcp object ..... giving up", null);
					cc.cnWriteLog(cc.CnLogProgramError,	method.cnGetMethodName() & " discarded msg buf=" & binMsg.String, null);
					return;
				endif;
	        
				if tcpState = 2 then
		        	tcp.cnWrite(binMsg, tcp);
					
		        else
		        	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : child tcp state=" & tcpState.String & ", message send to Karma/KCCMgr not done", tcp);
		        endif;
			endif;

		elseif processAppName = CN_KCCMGR then
			cnmach := kc.allMachines[self.clientFQDN]; 
			//
			//  Not sure why this code is here, or when it's used.  So log its use  .....
			//
			cc.cnWriteLog(cc.CnLogErrors, "Possible program error : KCCMgr in wrong method ?  Msg class is " &
					      self.class.name & " destProcType=" & self.destProcessType & ", dest app=" & self.appName, null);	

			on SystemException do app.cnHandleNullOrInvObjectRef(exception, cnmach, badObject);
			x := cnmach.edition;
			if badObject then
				cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " can't forward : no machine with fqdn=" & self.clientFQDN, tcp);
				return;
			endif;

			fwd_done := false;
			if self.processId > null then
				cnproc := cnmach.allProcesses[self.processId];
				on SystemException do app.cnHandleNullOrInvObjectRef(exception, cnproc, badObject);
				proc := cnproc.myProcess;
				if not badObject then
					proc.causeEvent(Cn_Message_To_Client, true, binMsg);
					fwd_done := true;
				endif;
			endif;

			if not fwd_done then 
				foreach cnproc in cnmach.allProcesses do
					cnproc.myProcess.causeEvent(Cn_Message_To_Client, true, binMsg);
	            endforeach;
	        endif;
			
		else  																	// must be app client
			cc.cnWriteLog(cc.CnLogProgramError, method.cnGetMethodName() & " : erroneously asked to send " & self.class.name & " dest=" & self.destProcessType, tcp);		
		endif;
 	endif;
end;
}
setAppName
{
setAppName(appname : String) updating;

vars

begin
 	self.appName := appname;
end;
}
setAppSchemaName
{
setAppSchemaName(pValue : String) updating;

vars

begin
 	self.appSchemaName := pValue;
end;
}
setArchitectureRemote
{
setArchitectureRemote(arch : Integer) updating;

vars

begin
	self.architectureRemote := arch;
end;
}
setClientAlias
{
setClientAlias(alias : String) updating;

vars

begin
	self.clientAlias := alias.toLower;
end;
}
setClientFQDN
{
setClientFQDN(fqdn : String) updating;

vars

begin
	self.clientFQDN := fqdn.toLower;
end;
}
setClientIpAddress
{
setClientIpAddress(ipaddress : String) updating;

vars

begin
	self.clientIpAddress := ipaddress;
end;
}
setComputerName
{
setComputerName(name : String) updating;

vars
	cc		: CnCntrl;
	maxlen	: Integer;
begin
	maxlen	:= self.computerName.maxLength;				// detour for unobtainable computer name scenario
	
	if name.length > maxlen then
		cc	:= app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " will truncate overlength computer name (" & name & ").", null);
		self.computerName	:= name[1:maxlen];
	else
		self.computerName 	:= name;
	endif;
end;
}
setCreatorMethod
{
setCreatorMethod(name : String) updating;

vars

begin
	self.creatorMethod := name;
end;
}
setDestProcessType
{
setDestProcessType(type : String) updating;

vars

begin
	self.destProcessType := type;
end;
}
setDriveLetter
{
setDriveLetter(drive : String) updating;

vars

begin
 	self.driveLetter := drive;
end;
}
setEnvironmentId
{
setEnvironmentId(pValue : String) updating;

vars

begin
	self.environmentId := pValue[1:30];
end;
}
setErrorCode
{
setErrorCode(pCode : Integer) updating;

vars

begin
	self.errorCode := pCode;
end;
}
setManagedEnvironmentName
{
setManagedEnvironmentName(name : String) updating;

vars

begin
 	self.managedEnvironmentName := name;
end;
}
setMsgParam1
{
setMsgParam1(param : String) updating;

vars

begin
 	self.msgParam1 := param;
end;
}
setMsgParam2
{
setMsgParam2(val : String) updating;

vars

begin
	msgParam2 := val;
end;
}
setMyTcp
{
setMyTcp(tcp : CnTcpConnection) updating;

vars

begin
 	self.myTcp := tcp;
end;
}
setPos
{
setPos(pValue : Integer) updating;

vars

begin
	self.pos := pValue;
end;
}
setProcessId
{
setProcessId(procid : Integer) updating;

vars

begin
	self.processId := procid;
end;
}
setProtocolVersion
{
setProtocolVersion(version : Integer) updating;

vars

begin
	self.protocolVersion := version;
end;
}
setServerHostFQDN
{
setServerHostFQDN(fqdn : String) updating;

vars

begin
	self.serverHostFQDN := fqdn;
end;
}
setServerHostIpAddress
{
setServerHostIpAddress(ipaddr : String) updating;

vars

begin
 	self.serverHostIpAddress := ipaddr;
end;
}
	)
	CnAdvice (
	jadeMethodSources
processMsg
{
processMsg(proc: Process): String updating;

vars
	cc		: CnCntrl;

	fqdn,
	result	: String;
begin
	result := inheritMethod(proc);
 	if result <> CN_OK then
 		return result;
 	endif;
 	
 	cc	:= app.myCnCntrl;
 	if cc.appName = CN_JOSSCOMMSMGR then
	 	if self.computerName <> null then
	 		fqdn	:= app.cnBuildFQDN(computerName).toLower;				// re-implemented in Joss schema
			if self.clientFQDN <> fqdn then																						// JSM PAR 6577
//				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " client computerName = " & self.computerName &
//											" : changing clientFQDN from " & self.clientFQDN & " to " & fqdn, null);			// JSM PAR 6577
				self.setClientFQDN(fqdn);
			endif;																												// JSM PAR 6577
			
	  	else
//	  		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " computerName was null : clientFQDN=" & self.clientFQDN & " : not changed.", null);	
	 	endif;
	 endif;
 	
 	return CN_OK;	
end;
}
	)
	CnBackupAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;


vars
 	bin,
 	bin2,		
	backupInfo 	: Binary;

	filename,
 	str			: String;
	
 	int,
	sz			: Integer;
 	
	mapSize		: Integer64;	
	
	cc			: CnCntrl;	
begin
	cc := app.myCnCntrl;
	bin	:= inheritMethod();

	// as KCDatabaseBackupMulti is using this, we don't want the
	// message header details unless we are actually sending the 
	// message to JSA.
	backupInfo := 	cnAnsiBinary(adviceType.padBlanks(8))	&
					timestamp.Binary						&
					currentFileName.length.Binary			&
					cnAnsiBinary(currentFileName)			&
					percentProgress.Binary					&
					fileSize.Integer64.Binary				&
					errorText.length.Binary					&
					cnAnsiBinary(errorText)					;
	
	if self.protocolVersion < 20 then
		foreach filename in structureNames do
			str := str & filename.padBlanks(30);
		endforeach;
	
		backupInfo := 	backupInfo							&
						str.length.Binary					&
						cnAnsiBinary(str)					;
		
		foreach mapSize in structureSizes do
			bin2 := bin2 & mapSize.Binary;
		endforeach;
	
		backupInfo := 	backupInfo							&
						bin2.length.Binary					&
						bin2								;
						
	elseif app.name = CN_KCDATABASEBACKUPMULTI 		then			// This application is specifically for non-managed environments
		bin2 := structureNames.size().Binary;						// so JSA will never see this backup advice.
		foreach filename in structureNames do
			bin2 := bin2 & filename.length().Binary &
							cnAnsiBinary(filename);					//JADECare Start PAR 1100
		endforeach;
	
		foreach mapSize in structureSizes do
			bin2 := bin2 & mapSize.Binary;
		endforeach;
	
		backupInfo := 	backupInfo							&
						bin2								;
	endif;

    str := null;
	if self.protocolVersion > 24 then			// 3.7.04 now caters for database structure names of 115 bytes (as from JADE 7.1)
		backupInfo := backupInfo &
						droppedFileNames.size().Binary;
		foreach filename in droppedFileNames do
			backupInfo := backupInfo & 
							filename.length().Binary &
							cnAnsiBinary(filename);
		endforeach;
	
	else
		foreach filename in droppedFileNames do
			str := str & filename.padBlanks(30);
		endforeach;
		
		backupInfo := backupInfo							&
					str.length.Binary						&
					cnAnsiBinary(str);
	endif;

   	backupInfo := backupInfo								&
					endLogNo.Binary							&
					startLogNo.Binary						&
					backupWorkerId.Binary					&
					cnAnsiBinary(phase);
	
	if self.Current_Protocol_Version > 35 then //4.0.01+
		backupInfo := backupInfo & self.completedBackupIsCommitCoherent.Binary; //NFS 7055
	endif;
	
	if app.name = CN_KCDATABASEBACKUPMULTI then
		sz := backupInfo.length();
		if sz > 47000 then
			str := "backupInfo size=" & sz.userNumberFormat($CnWholeNumbers);
			app.cnManagerLog(str);
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " " & str, null);
		endif;
		
		system.causeEvent(Cn_Backup_Progress_Update, true, backupInfo);	// backupInfo for JADECare non-managed multi worker backups
	endif;
	
   	bin := bin & backupInfo;											// bin for JADECare managed backups
	return bin;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;


vars
	cc		: CnCntrl;

	count,
	endPos,
	expected,
	len			: Integer;
begin
	cc := app.myCnCntrl;
	inheritMethod(buf);
	adviceType			:= getField(buf, 8).ansiToString.trimRight;
	timestamp			:= byteOrderTimeStamp(getField(buf, 8));
	len					:= byteOrderInteger(getField(buf, 4));

	if len > null then
		currentFileName	:= getField(buf, len).ansiToString;
	endif;

 	percentProgress		:= byteOrderInteger(getField(buf, 4));
	fileSize			:= byteOrderInteger64(getField(buf, 8));
 	len					:= byteOrderInteger(getField(buf, 4));
	if len > null then
		errorText		:= getField(buf, len).ansiToString;
	endif;
	
	if self.protocolVersion < 20 then
		endPos				:= byteOrderInteger(getField(buf, 4)) + pos;
		while pos < endPos do
			structureNames.add(getField(buf, 30).ansiToString.trimRight);
		endwhile;
	
		endPos				:= byteOrderInteger(getField(buf, 4)) + pos;
		while pos < endPos do
			structureSizes.add(byteOrderInteger64(getField(buf, 8)));
		endwhile;
	endif;
	
    if self.protocolVersion > 24 then   // 3.7.04
        expected        := byteOrderInteger(getField(buf, 4));          
        foreach count in 1 to expected do
            len             := byteOrderInteger(getField(buf, 4));       
            droppedFileNames.add(getField(buf, len).ansiToString());
        endforeach;

    else        
        endPos              := byteOrderInteger(getField(buf, 4)) + pos;
        while pos < endPos do
            droppedFileNames.add(getField(buf, 30).ansiToString.trimRight);
        endwhile;
    endif;

	endLogNo		:= byteOrderInteger(getField(buf, 4));
	startLogNo		:= byteOrderInteger(getField(buf, 4));
	backupWorkerId	:= byteOrderInteger(getField(buf, 4));
	phase			:= getField(buf, 1).ansiToString.Character;
	
	if self.protocolVersion > 35 then
		self.completedBackupIsCommitCoherent := getField(buf, 1).Character.Boolean;
	endif;
end;
}
setAdviceType
{
setAdviceType(type : String) updating;

vars

begin
 	self.adviceType := type;
end;
}
setBackupWorkerId
{
setBackupWorkerId(id : Integer) updating;

vars

begin
	self.backupWorkerId := id;
end;
}
setCompletedBackupIsCommitCoherent
{
setCompletedBackupIsCommitCoherent(pIsCommitCoherentBackup : Boolean) updating;

vars

begin
	self.completedBackupIsCommitCoherent := pIsCommitCoherentBackup;
end;
}
setCurrentFileName
{
setCurrentFileName(name : String) updating;

vars

begin
 	self.currentFileName := name;
end;
}
setEndLogNo
{
setEndLogNo(num : Integer) updating;

vars

begin
	self.endLogNo := num;
end;
}
setErrorText
{
setErrorText(text : String) updating;

vars

begin
   	self.errorText := text;
end;
}
setFileSize
{
setFileSize(size : Decimal) updating;

vars

begin
	self.fileSize := size;
end;
}
setPercentProgress
{
setPercentProgress(pc : Integer) updating;

vars

begin
 	self.percentProgress := pc;
end;
}
setPhase
{
setPhase(char : Character) updating;

vars

begin
	self.phase := char;
end;
}
setStartLogNo
{
setStartLogNo(logNo : Integer) updating;

vars

begin
	self.startLogNo := logNo;	
end;
}
setTimestamp
{
setTimestamp(ts : TimeStamp) updating;

vars

begin
	self.timestamp := ts;
end;
}
	)
	CnCompactAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;

vars
 	bin,
	bin2,
	bin3		: Binary;

 	filename	: String;
 	
	str			: String;
 	
	afterSize,
	mapSize		: Integer64;	
begin
	bin	:= inheritMethod();
	bin := bin &
		   cnAnsiBinary(adviceType.padBlanks(8))	&
		   self.timeStamp.Binary					&
		   self.currentFileName.length.Binary		&
		   cnAnsiBinary(currentFileName)			&
		   self.percentProgress.Binary				&
		   self.fileSize.Binary						&
		   self.errorText.length.Binary				&
		   cnAnsiBinary(errorText)					;

	foreach filename in self.mapFileNames do
		str := str & filename & "|";
	endforeach;

	bin := bin 										&
		   str.length.Binary						&
		   cnAnsiBinary(str)						;

	foreach mapSize in self.mapFileSizes do
		bin2 := bin2 & mapSize.Binary;
	endforeach;
	
	foreach afterSize in self.mapFileSizesAfter do
		bin3 := bin3 & afterSize.Binary;
	endforeach;
	
	bin	:= bin 										&
		   bin2.length.Binary						&
		   bin2										&
		   bin3.length.Binary						&
		   bin3										&
		   self.compactWorkerId.Binary				&
		   cnAnsiBinary(self.phase);   
	return bin;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars
	len,
	endPos			: Integer;
	
	mapFileName		: String;
	
	mapFileStrArray : CnStringArray;
begin
	inheritMethod(buf);
	self.adviceType				:= getField(buf, 8).ansiToString.trimRight;
	self.timeStamp				:= byteOrderTimeStamp(getField(buf, 8));

 	len							:= byteOrderInteger(getField(buf, 4));
	if len > null then
		self.currentFileName	:= getField(buf, len).ansiToString;
	endif;	
	
	self.percentProgress		:= byteOrderInteger(getField(buf, 4));
	self.fileSize				:= byteOrderInteger64(getField(buf, 8));
	
 	len							:= byteOrderInteger(getField(buf, 4));
	if len > null then
		self.errorText			:= getField(buf, len).ansiToString;
	endif;
	
	endPos						:= byteOrderInteger(getField(buf, 4)) + pos;
	mapFileStrArray				:= getField(buf, endPos-pos).ansiToString.cnGetTokens("|");
	foreach mapFileName in mapFileStrArray do
		self.mapFileNames.add (mapFileName);
	endforeach;
	
	endPos						:= byteOrderInteger(getField(buf, 4)) + pos;
	while pos < endPos do
		self.mapFileSizes.add(byteOrderInteger64(getField(buf, 8)));		
	endwhile;
	
	endPos						:= byteOrderInteger(getField(buf, 4)) + pos;
	while pos < endPos do
		self.mapFileSizesAfter.add(byteOrderInteger64(getField(buf, 8)));		
	endwhile;
   
	self.compactWorkerId		:= byteOrderInteger(getField(buf, 4));
	self.phase					:= getField(buf, 1).ansiToString().Character;
epilog
	delete mapFileStrArray;
end;
}
setAdviceType
{
setAdviceType(type : String) updating;

vars

begin
 	self.adviceType := type;
end;
}
setCompactWorkerId
{
setCompactWorkerId(id : Integer) updating;

vars

begin
	self.compactWorkerId := id;
end;
}
setCurrentFileName
{
setCurrentFileName(pFileName : String) updating;

vars

begin
	self.currentFileName := pFileName;
end;
}
setErrorText
{
setErrorText(text : String) updating;

vars

begin
   	self.errorText := text;
end;
}
setFileSize
{
setFileSize(pFileSize : Integer64) updating;

vars

begin
	self.fileSize := pFileSize;
end;
}
setPercentProgress
{
setPercentProgress(pc : Integer) updating;

vars

begin
 	self.percentProgress := pc;
end;
}
setPhase
{
setPhase(char : Character) updating;

vars

begin
	self.phase := char;
end;
}
setTimeStamp
{
setTimeStamp(pTimeStamp : TimeStamp) updating;

vars

begin
	self.timeStamp := pTimeStamp;
end;
}
	)
	CnControlAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;

vars
	bin	: Binary;
begin
	bin	:= inheritMethod()							&
		   cnAnsiBinary(commandType.padBlanks(5))	&
		   cnAnsiBinary(adviceType.padBlanks(8))	&
   		   databaseRole.Binary						&
		   adviceText.length.Integer.Binary 		&
		   cnAnsiBinary(adviceText);
	
	return bin;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars
	len	: Integer;
begin
	inheritMethod(buf);
	
	self.commandType	:= getField(buf, 5).ansiToString.trimRight;
	self.adviceType		:= getField(buf, 8).ansiToString.trimRight;
	self.databaseRole	:= byteOrderInteger(getField(buf, 4));
	len					:= byteOrderInteger(getField(buf, 4));
	if len > 0 then
		self.adviceText	:= getField(buf, len).ansiToString;
	endif;	
end;
}
setAdviceText
{
setAdviceText(text	: String) updating;

vars

begin
	self.adviceText := text;
end;
}
setAdviceType
{
setAdviceType(advType : String) updating;

vars

begin
	self.adviceType := advType;
end;
}
setCommandType
{
setCommandType(command : String) updating;

vars

begin
	self.commandType := command;
end;
}
setDatabaseRole
{
setDatabaseRole(role : Integer) updating;

vars

begin
	self.databaseRole	:= role;
end;
}
	)
	CnExceptionAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;

vars
	bin		: Binary;
begin
	if self.protocolVersion < 25 then
		// can be removed when CardSchema 3.7.03 is no longer supported
		bin		:= inheritMethod()								&
				   cnAnsiBinary(receiver.padBlanks(70))			&
				   cnAnsiBinary(errorMethodA.padBlanks(64))		&
				   cnAnsiBinary(errorMethodB.padBlanks(64))		&
				   stackDumpFileName.length.Binary 				&
				   cnAnsiBinary(stackDumpFileName)				&
				   exceptionComment.length.Binary				&
				   cnAnsiBinary(exceptionComment)				&
				   extendedErrorText.length.Binary				&
				   cnAnsiBinary(extendedErrorText)				&
				   timestamp.Binary								&
				   exceptionCode.Binary							&
				   codePositionA.Binary							&
				   codePositionB.Binary							&
				   recursive.Character.Binary					&
				   cnAnsiBinary(thinClientComputerName.padBlanks(65)) &
				   cnAnsiBinary(thinClientComputerIpAddress.padBlanks(65));
		return bin;
	endif;
	
	if self.protocolVersion < 26 then	// 3.7.04
		bin		:= inheritMethod()								&
				   receiver.length().Binary					    &
				   cnAnsiBinary(receiver)						&
				   errorMethodA.length().Binary				    &
				   cnAnsiBinary(errorMethodA)					&
				   errorMethodB.length().Binary					&
				   cnAnsiBinary(errorMethodB)					&
				   stackDumpFileName.length.Binary 				&
				   cnAnsiBinary(stackDumpFileName)				&
				   exceptionComment.length.Binary				&
				   cnAnsiBinary(exceptionComment)				&
				   extendedErrorText.length.Binary				&
				   cnAnsiBinary(extendedErrorText)				&
				   timestamp.Binary								&
				   exceptionCode.Binary							&
				   codePositionA.Binary							&
				   codePositionB.Binary							&
				   recursive.Character.Binary					&
				   thinClientComputerName.length().Binary		&
				   cnAnsiBinary(thinClientComputerName) 		&
				   thinClientComputerIpAddress.length().Binary	&
				   cnAnsiBinary(thinClientComputerIpAddress);
		return bin;
	endif;

	// pv = 26 3.7.05
	bin		:= inheritMethod()								&
			   receiver.length().Binary					    &
			   cnAnsiBinary(receiver)						&
			   errorMethodA.length().Binary				    &
			   cnAnsiBinary(errorMethodA)					&
			   errorMethodB.length().Binary					&
			   cnAnsiBinary(errorMethodB)					&
			   stackDumpFileName.length.Binary 				&
			   cnAnsiBinary(stackDumpFileName)				&
			   exceptionComment.length.Binary				&
			   cnAnsiBinary(exceptionComment)				&
			   extendedErrorText.length.Binary				&
			   cnAnsiBinary(extendedErrorText)				&
			   timestamp.Binary								&
			   exceptionCode.Binary							&
			   codePositionA.Binary							&
			   codePositionB.Binary							&
			   cnAnsiBinary(recursive.Character)			&
			   thinClientComputerName.length().Binary		&
			   cnAnsiBinary(thinClientComputerName) 		&
			   thinClientComputerIpAddress.length().Binary	&
			   cnAnsiBinary(thinClientComputerIpAddress);
	return bin;	
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars
	len		: Integer;
begin
	inheritMethod(buf);
	
	if self.protocolVersion < 25 then
		// can be removed when CardSchema 3.7.03 is no longer supported
		receiver			:= getField(buf, 70).ansiToString.trimRight;
		errorMethodA		:= getField(buf, 64).ansiToString.trimRight;
		errorMethodB		:= getField(buf, 64).ansiToString.trimRight;
		len					:= byteOrderInteger(getField(buf, 4));
		stackDumpFileName	:= getField(buf, len).ansiToString;
		len					:= byteOrderInteger(getField(buf, 4));
		exceptionComment	:= getField(buf, len).ansiToString;
		len					:= byteOrderInteger(getField(buf, 4));
		extendedErrorText	:= getField(buf, len).ansiToString;
		timestamp			:= byteOrderTimeStamp(getField(buf, 8));
		exceptionCode		:= byteOrderInteger(getField(buf, 4));
		codePositionA		:= byteOrderInteger(getField(buf, 4));
		codePositionB		:= byteOrderInteger(getField(buf, 4));
		recursive			:= getField(buf, 1).ansiToString.Character.Boolean;
	
		if self.protocolVersion > 22 then												// release 3.7 or greater
			thinClientComputerName		:= getField(buf, 65).ansiToString.trimRight;
			thinClientComputerIpAddress	:= getField(buf, 65).ansiToString.trimRight();	// 3.7 supports IPv6 addresses
			
		else
			thinClientComputerName		:= getField(buf, 20).ansiToString.trimRight;
			thinClientComputerIpAddress	:= getField(buf, 15).ansiToString.trimRight();
		endif;
	
		return;
	endif;
	
	if self.protocolVersion < 26 then
			// can be removed when CardSchema 3.7.03 is no longer supported
		len					:= byteOrderInteger(getField(buf, 4));
		receiver			:= getField(buf, len).ansiToString();
		len					:= byteOrderInteger(getField(buf, 4));
		errorMethodA		:= getField(buf, len).ansiToString();
		len					:= byteOrderInteger(getField(buf, 4));
		errorMethodB		:= getField(buf, len).ansiToString();
		len					:= byteOrderInteger(getField(buf, 4));
		stackDumpFileName	:= getField(buf, len).ansiToString();
		len					:= byteOrderInteger(getField(buf, 4));
		exceptionComment	:= getField(buf, len).ansiToString();
		len					:= byteOrderInteger(getField(buf, 4));
		extendedErrorText	:= getField(buf, len).ansiToString();
		timestamp			:= byteOrderTimeStamp(getField(buf, 8));
		exceptionCode		:= byteOrderInteger(getField(buf, 4));
		codePositionA		:= byteOrderInteger(getField(buf, 4));
		codePositionB		:= byteOrderInteger(getField(buf, 4));
		if app.isUnicode then
			recursive			:= getField(buf, 2).Character.Boolean;
		
		else
			recursive			:= getField(buf, 1).ansiToString.Character.Boolean;
		endif;
		
		len							:= byteOrderInteger(getField(buf, 4));
		thinClientComputerName		:= getField(buf, len).ansiToString();
		len							:= byteOrderInteger(getField(buf, 4));
		thinClientComputerIpAddress	:= getField(buf, len).ansiToString();	// 3.7 supports IPv6 addresses
		return;
	endif;
	
	len						:= byteOrderInteger(getField(buf, 4));
	receiver				:= getField(buf, len).ansiToString();
	len						:= byteOrderInteger(getField(buf, 4));
	errorMethodA			:= getField(buf, len).ansiToString();
	len						:= byteOrderInteger(getField(buf, 4));
	errorMethodB			:= getField(buf, len).ansiToString();
	len						:= byteOrderInteger(getField(buf, 4));
	stackDumpFileName		:= getField(buf, len).ansiToString();
	len						:= byteOrderInteger(getField(buf, 4));
	exceptionComment		:= getField(buf, len).ansiToString();
	len						:= byteOrderInteger(getField(buf, 4));
	extendedErrorText		:= getField(buf, len).ansiToString();
	timestamp				:= byteOrderTimeStamp(getField(buf, 8));
	exceptionCode			:= byteOrderInteger(getField(buf, 4));
	codePositionA			:= byteOrderInteger(getField(buf, 4));
	codePositionB			:= byteOrderInteger(getField(buf, 4));
	recursive				:= getField(buf, 1).ansiToString.Character.Boolean;
	len						:= byteOrderInteger(getField(buf, 4));
	thinClientComputerName	:= getField(buf, len).ansiToString();
	len						:= byteOrderInteger(getField(buf, 4));
	thinClientComputerIpAddress	:= getField(buf, len).ansiToString();	// 3.7 supports IPv6 addresses
end;
}
setThinClientComputerIpAddress
{
setThinClientComputerIpAddress(address : String) updating;

vars

begin
	self.thinClientComputerIpAddress := address;
end;
}
setThinClientComputerName
{
setThinClientComputerName(name : String) updating;

vars

begin
	self.thinClientComputerName := name[1:65];
end;
}
	)
	CnExecuteAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;

vars
	bin		: Binary;
begin
	bin 	:= inheritMethod();
	attachField(bin, self.executeFunction.length().Binary);
	attachField(bin, cnAnsiBinary(self.executeFunction));
	attachField(bin, self.exitCode.Binary);
	attachField(bin, self.itemIndex.Binary);
	attachField(bin, self.itemName.length().Binary);
	attachField(bin, cnAnsiBinary(self.itemName));
	attachField(bin, self.errorMessage.length().Binary);
	attachField(bin, cnAnsiBinary(self.errorMessage));
	return bin;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars
	len						: Integer;
begin
	inheritMethod(buf);
	len						:= byteOrderInteger(getField(buf, 4));
	self.executeFunction	:= getField(buf, len).ansiToString();
	self.exitCode			:= byteOrderInteger(getField(buf, 4));
	self.itemIndex			:= byteOrderInteger(getField(buf, 4));
	len						:= byteOrderInteger(getField(buf, 4));
	self.itemName			:= getField(buf, len).ansiToString();
	len						:= byteOrderInteger(getField(buf, 4));
	self.errorMessage		:= getField(buf, len).ansiToString();
end;
}
setErrorMessage
{
setErrorMessage(pValue : String) updating;

vars

begin
	self.errorMessage := pValue;
end;
}
setExecuteFunction
{
setExecuteFunction(pValue : String) updating;

vars

begin
	self.executeFunction := pValue;
end;
}
setExitCode
{
setExitCode(pValue : Integer) updating;

vars

begin
	self.exitCode := pValue;
end;
}
setItemIndex
{
setItemIndex(pValue : Integer) updating;

vars

begin
	self.itemIndex	:= pValue;
end;
}
setItemName
{
setItemName(pValue : String) updating;

vars

begin
	self.itemName := pValue;
end;
}
	)
	CnFileDetailsAdvice (
	jadeMethodSources
addItemDbData
{
addItemDbData(	pDir,
				pName				: String;
				pStatus,
				pEncryptionStatus	: Integer;																					// JSM PAR 7050
				pType				: Character;
				pPartitionId,
				pLength,
				pUDRLength,
				pUDRStructures		: Integer64;
				pFrozen,
				pOffline			: Boolean) updating;

vars

begin
	self.directoryNameArray.add(pDir);
	self.fileLengthArray.add(pLength);
	self.fileNameArray.add(pName);
	self.fileStatusArray.add(pStatus);
	self.fileTypeArray.add(pType);
	self.partitionIdArray.add(pPartitionId);
	self.udrLengthArray.add(pUDRLength);
	self.udrStructuresArray.add(pUDRStructures);
	self.fileFrozenArray.add(pFrozen);
	self.fileOfflineArray.add(pOffline);
	self.fileEncryptionArray.add(pEncryptionStatus);																			// JSM PAR 7050
end;
}
addItemUserPatches
{
addItemUserPatches(	pName		: String;
					pType		: Character;
					pModified	: TimeStamp) updating;

vars

begin
	self.fileNameArray.add(pName);
	self.fileTypeArray.add(pType);
	self.fileModifiedArray.add(pModified);
end;
}
assembleMsg
{
assembleMsg(): Binary updating;

vars
	bin		: Binary;
	
	cc		: CnCntrl;
begin
	bin := inheritMethod();

	if self.protocolVersion < 20 then
		return bin;
	endif;
	
	if self.adviceType = self.Advice_Type_FileDet_BinVer then
		return self.zAssembleBinVer(bin);
	endif;
	
	if self.adviceType = self.Advice_Type_FileDet_DbData then
		return self.zAssembleDbData(bin);
	endif;
	
	if self.adviceType = self.Advice_Type_FileDet_ThinClient then
		return self.zAssembleThinClient(bin);
	endif;

	if self.adviceType = self.Advice_Type_FileDet_UserPatchs then
		return self.zAssembleUserPatches(bin);
	endif;
	
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " unknown advice type '" & self.adviceType & ", ignored...", null);
	return null;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars
	cc	: CnCntrl;
begin
	inheritMethod(buf);
	
	if self.protocolVersion < 20 then
		return;
	endif;
	
	self.adviceType		:= self.getField(buf, 8).ansiToString().trimRight();
	
	if self.adviceType = self.Advice_Type_FileDet_BinVer then
		self.zLoadBinVer(buf);
		return;
	endif;
	
	if self.adviceType = self.Advice_Type_FileDet_DbData then
		self.zLoadDbData(buf);
		return;
	endif;
	
	if self.adviceType = self.Advice_Type_FileDet_ThinClient then
		self.zLoadThinClient(buf);
		return;
	endif;
	
	if self.adviceType = self.Advice_Type_FileDet_UserPatchs then
		self.zLoadUserPatches(buf);
		return;
	endif;

	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " unknown advice type '" & self.adviceType & ", ignored...", null);
end;
}
setAdviceType
{
setAdviceType(pValue : String) updating;

vars

begin
	self.adviceType := pValue;
end;
}
zAssembleBinVer
{
zAssembleBinVer(pBin : Binary): Binary updating;

vars
	iterFileName,
	iterFileType,
	iterFileVersion,
	iterFileMD5Hash,
	iterFileModified	: Iterator;

	bin					: Binary;
	
	fileType			: Character;

	fileMD5HashLength,
	fileNameLength,
	fileVersionLength	: Integer;
	
	fileMD5Hash,
	fileName,
	fileVersion			: String;
	
	lastModified		: TimeStamp;
begin
	bin := pBin & 
			cnAnsiBinary(adviceType.padBlanks(8))			&
			fileNameArray.size().Binary;
	
	iterFileName 		:= fileNameArray.createIterator();
	iterFileType 		:= fileTypeArray.createIterator();
	iterFileVersion 	:= fileVersionArray.createIterator();
	iterFileMD5Hash 	:= fileMD5HashArray.createIterator();
	iterFileModified 	:= fileModifiedArray.createIterator();
	
	while iterFileName.next(fileName) do
		iterFileType.next(fileType);
		iterFileVersion.next(fileVersion);
		iterFileMD5Hash.next(fileMD5Hash);
		iterFileModified.next(lastModified);
	
		fileMD5HashLength	:= fileMD5Hash.length();
		fileNameLength 		:= fileName.length();
		fileVersionLength	:= fileVersion.length();
		bin	:= bin								&
				cnAnsiBinary(fileType)			&
				fileNameLength.Binary 			&
				cnAnsiBinary(fileName)			&
				fileVersionLength.Binary 		&
				cnAnsiBinary(fileVersion)		&
				lastModified.Binary;
		if self.protocolVersion > 23 then
			bin := bin							&
				   fileMD5HashLength.Binary		&
				   cnAnsiBinary(fileMD5Hash);
		endif;
	endwhile;

	return bin;
epilog
	delete iterFileName;
	delete iterFileType;
	delete iterFileVersion;
	delete iterFileMD5Hash;
	delete iterFileModified;
end;
}
zAssembleDbData
{
zAssembleDbData(pBin : Binary): Binary updating;

vars
	bin					: Binary;
	
	frozen,
	offline				: Boolean;
	
	count,
	directoryNameLength,
	fileEncryption,																												// JSM PAR 7050
	fileNameLength,
	fileStatus			: Integer;
	
	fileLength,
	partitionId,
	udrLength,
	udrStructures		: Integer64;
	
	directoryName,
	fileName			: String;
	
	fileType			: Character;

	iterFileFrozen,
	iterFileOffline,
	iterDirectoryName,
	iterFileLength,
	iterFileName,
	iterFileStatus,
	iterFileEncryption,																											// JSM PAR 7050
	iterFileType,
	iterPartitionId,
	iterUDRLength,
	iterUDRStructures	: Iterator;
	
	cc					: CnCntrl;
begin
	cc := app.myCnCntrl;
	bin := pBin &
			cnAnsiBinary(adviceType.padBlanks(8))			&
			fileNameArray.size().Binary;					// total number of instances

	executeWhen Cn_Debug_FileDetails;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " numItems=" & fileNameArray.size().String, null);		// TBR
	endExecuteWhen;
	
	iterDirectoryName	:= directoryNameArray.createIterator();
	iterFileFrozen		:= fileFrozenArray.createIterator();
	iterFileLength 		:= fileLengthArray.createIterator();
	iterFileName 		:= fileNameArray.createIterator();
	iterFileOffline		:= fileOfflineArray.createIterator();
	iterFileStatus 		:= fileStatusArray.createIterator();
	iterFileType 		:= fileTypeArray.createIterator();
	iterPartitionId 	:= partitionIdArray.createIterator();
	iterUDRLength	 	:= udrLengthArray.createIterator();
	iterUDRStructures 	:= udrStructuresArray.createIterator();
	iterFileEncryption	:= fileEncryptionArray.createIterator();																// JSM PAR 7050
	
	while iterFileName.next(fileName) do
		count := count + 1;
		iterDirectoryName.next(directoryName);
		iterFileLength.next(fileLength);
		iterFileStatus.next(fileStatus);
		iterFileType.next(fileType);
		iterPartitionId.next(partitionId);
		iterUDRLength.next(udrLength);
		iterFileFrozen.next(frozen);
		iterFileOffline.next(offline);
		if self.protocolVersion > 20 then		// 3.5.02
			iterUDRStructures.next(udrStructures);
		endif;
		
		if self.protocolVersion > 34 then		// 3.9.03																		// JSM PAR 7050
			iterFileEncryption.next(fileEncryption);																			// JSM PAR 7050
		endif;																													// JSM PAR 7050
		
		directoryNameLength := directoryName.length();
		fileNameLength 		:= fileName.length();
		
		executeWhen Cn_Debug_FileDetails;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " [" & count.String & 
														"] bin length=" & bin.length().String & 
														", directoryName=" & directoryName & " (" & directoryNameLength.String &
														"), fileStatus=" & fileStatus.String &
														", fileType=" & fileType &
														", fileEncryption=" & fileEncryption.String &							// JSM PAR 7050
														", fileName=" & fileName & " (" & fileNameLength.String &
														"), partitionId=" & partitionId.String &
														", fileLength=" & fileLength.String &
														", udrLength=" & udrLength.String &
														", udrStructures=" & udrStructures.String &
														", frozen=" & frozen.String &
														", offline=" & offline.String, null);
		endExecuteWhen;
		
		bin	:= bin			 					& 
				directoryNameLength.Binary 		&
				cnAnsiBinary(directoryName)		&
				fileStatus.Binary				&
				cnAnsiBinary(fileType)			&
				fileNameLength.Binary 			&
				cnAnsiBinary(fileName)			&
				partitionId.Binary				&
				fileLength.Binary				&
				udrLength.Binary;
		if self.protocolVersion > 20 then
			bin := bin &
					udrStructures.Binary;
		endif;
		
		if self.protocolVersion > 34 then		// 3.9.03																		// JSM PAR 7050
			bin := bin &																										// JSM PAR 7050
					fileEncryption.Binary;																						// JSM PAR 7050
		endif;																													// JSM PAR 7050
		
		bin := bin &
				cnAnsiBinary(frozen.Character)	&
				cnAnsiBinary(offline.Character);

	endwhile;

	return bin;
epilog
	delete iterDirectoryName;
	delete iterFileLength;
	delete iterFileName;
	delete iterFileStatus;
	delete iterFileType;
	delete iterFileFrozen;
	delete iterFileOffline;
	delete iterPartitionId;
	delete iterUDRLength;
	delete iterUDRStructures;
	delete iterFileEncryption;																									// JSM PAR 7050
end;
}
zAssembleThinClient
{
zAssembleThinClient(pBin : Binary): Binary updating;

vars
	bin					: Binary;
	
	directoryNameLength,
	fileNameLength		: Integer;
	
	fileLength			: Integer64;
	
	directoryName,
	fileName,
	md5Hash,
	version				: String;
	
	iterDirectoryName,
	iterFileLength,
	iterFileName,
	iterMD5Hash,
	iterModified,
	iterVersion			: Iterator;
	
	ts					: TimeStamp;
begin
	bin := pBin &
			cnAnsiBinary(adviceType.padBlanks(8))			&
			fileNameArray.size().Binary;						// total number of instances


	iterDirectoryName	:= directoryNameArray.createIterator();
	iterFileLength 		:= fileLengthArray.createIterator();
	iterFileName 		:= fileNameArray.createIterator();
	iterMD5Hash 		:= fileMD5HashArray.createIterator();
	iterModified 		:= fileModifiedArray.createIterator();
	iterVersion		 	:= fileVersionArray.createIterator();
	
	while iterFileName.next(fileName) do
		iterDirectoryName.next(directoryName);
		iterFileLength.next(fileLength);
		iterMD5Hash.next(md5Hash);
		iterModified.next(ts);
		iterVersion.next(version);
		
		directoryNameLength := directoryName.length();
		fileNameLength 		:= fileName.length();
		bin := bin 							&
				directoryNameLength.Binary 	&
				cnAnsiBinary(directoryName)	&
				fileNameLength.Binary 		&
				cnAnsiBinary(fileName)		&
				md5Hash.length().Binary		&
				cnAnsiBinary(md5Hash)		&
				version.length().Binary		&
				cnAnsiBinary(version)		&
				fileLength.Binary			&
				ts.Binary;
	endwhile;

	return bin;
epilog
	delete iterDirectoryName;
	delete iterFileLength;
	delete iterFileName;
	delete iterMD5Hash;
	delete iterModified;
	delete iterVersion;
end;
}
zAssembleUserPatches
{
zAssembleUserPatches(pBin : Binary): Binary updating;

vars
	bin					: Binary;
	
	fileNameLength		: Integer;
	
	lastModified		: TimeStamp;
	
	fileName			: String;
	
	fileType			: Character;
	
	iterFileName,
	iterFileType,
	iterFileNodified	: Iterator;
begin
	bin := pBin	&
			cnAnsiBinary(adviceType.padBlanks(8))			&
			fileNameArray.size().Binary;						// total number of instances
	
	iterFileName 		:= fileNameArray.createIterator();
	iterFileType 		:= fileTypeArray.createIterator();
	iterFileNodified 	:= fileModifiedArray.createIterator();
	
	while iterFileName.next(fileName) do
		iterFileType.next(fileType);
		iterFileNodified.next(lastModified);
	
		fileNameLength 		:= fileName.length();
		bin := bin 							&
				cnAnsiBinary(fileType)		&
				fileNameLength.Binary 		&
				cnAnsiBinary(fileName)		&
				lastModified.Binary;
	endwhile;

	return bin;
epilog
	delete iterFileName;
	delete iterFileType;
	delete iterFileNodified;
end;
}
zLoadBinVer
{
zLoadBinVer(buf: Binary) updating;

vars
	frozen,
	offline				: Boolean;
	
	char				: Character;
	
	count,
	len,
	numItems			: Integer;

	md5Hash,
	str					: String;
	
	ts					: TimeStamp;
begin
	numItems			:= self.byteOrderInteger(self.getField(buf, 4));
	
	// unpack 
	foreach count in 1 to numItems do
		char			:= self.getField(buf, 1).ansiToString().Character;
		self.fileTypeArray.add(char);

		len				:= self.byteOrderInteger(self.getField(buf, 4));		// length of fileName binary
		str				:= self.getField(buf, len).ansiToString();
		self.fileNameArray.add(str);

		len				:= self.byteOrderInteger(self.getField(buf, 4));		// length of version binary
		str				:= self.getField(buf, len).ansiToString();
		self.fileVersionArray.add(str);

		ts				:= self.byteOrderTimeStamp(getField(buf, 8));
		self.fileModifiedArray.add(ts);
		
		if self.protocolVersion > 23 then				// 3.7.03
			len				:= self.byteOrderInteger(self.getField(buf, 4));	// length of Md5 hash binary
			str				:= self.getField(buf, len).ansiToString();
			self.fileMD5HashArray.add(str);
		endif;
	endforeach;
end;
}
zLoadDbData
{
zLoadDbData(buf: Binary) updating;

vars
	frozen,
	offline				: Boolean;
	
	count,
	fileEncryption,
	fileStatus,
	len,
	numItems			: Integer;
	
	fileSize,
	partitionId,
	udrSize,
	udrStructures		: Integer64;
	
	directory,
	fileName			: String;
	
	fileType			: Character;
	
	cc					: CnCntrl;
begin
	cc := app.myCnCntrl;
	numItems			:= self.byteOrderInteger(self.getField(buf, 4));
	
	executeWhen Cn_Debug_FileDetails;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " numItems=" & numItems.String, null);
	endExecuteWhen;
	
	// unpack number of items
	fileEncryption	:= -1;																										// JSM PAR 7050
	foreach count in 1 to numItems do
		executeWhen Cn_Debug_FileDetails;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " [" & count.String & "] pos=" & self.pos.String, null);
		endExecuteWhen;
		
		len				:= self.byteOrderInteger(self.getField(buf, 4));		// length of directory name binary
		directory		:= self.getField(buf, len).ansiToString();
		fileStatus		:= self.byteOrderInteger(self.getField(buf, 4));
		fileType		:= self.getField(buf, 1).ansiToString().Character;

		len				:= self.byteOrderInteger(self.getField(buf, 4));		// length of fileName binary
		fileName		:= self.getField(buf, len).ansiToString();
		partitionId		:= self.byteOrderInteger64(getField(buf, 8));			// partitionIds binary
		fileSize		:= self.byteOrderInteger64(getField(buf, 8));			// fileSize binary
		udrSize			:= self.byteOrderInteger64(getField(buf, 8));			// udrSize binary
		if self.protocolVersion > 20 then		// 3.5.02
			udrStructures	:= self.byteOrderInteger64(getField(buf, 8));		// udrStructures binary
		endif;
		
		if self.protocolVersion > 34 then		// 3.9.03																		// JSM PAR 7050
			fileEncryption	:= self.byteOrderInteger(getField(buf, 4));			// file encryption status						// JSM PAR 7050
		endif;																													// JSM PAR 7050

		frozen			:= getField(buf, 1).ansiToString().Character.Boolean;	// frozen binary
		offline			:= getField(buf, 1).ansiToString().Character.Boolean;	// offline binary

		self.directoryNameArray.add(directory);
		self.fileStatusArray.add(fileStatus);
		self.fileTypeArray.add(fileType);
		self.fileNameArray.add(fileName);
		self.partitionIdArray.add(partitionId);
		self.fileLengthArray.add(fileSize);
		self.udrLengthArray.add(udrSize);
		self.udrStructuresArray.add(udrStructures);
		self.fileFrozenArray.add(frozen);
		self.fileOfflineArray.add(offline);
		self.fileEncryptionArray.add(fileEncryption);																			// JSM PAR 7050
		
		executeWhen Cn_Debug_FileDetails;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " [" & count.String & "] fileName=" & fileName & 
 																				", directory=" & directory &
																				", fileStatus=" & fileStatus.String & 
																				", fileType=" & fileType & 
																				", fileEncryption=" & fileEncryption.String &	// JSM PAR 7050
																				", partitionId=" & partitionId.String &
																				", fileSize=" & fileSize.String &
																				", udrSize=" & udrSize.String &
																				", udrStructures=" & udrStructures.String &
																				", frozen=" & frozen.String &
																				", offline=" & offline.String, null);
		endExecuteWhen;
	endforeach;
end;
}
zLoadThinClient
{
zLoadThinClient(buf: Binary) updating;

vars
	count,
	len,
	numItems			: Integer;
	
	fileSize			: Integer64;

	str					: String;
	
	modified			: TimeStamp;
begin
	numItems			:= self.byteOrderInteger(self.getField(buf, 4));

	// unpack number of items
	foreach count in 1 to numItems do
		len				:= self.byteOrderInteger(self.getField(buf, 4));		// length of directory name binary
		str				:= self.getField(buf, len).ansiToString();
		self.directoryNameArray.add(str);

		len		:= self.byteOrderInteger(self.getField(buf, 4));		// length of fileName binary
		str		:= self.getField(buf, len).ansiToString();
		self.fileNameArray.add(str);

		len		:= self.byteOrderInteger(self.getField(buf, 4));		// length of MD5 hash binary
		str		:= self.getField(buf, len).ansiToString();
		self.fileMD5HashArray.add(str);

		len		:= self.byteOrderInteger(self.getField(buf, 4));		// length of MD5 hash binary
		str		:= self.getField(buf, len).ansiToString();
		self.fileVersionArray.add(str);

		fileSize	:= self.byteOrderInteger64(getField(buf, 8));		// fileSize binary
		self.fileLengthArray.add(fileSize);

		modified	:= self.byteOrderTimeStamp(getField(buf, 8));			// length of modified timestamp binary
		self.fileModifiedArray.add(modified);
	endforeach;
end;
}
zLoadUserPatches
{
zLoadUserPatches(buf: Binary) updating;

vars
	count,
	len,
	numItems			: Integer;
	
	str					: String;
	
	char				: Character;
	
	ts					: TimeStamp;
begin
	numItems			:= self.byteOrderInteger(self.getField(buf, 4));

	// unpack file types
	foreach count in 1 to numItems do
		char			:= self.getField(buf, 1).ansiToString().Character;
		self.fileTypeArray.add(char);

		len				:= self.byteOrderInteger(self.getField(buf, 4));		// length of fileName binary
		str				:= self.getField(buf, len).ansiToString();
		self.fileNameArray.add(str);

		ts				:= self.byteOrderTimeStamp(getField(buf, 8));			// length of modified timestamp binary
		self.fileModifiedArray.add(ts);
	endforeach;
end;
}
	)
	CnNodeStatsAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;

vars
	
begin
	return inheritMethod()							&
		   statsVersion.Binary 						&
		   timestamp.Binary							&
		   nodeId.length.Binary						&
		   cnAnsiBinary(nodeId)						& 
		   dataLength.Binary						&
		   data										;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars
	len		: Integer;
begin
	inheritMethod(buf);
	
	self.statsVersion	:= byteOrderInteger(getField(buf, 4));
	self.timestamp		:= byteOrderTimeStamp(getField(buf, 8));
	len					:= byteOrderInteger(getField(buf, 4));
	self.nodeId			:= getField(buf, len).ansiToString;
	self.dataLength		:= byteOrderInteger(getField(buf, 4));
	self.data			:= getField(buf, dataLength);
end;
}
setData
{
setData(pData : Binary) updating;

vars

begin
	self.data := pData;
end;
}
setDataLength
{
setDataLength(len : Integer) updating;

vars

begin
	self.dataLength := len;
end;
}
setNodeId
{
setNodeId(pName : String) updating;

vars

begin
	self.nodeId := pName;
end;
}
setStatsVersion
{
setStatsVersion(version : Integer) updating;

vars

begin
	self.statsVersion := version;
end;
}
setTimestamp
{
setTimestamp(ts : TimeStamp) updating;

vars

begin
	self.timestamp := ts;
end;
}
	)
	CnPingReplyAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;

vars
	buf,
 	buf2	: Binary;
	
	trash	: Boolean;
begin
	buf		:= inheritMethod()			&
	timestamp.Binary					;
	
	if self.appName = CN_KCCMGR then
		if self.protocolVersion > 36 then
			buf2 :=	primaryServerName.length().Binary &
					cnAnsiBinary(primaryServerName);
		
		else
			buf2 := cnAnsiBinary(primaryServerName.padBlanks(9));
		endif;

		buf		:= buf 						&		
			connectedSecondaryServers.Binary	&
			connectionCheckInterval.Binary		&
			connectionState.Binary				&
			databaseRole.Binary					&
			databaseSubrole.Binary				&
			lastReplayJournalNumber.Binary		&
			lastReplayJournalTimeStamp.Binary	&
			latestReadyJournalNumber.Binary		&
			latestReadyJournalTimeStamp.Binary	&
			latestReplayedAuditTimeStamp.Binary	&
			latestStableAuditTimeStamp.Binary	&
			myName.length.Binary				&
			cnAnsiBinary(myName)				&
			primaryHostName.length.Binary		&
			cnAnsiBinary(primaryHostName)		&
			buf2								&
			reconnectInterval.Binary			&
			reorgStatus.Binary					&
			state.Binary						&
			syncMode.Binary						&
			cnAnsiBinary(sdsTracking.Character)	&
			sdsTrackingStoppedReason.Binary		&
			rpsTransitionHaltCode.Binary		&
			sdsLastErrorCode.Binary				&
			cnAnsiBinary(sdsTrackingDisabled.Character) &
			cnAnsiBinary(trash.Character)	&
			rpsWorkers.Binary					&
			cnAnsiBinary(isMultiUser.Character)	;
		
	endif;
	
	return buf;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars

begin
	inheritMethod(buf);
 	self.timestamp := byteOrderTimeStamp(getField(buf, 8));
end;
}
setIsMultiUser
{
setIsMultiUser(set : Boolean) updating;

vars

begin
	self.isMultiUser := set;
end;
}
setTimestamp
{
setTimestamp(ts : TimeStamp) updating;

vars

begin
 	self.timestamp := ts;
end;
}
	)
	CnSDSAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;

vars
	bin	: Binary;
begin
	bin	:= inheritMethod()									&
		   cnAnsiBinary(commandType.padBlanks(8))			&
		   cnAnsiBinary(adviceType.padBlanks(8))			&
		   cnAnsiBinary(masterEnvironmentId.padBlanks(9))	&
		   app.actualTime.localToUTCTime().Binary			&		// PAR 537
		   connectionState.Binary	 						&
		   databaseRole.Binary								&
		   lastReplayJournalNumber.Binary 					&
		   maxReplayedTranId.Binary							&
		   text.length.Binary								&
		   cnAnsiBinary(text)								&
		   cnAnsiBinary(sdsTracking.Character)				&
		   sdsLastErrorCode.Binary							&
		   cnAnsiBinary(sdsTrackingDisabled.Character)		&
		   sdsTrackingStoppedReason.Binary					&
		   rpsTransitionHaltCode.Binary						&		   
		   cnAnsiBinary(raiseAlert.Character)				&
		   cnAnsiBinary(hostileTakeover.Character)			&		// 3.5
		   databaseSubrole.Binary;									// 3.7.03 PAR 5299
		   
	return bin;
end;
}
setAdviceType
{
setAdviceType(pType : String) updating;

vars

begin
	self.adviceType := pType;
end;
}
setCommandType
{
setCommandType(pCommand : String) updating;

vars

begin
	self.commandType := pCommand;
end;
}
setConnectionState
{
setConnectionState(state : Integer) updating;

vars

begin
	self.connectionState := state;
end;
}
setDatabaseRole
{
setDatabaseRole(pRole : Integer) updating;

vars

begin
	self.databaseRole := pRole;
end;
}
setDatabaseSubrole
{
setDatabaseSubrole(pValue : Integer) updating;

vars

begin
	self.databaseSubrole := pValue;
end;
}
setHostileTakeover
{
setHostileTakeover(pValue : Boolean) updating;

vars

begin
	self.hostileTakeover := pValue;
end;
}
setLastReplayJournalNumber
{
setLastReplayJournalNumber(pJournal : Integer) updating;

vars

begin
	self.lastReplayJournalNumber := pJournal;
end;
}
setMasterEnvironmentId
{
setMasterEnvironmentId(id : String) updating;

vars

begin
	self.masterEnvironmentId := id;
end;
}
setMaxReplayedTranId
{
setMaxReplayedTranId(pTranId : Decimal) updating;

vars

begin
	self.maxReplayedTranId := pTranId;
end;
}
setRaiseAlert
{
setRaiseAlert(set : Boolean) updating;

vars

begin
	self.raiseAlert := set;
end;
}
setRpsTransitionHaltCode
{
setRpsTransitionHaltCode(code : Integer) updating;

vars

begin
	self.rpsTransitionHaltCode := code;
end;
}
setSdsLastErrorCode
{
setSdsLastErrorCode(code : Integer) updating;

vars

begin
	self.sdsLastErrorCode := code;
end;
}
setSdsTracking
{
setSdsTracking(set : Boolean) updating;

vars

begin
	self.sdsTracking := set;
end;
}
setSdsTrackingDisabled
{
setSdsTrackingDisabled(set : Boolean) updating;

vars

begin
	self.sdsTrackingDisabled := set;
end;
}
setSdsTrackingStoppedReason
{
setSdsTrackingStoppedReason(reason : Integer) updating;

vars

begin
	self.sdsTrackingStoppedReason := reason;
end;
}
setText
{
setText(str: String) updating;

vars

begin
	self.text	:= str;
end;
}
	)
	CnSSLAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;

vars
	bin				: Binary;
	
	cipherString,
	str				: String;
begin
	foreach str in self.sslCipherNames do
		cipherString := cipherString & str & CN_PIPE;
	endforeach;
	
	bin	:= inheritMethod()												&
		   self.nodeId.length().Binary									&	// 4
		   cnAnsiBinary(self.nodeId)									&	// use previous item length
		   cnAnsiBinary(self.rpcEncryptionEnabled.Character)			&	// 1
		   self.sslSecurePort.length().Binary							&	// 4
		   cnAnsiBinary(self.sslSecurePort)								&	// use previous item length
		   self.sslCertificateAuthFile.length().Binary					&	// 4
		   cnAnsiBinary(self.sslCertificateAuthFile)					&	// use previous item length
		   cnAnsiBinary(self.sslCertificateAuthFileResident.Character)	&	// 1
		   self.sslCertificateAuthFileSubject.length().Binary			&	// 4
		   cnAnsiBinary(self.sslCertificateAuthFileSubject)				&	// use previous item length
		   self.sslCertificateAuthFileExpiry.Binary						&	// 4
		   self.sslCertificateFile.length().Binary						&	// 4
		   cnAnsiBinary(self.sslCertificateFile)						&	// use previous item length
		   cnAnsiBinary(self.sslCertificateFileResident.Character)		&	// 1
		   self.sslCertificateFileSubject.length().Binary				&	// 4
		   cnAnsiBinary(self.sslCertificateFileSubject)					&	// use previous item length
		   self.sslCertificateFileExpiry.Binary							&	// 4
		   cnAnsiBinary(self.sslMethodName.padBlanks(10))				&	// 10
		   cipherString.length().Binary									&	// 4
		   cnAnsiBinary(cipherString);										// use previous item length

	return bin;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars
	len				: Integer;
	
	cipherString	: String;
begin
	inheritMethod(buf);
	len									:= byteOrderInteger(getField(buf, 4));
	self.nodeId							:= getField(buf, len).ansiToString();

	self.rpcEncryptionEnabled			:= getField(buf, 1).Character.Boolean;
	
	len									:= byteOrderInteger(getField(buf, 4));
	self.sslSecurePort					:= getField(buf, len).ansiToString();

	// SSL Ceritificate Authority File
	len									:= byteOrderInteger(getField(buf, 4));
	self.sslCertificateAuthFile			:= getField(buf, len).ansiToString();
	self.sslCertificateAuthFileResident	:= getField(buf, 1).Character.Boolean;
	len									:= byteOrderInteger(getField(buf, 4));
	self.sslCertificateAuthFileSubject	:= getField(buf, len).ansiToString();
	self.sslCertificateAuthFileExpiry	:= byteOrderDate(getField(buf, 4));

	// SSL Ceritificate File
	len									:= byteOrderInteger(getField(buf, 4));
	self.sslCertificateFile				:= getField(buf, len).ansiToString();
	self.sslCertificateFileResident		:= getField(buf, 1).Character.Boolean;
	len									:= byteOrderInteger(getField(buf, 4));
	self.sslCertificateFileSubject		:= getField(buf, len).ansiToString();
	self.sslCertificateFileExpiry		:= byteOrderDate(getField(buf, 4));

	self.sslMethodName					:= getField(buf, 10).ansiToString().trimBlanks();

	len									:= byteOrderInteger(getField(buf, 4));
	cipherString						:= getField(buf, len).ansiToString();
	
	self.sslCipherNames.cnGetTokens(cipherString, CN_PIPE, true);
end;
}
setNodeId
{
setNodeId(pValue : String) updating;

vars

begin
	self.nodeId := pValue;
end;
}
setRPCEncryptionEnabled
{
setRPCEncryptionEnabled(pValue : Boolean) updating;

vars

begin
	self.rpcEncryptionEnabled := pValue;
end;
}
setSSLCertificateAuthDetail
{
setSSLCertificateAuthDetail(pFileName		: String;
							pFileResident	: Boolean;
							pSubject 		: String; 
							pExpiryDate 	: Date) updating;

vars

begin
	self.sslCertificateAuthFile			:= pFileName;
	self.sslCertificateAuthFileResident	:= pFileResident;
	self.sslCertificateAuthFileSubject	:= pSubject;
	self.sslCertificateAuthFileExpiry	:= pExpiryDate;
end;
}
setSSLCertificateFileDetail
{
setSSLCertificateFileDetail(pFileName		: String;
							pFileResident	: Boolean;
							pSubject 		: String; 
							pExpiryDate 	: Date) updating;

vars

begin
	self.sslCertificateFile			:= pFileName;
	self.sslCertificateFileResident	:= pFileResident;
	self.sslCertificateFileSubject	:= pSubject;
	self.sslCertificateFileExpiry	:= pExpiryDate;
end;
}
setSSLMethodName
{
setSSLMethodName(pValue : String) updating;

vars

begin
	self.sslMethodName	:= pValue;
end;
}
setSSLSecurePort
{
setSSLSecurePort(pValue : String) updating;

vars

begin
	self.sslSecurePort	:= pValue;
end;
}
	)
	CnSessionAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;

vars
 	bin : Binary;
 	ts : TimeStamp;
 	cc : CnCntrl;
begin
	bin := 	inheritMethod							&
		 	self.timestamp.Binary					&
			self.currentClientSchemaVersion.Binary	&
			self.currentClientBinVersion.Binary		&
	 		self.currentClientMiscVersion.Binary	&
	 		self.nextClientSchemaVersion.Binary		&
	 		self.nextClientBinVersion.Binary		&
	 		self.nextClientMiscVersion.Binary		&
	 		self.priorClientSchemaVersion.Binary	&
	 		self.priorClientBinVersion.Binary		&
	 		self.priorClientMiscVersion.Binary		&

	 		self.currentServerSchemaVersion.Binary	&
	 		self.currentServerBinVersion.Binary		&
	 		self.currentServerMiscVersion.Binary	&
	 		self.nextServerSchemaVersion.Binary		&
	 		self.nextServerBinVersion.Binary		&
	 		self.nextServerMiscVersion.Binary		&
	 		self.priorServerSchemaVersion.Binary	&
	 		self.priorServerBinVersion.Binary		&
	 		self.priorServerMiscVersion.Binary		&
			cnAnsiBinary(self.schemaChangePending.Character);

	cc := app.myCnCntrl;
	if self.protocolVersion > 5 then
		bin := 	bin 								&
				currentThinClientBinVersion.Binary	&
				currentThinClientMiscVersion.Binary &
				nextThinClientBinVersion.Binary		&
				nextThinClientMiscVersion.Binary;
				cc := app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogMsgAssemble, method.cnGetMethodName() & " nextThinClientMiscVersion=" & nextThinClientMiscVersion.String, null);

 	endif;
 	
	cc.cnWriteLog(cc.CnLogMsgAssemble, method.cnGetMethodName() & " bin length=" & bin.length().String, null);
	return bin; 	
epilog
//	self.zDebug(method, "bin.length=" & bin.length().String);
end;
}
buildMsg
{
buildMsg(): String updating;

vars
	result : String;

	ts 	: TimeStamp;
begin
 	result := inheritMethod();
 	if result <> CN_OK then
 		return result;
 	endif;

	self.timestamp := ts.cnGMT();

 	return CN_OK;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars

begin
	inheritMethod(buf);

 	self.timestamp					:= byteOrderTimeStamp(getField(buf, 8));
 	self.currentClientSchemaVersion	:= byteOrderTimeStamp(getField(buf, 8));
 	self.currentClientBinVersion 	:= byteOrderTimeStamp(getField(buf, 8));
 	self.currentClientMiscVersion 	:= byteOrderTimeStamp(getField(buf, 8));

 	self.nextClientSchemaVersion	:= byteOrderTimeStamp(getField(buf, 8));
 	self.nextClientBinVersion 		:= byteOrderTimeStamp(getField(buf, 8));
 	self.nextClientMiscVersion 		:= byteOrderTimeStamp(getField(buf, 8));

 	self.priorClientSchemaVersion	:= byteOrderTimeStamp(getField(buf, 8));
 	self.priorClientBinVersion 		:= byteOrderTimeStamp(getField(buf, 8));
 	self.priorClientMiscVersion		:= byteOrderTimeStamp(getField(buf, 8));

 	self.currentServerSchemaVersion	:= byteOrderTimeStamp(getField(buf, 8));
 	self.currentServerBinVersion 	:= byteOrderTimeStamp(getField(buf, 8));
 	self.currentServerMiscVersion 	:= byteOrderTimeStamp(getField(buf, 8));

 	self.nextServerSchemaVersion	:= byteOrderTimeStamp(getField(buf, 8));
 	self.nextServerBinVersion 		:= byteOrderTimeStamp(getField(buf, 8));
 	self.nextServerMiscVersion 		:= byteOrderTimeStamp(getField(buf, 8));

 	self.priorServerSchemaVersion	:= byteOrderTimeStamp(getField(buf, 8));
 	self.priorServerBinVersion 		:= byteOrderTimeStamp(getField(buf, 8));
 	self.priorServerMiscVersion		:= byteOrderTimeStamp(getField(buf, 8));
 	self.schemaChangePending		:= getField(buf, 1).ansiToString.Character.Boolean;

 	if self.protocolVersion > 5 then
 		currentThinClientBinVersion		:= byteOrderTimeStamp(getField(buf, 8));
 		currentThinClientMiscVersion	:= byteOrderTimeStamp(getField(buf, 8));
 		nextThinClientBinVersion		:= byteOrderTimeStamp(getField(buf, 8));
 		nextThinClientMiscVersion		:= byteOrderTimeStamp(getField(buf, 8));
 	endif;
epilog
//	self.zDebug(method, "end of method, pos=" & self.pos.String);
end;
}
setCurrentClientVersions
{
setCurrentClientVersions(schema : TimeStamp; bin : TimeStamp; misc : TimeStamp) updating;

vars

begin
 	self.currentClientSchemaVersion := schema;
 	self.currentClientBinVersion	:= bin;
 	self.currentClientMiscVersion	:= misc;
end;
}
setCurrentServerVersions
{
setCurrentServerVersions(schema : TimeStamp; bin : TimeStamp; misc : TimeStamp) updating;

vars

begin
 	self.currentServerSchemaVersion := schema;
 	self.currentServerBinVersion	:= bin;
 	self.currentServerMiscVersion	:= misc;
end;
}
setCurrentThinClientVersions
{
setCurrentThinClientVersions(bin, misc : TimeStamp) updating;

vars

begin
	self.currentThinClientBinVersion 	:= bin;
	self.currentThinClientMiscVersion	:= misc;
end;
}
setNextClientVersions
{
setNextClientVersions(schema : TimeStamp; bin : TimeStamp; misc : TimeStamp) updating;

vars

begin
	self.nextClientSchemaVersion	:= schema;
	self.nextClientBinVersion		:= bin;
	self.nextClientMiscVersion		:= misc;
end;
}
setNextServerVersions
{
setNextServerVersions(schema : TimeStamp; bin : TimeStamp; misc : TimeStamp) updating;

vars
	file		: File;
	kc			: CnKarmaCntrl;
	fileRoot	: String;
	cc			: CnCntrl;
begin
	kc		:= app.myCnKarmaCntrl;
	cc		:= app.myCnCntrl;
	
	if app.cnOSPlatformIsWindows then
		fileRoot	:= kc.driveLetter & ":";
	else
		fileRoot	:= "/opt";
	endif;
	
	create file transient;
	file.fileName	:= app.cnGetPath(fileRoot, self.managedEnvironmentName, CN_SERVER, CN_N_MISC, true) & "/distribution_incomplete.htm";
	
	if not file.isAvailable then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " checked for " & file.fileName & " : not found.", null);
		self.nextServerSchemaVersion	:= schema;
		self.nextServerBinVersion		:= bin;
		self.nextServerMiscVersion		:= misc;
	else
		self.nextServerSchemaVersion.setDate(1.Date);			// 3.1 
		self.nextServerBinVersion.setDate(1.Date);
		self.nextServerMiscVersion.setDate(1.Date);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " checked for " & file.fileName & " : file is present : will ignore version control file timestamps.", null);
	endif;
	
epilog
	delete file;
end;
}
setNextThinClientVersions
{
setNextThinClientVersions(bin, misc : TimeStamp) updating;

vars

begin
	self.nextThinClientBinVersion 	:= bin;
	self.nextThinClientMiscVersion	:= misc;
end;
}
setPriorClientVersions
{
setPriorClientVersions(schema : TimeStamp; bin : TimeStamp; misc : TimeStamp) updating;

vars

begin
	self.priorClientSchemaVersion	:= schema;
	self.priorClientBinVersion		:= bin;
	self.priorClientMiscVersion		:= misc;
end;
}
setPriorServerVersions
{
setPriorServerVersions(schema : TimeStamp; bin : TimeStamp; misc : TimeStamp) updating;

vars

begin
	self.priorServerSchemaVersion	:= schema;
	self.priorServerBinVersion		:= bin;
	self.priorServerMiscVersion		:= misc;
end;
}
setSchemaChangePending
{
setSchemaChangePending(set : Boolean) updating;

vars

begin
  	self.schemaChangePending := set;
end;
}
setTimestamp
{
setTimestamp(ts : TimeStamp) updating;

vars

begin
 	self.timestamp := ts;
end;
}
	)
	CnSchemaCopyCompleteAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;

vars
	bin : Binary;
begin
 	bin := inheritMethod							&
 		   cnAnsiBinary(copyFailed.Character)			&
 		   cnAnsiBinary(copyMessage.padBlanks(300))	&
 		   cnAnsiBinary(isServer.Character)			;
 		   
 	return bin;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars

begin
	inheritMethod(buf);

	self.copyFailed 	:= getField(buf, 1).ansiToString.Character.Boolean;
	self.copyMessage 	:= getField(buf, 300).ansiToString.trimRight;			
	self.isServer		:= getField(buf, 1).Character.Boolean;
end;
}
setCopyFailed
{
setCopyFailed(set : Boolean) updating;

vars

begin
 	self.copyFailed := set;
end;
}
setCopyMessage
{
setCopyMessage(text : String) updating;

vars

begin
	self.copyMessage := text;
end;
}
setIsServer
{
setIsServer(set : Boolean) updating;

vars

begin
 	self.isServer := set;
end;
}
	)
	CnSessionOpenAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg() : Binary updating;

vars
 	bin 	: Binary;
 	mapbin	: Binary;
 	buf		: Binary;
 	str		: String;
 	i, sz	: Integer;
 	cc		: CnCntrl;
 	ts		: TimeStamp;
begin
	cc := app.myCnCntrl;
	
	if self.protocolVersion > 22 then
		bin := inheritMethod											&
 			cnAnsiBinary(cardSchemaVersion.padBlanks(10))				&
 			cnAnsiBinary(jadeVersion.padBlanks(10))						&
			licenceCompany.length().Binary								&
 			cnAnsiBinary(licenceCompany)								&
			licenceSerial.length().Binary								&
 			cnAnsiBinary(licenceSerial)									&
 			licenceProcesses.Binary										&
 			cnAnsiBinary(licenceRestriction)							&
 			licenceMaxDbSize.Binary										&
 			licenceSecondaries.Binary									&
			licenceUUID.length().Binary									&
 			cnAnsiBinary(licenceUUID)									&
 			licenceDevelopers.Binary									&
 			licenceNodes.Binary											&
			thinClientComputerIpAddress.length().Binary					&		// 3.7
 			cnAnsiBinary(thinClientComputerIpAddress) 					&		// 3.7
			v6IpAddress.length().Binary									&		// 3.7
			cnAnsiBinary(v6IpAddress) 									&		// 3.7
			thinClientComputerName.length().Binary						&		// 3.7
 			cnAnsiBinary(thinClientComputerName)	 					&		// 3.7
 			osPID.Binary;
	
	else
		bin := inheritMethod											&
 			cnAnsiBinary(cardSchemaVersion.padBlanks(10))				&
 			cnAnsiBinary(jadeVersion.padBlanks(10))						&
 			cnAnsiBinary(licenceCompany.padBlanks(50))					&
 			cnAnsiBinary(licenceSerial.padBlanks(40))					&
 			licenceProcesses.Binary										&
 			cnAnsiBinary(licenceRestriction)							&
 			licenceMaxDbSize.Binary										&
 			licenceSecondaries.Binary									&
 			cnAnsiBinary(licenceUUID.padBlanks(50))						&
 			licenceDevelopers.Binary									&
 			licenceNodes.Binary											&
			cnAnsiBinary(thinClientComputerIpAddress.padBlanks(15)) 	&
 			cnAnsiBinary(thinClientComputerName.padBlanks(64))			&
 			osPID.Binary;
	endif;
			
	if self.protocolVersion > 17 then
		if self.protocolVersion > 22 then
			bin := bin &
					distributionNode.length().Binary				&				// 3.7
					cnAnsiBinary(distributionNode) 					&				// 3.7
					distributionProcess.length().Binary				&				// 3.7
					cnAnsiBinary(distributionProcess);								// 3.7
				
		else
			bin := bin &
					cnAnsiBinary(distributionNode.padBlanks(40)) 	&				// 3.4
					cnAnsiBinary(distributionProcess.padBlanks(40));				// 3.4
		endif;
		
		bin := bin 													&
				clientPersistentCache.Binary						&
				clientTransientCache.Binary							&
				clientMethodCache.Binary							&
				serverPersistentCache.Binary						&
				serverTransientCache.Binary							&
				serverRemoteTransientCache.Binary					&
				serverDatabaseCache.Binary;

	else
		bin := bin 													& 
				cnAnsiBinary(true.Character)						&				// 3.4 - no longer used
				clientPersistentCache.Integer.Binary				&
				clientTransientCache.Integer.Binary					&
				clientMethodCache.Integer.Binary					&
				serverPersistentCache.Integer.Binary				&
				serverTransientCache.Integer.Binary					&
				serverRemoteTransientCache.Integer.Binary			&
				serverDatabaseCache.Integer.Binary;
	endif;

	bin := bin 														&
 			cnAnsiBinary( isServerApp.Character)					&
 			cnAnsiBinary(clientTranStats.Character);
 	 	
 	if self.appName = CN_KCCMGR then
 		bin	:= bin & licenceExpiryDate.Binary;									// 2.8
 	endif;
 	
 	/////  2.8 add-ons  ////
 	if self.protocolVersion > 22 then
		bin := bin 													&
				applicationVersion.length().Binary					&
				cnAnsiBinary(applicationVersion);								// 3.7
	
	else
		bin := bin & cnAnsiBinary(applicationVersion.padBlanks(30));			// Extended to 30 bytes for 3.1 / 6.1
	endif;
	
	bin := bin &
	             cnAnsiBinary(productionMode.Character) 		&			// 2.8		// only KCCMgr uses this, however
	             cnAnsiBinary(deploymentSystem.Character)		&			// 2.8		//  "     "     "    "     "
 				 logPath.length.Binary	 						&			
				 cnAnsiBinary(logPath)							&			// unconditional for 3.0 (PAR 1521)
				 cnAnsiBinary(binDriveLetter)					&
				 virtualMachineName.length().Binary				&			// changed cluster handling for 3.2
				 cnAnsiBinary(virtualMachineName) 				&			// changed cluster handling for 3.2
				 clusterName.length().Binary					&			// changed cluster handling for 3.2
		   		 cnAnsiBinary(clusterName)						&			// changed cluster handling for 3.2
				 clusterGroup.length().Binary					&			// changed cluster handling for 3.2
		   		 cnAnsiBinary(clusterGroup)						&			// changed cluster handling for 3.2
				 preferredHostName.length().Binary				&			// changed cluster handling for 3.2
		   		 cnAnsiBinary(preferredHostName)				&			// changed cluster handling for 3.2
		   		 hostsInCluster.size.Binary;								// changed cluster handling for 3.2
 			   
	foreach str in self.hostsInCluster do
		bin	:= bin & str.length().Binary & cnAnsiBinary(str);				// changed cluster handling for 3.2
	endforeach; 		
 	
 	bin 	:= bin & cnAnsiBinary(self.isMultiUser.Character)			&
 			   databaseRole.Binary										&
 			   nodeId.length.Binary										&				// 3.0
 			   cnAnsiBinary(nodeId)										&				// 3.0
 		       cnAnsiBinary(nodeType.Character)							&				// 3.0
 		   	   self.processSignOnTime.Binary							;				// 3.1
	
 	if self.appName = CN_KCCMGR then
		bin		:= bin & self.nameFromCommandLine.length.Binary			&				// 3.2	
 				   cnAnsiBinary(self.nameFromCommandLine)				&				// 3.2
				   self.rpsStorageMode.Binary;											// 3.2
				   
		if self.protocolVersion > 25 then
			bin := bin &
					cnAnsiBinary(self.encryptionEnabled.Character)		&				// 3.7.05
				    cnAnsiBinary(self.encryptionMasterKeyVerified.Character);			// 3.7.05	
		endif;

		if self.protocolVersion > 36 then												// 4.0.02
			bin := bin &																// 4.0.02
					cnAnsiBinary(self.isSingleUserApplicationServer.Character);			// 4.0.02
		endif;																			// 4.0.02
	endif;
	
	if app.name = CN_KCCMGR then
		if self.protocolVersion > 22 then
			bin		:= bin &														// always attach platform & SDS stuff (all clients).
					   self.platformType.Binary								&		// 3.1
					   self.sdsPrimaryServerName.length().Binary			&		// 3.7
					   cnAnsiBinary(self.sdsPrimaryServerName)				&		// 3.7
					   self.sdsPrimaryHostFQDN.length.Binary				&		// 3.1
					   cnAnsiBinary(self.sdsPrimaryHostFQDN)				&		// 3.1
					   self.sdsConnectionState.Binary						&		// 3.1	
					   cnAnsiBinary(self.sdsTrackingDisabled.Character)		&		// 3.1
					   cnAnsiBinary(self.sdsTracking.Character)				&		// 3.1
					   self.sdsLastErrorCode.Binary							&		// 3.1
					   self.masterEnvironmentId.length().Binary				&		// 3.7
					   cnAnsiBinary(self.masterEnvironmentId)				&		// 3.7
					   self.sdsEnvironmentId.length().Binary				&		// 3.7
					   cnAnsiBinary(self.sdsEnvironmentId)					&		// 3.7
					   self.databaseSubrole.Binary							&		// 3.1
					   libraryNames.size.Binary								;

		else
			bin		:= bin &														// always attach platform & SDS stuff (all clients).
					   self.platformType.Binary								&		// 3.1
					   cnAnsiBinary(self.sdsPrimaryServerName.padBlanks(9))	&		// 3.1
					   self.sdsPrimaryHostFQDN.length.Binary				&		// 3.1
					   cnAnsiBinary(self.sdsPrimaryHostFQDN)				&		// 3.1
					   self.sdsConnectionState.Binary						&		// 3.1	
					   cnAnsiBinary(self.sdsTrackingDisabled.Character)		&		// 3.1
					   cnAnsiBinary(self.sdsTracking.Character)				&		// 3.1
					   self.sdsLastErrorCode.Binary							&		// 3.1
					   cnAnsiBinary(self.masterEnvironmentId.padBlanks(9))	&		// 3.1
					   cnAnsiBinary(self.sdsEnvironmentId.padBlanks(30))	&		// 3.1
					   self.databaseSubrole.Binary							&		// 3.1
					   libraryNames.size.Binary								;
		endif;
		
 		buf		:= null;
		sz		:= libraryNames.size;
 		
 		foreach i in 1 to sz do
 			buf	:= buf & cnAnsiBinary(libraryNames[i]) & cnAnsiBinary("|") &
 							    cnAnsiBinary(libraryVersions[i]) & cnAnsiBinary("|");
 		endforeach;
 		
 		bin		:= bin & buf.length.Binary & buf;	
 		buf		:= null;
 		
 		foreach ts in libraryModifyTimes do
 			buf	:= buf & ts.Binary;
 		endforeach;

		bin		:= bin & buf;
 	endif;
 	
 	return bin;
epilog
//	self.zDebug(method, "bin.length=" & bin.length().String);
end;
}
buildMsg
{
buildMsg(): String updating;

vars
 	result 			: String;
    fileroot		: String;
    cc				: CnCntrl;
    kc				: CnKarmaCntrl;
    file			: File;
    defaultTs		: TimeStamp;
    msg				: CnMessage;
    clientIsOnServer: Boolean;			// if true, then client is running on server
    serverNode		: Node;
    tcRoot			: String;
    str, str2		: String;
    posn			: Integer;
    envId			: String;
begin
	result := inheritMethod();
 	if result <> CN_OK then
 		return result;
 	endif;

 	cc 		:= app.myCnCntrl;
 	kc 		:= app.myCnKarmaCntrl;
 	envId	:= kc.environmentId.toLower;

 	if app.cnComputerNameAppServer = cc.myTransientGlobal.cnGetServerComputerName then	   
 		clientIsOnServer := true;
 	endif;

 	///  Find schema, misc and bin versions ///
 	
 	if app.cnOSPlatformIsWindows then								// NODE is Windows, not process
 		fileroot 	:= (kc.driveLetter & ":").toLower;				// we assume that the appserver doesn't have a UNC name for the install dir		
 	endif;

   	/////  Now get file timestamps for 'next' directories.  We don't bother with the 'current' 	//////
   	/////  directories because this is implicit if we get connected to our server.  So this 	//////
   	/////  message gets updated with 'current' version info by KarmaCommsMgr when it receives	//////
   	/////  and processes our message.															//////		  

	create file transient;
	file.usePresentationFileSystem	:= false;
	
	///////////////////////  n_schema  ///////////////////////////////////////////	

	if not process.isUsingThinClient then
		if clientIsOnServer then
			file.fileName        	:= app.cnGetPath(fileroot, envId, CN_SERVER, CN_N_SYSTEM, true) & "/" & envId & "_jom_" & D_schema_ver;
		else
			file.fileName        	:= app.cnGetPath(fileroot, envId, null, CN_N_SCHEMA, true) & "/" & envId & "_" & D_schema_ver;
		endif;
	
		if file.isAvailable then
			self.nextClientSchemaVersion := file.cnLastModifiedGMT;
		else
			cc.cnWriteLog(cc.CnLogDiag, "CnSessionOpenAdvice::buildMsg didn't find file " & file.fileName, null);
		endif;
	endif;
	
	////////////////////  n_bin  /////////////////////////////////////////////

	if clientIsOnServer then
		file.fileName			:= app.cnGetPath(fileroot, envId, CN_SERVER, CN_N_BIN, true) & "/" & envId & "_jom_" & D_bin_ver;
	else
		file.fileName			:= app.cnGetPath(fileroot, envId, null, CN_N_BIN, true) & "/" & envId & "_" & D_bin_ver;
	endif;

	if file.isAvailable then
		self.nextClientBinVersion := file.cnLastModifiedGMT;
	else
		cc.cnWriteLog(cc.CnLogDiag, "CnSessionOpenAdvice::buildMsg didn't find file " & file.fileName, null);
	endif;
	
	//////////////////   n_misc   ////////////////////////////////////////////

	if clientIsOnServer then
		file.fileName			:= app.cnGetPath(fileroot, envId, CN_SERVER, CN_N_MISC, true) & "/" & envId & "_jom_" & D_misc_ver;
	else
		file.fileName			:= app.cnGetPath(fileroot, envId, null, CN_N_MISC, true) & "/" & envId & "_" & D_misc_ver;
	endif;

	if file.isAvailable then
		self.nextClientMiscVersion := file.cnLastModifiedGMT;
	else
		cc.cnWriteLog(cc.CnLogDiag, "CnSessionOpenAdvice::buildMsg didn't find file " & file.fileName, null);
	endif;

	self.setThinClientComputerIpAddress(kc.thinClientComputerIpAddress);
	self.setV6IpAddress(kc.v6IpAddress);
	self.setThinClientComputerName(kc.thinClientComputerName);
	self.setIsServerApp(app.cnIsServerApp);
	self.setClientTranStats(cc.clientTranStats);
epilog
	delete file;
end;
}
loadMsg
{
loadMsg(buf : Binary) updating;

vars
	len	: Integer;
	sz	: Integer;
	i	: Integer;
	occ	: Integer;
	str	: String;
begin
 	inheritMethod(buf);

	if self.protocolVersion > 22 then															// 3.7 release or greater
		cardSchemaVersion			:= getField(buf, 10).ansiToString().trimRight();
		jadeVersion 				:= getField(buf, 10).ansiToString().trimRight();
		len							:= byteOrderInteger(getField(buf, 4));						// 3.7
		licenceCompany				:= getField(buf, len).ansiToString();						// 3.7
		len							:= byteOrderInteger(getField(buf, 4));						// 3.7
		licenceSerial				:= getField(buf, len).ansiToString();						// 3.7
		licenceProcesses			:= byteOrderInteger(getField(buf, 4));
		licenceRestriction			:= getField(buf, 1).ansiToString().Character;
		licenceMaxDbSize			:= byteOrderInteger(getField(buf, 4));
		licenceSecondaries			:= byteOrderInteger(getField(buf, 4));
		len							:= byteOrderInteger(getField(buf, 4));						// 3.7
		licenceUUID					:= getField(buf, len).ansiToString();						// 3.7
		licenceDevelopers 			:= byteOrderInteger(getField(buf, 4));
		licenceNodes				:= byteOrderInteger(getField(buf, 4));
		len							:= byteOrderInteger(getField(buf, 4));						// 3.7
		thinClientComputerIpAddress	:= getField(buf, len).ansiToString();						// 3.7
		len							:= byteOrderInteger(getField(buf, 4));						// 3.7
		v6IpAddress					:= getField(buf, len).ansiToString();						// 3.7
		len							:= byteOrderInteger(getField(buf, 4));						// 3.7
		thinClientComputerName		:= getField(buf, len).ansiToString();						// 3.7
		osPID						:= byteOrderInteger(getField(buf, 4));

	else
		cardSchemaVersion			:= getField(buf, 10).ansiToString().trimRight();
		jadeVersion 				:= getField(buf, 10).ansiToString().trimRight();
		licenceCompany				:= getField(buf, 50).ansiToString().trimRight();
		licenceSerial				:= getField(buf, 40).ansiToString().trimRight();
		licenceProcesses			:= byteOrderInteger(getField(buf, 4));
		licenceRestriction			:= getField(buf, 1).ansiToString().Character;
		licenceMaxDbSize			:= byteOrderInteger(getField(buf, 4));
		licenceSecondaries			:= byteOrderInteger(getField(buf, 4));
		licenceUUID					:= getField(buf, 50).ansiToString().trimRight();
		licenceDevelopers 			:= byteOrderInteger(getField(buf, 4));
		licenceNodes				:= byteOrderInteger(getField(buf, 4));
		thinClientComputerIpAddress	:= getField(buf, 15).ansiToString().trimRight();
		thinClientComputerName		:= getField(buf, 64).ansiToString().trimRight();
		osPID						:= byteOrderInteger(getField(buf, 4));
	endif;
	
	
	if self.protocolVersion > 17 then															// 3.4
		if self.protocolVersion > 22 then
			len						:= byteOrderInteger(getField(buf, 4));						// 3.7
			distributionNode		:= getField(buf, len).ansiToString();						// 3.7
			len						:= byteOrderInteger(getField(buf, 4));						// 3.7
			distributionProcess		:= getField(buf, len).ansiToString();						// 3.7

		else
			distributionNode		:= getField(buf, 40).ansiToString().trimRight();			// 3.4
			distributionProcess		:= getField(buf, 40).ansiToString().trimRight();			// 3.4
		endif;
	else																						// 3.4
		str						:= getField(buf, 1).ansiToString();								// 3.4 - was usesJadeThinClient
	endif;
	
	if self.protocolVersion < 18 then															// 3.4
		clientPersistentCache		:= byteOrderInteger(getField(buf, 4));						// 3.4
		clientTransientCache		:= byteOrderInteger(getField(buf, 4));						// 3.4
		clientMethodCache			:= byteOrderInteger(getField(buf, 4));						// 3.4
	
		serverPersistentCache		:= byteOrderInteger(getField(buf, 4));						// 3.4
		serverTransientCache		:= byteOrderInteger(getField(buf, 4));						// 3.4
		serverRemoteTransientCache	:= byteOrderInteger(getField(buf, 4));						// 3.4
		serverDatabaseCache			:= byteOrderInteger(getField(buf, 4));						// 3.4
	
	else
		clientPersistentCache		:= byteOrderInteger64(getField(buf, 8));					// 3.4
		clientTransientCache		:= byteOrderInteger64(getField(buf, 8));					// 3.4
		clientMethodCache			:= byteOrderInteger64(getField(buf, 8));					// 3.4
	
		serverPersistentCache		:= byteOrderInteger64(getField(buf, 8));					// 3.4
		serverTransientCache		:= byteOrderInteger64(getField(buf, 8));					// 3.4
		serverRemoteTransientCache	:= byteOrderInteger64(getField(buf, 8));					// 3.4
		serverDatabaseCache			:= byteOrderInteger64(getField(buf, 8));					// 3.4
	endif;																						// 3.4

	isServerApp					:= getField(buf, 1).ansiToString().Character.Boolean;
	clientTranStats				:= getField(buf, 1).ansiToString().Character.Boolean;
	if self.protocolVersion > 22 then															// 3.7
		len						:= byteOrderInteger(getField(buf, 4));							// 3.7
		applicationVersion		:= getField(buf, len).ansiToString();							// 3.7
	
	else
		applicationVersion		:= getField(buf, 30).ansiToString().trimRight();
	endif;
	
	productionMode				:= getField(buf, 1).ansiToString().Character.Boolean;
	deploymentSystem			:= getField(buf, 1).ansiToString().Character.Boolean;
	
	len							:= byteOrderInteger(getField(buf, 4));
	logPath						:= getField(buf, len).ansiToString();
	binDriveLetter				:= getField(buf, 1).ansiToString().Character;					// unconditional for 3.0 - see PAR 1521
	if self.protocolVersion > 15 then															// 3.2 release
		// change cluster handling so we allow full lengths rather than 16 bytes per item
		sz := byteOrderInteger(getField(buf, 4));
		virtualMachineName			:= getField(buf, sz).ansiToString();
		
		sz := byteOrderInteger(getField(buf, 4));
		clusterName					:= getField(buf, sz).ansiToString();
		
		sz := byteOrderInteger(getField(buf, 4));
		clusterGroup				:= getField(buf, sz).ansiToString();
		
		sz	:= byteOrderInteger(getField(buf, 4));
		preferredHostName			:= getField(buf, sz).ansiToString();
		
		occ	:= byteOrderInteger(getField(buf, 4));
		
		foreach i in 1 to occ do
			sz := byteOrderInteger(getField(buf, 4));
			hostsInCluster.add(getField(buf, sz).ansiToString());
		endforeach;
		
	else
		virtualMachineName			:= getField(buf, 16).ansiToString().trimRight();	
		clusterName					:= getField(buf, 16).ansiToString().trimRight();
		preferredHostName			:= getField(buf, 16).ansiToString().trimRight();
		sz							:= byteOrderInteger(getField(buf, 4));
		
		foreach i in 1 to sz do
			hostsInCluster.add(getField(buf, 16).ansiToString().trimRight());
		endforeach;
	endif;
	
	self.isMultiUser			:= getField(buf, 1).ansiToString().Character.Boolean;	
	self.databaseRole			:= byteOrderInteger(getField(buf, 4));
	
	len							:= byteOrderInteger(getField(buf, 4));
	nodeId						:= getField(buf, len).ansiToString();
	nodeType					:= getField(buf, 1).ansiToString().Character;
	processSignOnTime			:= byteOrderTimeStamp(getField(buf, 8));			// 3.1
epilog
//	self.zDebug(method, "end of method, pos=" & self.pos.String);
end;
}
processMsg
{
processMsg(proc : Process) : String updating;

vars
	cnapp 			: CnApp;

	cc 				: CnCntrl;

	cnJadeProcess	: CnJadeProcess;

	kc	 			: CnKarmaCntrl;

	cnmach 			: CnMachine;
	
	nodeControl		: CnNodeControl;

	cnproc,
	cnproc2 		: CnProcess;
	
	sdsDba			: CnSDSDatabaseAdmin;

	nod				: Node;

	prc				: Process;

	error			: Boolean;
	posn 			: Integer;
	
	env_id,
	procid,
	result,
	str				: String;

	now				: TimeStamp;
begin
 	result := inheritMethod(proc);

 	if result <> CN_OK then
 		return result;
 	endif;

 	cc := app.myCnCntrl;
 	kc := app.myCnKarmaCntrl;

 	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & "...", null);

	cnmach := kc.allMachines[self.clientFQDN];
	if cnmach = null then
 		create cnmach;
 		cnmach.setClientFQDN(self.clientFQDN);
 		cnmach.setMyKarmaCntrl(kc);
		
 	else
 		cnapp := cnmach.allApps[self.appSchemaName, self.appName];
 	endif;

	if cnapp = null then
		create cnapp transient;
		cnapp.setAppSchemaName(self.appSchemaName);
		cnapp.setAppName(self.appName);
	endif;

 	cnmach.setIpAddress(self.clientIpAddress);
 	cnmach.setCurrentClientVersions(currentClientSchemaVersion, currentClientBinVersion, currentClientMiscVersion);
 	cnmach.setNextClientVersions(nextClientSchemaVersion, nextClientBinVersion, nextClientMiscVersion);
 	cnmach.setIsActive(true);

 	cnapp.setMyMachine(cnmach);
 	cnapp.setMyKarmaCntrl(kc);
 	cnapp.setMyCnCntrl(cc);
 	cnapp.setLogonTime(self.timestamp);				// GMT

 	self.environmentId := kc.environmentId[1:Cn_Max_EnvironmentName_Length];													// JSM PAR 7896
	
	// CnKarmaCntrl.allCnJadeProcesses contains ALL non-development processes including those that don't activate Karma Control
	cnJadeProcess := kc.allCnJadeProcesses[self.processId];
	if cnJadeProcess <> null then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & "  NODE_MONITOR end timer CN_PROCESS_REGISTRATION_TIMER for " & cnJadeProcess.String, null);
		cnJadeProcess.endTimer(CN_PROCESSREGISTRATION_TIMER);
	endif;

 	/////////////////  CnProcess  //////////////////////////////
	// CnKarmaCntrl.allCnProcesses contains only those JADE processes that have activated Karma Control
 	cnproc := kc.allCnProcesses[self.processId];
 	if cnproc = null then								// sometimes two CnSessionOpenAdvices can come through for
 		create cnproc;									// the same process, due to timing factors between KCCMgr and
 		cnproc.setProcessId(self.processId);			// KarmaCommsMgr, so the CnProcess object may already exist
 	endif;	

 	cnproc.setMyCnApp(cnapp);
 	cnproc.setMyProcess(proc);
	cnproc.setMyMachine(cnmach);
	cnproc.setComputerName(self.computerName);
 	cnproc.setStartTime(self.timestamp);				// GMT
 	cnproc.setOsPID(self.osPID);
 	cnproc.setClientTranStats(self.clientTranStats);	// application stats capture on
	
	// MFJ PAR 1050 - following 2 lines have been moved from after 'if kc.tranStatsInterval' conditional code					// PAR 1050
	//					to here as the SESSOPEN advice is still sent to JSA/JSM and was causing phantom							// PAR 1050
	//					master environments to be created due to timing issue.													// PAR 1050
 	self.databaseRole			:= system.getDatabaseRole;		// only KCCMgr should execute this ::processMsg method			// PAR 1050
	self.masterEnvironmentId	:= kc.masterEnvironmentId[1:Cn_Max_EnvironmentName_Length];	// PAR 570							// PAR 1050

 	on SystemException do app.cnHandleSpecifiedInvalidObjRef(exception, proc, error);
 	
 	if kc.tranStatsInterval > null then
 		proc.causeEvent(Cn_Tran_Stats_Timer_Change, true, kc.tranStatsInterval);
 		if error then 
 			return app.cnGetClassAndOid(proc) & " (" & self.appName & ") has gone away : won't forward advice.";
 		endif;
 		
 		if self.appName = CN_KCNODECONTROL then
 			nodeControl	:= cc.myNodeControl;
			proc.causeEvent(Cn_Node_Sampling_Status_Chg, true, nodeControl.sampleProcessStats.Character & nodeControl.sampleCacheStats.Character);
			if error then 
	 			return app.cnGetClassAndOid(proc) & " (" & self.appName & ") has gone away : won't forward advice.";
	 		endif;
 		endif;
 	endif;
 	
 	if self.databaseRole <> SDS_RoleUndefined then
 		sdsDba					:= app.myCnSDSDbAdmin;
 		sdsEnvironmentId		:= sdsDba.sdsEnvironmentId;
 	endif;

	cc.cnWriteLog(cc.CnLogDiag, "Processed SessionOpenAdvice OK, CnMachine=" &
    		 			cnmach.ipAddress & ", tranStatsInterval=" & kc.tranStatsInterval.String, null);
    return CN_OK;	
end;
}
setApplicationVersion
{
setApplicationVersion() updating;

vars

begin
	self.applicationVersion	:= app.cnGetApplicationVersion();
end;
}
setBinDriveLetter
{
setBinDriveLetter(char : Character) updating;

vars

begin
	self.binDriveLetter := char;
end;
}
setCardSchemaVersion
{
setCardSchemaVersion(version : String) updating;

vars

begin
 	self.cardSchemaVersion := version;
end;
}
setClientMethodCache
{
setClientMethodCache(size : Integer) updating;

vars

begin
  	self.clientMethodCache := size;
end;
}
setClientPersistentCache
{
setClientPersistentCache(size : Integer64) updating;

vars

begin
 	clientPersistentCache := size;
end;
}
setClientTranStats
{
setClientTranStats(set : Boolean) updating;

vars

begin
 	self.clientTranStats := set;
end;
}
setClientTransientCache
{
setClientTransientCache(size : Integer64) updating;

vars

begin
 	self.clientTransientCache := size;
end;
}
setClusterDetails
{
setClusterDetails(virtualName, clusterName, clusterGroup, preferredHost : String; hosts : StringArray) updating;

vars

begin
	self.virtualMachineName	:= virtualName;
	self.clusterName		:= clusterName;
	self.clusterGroup		:= clusterGroup;
	self.preferredHostName	:= preferredHost;
	
	self.hostsInCluster.clear();
	hosts.copy(self.hostsInCluster);	
end;
}
setDatabaseRole
{
setDatabaseRole(role : Integer) updating;

vars

begin
	self.databaseRole := role;
end;
}
setDatabaseSubrole
{
setDatabaseSubrole(pRole : Integer) updating;

vars

begin
	self.databaseSubrole := pRole;
end;
}
setDeploymentSystem
{
setDeploymentSystem(set : Boolean) updating;

vars

begin
	self.deploymentSystem := set;
end;
}
setDistributionNode
{
setDistributionNode(pDistributionName : String) updating;

vars

begin
	self.distributionNode := pDistributionName;
end;
}
setDistributionProcess
{
setDistributionProcess(pDistributionName : String) updating;

vars

begin
	self.distributionProcess := pDistributionName;
end;
}
setEncryptionEnabled
{
setEncryptionEnabled(pValue : Boolean) updating;

vars

begin
	self.encryptionEnabled := pValue;
end;
}
setEncryptionMasterKeyVerified
{
setEncryptionMasterKeyVerified(pValue : Boolean) updating;

vars

begin
	self.encryptionMasterKeyVerified := pValue;
end;
}
setIsMultiUser
{
setIsMultiUser(set : Boolean) updating;

vars

begin
	self.isMultiUser	:= set;
end;
}
setIsServerApp
{
setIsServerApp(set : Boolean) updating;

vars

begin
 	self.isServerApp := set;
end;
}
setIsSingleUserApplicationServer
{
setIsSingleUserApplicationServer(pValue : Boolean) updating;
// added in 4.0.02
vars

begin
	self.isSingleUserApplicationServer := pValue;
end;
}
setJadeVersion
{
setJadeVersion(version : String) updating;

vars

begin
  	self.jadeVersion := version;
end;
}
setLicenceCompany
{
setLicenceCompany(coy : String) updating;

vars

begin
 	self.licenceCompany := coy;
end;
}
setLicenceDevelopers
{
setLicenceDevelopers(dev : Integer) updating;

vars

begin
	self.licenceDevelopers := dev;
end;
}
setLicenceExpiryDate
{
setLicenceExpiryDate(date : Date) updating;

vars
	d : Date;
begin
	if date = null then
		self.licenceExpiryDate	:= "31/12/2199".Date;
	else
		self.licenceExpiryDate	:= date;
	endif;
end;
}
setLicenceMaxDbSize
{
setLicenceMaxDbSize(size : Integer) updating;

vars

begin
	self.licenceMaxDbSize := size;
end;
}
setLicenceNodes
{
setLicenceNodes(servers : Integer) updating;

vars

begin
  	self.licenceNodes := servers;
end;
}
setLicenceProcesses
{
setLicenceProcesses(procs : Integer) updating;

vars

begin
	self.licenceProcesses	:= procs;
end;
}
setLicenceRestriction
{
setLicenceRestriction(val : Character) updating;

vars

begin
	self.licenceRestriction := val;
end;
}
setLicenceSecondaries
{
setLicenceSecondaries(num : Integer) updating;

vars

begin
	self.licenceSecondaries := num;
end;
}
setLicenceSerial
{
setLicenceSerial(serial : String) updating;

vars

begin
  	self.licenceSerial := serial;
end;
}
setLicenceUUID
{
setLicenceUUID(uuid : String) updating;

vars

begin
	self.licenceUUID := uuid;
end;
}
setLogPath
{
setLogPath(path : String) updating;

vars

begin
	self.logPath := path;
end;
}
setMasterEnvironmentId
{
setMasterEnvironmentId(pValue : String) updating;

vars

begin
	self.masterEnvironmentId := pValue;
end;
}
setNameFromCommandLine
{
setNameFromCommandLine(pName : String) updating;

vars

begin
	self.nameFromCommandLine := pName;
end;
}
setNodeId
{
setNodeId(id : String) updating;

vars

begin
	self.nodeId := id;
end;
}
setNodeType
{
setNodeType(pType : Character) updating;

vars

begin
	self.nodeType	:= pType;
end;
}
setOsPID
{
setOsPID(pid : Integer) updating;

vars

begin
 	self.osPID := pid;
end;
}
setPlatformType
{
setPlatformType(pType : Integer) updating;

vars

begin
	self.platformType	:= pType;
end;
}
setProcessSignOnTime
{
setProcessSignOnTime(ts : TimeStamp) updating;

vars

begin
	self.processSignOnTime := ts;	
end;
}
setProductionMode
{
setProductionMode(set : Boolean) updating;

vars

begin
	self.productionMode := set;
end;
}
setRpsStorageMode
{
setRpsStorageMode(pInt : Integer) updating;

vars

begin
	self.rpsStorageMode := pInt;
end;
}
setSdsConnectionState
{
setSdsConnectionState(state : Integer) updating;

vars

begin
	self.sdsConnectionState := state;
end;
}
setSdsEnvironmentId
{
setSdsEnvironmentId(id : String) updating;

vars

begin
	self.sdsEnvironmentId	:= id;
end;
}
setSdsLastErrorCode
{
setSdsLastErrorCode(code : Integer) updating;

vars

begin
	self.sdsLastErrorCode := code;
end;
}
setSdsPrimaryHostFQDN
{
setSdsPrimaryHostFQDN(fqdn : String) updating;

vars

begin
	self.sdsPrimaryHostFQDN := fqdn;
end;
}
setSdsPrimaryServerName
{
setSdsPrimaryServerName(name : String) updating;

vars

begin
	self.sdsPrimaryServerName := name;
end;
}
setSdsTracking
{
setSdsTracking(set : Boolean) updating;

vars

begin
	self.sdsTracking := set;
end;
}
setSdsTrackingDisabled
{
setSdsTrackingDisabled(set : Boolean) updating;

vars

begin
	self.sdsTrackingDisabled := set;
end;
}
setServerDatabaseCache
{
setServerDatabaseCache(size : Integer64) updating;

vars

begin
  	self.serverDatabaseCache := size;
end;
}
setServerPersistentCache
{
setServerPersistentCache(size : Integer64) updating;

vars

begin
 	self.serverPersistentCache := size;
end;
}
setServerRemoteTransientCache
{
setServerRemoteTransientCache(size : Integer64) updating;

vars

begin
	self.serverRemoteTransientCache := size;
end;
}
setServerTransientCache
{
setServerTransientCache(size : Integer64) updating;

vars

begin
 	self.serverTransientCache := size;
end;
}
setThinClientComputerIpAddress
{
setThinClientComputerIpAddress(ipAddress : String) updating;

vars

begin
	thinClientComputerIpAddress := ipAddress;
end;
}
setThinClientComputerName
{
setThinClientComputerName(name : String) updating;

vars

begin
 	thinClientComputerName := name;
end;
}
setV6IpAddress
{
setV6IpAddress(pV6IpAddress : String) updating;

vars

begin
	self.v6IpAddress := pV6IpAddress;
end;
}
setupLicenceDetails
{
setupLicenceDetails() updating;

vars
	lic			: JadeLicenceInfo;
	company		: String;
	serial		: String;
	servers		: Integer;
	developers	: Integer;
begin
	create lic transient;
	lic.getLicenceInfo();
	system.getLicenceInfo(company, serial, servers, developers);	// we now only do this to get serial
	
	self.setLicenceCompany(lic.licenceName);
	self.setLicenceSerial(serial);
	self.setLicenceNodes(0);										// not used in JADE 6.0
	self.setLicenceProcesses(lic.processLicences);
	self.setLicenceDevelopers(lic.developmentLicences);
	self.setLicenceExpiryDate(lic.expiryDate);
	self.setLicenceMaxDbSize(lic.maxDBSize);
	self.setLicenceSecondaries(null);
	self.setLicenceRestriction(lic.licenceRestriction);
	self.setLicenceUUID(lic.uuid);

epilog
	delete lic;
end;
}
	)
	CnStatisticsAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;


vars
	bin : Binary;
begin
	bin := inheritMethod;
	bin := bin 					&
		   statsVersion.Binary	&
		   timestamp.Binary 	& 
		   dataLength.Binary 	& 
		   data;

	return bin;
end;
}
setData
{
setData(bin : Binary) updating;

vars

begin
 	self.data := bin;
end;
}
setDataLength
{
setDataLength(length : Integer) updating;

vars

begin
 	self.dataLength := length;
end;
}
setStatsVersion
{
setStatsVersion(ver : Integer) updating;

vars

begin
	self.statsVersion := ver;
end;
}
setTimestamp
{
setTimestamp(ts : TimeStamp) updating;

vars

begin
 	self.timestamp := ts;
end;
}
	)
	CnThreadAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating ;
// 
// concatenate the attributes into a binary buffer
//
vars
 	bin 		: Binary;
 	ts 			: TimeStamp;
 	charCount 	: Integer ;
 	i 			: Integer ;
	val 		: Integer ;
begin
	bin := inheritMethod()			&
		   procId.Binary			&
		   procName.length.Binary	;
		   
	if procName.length > 0 then
		bin := bin & cnAnsiBinary(procName);
	endif;
	 
	bin := bin 						&
		   sampleTime.Binary		&
		   sampleTimeGMT.Binary		&
		   tiKey.Binary				&		// key
		   numOfThreads.Binary		;

	i := 1 ;

	while i <= self.numOfThreads do			// attach info for each thread
		bin := bin					&
			   threadId[i].Binary	&
			   priority[i].Binary	&
			   state[i].Binary		&		// thread state
			   waitReason[i].Binary	;

		i := i + 1 ;
	endwhile ;

	return bin; 	
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

//
// examines the message and extracts the attributes
//
vars

	charCount : Integer ;

	i : Integer ;

	val : Integer ;

begin

	inheritMethod ( buf ) ;

	// Process id

	self.procId := byteOrderInteger(getField(buf, 4));

	// Process name

	charCount := byteOrderInteger(getField(buf, 4));

	if charCount > 0 then
		self.procName := getField ( buf , charCount ).ansiToString ;
	else
		self.procId := null ;
	endif ;

	// time at which sample was taken

	self.sampleTime := byteOrderTimeStamp(getField(buf, 8));

	self.sampleTimeGMT := byteOrderTimeStamp(getField(buf, 8));

	// key

	self.tiKey := byteOrderInteger(getField(buf, 4));

	// number of different values being reported back

	self.numOfThreads := byteOrderInteger(getField(buf, 4));

	// extract info for each thread

	i := 1 ;

	while i <= self.numOfThreads do

		// thread id

		self.threadId[i] := byteOrderInteger(getField(buf, 4));

		// Priority

		self.priority[i] := byteOrderInteger(getField(buf, 4));

		// state

		self.state[i] := byteOrderInteger(getField(buf, 4));

		// wait reason

		self.waitReason[i] := byteOrderInteger(getField(buf, 4));
		
		i := i + 1 ;

	endwhile ;


end;
}
setNumOfThreads
{
setNumOfThreads( arg : Integer ) updating;

vars

begin
    self.numOfThreads := arg ;
end;
}
setPriority
{
setPriority( indx : Integer ;  arg : Integer ) updating;

vars

begin
    self.priority[indx] := arg ;
end;
}
setProcId
{
setProcId( arg : Integer ) updating;

vars

begin
    self.procId := arg ;
end;
}
setProcName
{
setProcName( arg : String ) updating;

vars

begin
    self.procName := arg ;
end;
}
setSampleTime
{
setSampleTime ( arg : TimeStamp ) updating;

vars

begin
    self.sampleTime := arg ;
end;
}
setSampleTimeGMT
{
setSampleTimeGMT( ts : TimeStamp ) updating;

vars

begin
    self.sampleTimeGMT := ts ;
end;
}
setState
{
setState( indx : Integer ; arg : Integer ) updating;

vars

begin
    self.state[indx] := arg ;
end;
}
setThreadId
{
setThreadId( indx : Integer ; arg : Integer ) updating;

vars

begin
    self.threadId[indx] := arg ;
end;
}
setTiKey
{
setTiKey( arg : Integer ) updating;

vars

begin
    self.tiKey := arg ;
end;
}
setWaitReason
{
setWaitReason( indx : Integer ; arg : Integer ) updating;

vars

begin
    self.waitReason[indx] := arg ;
end;
}
	)
	CnTrapAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg() : Binary updating;

vars
 	bin 		: Binary;
 	ts 			: TimeStamp;
	charCount 	: Integer ;
	i 			: Integer ;
	numOfVars 	: Integer ;
begin
	bin := inheritMethod() 					&
		   format.Binary					&
		   sourceIpAddress.length.Binary	&
		   cnAnsiBinary(sourceIpAddress)	&
		   deviceIpAddress.length.Binary	&
		   cnAnsiBinary(deviceIpAddress)	&
		   enterprise.length.Binary			&
		   cnAnsiBinary(enterprise)			&
		   genericTrapNum.Binary			&
		   specificTrapNum.Binary			&
		   timestamp.Binary					;

	numOfVars := (self.varNames.size()).min(self.varValues.size()) ;
	bin := bin & numOfVars.Binary;
	
	i := 1 ;
	while i <= numOfVars do
		charCount := self.varNames[i].length() ;
		bin := bin & charCount.Binary;
		if charCount > 0 then
			bin := bin & cnAnsiBinary(varNames[i]);
		endif ;
		
		charCount := self.varValues[i].length() ;
		bin := bin & charCount.Binary;
		if charCount > 0 then
			bin := bin & cnAnsiBinary(varValues[i]);
		endif ;
		
		i := i + 1 ;
	endwhile ;
	
	return bin; 	
end;
}
loadMsg
{
loadMsg(buf : Binary) updating;
// examines the message and extracts the attributes
vars
	charCount 		: Integer ;
	numOfVars 		: Integer ;
	i 				: Integer ;
	vName , vValue 	: String ;
begin
	inheritMethod ( buf ) ;
	// format : currently 1 = SNMP vn 1 , 2 = SNMP vn 2 
	self.format := byteOrderInteger(getField(buf, 4));
	// source TCP/IP address - held as an 8 or 32-byte hex-digit string
	charCount := byteOrderInteger(getField(buf, 4));
	self.sourceIpAddress := getField ( buf , charCount ).ansiToString ;
	// device TCP/IP address
	charCount := byteOrderInteger(getField(buf, 4));
	self.deviceIpAddress := getField ( buf , charCount ).ansiToString ;
	// enterprise
	charCount := byteOrderInteger(getField(buf, 4));
	self.enterprise := getField ( buf , charCount ).ansiToString ;
	// generic trap num
	self.genericTrapNum := byteOrderInteger(getField(buf, 4));
	// specific trap num
	self.specificTrapNum := byteOrderInteger(getField(buf, 4));
	// time at which this trap was received
	self.timestamp := byteOrderTimeStamp(getField(buf, 8));
	// Now the variables
	numOfVars := byteOrderInteger(getField(buf, 4));
	i := 1 ;
	while i <= numOfVars do
		charCount := byteOrderInteger(getField(buf, 4));
		if charCount > 0 then
			vName := getField ( buf , charCount ).ansiToString ;
		endif ;
		charCount := byteOrderInteger(getField(buf, 4));
		if charCount > 0 then
			vValue := getField ( buf , charCount ).ansiToString ;
		endif ;
		self.varNames[i] := vName ;
		self.varValues[i] := vValue ;
		i := i + 1 ;
	endwhile ;
end;
}
processMsg
{
processMsg(proc : Process) : String updating;

vars
	cc			: CnCntrl;

	kc          : CnKarmaCntrl;

	ipToken     : CnStringArray;

	goodAddr,
	ipError     : Boolean;
	
	i,
	n,
	val			: Integer;
	
	clientIpAddr,
	hexIpAddr,
	result      : String;
begin
 	result := inheritMethod(proc);
	if result <> CN_OK then
 		return result;
 	endif;
	
	cc := app.myCnCntrl; 	
 	kc := app.myCnKarmaCntrl;
	if cc.appName <> CN_KARMACOMMSMGR or (self.clientIpAddress <> "127.0.0.1"	and
										  self.clientIpAddress <> "::1"			and 
										  self.clientIpAddress <> null)			then
		return CN_OK;
	endif;
	
	// need to fix up the TCP/IP address, because we did not know what it was before now
	clientIpAddr := kc.localIpAddress;
	if clientIpAddr = null then
		ipError := true;
		
	else
		ipToken := clientIpAddr.cnGetTokens(".");
		if ipToken.size() <> 4 then
			ipError := true;
			
		else
			hexIpAddr := app.myTransientCnIpAddress.v4DisplayToHex(clientIpAddr);
		endif;
	endif;
	
	if ipError then
    	return "Invalid client TCP/IP address" & "(" & clientIpAddr & ")";
	endif;
	
	self.setClientIpAddress(clientIpAddr);
	self.setDeviceIpAddress(hexIpAddr);
	self.setSourceIpAddress(hexIpAddr);
	
	cc.cnWriteLog(cc.CnLogDiag, "Processed CnTrapAdvice OK, client TCP/IP address=" & self.clientIpAddress, null);
    return CN_OK;	
epilog
	delete ipToken;
end;
}
setDeviceIpAddress
{
setDeviceIpAddress( ip : String ) updating;

vars

begin
	self.deviceIpAddress := ip ;
end;
}
setEnterprise
{
setEnterprise( ent : String ) updating;

vars

begin
	self.enterprise := ent ;
end;
}
setFormat
{
setFormat( i : Integer) updating ;

vars

begin
	self.format := i ;
end;
}
setGenericTrapNum
{
setGenericTrapNum( num : Integer ) updating;

vars

begin
    self.genericTrapNum := num ;
end;
}
setSourceIpAddress
{
setSourceIpAddress( ip : String ) updating;

vars

begin
	self.sourceIpAddress := ip ;
end;
}
setSpecificTrapNum
{
setSpecificTrapNum( num : Integer ) updating;

vars

begin
	self.specificTrapNum := num ;
end;
}
setTimestamp
{
setTimestamp( ts : TimeStamp ) updating;

vars

begin
	self.timestamp := ts ;
end;
}
setVarNameAndValue
{
setVarNameAndValue( ix : Integer ; vName : String ; vValue : String ) updating;

vars
	val		: String;
begin
	val		:= vValue;

	if vValue.length > 2030 then							// HugeStringArray max is 2047
		val		:= vValue[1:2030] & "....[truncated]";
	endif;

	self.varNames[ix] := vName;
	self.varValues[ix] := val;
end;
}
	)
	CnWatchAdvice (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating ;
// 
// concatenate the attributes into a binary buffer
//
vars
 	bin 		: Binary;
 	ts 			: TimeStamp;
	charCount 	: Integer ;
 	i 			: Integer ;
	val 		: Integer ;
begin
	bin := inheritMethod()				&
		   wiKey.Binary					& 
		   sampleTime.Binary			&
		   sampleTimeGMT.Binary			&
		   numOfValues.Binary			;

	i := 1 ;

	while i <= self.numOfValues do				// attach each value and its definition
		bin := bin 						&
		 	   objNum[i].Binary			&
		 	   ctrNum[i].Binary			&
		 	   instName[i].length.Binary;

		if instName[i].length > 0 then
			bin := bin & cnAnsiBinary(instName[i]);
		endif;

		if self.scaled[i] then					// flag to indicate if values are scaled by factor of 10 or not
			val := 1 ;
		else
			val := 0 ;
		endif;

		bin := bin						&
			   val.Binary				&
			   value[i].Binary			;		// actual mesaured value

		i := i + 1 ;
	endwhile ;

	return bin; 	
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;
//
// examines the message and extracts the attributes
//
vars
	charCount 	: Integer ;
	i 			: Integer ;
	val 		: Integer ;
begin

	inheritMethod ( buf ) ;

	// WatchInfo key num

	self.wiKey := byteOrderInteger(getField(buf, 4));

	// time at which sample was taken

	self.sampleTime := byteOrderTimeStamp(getField(buf, 8));

	self.sampleTimeGMT := byteOrderTimeStamp(getField(buf, 8));

	// number of different values being reported back

	self.numOfValues := byteOrderInteger(getField(buf, 4));

	// extract each value and its definition

	i := 1 ;

	while i <= self.numOfValues do

		// Performance object number

		self.objNum[i] := byteOrderInteger(getField(buf, 4));

		// Performance counter number

		self.ctrNum[i] := byteOrderInteger(getField(buf, 4));

		// instance name - number of characters followed by text

		charCount := byteOrderInteger(getField(buf, 4));

		if charCount > 0 then
			self.instName[i] := getField ( buf , charCount ).ansiToString ;
		else
			self.instName[i] := "" ;
		endif;

		// flag to indicate if values are scaled by factor of 10 or not

		val := byteOrderInteger(getField(buf, 4));

		self.scaled[i] := (val <> 0) ;

		// the actual measured value

		self.value[i] := byteOrderInteger(getField(buf, 4));

		i := i + 1 ;

	endwhile ;

end;
}
setCtrNum
{
setCtrNum( indx : Integer ; argCtrNum : Integer ) updating;

vars

begin
    self.ctrNum[indx] := argCtrNum ;
end;
}
setInstName
{
setInstName( indx : Integer ; argInstName : String ) updating;

vars

begin
    self.instName[indx] := argInstName[1:62];			// PAR 3790 - truncate name as may be mount point and can cause 1035 string too long
end;
}
setNumOfValues
{
setNumOfValues( argNumOfVals : Integer ) updating;

vars

begin
    self.numOfValues := argNumOfVals ;
end;
}
setObjNum
{
setObjNum( indx : Integer ; argObjNum : Integer ) updating;

vars

begin
    self.objNum[indx] := argObjNum ;
end;
}
setSampleTime
{
setSampleTime( argTime : TimeStamp ) updating;

vars

begin
    self.sampleTime := argTime ;
end;
}
setSampleTimeGMT
{
setSampleTimeGMT( ts : TimeStamp ) updating;

vars

begin
    self.sampleTimeGMT := ts ;
end;
}
setScaled
{
setScaled( indx : Integer ; argScaled : Boolean ) updating;

vars

begin
    self.scaled[indx] := argScaled ;
end;
}
setValue
{
setValue( indx : Integer ; argValue : Integer ) updating;

vars

begin
    self.value[indx] := argValue ;
end;
}
setWiKey
{
setWiKey( argKey : Integer ) updating;

vars

begin
    self.wiKey := argKey ;
end;
}
	)
	CnBackupCmd (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;


vars
	iterLocn		: Iterator;
	
	bin 			: Binary;
	
	pv				: Integer;
	
	locn,
	structureName: String;
begin
	pv := self.protocolVersion;
	bin := inheritMethod()								&
		   cnAnsiBinary(commandType.padBlanks(8))		&
		   cnAnsiBinary(backupDirectory.padBlanks(128))	&
		   cnAnsiBinary(compress.Character);
	
	if pv < 20 then
		bin := bin 										&
		   cnAnsiBinary(false.Character);					// no longer required as verify now always set to true
	endif;
	
	bin := bin 											&
		   cnAnsiBinary(quiesce.Character)				&
		   backupWorkers.Binary;
		   
	if pv > 35 then															// 4.0.01+
		bin := bin & self.commitCoherentBackup.Character.Binary;			// 7055
	endif;
	
	if pv > 19 then
		bin := bin &
				self.backupStructureNames.size64().Binary;
	
		iterLocn := self.backupLocations.createIterator();
		foreach structureName in self.backupStructureNames do
			iterLocn.next(locn);
			bin := bin										&
					structureName.length().Binary			&
					cnAnsiBinary(structureName)				&
					locn.length().Binary					&
					cnAnsiBinary(locn);
		endforeach;
	endif;
	
	return bin;
epilog
	delete iterLocn;
end;
}
exceptionHandler
{
exceptionHandler(exObj : Exception) : Integer;

vars
	cc		: CnCntrl;
	kc		: CnKarmaCntrl;
	str		: String;
	msg		: CnBackupAdvice;
	cdba	: CnDatabaseAdmin;
begin
	cc		:= app.myCnCntrl;
	kc		:= app.myCnKarmaCntrl;
	cdba := app.myCnDba;
	str		:= "Backup startup failure : KCOnLineBackup problem for " & kc.environmentId & " on " & node.cnGetComputerName;
	app.cnManagerLog(str);
				 
	msg	:= cdba.createBackupAdviceMessage(CnMessage.Advice_Type_Backup_Failed);
    msg.setErrorText(str); 
    msg.sendMessage(kc.myParentTcp);
	return Ex_Pass_Back;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;


vars
	len,
	pv			: Integer;

	num,
	numItems	: Integer64;
	
	trash		: String;
begin
	inheritMethod(buf);
	pv := self.protocolVersion;
	self.commandType		:= getField(buf, 8).ansiToString.trimRight;
	self.backupDirectory	:= getField(buf, 128).ansiToString.trimRight;
	self.compress			:= getField(buf, 1).ansiToString.Character.Boolean;
	if pv < 20 then
		trash				:= getField(buf, 1).ansiToString;
	endif;
	
	self.quiesce			:= getField(buf, 1).ansiToString.Character.Boolean;
	self.backupWorkers		:= byteOrderInteger(getField(buf,4));
	
	if pv > 35 then																				// 4.0.01+
		self.commitCoherentBackup := getField(buf, 1).ansiToString.Character.Boolean;			// 7055
	endif;
	
	if pv > 19 then
		numItems				:= byteOrderInteger64(getField(buf,8));			// number of structures with specific backup locations
		
		foreach num in 1 to numItems do
			len	:= byteOrderInteger(getField(buf,4));
			self.backupStructureNames.add(getField(buf, len).ansiToString);
			len	:= byteOrderInteger(getField(buf,4));
			self.backupLocations.add(getField(buf, len).ansiToString);
		endforeach;
	endif;
end;
}
processMsg
{
processMsg(proc: Process): String updating;

vars
	cc					: CnCntrl;
	
	dba					: CnDatabaseAdmin;
	
	prc					: Process;
	
	x					: Integer;
	
	badObject,
	exceededLicence,
	signOnDisabled		: Boolean;
	
	result,
	str					: String;
begin
	result 	:= inheritMethod(proc);
	cc		:= app.myCnCntrl;
	
	if result <> CN_OK then
		cc.cnWriteLog(cc.CnLogErrors, "Backup command not processed : " & result, null);
		self.sendBackupFailureResponse("cannot action backup command : " & result);
		return CN_OK;
	endif;
	
	prc		:= Process.firstInstance;
	if prc.adminInfo = CnKarmaCntrl.System_Stopping then
		str		:= "cannot action backup command because system is stopping.";
		cc.cnWriteLog(cc.CnLogErrors, "Backup command not processed : " & str, null);
		self.sendBackupFailureResponse(str);
		return CN_OK;
	endif;    	
	
	if commandType = Command_Type_Backup_Start then
		cc.cnWriteLog(cc.CnLogComment, "KCCMgr has been requested to initiate on-line database backup, quiesce=" & quiesce.String, null);
		
		beginTransientTransaction;
		create dba sharedTransient;
		dba.setBackupRootDir(backupDirectory);
		dba.setQuiesce(quiesce);
		dba.setCompressFiles(compress);
		dba.setBackupWorkers(backupWorkers);
		
		// 3.5.01
		backupStructureNames.copy(dba.backupStructureNames);
		backupLocations.copy(dba.backupLocations);
		
		dba.setCommitCoherentBackup(self.commitCoherentBackup);																// NFS 7055
		dba.setMustBeCommitCoherentBackup(self.mustBeCommitCoherentBackup);													// NFS 7055
		commitTransientTransaction;
		
		on Exception do exceptionHandler(exception);								// catch launch failures
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_ExceededProcessLicences, null, exceededLicence);
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_AttemptedAccessViaNullRef, null, badObject);
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_UserSignOnCurrentlyDisabled, null, signOnDisabled);
		prc := app.startApplicationWithParameter(CN_CARDSCHEMA, CN_KCONLINEBACKUP, dba);
		x := prc.edition;
		if exceededLicence 	or
		   badObject 		or
		   signOnDisabled	then																								// PAR 787
			if exceededLicence then
				self.sendBackupFailureResponse("Unable to start database backup as exceeded process licences.");
			
			elseif badObject then
				self.sendBackupFailureResponse("Unable to start database backup, process failed, refer to jommsg.log.");
			
			elseif signOnDisabled then
				self.sendBackupFailureResponse("Unable to start database backup as user sign-on is disabled.");
			endif;
			
			beginTransientTransaction;
			delete dba;
			commitTransientTransaction;
		endif;
		
		return CN_OK;
	endif;
					
	if commandType = Command_Type_Backup_Stop then
		cc.cnWriteLog(cc.CnLogComment, "KCCMgr has been requested to cancel on-line database backup.", null);
		system.causeEvent(CN_BACKUP_ABORT_REQUESTED, true, 0);		// subscribed to by KCOnLineBackup
		cc.cnWriteLog(cc.CnLogComment, "KCCMgr has issued backup abort notification.", null);
		return CN_OK;
	endif;
		
	return method.cnGetMethodName() & " : unknown command type '" & self.commandType & "'.";			
end;
}
sendBackupFailureResponse
{
sendBackupFailureResponse(errText : String);

vars
	cc		: CnCntrl;
	kc		: CnKarmaCntrl;
	str		: String;
	msg		: CnBackupAdvice;	
	cdba	: CnDatabaseAdmin;
begin
	cc		:= app.myCnCntrl;
	kc		:= app.myCnKarmaCntrl;
	cdba	:= app.myCnDba;
	str		:= "Backup startup failure for " & kc.managedEnvironmentName.toUpper & " on " & node.cnGetComputerName;
	app.cnManagerLog(str);
			 
	msg	:= cdba.createBackupAdviceMessage(CnMessage.Advice_Type_Backup_Failed);
    msg.setErrorText(str & " : " & errText); 
    msg.sendMessage(kc.myParentTcp);
end;
}
setBackupDirectory
{
setBackupDirectory(dir : String) updating;

vars

begin
	self.backupDirectory := dir;
end;
}
setBackupWorkers
{
setBackupWorkers(count : Integer) updating;

vars

begin
	self.backupWorkers	:= count;
end;
}
setCommandType
{
setCommandType(type : String) updating;

vars

begin
	commandType := type;
end;
}
setCommitCoherentBackup
{
setCommitCoherentBackup(pCommitCoherentBackup : Boolean) updating;

vars

begin
	self.commitCoherentBackup := pCommitCoherentBackup;
end;
}
setCompress
{
setCompress(set : Boolean) updating;

vars

begin
  	self.compress := set;
end;
}
setMustBeCommitCoherentBackup
{
setMustBeCommitCoherentBackup(pMustBeCommitCoherentBackup : Boolean) updating;

vars

begin
	self.mustBeCommitCoherentBackup := pMustBeCommitCoherentBackup;
end;
}
setQuiesce
{
setQuiesce(set : Boolean	) updating;

vars

begin
	self.quiesce	:= set;
end;
}
	)
	CnCompactCmd (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;

vars
	cc			: CnCntrl;
	
	bin,
	bin2 		: Binary;
	
	mapFileName	: String;
	
	int			: Integer;
begin
	cc	:= app.myCnCntrl;
	bin := inheritMethod();
	bin	:= bin & cnAnsiBinary(self.commandType.padBlanks(8))	&
			self.timeStamp.Binary								&
			self.compactWorkers.Binary							;

	foreach mapFileName in self.mapFileNames do
		bin2 := bin2 & cnAnsiBinary(mapFileName & "|");
	endforeach;
	
	bin := bin 					&
		   bin2.length.Binary	&
		   bin2					;
		   
	return bin;
end;
}
exceptionHandler
{
exceptionHandler(exObj : Exception) : Integer;

vars
	cc		: CnCntrl;
	kc		: CnKarmaCntrl;
	str		: String;
	msg		: CnCompactAdvice;
	cdba	: CnDatabaseAdmin;
begin
	cc		:= app.myCnCntrl;
	kc		:= app.myCnKarmaCntrl;
	cdba 	:= app.myCnDba;
	str		:= "Online compaction startup failure : KCOnLineCompact problem for " & kc.environmentId & " on " & node.cnGetComputerName;
	app.cnManagerLog(str);
	msg	:= cdba.createCompactAdviceMessage(CnMessage.Advice_Type_Compact_Failed);
    msg.setErrorText(str); 
    msg.sendMessage(kc.myParentTcp);
	return Ex_Pass_Back;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars
	cc					: CnCntrl;

	mapFileName			: String;
	
	mapFileNamesLength	: Integer;
	
	mapFileStrArray		: CnStringArray;
begin
	cc	:= app.myCnCntrl;
	inheritMethod(buf);

	self.commandType	:= getField(buf, 8).ansiToString.trimRight;
    self.timeStamp 		:= byteOrderTimeStamp(getField(buf, 8));
   	self.compactWorkers	:= byteOrderInteger(getField(buf, 4));	
	mapFileNamesLength	:= byteOrderInteger(getField(buf, 4));
	
	mapFileStrArray := getField(buf, mapFileNamesLength).ansiToString().cnGetTokens("|"); // buf.length - 8 allows for the scheduled timestamp in CompactCmd
   	foreach mapFileName in mapFileStrArray do
   		self.mapFileNames.add(mapFileName);
   	endforeach;
epilog
	delete mapFileStrArray;
end;
}
processMsg
{
processMsg(proc: Process): String updating;

vars
	result 			: String;

	dba				: CnDatabaseAdmin;
	
	cc				: CnCntrl;
	
	prc				: Process;
	
	str				: String;
	
	x				: Integer;
	
	badObject,
	exceededLicence	: Boolean;
begin
	result 	:= inheritMethod(proc);
	cc		:= app.myCnCntrl;
	
	if result <> CN_OK then
		cc.cnWriteLog(cc.CnLogErrors, "Compact command not processed : " & result, null);
		sendCompactFailureResponse("Cannot action online compaction command : " & result);
		return CN_OK;
	endif;
	
	prc	:= Process.firstInstance;
	if prc.adminInfo = CnKarmaCntrl.System_Stopping then
		str		:= "cannot action compact command because system is stopping.";
		cc.cnWriteLog(cc.CnLogErrors, "Compact command not processed : " & str, null);
		sendCompactFailureResponse(str);
		return CN_OK;
	endif;    	
	
	if self.commandType = self.Command_Type_Compact_Start then
		cc.cnWriteLog(cc.CnLogComment, "KCCMgr has been requested to initiate an online database compaction...", null);
		
		beginTransientTransaction;
		create dba sharedTransient;
		dba.setScheduleTime(self.timeStamp);
		dba.setCompactWorkers(self.compactWorkers);
		self.mapFileNames.copy(dba.compactStructureNames);
		commitTransientTransaction;
		
		on Exception do exceptionHandler(exception); // catch launch failures
		on SystemException do app.cnGenericExceptionHandler(exception, 5504, null, exceededLicence);
		on SystemException do app.cnGenericExceptionHandler(exception, 1090, null, badObject);
		prc := app.startApplicationWithParameter(CN_CARDSCHEMA, CN_KCONLINECOMPACT, dba);
		x := prc.edition;
		if exceededLicence 	or
		   badObject 		then
			if exceededLicence then
				self.sendCompactFailureResponse("Unable to start online compaction as the allocated number of process licences has been exceeded.");
			
			elseif badObject then
				self.sendCompactFailureResponse("Unable to start database online compaction, process failed, refer to jommsg.log.");
			endif;
			
			beginTransientTransaction;
			delete dba;
			commitTransientTransaction;
		endif;
		
		return CN_OK;
	endif;
					
	if commandType = self.Command_Type_Compact_Stop then
		cc.cnWriteLog(cc.CnLogComment, "KCCMgr has been requested to stop online database compaction.", null);
		system.causeEvent(CN_COMPACTION_STOP_REQUESTED, true, 0);	// subscribed to by KCOnLineCompact
		cc.cnWriteLog(cc.CnLogComment, "KCCMgr has issued online compaction stop notification.", null);
		return CN_OK;
	endif;
		
	if commandType = self.Command_Type_Compact_Abort then
		cc.cnWriteLog(cc.CnLogComment, "KCCMgr has been requested to abort online database compaction.", null);
		system.causeEvent(CN_COMPACTION_ABORT_REQUESTED, true, 0);	// subscribed to by KCOnLineCompact
		cc.cnWriteLog(cc.CnLogComment, "KCCMgr has issued online compaction abort notification.", null);
		return CN_OK;
	endif;
		
	return method.cnGetMethodName() & " : unknown command type '" & self.commandType & "'.";			
end;
}
sendCompactFailureResponse
{
sendCompactFailureResponse(errText : String);

vars
	cc		: CnCntrl;
	kc		: CnKarmaCntrl;
	str		: String;
	msg		: CnCompactAdvice;	
	cdba	: CnDatabaseAdmin;
begin
	cc		:= app.myCnCntrl;
	kc		:= app.myCnKarmaCntrl;
	cdba	:= app.myCnDba;
	str		:= "Online compaction startup failure for " & kc.managedEnvironmentName.toUpper & " on " & node.cnGetComputerName;
	app.cnManagerLog(str);
	msg	:= cdba.createCompactAdviceMessage(CnMessage.Advice_Type_Compact_Failed);
    msg.setErrorText(str & " : " & errText); 
    msg.sendMessage(kc.myParentTcp);
end;
}
setCommandType
{
setCommandType(pCmdType : String) updating;

vars

begin
	commandType := pCmdType;
end;
}
setCompactWorkers
{
setCompactWorkers(pWorkers : Integer) updating;

vars

begin
	self.compactWorkers	:= pWorkers;
end;
}
setMapFileNames
{
setMapFileNames(pMapFileNames : CnStringArray) updating;

vars

begin
	pMapFileNames.copy(self.mapFileNames);
end;
}
setTimeStamp
{
setTimeStamp(pTimeStamp : TimeStamp) updating;

vars

begin
	self.timeStamp := pTimeStamp;
end;
}
	)
	CnControlCmd (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;

vars
	buf	: Binary;
	
	len	: Integer;
begin
	buf := inheritMethod();
	attachField(buf, commandType.padBlanks(5).Binary);	
	attachField(buf, sourceComputer.padBlanks(30).Binary);
	attachField(buf, targetComputer.padBlanks(30).Binary);
	attachField(buf, delay.String.padBlanks(4).Binary);
	
	len		:= message.length;
	attachField(buf, len.Binary);
	attachField(buf, message.Binary);
	attachField(buf, sampleProcessStats.Character.Binary);
	attachField(buf, sampleCacheStats.Character.Binary);
	attachField(buf, commandVar.Binary);						// 3.1
	attachField(buf, nodeMonitorThresholdPercent.Binary);		// 3.3
	attachField(buf, nodeMonitorMaxProcessesDef.Binary);		// 3.3
	attachField(buf, timestamp.Binary);							// 3.5
	return buf;
end;
}
loadMsg
{
loadMsg(buf : Binary) updating;

vars
	len	: Integer;
	
	cc	: CnCntrl;
begin
	cc := app.myCnCntrl;
	inheritMethod(buf);

	commandType			:= getField(buf, 5).ansiToString.trimRight;
	sourceComputer		:= getField(buf, 30).ansiToString.trimRight;
	targetComputer		:= getField(buf, 30).ansiToString.trimRight;
	delay				:= getField(buf, 4).ansiToString.Integer;
	len					:= byteOrderInteger(getField(buf, 4));
	message				:= buf[pos : len].ansiToString;
	sampleProcessStats	:= getField(buf, 1).Character.Boolean;
	sampleCacheStats	:= getField(buf, 1).Character.Boolean;
	
	if self.protocolVersion > 14 then								// 3.1
		commandVar		:= byteOrderInteger(getField(buf, 4));
	endif;
	
	if self.protocolVersion > 16 then								// 3.3
		nodeMonitorThresholdPercent	:= byteOrderInteger(getField(buf, 4));
		nodeMonitorMaxProcessesDef	:= byteOrderInteger(getField(buf, 4));
	endif;
	
	if self.protocolVersion > 19 then								// 3.5
		timestamp					:= byteOrderTimeStamp(getField(buf, 8));
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " protocolVersion " & self.protocolVersion.String & ", timestamp" & self.timestamp.String, null);
	endif;
end;
}
processMsg
{
processMsg(proc : Process) : String updating;

vars
 	result		: String;
 	kc			: CnKarmaCntrl;
 	cc			: CnCntrl;
 	errorcode	: Integer;
 	errortext	: String;
begin
	result := inheritMethod(proc);
	if result <> CN_OK then
		return result;
	endif;

	cc := app.myCnCntrl;
	kc := app.myCnKarmaCntrl;

	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " command type = " & self.commandType, null);
	if cc.appName <> CN_KCCMGR then				// should only ever be KCCMgr.  See ControlCmd in Joss Schema for KarmaCommsMgr code
		return CN_OK;							// so that ControlCmd works OK for JSA
	endif;
	
	on SystemException do app.cnHandleReorgException(exception, errorcode, errortext);
	result	:= self.processMsgActual(proc);
	if errorcode > null then
		if self.commandType = self.Command_Type_GetMapFileSizes then
			return CN_OK;
		endif;
		
		self.sendControlAdvice(errorcode, errortext);
		return "Processing of CnControlCmd failed due to exception : error=" & errortext;
	endif;	
	
	return result;
end;
}
processMsgActual
{
processMsgActual(proc : Process) : String updating;

vars
 	cc					: CnCntrl;

 	kc					: CnKarmaCntrl;

 	machine				: CnMachine;
	
 	cnproc				: CnProcess;
 	
	prc					: Process;
 	
	badObject			: Boolean;
begin
	cc 	:= app.myCnCntrl;
	kc 	:= app.myCnKarmaCntrl;

	if commandType = self.Command_Type_GetMapFileSizes then
		self.zSendMapFileSizes();
		return CN_OK;
	endif;
	
	if commandType = self.Command_Type_FileDet_DbData then
		self.zSendDbFileDetails();
		return CN_OK;
	endif;

	if commandType = self.Command_Type_UserPatchRequest then
		self.zSendUserPatches();
		return CN_OK;
	endif;
	/////////////////////////////////   Application Transaction Stats Request from Karma  ///////////////////////////////		

	if commandType = self.Command_Type_TransStatsTimeChg then		// TSRQ			// used to be Tran_Stats_Request
		self.zTranStatsTimeChange();																							// PAR 977
		return CN_OK;												
	endif;

	if commandType = self.Command_Type_NodeMonitorChange then
		return cc.nodeMonitorChange(self.delay, self.nodeMonitorThresholdPercent, self.nodeMonitorMaxProcessesDef);
	endif;
	////////////////////////////////////////     System Shut Down Stuff   /////////////////////////////////////////////////

	if commandType = self.Kill_KCCMgr_Process then
		cc.cnWriteLog(cc.CnLogComment, "KCCMgr told to shut down by Karma ... checking for clients not yet shut down....", null);
		on SystemException do app.cnHandleInvalidObjectReference(exception, badObject);
		
		foreach prc in Process.instances do		// gets a virtual collection and doesn't hold system collections
			badObject	:= false;
			prc.edition;							// trigger exception 4 here if the process has gone
			if not badObject then
				if prc <> process and prc.userCode <> "clientBackground" and prc.userCode <> "serverBackground" then
					cc.cnWriteLog(cc.CnLogComment, "App '" & prc.persistentApp.name & "' (usercode=" & prc.userCode & ") still running on " & 
													prc.node.networkAddress & " (" & prc.String & "), now being told to kill itself.", null);
					prc.causeEvent(cc.Cn_Control_Command, true, CnMessage.Kill_Client & "/" & sourceComputer &
										 "/" & delay.String & "/" & message);
				endif;
			endif;
		endforeach;
		
		on SystemException do null;
		cc.cnWriteLog(cc.CnLogComment, "Client shut down checks done ....checking that reorg is not in process.....", null);
		beginTransaction;							// if reorging this will throw an exception to be caught by reorgExceptionHandler
		abortTransaction;
		
		sendControlAdvice(0, null);
		app.cnTerminate();
	endif;
	
	if self.commandType = self.System_Shut_Down_Msg then			// this is the 60 second warning prior to shut down
		cc.cnWriteLog(cc.CnLogDiag, "Processing System_Shut_Down_Msg : flagging serverBackground's process object...", null);
		prc			:= Process.firstInstance.Process;		// instance id=1 is always serverBackground
		beginTransaction;
		prc.adminInfo	:= kc.System_Stopping; 				// CardSchema uses this to stop any new clients from starting
		commitTransaction;
		
		sendControlAdvice(0, null);
	endif;

	cc.cnWriteLog(cc.CnLogDiag, "CnControlCmd::processMsg issuing " & commandType & " command(s) to computer " & targetComputer, null);

	if targetComputer = "ALL" then
		on SystemException do app.cnHandleInvalidObjectReference(exception, badObject);		// process may go away
		foreach cnproc in kc.allCnProcesses do
			badObject	:= false;
			cc.cnWriteLog(cc.CnLogDiag, "Causing Cn_Control_Command event on " & cnproc.myProcess.String & " for client " &
					  cnproc.myMachine.clientFQDN & " (" & cnproc.myMachine.ipAddress & ")", null);
			if badObject then
				continue;
			endif;
			cnproc.myProcess.causeEvent(cc.Cn_Control_Command, true, commandType & "/" & sourceComputer &
										 "/" & delay.String & "/" & message);
		endforeach;
		on SystemException do null;
	endif;

	if self.commandType = self.Command_Type_SessOpen_Request then	// request all processes to reissue SessionOpenAdvices
		cnproc	:= kc.myCnProcess;
		machine	:= cnproc.myMachine;
		kc.issueKCCMgrSessionOpenAdvice(self.myTcp.CnKarmaTcpConnection, machine, cnproc);
		kc.endTimer(Cn_SendDbDetails_Timer);														// stop timer if running
		kc.beginTimer(Cn_SendDbDetails_TimeReorg, Timer_OneShot, Cn_SendDbDetails_Timer); 	// send database details in two min time
		cc.cnWriteLog(cc.CnLogDiag, "KCCMgr now asking all processes to submit SessionOpenAdvices", null);
		on SystemException do app.cnHandleInvalidObjectReference(exception, badObject);
		foreach prc in Process.instances do
			badObject := false;
			prc.edition;			// force exception 4 here if its going to happen
			if badObject then
				continue;
			endif;
			
			if prc.userCode <> "clientBackground" and
			   prc.userCode <> "serverBackground" and
			   prc <> process then										// ignore myself
				prc.causeEvent(Cn_Session_Open_Advice_Request, true, 0);
			endif;
		endforeach;
		
		on SystemException do null;
	endif;

	return CN_OK;
end;
}
sendControlAdvice
{
sendControlAdvice(errorcode : Integer; errortext : String) updating;

vars
	tmsg, newmsg	: CnMessage;
	msg				: CnControlAdvice;
	kc				: CnKarmaCntrl;
	cc				: CnCntrl;	
begin
	kc	:= app.myCnKarmaCntrl;
	cc	:= app.myCnCntrl;

	create tmsg transient;
	tmsg.createNewMsg(msg.Advice, msg.Control_Advice, kc.localFQDN, kc.localIpAddress, cc.KCCMgr_Process, cc.KarmaCommsMgr_Process, newmsg);
	msg	:= newmsg.CnControlAdvice;
	msg.setManagedEnvironmentName(kc.managedEnvironmentName);
	msg.setCommandType(self.commandType);
	if errorcode > 0 then
		msg.setAdviceText("Error " & errorcode.String & " (" & errortext & ")");
	else
		msg.setAdviceText(CN_OK);
	endif;
	msg.sendMessage(kc.myParentTcp);
	
	cc.cnWriteLog(cc.CnLogDiag, "Sent CnControlAdvice : error=" & errorcode.String & ", text=" & errortext, null);
epilog
	delete msg;
	delete tmsg;
end;
}
setCommandType
{
setCommandType(command : String) updating;

vars

begin
 	self.commandType := command;
end;
}
setDelay
{
setDelay(time : Integer) updating;

vars

begin
 	self.delay := time;
end;
}
setMessage
{
setMessage(msg	: String) updating;

vars

begin
 	self.message := msg;
end;
}
setNodeMonitoringValues
{
setNodeMonitoringValues(pCheckInterval, pThresholdPercent, pMaxProcessesDefault : Integer) updating;

vars

begin
	self.delay							:= pCheckInterval;
	self.nodeMonitorThresholdPercent 	:= pThresholdPercent;
	self.nodeMonitorMaxProcessesDef		:= pMaxProcessesDefault;
end;
}
setSampleCacheStats
{
setSampleCacheStats(set : Boolean) updating;

vars

begin
	self.sampleCacheStats := set;
end;
}
setSampleProcessStats
{
setSampleProcessStats(set : Boolean) updating;

vars

begin
	self.sampleProcessStats	:= set;
end;
}
setSourceComputer
{
setSourceComputer(computer : String) updating;

vars

begin
 	self.sourceComputer := computer;
end;
}
setTargetComputer
{
setTargetComputer(computer : String) updating;

vars

begin
 	self.targetComputer := computer;	
end;
}
setTimestamp
{
setTimestamp(pValue : TimeStamp) updating;

vars

begin
	self.timestamp := pValue;
end;
}
zSendDbFileDetails
{
zSendDbFileDetails() protected;

vars
	cndba : CnJadeDatabaseAdmin;
begin
	create cndba transient;
	cndba.getDatabaseDetailsSendAdvice();
epilog
	delete cndba;
end;
}
zSendMapFileSizes
{
zSendMapFileSizes() protected;

vars
	cc					: CnCntrl;
	
	kc					: CnKarmaCntrl;
	
	tmsg, 
	newmsg				: CnMessage;

	msg					: CnStatisticsAdvice;
	
	mapFileNameArray	: CnStringArray;
	
	mapFileSizeArray	: Integer64Array;
	
	bin					: Binary;
	
	iter				: Iterator;

	mapFileSize			: Real;

	mapFileName			: String;
	
	ts					: TimeStamp;
begin
	kc	:= app.myCnKarmaCntrl;
	cc  := app.myCnCntrl;
	create mapFileNameArray transient;
	create mapFileSizeArray transient;
	app.myCnSDSDbAdmin.getMapFileInfo(mapFileNameArray, mapFileSizeArray);
	// if exception 3059, 3116 or 3213 is incurred in the above method, this
	// is caught by the exception handler armed by processMsg higher in the stack
	
	bin := cnAnsiBinary("M") &
			0.Binary;					// fix up length later
	iter := mapFileSizeArray.createIterator();
	foreach mapFileName in mapFileNameArray do
		iter.next(mapFileSize);
		bin := bin &
				mapFileName.length().Binary &
				cnAnsiBinary(mapFileName)	&
				mapFileSize.Binary;
	endforeach;
	
	bin[2:4] := bin.length().Binary;

	create tmsg transient;
	tmsg.createNewMsg(msg.Advice, msg.Statistics_Advice, kc.localFQDN, kc.localIpAddress, cc.KCCMgr_Process, cc.JossCommsMgr_Process, newmsg);
	msg	:= newmsg.CnStatisticsAdvice;
	msg.setManagedEnvironmentName(kc.managedEnvironmentName);
	msg.setMsgParam1(newmsg.Advice_Type_Map_Sizes);
	msg.setTimestamp(ts);
	msg.setStatsVersion(Cn_Current_Stats_Version);
	msg.setData(bin);
	msg.setDataLength(bin.length);
	msg.sendMessage(kc.myParentTcp);

	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " sent CnStatisticsAdvice : " & mapFileNameArray.size64().String & " map files", null);
epilog
	delete iter;
	delete msg;
	delete tmsg;
	delete mapFileNameArray;
	delete mapFileSizeArray;
end;
}
zSendUserPatches
{
zSendUserPatches() protected;

vars
	fa			: CnFunctionAgent;
	
	seColl		: CnSchemaElementDict;
	
	se			: CnSchemaElement;
	
	msg,
	newmsg		: CnMessage;
	
	fda			: CnFileDetailsAdvice;
	
	patchName,
	userPatches	: String;
	
	count		: Integer;

	seTs,
	ts			: TimeStamp;
	
	kc			: CnKarmaCntrl;
	
	cc			: CnCntrl;
begin
	kc := app.myCnKarmaCntrl;
	cc := app.myCnCntrl;
	userPatches := rootSchema.getUserAppliedPatches();
	create fa transient;
	create seColl transient;
	fa.parseUserAppliedSchemaPatches(userPatches, seColl);
	
	create msg transient;
	msg.createNewMsg(msg.Advice, msg.File_Details_Advice, kc.localFQDN, kc.localIpAddress, cc.KCCMgr_Process, cc.JossCommsMgr_Process, newmsg);
	fda := newmsg.CnFileDetailsAdvice;
	fda.setAdviceType(fda.Advice_Type_FileDet_UserPatchs);
	// seColl is in descending lastModified order so we can
	// quit scanning when timestamp is less then or equal to 
	// the one specified in this message.
	ts := self.timestamp;
	foreach se in seColl do
		seTs := se.lastModified;
		if ts <> null and 
		   seTs <= ts then
			break;
		endif;
		
		count := count + 1;
		patchName := se.appSchemaName & "|" & se.appName;				// name is composed of Schema Name and File Name
		fda.addItemUserPatches(patchName,					// name
								se.schemaFileType,			// file type
								se.lastModified);
	endforeach;
	
	fda.sendMessage(kc.myParentTcp);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " sent CnFileDetailsAdvice : starting period " & 
														ts.date().cnUserFormat($CnDDMMYY) & " " &
														ts.time().cnUserFormat($CnHHMMSS) &
														" number of schema elements issued = " & count.String, null);
epilog
	if seColl <> null then
		seColl.purge();
		delete seColl;
	endif;
	
	delete fa;
	delete msg;
	delete newmsg;
end;
}
zTranStatsTimeChange
{
zTranStatsTimeChange() protected;

vars
	cc					: CnCntrl;
	
	kc					: CnKarmaCntrl;
	
	nodeControl			: CnNodeControl;
	
	cnproc				: CnProcess;
	
	badObject			: Boolean;
	
	oldStatsInterval,
	option,
	remaining			: Integer;
begin
	kc					:= app.myCnKarmaCntrl;
	cc					:= app.myCnCntrl;
	oldStatsInterval	:= kc.tranStatsInterval;

    //
	//  As of 2.9, transaction stats submission timing is autonomously handled by each client.
	//  We only need to send them an updated message when the interval changes.  JSA 2.9 only 
	//  sends this message to systems that are on CardSchema 2.9 or later if the delay changes.
	//
	//  Extended for 3.0 to emit ControlCmd message if sampleProcessStats or sampleCacheStats
	//  changes.			
	//
	cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : tran stats timer=" & self.delay.String & " seconds" &		// PAR 977
																", sampleProcessStats=" & self.sampleProcessStats.String & 
																", sampleCacheStats=" & self.sampleCacheStats.String, null);
	on SystemException do app.cnHandleInvalidObjectReference(exception, badObject);
	foreach cnproc in kc.allCnProcesses do
		badObject	:= false;
		if cnproc.clientTranStats then
			cnproc.myProcess.causeEvent(Cn_Tran_Stats_Timer_Change, true, self.delay);
			if badObject then
				cc.cnWriteLog(cc.CnLogComment, "CnControlCmd::processMsg Cn_Tran_Stats_Timer_Change : " &
							  "JADE process " & cnproc.processId.String & " has gone away - skipping..", null);
			endif;
		endif;
	endforeach;
	
	kc.setTranStatsInterval(self.delay);
	if kc.getTimerStatus(kc.Tran_Stats_Timer, option, remaining) then		// KCCMgr's timer not currently running
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " tran stats timer is still running, time remaining before change " & remaining.String & "ms", null);
	
	elseif self.delay > null then
			kc.beginTimer(kc.tranStatsInterval * 1000, Timer_OneShot, kc.Tran_Stats_Timer);
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " started Tran_Stats_Timer, interval=" & (kc.tranStatsInterval * 1000).String & "ms", null);
	
	else
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " timer was not running and not started as interval is 0", null);
	endif;
	
	if oldStatsInterval = null 	and																						// PAR 977	
	   self.delay > null		then 																					// PAR 977
		app.startApplication(CN_CARDSCHEMA, CN_KCSTATSCOLLECTOR);														// PAR 977
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " starting application " & CN_KCSTATSCOLLECTOR, null);	// PAR 977	
	endif;

	
	///////////  Sampling setup  ////////////////
	
	nodeControl	:= cc.myNodeControl;
	
	if nodeControl <> null 											and				// sampling defeated
	  (nodeControl.sampleProcessStats <> self.sampleProcessStats 	or
	   nodeControl.sampleCacheStats <> self.sampleCacheStats) 		then
		beginTransientTransaction;
		nodeControl.doSamplingStatusChange(sampleProcessStats, sampleCacheStats);
		commitTransientTransaction;
		
		system.causeEvent(Cn_Node_Sampling_Status_Chg, true, sampleProcessStats.Character & sampleCacheStats.Character);
	endif;
end;
}
	)
	CnExecuteCmd (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;

vars
	bin,
	compressedBin	: Binary;
	
	len				: Integer;
	
	parameter		: String;
begin
	bin 		:= inheritMethod();
	attachField(bin, executeFunction.length().Binary);
	attachField(bin, executeFunction.Binary);				
	attachField(bin, itemIndex.Binary);
	attachField(bin, itemName.length().Binary);
	attachField(bin, itemName.Binary);
	attachField(bin, parameterArray.size().Binary);				// number of items
	foreach parameter in parameterArray do
		attachField(bin, parameter.length().Binary);
		attachField(bin, parameter.Binary);
	endforeach;
	
	if self.protocolVersion <= 38 then							// 4.0.03 or earlier
		return bin;
	endif;
	
	if self.scriptText = null then
		len := null;
		attachField(bin, len.Binary);
	
	else
		compressedBin := self.scriptText.compressToBinary(Binary.Compression_ZLib);
		len := compressedBin.length();
		attachField(bin, len.Binary);
		attachField(bin, compressedBin);
	endif;
	
	return bin;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars
	bin			: Binary;
	
	index,
	len,
	maxItems	: Integer;
	
	parameter	: String;
begin
	inheritMethod(buf);
	len						:= byteOrderInteger(getField(buf, 4));
	self.executeFunction	:= getField(buf, len).ansiToString();
	self.itemIndex			:= byteOrderInteger(getField(buf, 4));
	len						:= byteOrderInteger(getField(buf, 4));
	self.itemName			:= getField(buf, len).ansiToString();
	maxItems				:= byteOrderInteger(getField(buf,4));			// number of parameters
	foreach index in 1 to maxItems do
		len					:= byteOrderInteger(getField(buf,4));
		parameter			:= getField(buf, len).ansiToString();
		self.parameterArray.add(parameter);
	endforeach;
	
	if self.protocolVersion <= 38 then							// 4.0.03 or earlier
		return;
	endif;
	
	len := byteOrderInteger(getField(buf,4));
	if len > null then
		bin := getField(buf, len);
		self.scriptText := bin.uncompressToString();
	endif;
end;
}
processMsg
{
processMsg(proc: Process): String updating;

vars
	cc			: CnCntrl;
	
	errorMsg,
	result		: String;
begin
	cc			:= app.myCnCntrl;
	result		:= inheritMethod(proc);
	if result <> CN_OK then
		errorMsg := "Execute command not processed : " & result;
		cc.cnWriteLog(cc.CnLogErrors, errorMsg, null);
		self.zSendFailureResponse(-1, errorMsg);
		return CN_OK;
	endif;
	
	if self.executeFunction = CN_JADESCHEMALOADER then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " starting " & self.executeFunction & "...", null);
		self.zExecuteJadeSchemaLoader();
		return CN_OK;
	endif;
	
	if self.executeFunction = CN_JADEREORGAPP then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " starting " & self.executeFunction & "...", null);
		self.zExecuteJadeReorgApp();
		return CN_OK;
	endif;

	if self.executeFunction = CN_JADERECOMPILEALLMETHODS then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " starting " & self.executeFunction & "...", null);
		self.zExecuteJadeRecompileAllMethods();
		return CN_OK;
	endif;
	
	if self.executeFunction = CN_KCVALIDATEMETHODS then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " starting " & self.executeFunction & "...", null);
		self.zExecuteCardSchemaValidateMethods();
		return CN_OK;
	endif;
	

	self.zSendFailureResponse(-1, "Unexpected execute function '" & self.executeFunction & "'");
	return CN_OK;
end;
}
setExecuteFunction
{
setExecuteFunction(pValue : String) updating;

vars

begin
	self.executeFunction := pValue;
end;
}
setItemIndex
{
setItemIndex(pValue : Integer) updating;

vars

begin
	self.itemIndex	:= pValue;
end;
}
setItemName
{
setItemName(pValue : String) updating;

vars

begin
	self.itemName := pValue;
end;
}
setScriptText
{
setScriptText(pValue : String) updating;

vars

begin
	self.scriptText := pValue;
end;
}
zExecuteCardSchemaValidateMethods
{
zExecuteCardSchemaValidateMethods() protected;

vars
	cc			: CnCntrl;
	
	jcExec		: CnJadeCareExecutor;
begin
	cc			:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " initiating CardSchema ValidateMethods with parameters " & self.parameterArray.cnGetAsParameterString(), null);
	create jcExec transient;
	jcExec.executeCardSchemaValidateMethods(self.executeFunction,
											self.itemIndex,
											self.itemName,
											self.parameterArray);
	// now we wait for sysNotification event on CnJadeCareExecutor instance.
end;
}
zExecuteJadeRecompileAllMethods
{
zExecuteJadeRecompileAllMethods() protected;

vars
	cc			: CnCntrl;
	
	jcExec		: CnJadeCareExecutor;
begin
	cc			:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " initiating JadeRecompileAllMethods with parameters " & self.parameterArray.cnGetAsParameterString(), null);
	create jcExec transient;
	jcExec.executeJadeRecompileAllMethods(self.executeFunction,
								self.itemIndex,
								self.itemName,
								self.parameterArray);
	// now we wait for sysNotification event on CnJadeCareExecutor instance.
end;
}
zExecuteJadeReorgApp
{
zExecuteJadeReorgApp() protected;

vars
	cc			: CnCntrl;
	
	jcExec		: CnJadeCareExecutor;
begin
	cc			:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " initiating JadeReorgApp with parameters " & self.parameterArray.cnGetAsParameterString(), null);
	create jcExec transient;
	jcExec.executeJadeReorgApp(self.executeFunction,
								self.itemIndex,
								self.itemName,
								self.parameterArray);
	
	// now we wait for sysNotification event on CnJadeCareExecutor instance.
end;
}
zExecuteJadeSchemaLoader
{
zExecuteJadeSchemaLoader() protected;

vars
	cc			: CnCntrl;
	
	jcExec		: CnJadeCareExecutor;
begin
	cc			:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " initiating JadeSchemaLoader with parameters " & self.parameterArray.cnGetAsParameterString(), null);
	create jcExec transient;
	jcExec.executeJadeSchemaLoader(self.executeFunction,
								self.itemIndex,
								self.itemName,
								self.parameterArray);
	// now we wait for sysNotification event on CnJadeCareExecutor instance.
end;
}
zSendFailureResponse
{
zSendFailureResponse(pExitcode 		: Integer;
					 pErrorMessage	: String) protected;

vars
	cc			: CnCntrl;
	
	execAdv		: CnExecuteAdvice;
	
	kc			: CnKarmaCntrl;
	
	msg,
	newmsg		: CnMessage;
begin
	kc			:= app.myCnKarmaCntrl;
	cc			:= app.myCnCntrl;
	create msg transient;
	msg.createNewMsg(msg.Advice, msg.Execute_Advice, kc.localFQDN, kc.localIpAddress, cc.KCCMgr_Process, cc.KarmaCommsMgr_Process, newmsg);
	execAdv		:= newmsg.CnExecuteAdvice;
	execAdv.setManagedEnvironmentName(kc.managedEnvironmentName);
	execAdv.setExecuteFunction(self.executeFunction);
	execAdv.setItemIndex(self.itemIndex);
	execAdv.setItemName(self.itemName);
	execAdv.setExitCode(pExitcode);
	execAdv.setErrorMessage(pErrorMessage);
	execAdv.sendMessage(kc.myParentTcp);
epilog
	delete msg;
	delete newmsg;
end;
}
	)
	CnPingCmd (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;

vars

begin
 	return inheritMethod		&
 		   timestamp.Binary		&
		   pingInterval.Binary	;
end;
}
buildMsg
{
buildMsg(): String updating;

vars
	ts : TimeStamp;
	result : String;
begin
	result := inheritMethod;
	if result <> CN_OK then
		return result;
	endif;

 	self.timestamp := ts;
 	return CN_OK;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars

begin
 	inheritMethod(buf);
 	self.timestamp 			:= byteOrderTimeStamp(getField(buf, 8));
	
	if self.protocolVersion >= 15 then		// 3.1
		self.pingInterval	:= byteOrderInteger(getField(buf, 4));
	endif;
end;
}
processMsg
{
processMsg(proc: Process): String updating;

vars
	result 	: String;
	cc		: CnCntrl;
	kc		: CnKarmaCntrl;
	msg		: CnMessage;
	newmsg 	: CnMessage;
	dest	: String;
	cnproc	: CnProcess;
	now		: TimeStamp;
	delta	: Integer;
begin
	result := inheritMethod(proc);

 	if result <> CN_OK then
 		return result;
 	endif;

 	cc := app.myCnCntrl;
 	kc := app.myCnKarmaCntrl;
 	
	if cc.noPingReplies then
		cc.cnWriteLog(cc.CnLogComment, "Ping replies have been manually stopped (testing) at " & cc.appName & " : won't reply", null);
		return CN_OK;
	endif;
	
	if cc.appName = CN_KCCMGR and self.appName <> CN_KCCMGR then				// KCCMgr as proxy i.e. the ping is for another application,
		cnproc	:= kc.allCnProcesses[self.processId];							// so check for possible heartbeat timestamp (3.1 feature) 
		if cnproc <> null and cnproc.heartbeatTimestamp <> null then
			delta	:= cnproc.heartbeatTimestamp.cnSecondsDifference(now);
			if delta < self.pingInterval then
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : heartbeat timestamp for app=" & self.appName &
											" OK (ts=" & cnproc.heartbeatTimestamp.String & ", pingInterval=" & self.pingInterval.String &
											") : will now send proxy PingReplyAdvice...", null);
				kc.sendPingReplyAdvice(self.appSchemaName, self.appName, self.processId, false, self.timestamp);	// KCCMgr replies on behalf of the app being pinged
				return CN_OK;
			endif;
		endif;
		
		self.destProcessType	:= cc.Application_Process;		// morph message, because we now have to forward it to the app itself
		self.forwardMsg();
		return CN_OK;
	endif;			

	if cc.appName = self.appName or 
	   app.cnAppAlias = self.appName or							// PAR 480
	   (cc.appName = CN_KARMACOMMSMGR and kc.managedEnvironmentName = self.managedEnvironmentName) then
 		//
    	//  We are the app client being pinged, or the message is FOR KarmaCommsMgr, so we must build PingReplyAdvice.	
   		//  Forwarding code, from KarmaCommsMgr to KCCMgrs, is in schema Joss PingCmd::processMsg
   		//
   		sharedLock(process);				// confirm that the Jade database can still be contacted
   		unlock(process);
		kc.sendPingReplyAdvice(self.appSchemaName, self.appName, self.processId, false, self.timestamp);
		return CN_OK;
	endif;

	if cc.appName <> CN_KARMACOMMSMGR then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " won't reply : looks like ping isn't for me.", null); 
	endif;
	
    return CN_OK;
end;
}
setPingInterval
{
setPingInterval(secs : Integer) updating;

vars

begin
	self.pingInterval := secs;
end;
}
setTimeStamp
{
setTimeStamp(ts : TimeStamp) updating;

vars

begin
	timestamp := ts;
end;
}
	)
	CnProcCmd (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating ;

//
// a ProcCmd message has two fields : 
//     a string, length 3, containing "OFF", "ON " or "ADJ".
//
//     and an integer , for the frequency at which to monitor.
//
// Joss sends this to Karma to start or stop sampling process information,
// or to change the sampling frequency.
//
vars
    bin : Binary ;
begin
    bin := inheritMethod()						&
		   cnAnsiBinary(offOrOn.padBlanks(3))	&
		   frequency.Binary						;

    return bin ;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars

begin
    inheritMethod ( buf ) ;
    self.offOrOn := getField ( buf , 3 ).ansiToString ;
    self.frequency := byteOrderInteger(getField(buf, 4));
end;
}
setFrequency
{
setFrequency( f : Integer ) updating;

vars

begin
    self.frequency := f ;
end;
}
setOffOrOn
{
setOffOrOn( s : String ) updating;

vars

begin
	if s.length() > 3 then
        self.offOrOn := (s.toUpper)[1:3] ;
    elseif s.length < 3 then
    	self.offOrOn := s.toUpper.padBlanks(3) ;
    else
    	self.offOrOn := s.toUpper ;
    endif;
end;
}
	)
	CnSDSCmd (
	jadeMethodSources
loadMsg
{
loadMsg(buf: Binary) updating;

vars

begin
	inheritMethod(buf);
	command		:= getField(buf, 30).ansiToString.trimRight;
end;
}
processMsg
{
processMsg(proc: Process): String updating;

vars
	result	: String;
	
	cc		: CnCntrl;
begin
	cc := app.myCnCntrl;
	result	:= inheritMethod(proc);
	if result <> CN_OK then
		return result;
	endif;
	
	if cc.appName <> CN_KCCMGR then
		return CN_OK;									// Karma
	endif;
	
	if command = Cn_Cmd_Report_SDS_Status then
		self.sendSDSAdviceMsg(self.sourceProcessType);
		return CN_OK;
	endif;
		
	if command = Cn_Cmd_Disconnect 		or
	   command = Cn_Cmd_StopTracking 	or
	   command = Cn_Cmd_Reconnect 		or	
	   command = Cn_Cmd_ResumeTracking 	or
	   command = Cn_Cmd_Stop_KCCMgr		then
		//
		if system.getDatabaseRole <> SDS_RoleSecondary then
			return command & " not applicable to SDS primary : not actioned.";		// shouldn't happen : current design directs all	
		endif;																		// SDS commands to the secondary

		app.myCnSDSDbAdmin.doCommand(command);
		return CN_OK;
	endif;
	
	return method.cnGetMethodName() & " : unrecognized command '" & command & "'.";
end;
}
sendSDSAdviceMsg
{
sendSDSAdviceMsg(destProcess : String) updating;

vars
	dba						: CnSDSDatabaseAdmin;
	tracking				: Boolean;
	trackingStoppedReason	: Integer;
	rpsTransitionHaltCode	: Integer;
begin
	dba			:= app.myCnSDSDbAdmin;
	tracking	:= dba.getTracking(trackingStoppedReason, rpsTransitionHaltCode);
	dba.sendSDSAdviceMsg(CnMessage.Advice_Type_SDS_Status, tracking, trackingStoppedReason, rpsTransitionHaltCode, "Response to SDS Command", false);
end;
}
setCommand
{
setCommand(cmd : String) updating;

vars

begin
	self.command := cmd;
end;
}
	)
	CnSchemaCopyCmd (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating;

vars
 	bin : Binary;
begin
	bin := inheritMethod							&
		   currentClientBinVersion.Binary			&
		   currentClientMiscVersion.Binary			&
		   currentClientSchemaVersion.Binary		&
		   nextClientBinVersion.Binary				&
		   nextClientMiscVersion.Binary				&
		   nextClientSchemaVersion.Binary			&
		   cnAnsiBinary(copyMessage.padBlanks(254))	&
		   cnAnsiBinary(clientRequiresMisc.Character) &
		   cnAnsiBinary(serverRequiresMisc.Character) &
		   cnAnsiBinary(true.Character);							// as at 3.4 always true, reqd for JSA 3.3 interface to ensure defaults to true

	return bin;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars

begin
 	inheritMethod(buf);

 	self.currentClientBinVersion 	:= byteOrderTimeStamp(getField(buf, 8));
 	self.currentClientMiscVersion 	:= byteOrderTimeStamp(getField(buf, 8));
 	self.currentClientSchemaVersion	:= byteOrderTimeStamp(getField(buf, 8));
 	self.nextClientBinVersion 		:= byteOrderTimeStamp(getField(buf, 8));
 	self.nextClientMiscVersion 		:= byteOrderTimeStamp(getField(buf, 8));
 	self.nextClientSchemaVersion	:= byteOrderTimeStamp(getField(buf, 8));
 	self.copyMessage				:= getField(buf, 254).ansiToString.trimRight;
 	self.clientRequiresMisc			:= getField(buf, 1).ansiToString.Character.Boolean;
 	self.serverRequiresMisc			:= getField(buf, 1).ansiToString.Character.Boolean;
 	self.usesJadeThinClient			:= getField(buf, 1).ansiToString.Character.Boolean;
end;
}
processMsg
{
processMsg(proc: Process): String updating;

vars
 	result 			: String;
 	iResult			: Integer;
 	cc 				: CnCntrl;
 	meth 			: String;
 	kc				: CnKarmaCntrl;
 	commandline		: String;
 	commandinfo		: String;
 	iniInfo			: String;
 	binPath, dbPath	: String;
 	doDownLoad		: Boolean;
 	proc2			: Process;
begin
	result := inheritMethod(proc);
	if result <> CN_OK then
		return result;
	endif;

	cc := app.myCnCntrl;
	kc := app.myCnKarmaCntrl;
	meth := "CnSchemaCopyCmd::processMsg";
	cc.cnWriteLog(cc.CnLogDiag, "in " & meth & "....", null);

	if cc.appName		<> CN_JOSSCOMMSMGR 		and
	   cc.appName 		<> CN_KARMACOMMSMGR 	and
	   cc.appName[1:12] <> CN_KCSCHEMACOPY 		and
	   cc.appName		<> CN_KCDATABASEBACKUP 	and
	   cc.appName		<> CN_KCDBBACKUPWORKER 	and
	   cc.appName 		<> CN_KCCMGR 			then	

		////  If client isn't using read-only schema then discard the message  //////

		if not cc.readOnlySchema and cc.omitBinaryVersionControlCheck then
			cc.cnWriteLog(cc.CnLogDiag, "Client not using managed binaries or read-only schema - copy command ignored", null);
		    return CN_OK;
		endif;

		if app.cnComputerName = cc.myTransientGlobal.cnGetServerComputerName then
			if app.cnStandardizePathName(app.getJadeInstallDir).toLower = cc.myTransientGlobal.cnGetServerInstallDir.toLower then
				cc.cnWriteLog(cc.CnLogDiag, "Client is running on server machine using server binaries  - copy command ignored", null);
		    	return CN_OK;
		    endif;
		endif;	

		if cc.suppressManagementDialogs then
			cc.cnWriteLog(cc.CnLogDiag, "Client has suppressed dialogs in .ini file : schema copy might be unconditional....", null); 	
			doDownLoad := true;
		endif;

		if self.copyMessage = "*" or
		   app.cnApplicationType = app.ApplicationType_Web_Enabled	or 
		   app.cnApplicationType = app.ApplicationType_Non_GUI 		or
		   app.cnApplicationType = app.ApplicationType_Non_GUI_Web 	or
		   process.isUsingThinClient 								or 
		   doDownLoad 												then			// unattended download for web or thin clients  
			doDownLoad := true;														// or those with SuppressManagementDialogs=true

		elseif app.msgBox("The system administrator has scheduled a software change, and you should prepare for " & CrLf &
	       				  "this by copying the new files to your workstation in advance of the change.  The message " & CrLf &
	       				  "from your administrator is as follows:" & CrLf & Lf & ">> " & self.copyMessage & " <<" & CrLf & Lf &
	       				  "You can initiate the copy NOW by pressing 'Yes', or defer this till next time you" & CrLf &
	       				  "start this application, by pressing 'No'." & CrLf & Lf &
	       				  Tab & Tab & "Do you wish to start the copy now ?",
	       	              "JADE Application Software Change Notification",
       	              MsgBox_Yes_No + MsgBox_Question_Mark_Icon) = MsgBox_Return_Yes then
       		doDownLoad := true;
       	endif;

		if doDownLoad then
			if not node.isApplicationServer then
				cc.cnWriteLog(cc.CnLogConnect, "Starting KCSchemaCopy background client as new thread, same node.", null);
				app.startApplication(CN_CARDSCHEMA, CN_KCSCHEMACOPY);

			else
				//  Must be an app server
				//
				//  We need to preload the app server if it's not running on the server host
				//
				if not app.cnAppServerIsOnServer then
					exclusiveLock(global);		// force single-threading
					if app.cnAppIsRunning("CardSchema", "KCSchemaCopyAppServer", app.cnComputerNameAppServer, proc2) then
						cc.cnWriteLog(cc.CnLogComment, "KCSchemaCopyAppServer is already running on app server, so " &
													   "this process won't initiate it.", null);
					else
						cc.cnWriteLog(cc.CnLogComment, "Starting KCSchemaCopyAppServer background client as new node on host " &
									  app.cnComputerNameAppServer & ".", null);
						binPath 	:= app.getJadeInstallDirAppServer;      									// have to start it on the app server
						commandline :=  binPath & "/jade.exe path=" & app.dbPath &		
									    " app=KCSchemaCopyAppServer schema=CardSchema ini=" & binPath & "/" & 
									    kc.environmentId & ".ini server=multiuser";  
		            	node.createExternalProcess(binPath, commandline, null, null, false, false, iResult);
		            endif;
					
					unlock(global);

	            else
	        		cc.cnWriteLog(cc.CnLogDiag, "CnSchemaCopyCmd::processMsg : thin client app server is on server : download not required.", null);
	        	endif;
			endif;

		else
			cc.cnWriteLog(cc.CnLogDiag, "CnSchemaCopyCmd::processMsg : download not required.", null);
     	endif;

     	return CN_OK;

	elseif cc.appName = CN_KCCMGR then
		return cc.appName & ": didn't expect to be here, in " & meth;

	else
		return CN_OK;								// for inheritors
	endif;
epilog
	unlock(global);
end;
}
setClientRequiresMisc
{
setClientRequiresMisc(set : Boolean) updating;

vars

begin
	self.clientRequiresMisc := set;
end;
}
setCopyMessage
{
setCopyMessage(msg : String) updating;

vars

begin
	self.copyMessage := msg;
end;
}
setCurrentClientVersions
{
setCurrentClientVersions(schemaversion : TimeStamp; binversion : TimeStamp; miscversion : TimeStamp) updating;

vars

begin
 	self.currentClientSchemaVersion := schemaversion;
 	self.currentClientBinVersion	:= binversion;
 	self.currentClientMiscVersion	:= miscversion;
end;
}
setNextClientVersions
{
setNextClientVersions(schemaversion : TimeStamp; binversion : TimeStamp; miscversion : TimeStamp) updating;

vars

begin
 	self.nextClientSchemaVersion 	:= schemaversion;
 	self.nextClientBinVersion	    := binversion;
 	self.nextClientMiscVersion		:= miscversion;
end;
}
setNextThinClientVersions
{
setNextThinClientVersions(bin, misc : TimeStamp) updating;

vars

begin
   	self.nextThinClientBinVersion	:= bin;
   	self.nextThinClientMiscVersion	:= misc;
end;
}
setServerRequiresMisc
{
setServerRequiresMisc(set : Boolean) updating;

vars

begin
 	self.serverRequiresMisc := set;
end;
}
	)
	CnThreadCmd (
	jadeMethodSources
assembleMsg
{
assembleMsg(): Binary updating ;

//
// 	An AlertCtlCmd message has a single field : 
//     an integer, representing the process id of the process for
//     which thread information is to be sampled.
//
vars
    bin : Binary ;
begin
    bin := inheritMethod()		&
    	   procId.Binary		&
    	   tiKey.Binary			;

    return bin ;
end;
}
loadMsg
{
loadMsg(buf: Binary) updating;

vars

begin
    inheritMethod ( buf ) ;
    self.procId := byteOrderInteger(getField(buf, 4));
    self.tiKey  := byteOrderInteger(getField(buf, 4));
end;
}
setProcId
{
setProcId( pId : Integer ) updating;

vars

begin
    self.procId := pId ;
end;
}
setTiKey
{
setTiKey( arg : Integer ) updating;

vars

begin
    self.tiKey := arg ;
end;
}
	)
	CnLockTarget (
	jadeMethodSources
getName
{
getName(): String;

vars

begin
	return self.schemaName & "," & self.appName;
end;
}
loadSelf
{
loadSelf(pSchemaName, pAppName : String) updating;

vars

begin
	self.schemaName	:= pSchemaName;
	self.appName	:= pAppName;
	self.myCnRoot	:= app.myCnRoot;
end;
}
setId
{
setId(pId : Integer) updating;

vars

begin
	self.id := pId;
end;
}
	)
	CnRoot (
	jadeMethodSources
clearClusterInfo
{
clearClusterInfo() updating;

vars

begin
	self.clusterName		:= null;
	self.clusterGroup		:= null;
	self.preferredHost		:= null;
	self.virtualMachineName	:= null;
	self.possibleHosts.clear();
end;
}
initializeClusterInfo
{
initializeClusterInfo() updating;

vars
	// for external run via JadeScript or JADLOADB
begin
	beginTransaction;
	self.clusterName		:= null;
	self.clusterGroup		:= null;
	self.preferredHost		:= null;
	self.virtualMachineName	:= null;
	self.possibleHosts.clear();
	commitTransaction;
end;
}
loadClusterInfo
{
loadClusterInfo(ci : CnClusterInfo) updating;

vars
	host	: String;
begin
	self.clusterName		:= ci.clusterName;
	self.clusterGroup		:= ci.clusterGroup;
	self.preferredHost		:= ci.preferredHost;
	self.virtualMachineName	:= ci.virtualMachineName;
	self.possibleHosts.clear();
	foreach host in ci.possibleHosts do
		self.possibleHosts.add(host.toUpper);			// ensure in upper case
	endforeach;
end;
}
setDeploymentStatus
{
setDeploymentStatus(status : Integer) updating;

vars

begin
	self.deploymentStatus := status;
end;
}
setMyKCCMgrProcess
{
setMyKCCMgrProcess(pProcess : Process) updating;

vars

begin
	self.myKCCMgrProcess := pProcess;
end;
}
	)
	CnSDSStructureState (
	jadeMethodSources
delete
{
delete() updating;

// raise an SDS event so the deleted object can be obtained in the Secondary
vars
	name,
	paritionId,
	structInfo	: String;
begin
	structInfo	:= self.name & "|" & self.partitionId.String;
	system.sdsCauseEvent(Cn_SDS_Structure_State_Delete, false, structInfo); // submit the structure name and partitionId
end;
}
setFrozen
{
setFrozen(pFrozen : Boolean) updating;

vars

begin
	self.frozen := pFrozen;
end;
}
setMyCnRoot
{
setMyCnRoot(pCnRoot : CnRoot) updating;

vars

begin
	self.myCnRoot := pCnRoot;
end;
}
setName
{
setName(pName : String) updating;

vars

begin
	self.name := pName;
end;
}
setOffline
{
setOffline(pOffline : Boolean) updating;

vars

begin
	self.offline := pOffline;
end;
}
setPartitionId
{
setPartitionId(pPartitionId : Integer64) updating;

vars

begin
	self.partitionId := pPartitionId;
end;
}
	)
	CnProcess (
	jadeMethodSources
incrementTransStatsLength
{
incrementTransStatsLength(pValue : Integer) updating;

vars

begin
	self.tranStatsLength := self.tranStatsLength + pValue;
end;
}
setClientTranStats
{
setClientTranStats(set : Boolean) updating;

vars

begin
 	self.clientTranStats := set;
end;
}
setComputerName
{
setComputerName(name : String) updating;

vars

begin
	self.computerName := name;
end;
}
setHeartbeatTimestamp
{
setHeartbeatTimestamp(ts : TimeStamp) updating;

vars

begin
	self.heartbeatTimestamp := ts;
end;
}
setMyCnApp
{
setMyCnApp(cnapp : CnApp) updating;

vars

begin
 	self.myCnApp := cnapp;
end;
}
setMyMachine
{
setMyMachine(cnmach : CnMachine) updating;

vars

begin
	self.myMachine := cnmach;
end;
}
setMyProcess
{
setMyProcess(proc : Process	) updating;

vars

begin
	self.myProcess := proc;
end;
}
setOsPID
{
setOsPID(pid : Integer) updating;

vars

begin
 	self.osPID := pid;
end;
}
setProcessId
{
setProcessId(procid : Integer) updating;

vars

begin
  	self.processId 	:= procid;
  	self.myCnKarmaCntrl	:= app.myCnKarmaCntrl;
end;
}
setStartTime
{
setStartTime(ts : TimeStamp) updating;

vars

begin
	self.startTime := ts;
end;
}
setTransStatsLength
{
setTransStatsLength(pValue : Integer) updating;

vars

begin
	self.tranStatsLength := pValue;
end;
}
	)
	CnSmtpState (
	jadeMethodSources
defaultServerErrorHandler
{
defaultServerErrorHandler(smtp:CnSmtpConnection input);

//V2	23.06.00	Remove unnecessary 'get' method calls

vars

begin

	smtp.extendedErrorText := smtp.serverMessage;		//V2 Pass the server's message on to the user
    sendRSET(smtp);										//The reply to the RSET will generate a QUIT, the reply to which will break the TCP connection

end;
}
do214
{
do214(smtp:CnSmtpConnection input);

vars

begin

	ignore(smtp);		//Default behaviour for 214 - may be reimplemented in subclasses

end;
}
do220
{
do220(smtp:CnSmtpConnection input);

vars

begin

	ignore(smtp);		//Default behaviour for 220 - may be reimplemented in subclasses

end;
}
do221
{
do221(smtp:CnSmtpConnection input);

vars

begin

	do421(smtp);		//Process as for 421 (Service Not Available: Closing Transmission Channel)

end;
}
do235
{
do235(smtp:CnSmtpConnection input);

//V8 13.05.14 Provide SMTP authentication and TLS (Transport Layer Security)
vars

begin

	defaultServerErrorHandler(smtp);				// V8

end;
}
do250
{
do250(smtp:CnSmtpConnection input);

vars

begin

	ignore(smtp);		//Default behaviour for 250 - may be reimplemented in subclasses

end;
}
do334
{
do334(smtp:CnSmtpConnection input);
//V8 13.05.14 Provide SMTP authentication and TLS (Transport Layer Security)
vars

begin

	defaultServerErrorHandler(smtp);	// V8
end;
}
do354
{
do354(smtp:CnSmtpConnection input);

vars

begin

	ignore(smtp);		//Default behaviour for 354 - may be reimplemented in subclasses

end;
}
do421
{
do421(smtp:CnSmtpConnection input);

//V3 	06.08.2002	Delay sending completion notification until callback from cnClose is received.
//V2	23.06.00	Remove unnecessary 'get' method calls

// 421 = Service Not Available: Closing Transmission Channel

vars

begin

	smtp.changeState(CnSmtpStateTCPDisconnected);
	smtp.cnClose(smtp);									//Close the TCP connection
    smtp.extendedErrorText := smtp.serverMessage;		//V2 Pass the server's message on to the user
    //setCompleted(smtp);  //V3

end;
}
do450
{
do450(smtp: CnSmtpConnection input);

// 450 = Requested mail action not taken: mailbox unavailable (e.g. mailbox busy)

vars

begin

	defaultServerErrorHandler(smtp);

end;
}
do451
{
do451(smtp:CnSmtpConnection input);

// 451 = Requested action aborted: local error in processing

vars

begin

      defaultServerErrorHandler(smtp);

end;
}
do452
{
do452(smtp:CnSmtpConnection input);

// 452 = Requested action not taken: insufficient system storage

vars

begin

      defaultServerErrorHandler(smtp);

end;
}
do500
{
do500(smtp:CnSmtpConnection input);

// 500 = Syntax error, command unrecognised

vars

begin

      defaultServerErrorHandler(smtp);

end;
}
do501
{
do501(smtp:CnSmtpConnection input);

// 501 = Syntax error in parameters or arguments

vars

begin

      defaultServerErrorHandler(smtp);

end;
}
do502
{
do502(smtp:CnSmtpConnection input);

// 502 = Command not implemented

vars

begin

      defaultServerErrorHandler(smtp);

end;
}
do503
{
do503(smtp:CnSmtpConnection input);

// 503 = Bad sequence of commands

vars

begin

      defaultServerErrorHandler(smtp);

end;
}
do504
{
do504(smtp:CnSmtpConnection input);

// 504 = Command parameter not implemented

vars

begin

      defaultServerErrorHandler(smtp);

end;
}
do530
{
do530(smtp: CnSmtpConnection input);
//V9 Handle message type 530
// 530 = STARTTLS expected
// 530 = 5.5.1 Authentication Required

vars

begin
	smtp.changeState(CnSmtpStateTCPDisconnected);														// V9
	smtp.cnClose(smtp);									//Close the TCP connection						// V9
    smtp.extendedErrorText := smtp.serverMessage;														// V9
end;
}
do534
{
do534(smtp: CnSmtpConnection input);
//V9 Handle message type 530
// 534 = 5.7.9 Application-specific password required.

vars

begin
	smtp.changeState(CnSmtpStateTCPDisconnected);														// V9
	smtp.cnClose(smtp);									//Close the TCP connection						// V9
    smtp.extendedErrorText := smtp.serverMessage;														// V9
end;
}
do535
{
do535(smtp: CnSmtpConnection input);
//V8 13.05.14 Provide SMTP authentication and TLS (Transport Layer Security)


// 535 = Authentication failed

vars

begin
	smtp.changeState(CnSmtpStateTCPDisconnected);											// V8
	smtp.cnClose(smtp);									//Close the TCP connection			// V8
    smtp.extendedErrorText := smtp.serverMessage;											// V8
end;
}
do550
{
do550(smtp:CnSmtpConnection input);

// 550 = Requested action not taken: mailbox unavailable (e.g. mailbox not found, no access)

vars

begin

      defaultServerErrorHandler(smtp);

end;
}
do551
{
do551(smtp:CnSmtpConnection input);

// 551 = User not local; please try <forward-path>

vars

begin

      defaultServerErrorHandler(smtp);

end;
}
do552
{
do552(smtp:CnSmtpConnection input);

// 552 = Requested mail action aborted: exceeded storage allocation

vars

begin

      defaultServerErrorHandler(smtp);

end;
}
do553
{
do553(smtp:CnSmtpConnection input);

// 553 = Requested mail action not taken: mailbox name not allowed (e.g. mailbox syntax incorrect)

vars

begin

		defaultServerErrorHandler(smtp);

end;
}
do554
{
do554(smtp:CnSmtpConnection input);

// 554 = Transaction Failed

vars

begin

      defaultServerErrorHandler(smtp);

end;
}
findLastLine
{
findLastLine(pMessage:String input; pSmtp:CnSmtpConnection input):Boolean updating;

//V2	06.08.2002	Delay sending completion notification until callback from cnClose is received.

vars
       lastLineStart:Integer;
       replyCode:String;
begin

       replyCode		:=	pMessage[1:3];

       lastLineStart	:=	pMessage.pos(replyCode & " ", 1);
       if lastLineStart = null then
          pSmtp.extendedErrorText	:=	"Server sent message with invalid format (" & pMessage & ")";
          sendQUIT(pSmtp);
          //setCompleted(pSmtp); //V2
          	return false;
	 	else
     		pSmtp.setServerMessage(pMessage[lastLineStart:end]);	//Replace the received message with just the last line
            return true;
       endif;

end;
}
handleEvent
{
handleEvent(smtp:CnSmtpConnection input) updating;

//V8 	13.05.14 Provide SMTP authentication and TLS (Transport Layer Security)
//V3	21.09.2000 Changes for UNICODE
//V2	23.06.00	Remove unnecessary 'get' method calls	

vars
    msgNumber, command, message, lastLine:String;
begin

	message := smtp.serverMessage;			//V2
	if message[1:3].isInteger then	

		//We have a reply code
		msgNumber := message[1:3];			//First three characters of the message are the message number

        //If it's a multi-line reply and not a state where we want all detakls, discard all but the last line
        if msgNumber = "530" or
		   msgNumber = "534" then
		   // don't change the serverMessage
		elseif message[4] = "-" and
           not findLastLine(message, smtp) then
			return;						//Format error in server message
        endif;

		if msgNumber = "220" then			//Service Ready
			do220(smtp);
		elseif msgNumber = "221" then		//Service Closing Transmission Channel
			do221(smtp);
		elseif msgNumber = "235" then		//Authentication Successful															// V8
			do235(smtp);																										// V8
		elseif msgNumber = "250" then		//OK
			do250(smtp);	
		elseif msgNumber = "211" then		//System Status, or System Help Reply (ignore for the time being)
			ignore(smtp);
		elseif msgNumber = "214" then		//Help Message (ignore for the time being)
			do214(smtp);	
		elseif msgNumber = "251" then		//User Not Local: Will Forward To <forward-path>
			ignore(smtp);	
		elseif msgNumber = "334" then		//Request username or password														// V8
			do334(smtp);																										// V8
		elseif msgNumber = "354" then		//Start Mail Input
			do354(smtp);	
		elseif msgNumber = "421" then		//Service Not Available: Closing Transmission Channel
			do421(smtp);
		elseif msgNumber = "450" then		//Requested Mail Action Not Taken: Mailbox Unavailable
			do450(smtp);
		elseif msgNumber = "451" then		//Requested Action Aborted: Local Error in Processing
			do451(smtp);
		elseif msgNumber = "452" then		//Requested Action Aborted: Insufficient System Storage
			do452(smtp);			
		elseif msgNumber = "500" then		//Syntax Error, Command Not Recognised
			do500(smtp);	
		elseif msgNumber = "501" then		//Syntax Error in Parameters or Arguments
			do501(smtp);
		elseif msgNumber = "502" then		//Command Not Implemented
			do502(smtp);
		elseif msgNumber = "503" then		//Bad Sequence of Commands
			do503(smtp);
		elseif msgNumber = "504" then		//Command Parameter Not Implemented
			do504(smtp);
		elseif msgNumber = "530" then		// Error : eg STARTTLS expected or authentication required
			do530(smtp);
		elseif msgNumber = "534" then		// Error : eg Application-specific password required
			do534(smtp);
		elseif msgNumber = "535" then		//Authentication failed																// V8
			do535(smtp);																										// V8
		elseif msgNumber = "550" then		//Requested Action Not Taken: MailBox Unavailable
			do550(smtp);	
		elseif msgNumber = "551" then		//User Not Local; Please Try <forward-path>
			do551(smtp);	
		elseif msgNumber = "552" then		//Requested Mail Action Aborted: Exceeded Storage Allocation
			do552(smtp);	
		elseif msgNumber = "553" then		//Requested Action Not Taken: MailBox Name Not Allowed
			do553(smtp);
		elseif msgNumber = "554" then		//Transaction Failed
			do554(smtp);	
		else
			ignore(smtp);					//Ignore any unrecognised messages from server (should these be logged?)											
		endif;

	else

		//Not a reply code : is it a command?

		message[1:4].toUpper;
		if message[1:4] = "RSET" then										//Handle RESET
			smtp.cnWrite(cnAnsiBinary("250 OK" &  CrLf), smtp);				//V3
			smtp.CnSmtpConnection.extendedErrorText := "Mail server has aborted the current transaction";
			sendQUIT(smtp);
		elseif message[1:4] = "NOOP" then                    				//Handle NOOP
			sendOK(smtp);
		else
			//The server sent something we don't yet recognise
			smtp.cnWrite(cnAnsiBinary("500 " & E500), smtp);				// V3 Indicate 'syntax error' to the mail server
		endif;
	endif;	


end;
}
ignore
{
ignore(smtp: CnSmtpConnection input);

//V2	20.06.01	Clear serverMessage before reading.
vars

begin

	smtp.setServerMessage("");		// Delete any data received so far, and issue a new read
	smtp.clearServerMessageAndRead(smtp);	//V2

end;
}
markAsUndelivered
{
markAsUndelivered(smtp : CnSmtpConnection input);

//V2 23.06.00	Remove unnecessary 'get' method calls

vars

begin

	smtp.undelivered.add(smtp.recipientArray[smtp.recipientArrayIndex] & "/" & smtp.serverMessage);

end;
}
sendOK
{
sendOK(smtp:CnSmtpConnection input);

//V3	20.06.2001 Clear server message before reading
//V2	21.09.2000 Changes for UNICODE
// Send 250 OK when we receive a NOOP from server, and stay in the same state
vars

begin

	smtp.cnWrite(cnAnsiBinary("250 OK" &  CrLf), smtp); //V2
	smtp.clearServerMessageAndRead(smtp);				//V3

end;
}
sendQUIT
{
sendQUIT(smtp:CnSmtpConnection input);

//V3	20.06.2001 Clear server message before reading
//V2	21.09.2000 Changes for UNICODE

vars

begin

	smtp.cnWrite(cnAnsiBinary("QUIT" &  CrLf), smtp);		//V2
	smtp.changeState(CnSmtpStateQUIT);
	smtp.clearServerMessageAndRead(smtp);		//V3 Now we expect a 221 reply to QUIT

end;
}
sendRSET
{
sendRSET(smtp : CnSmtpConnection input);

//V3	20.06.2001 Clear serverMessage before reading
//V2	21.09.2000 Changes for UNICODE

vars

begin


	smtp.cnWrite(cnAnsiBinary("RSET" & CrLf), smtp);	//V2
	smtp.CnSmtpConnection.changeState(CnSmtpStateRSET);
	smtp.clearServerMessageAndRead(smtp);		//V3 Now we expect a 250 reply to RSET

end;
}
setCompleted
{
setCompleted(smtp:CnSmtpConnection input);

//V3 30.06.00 Set 'completed' attribute
//V2 26.04.99 Delete any open file objects - otherwise they stay open until smtp and attachment objects are deleted.

vars

begin

	// Set 'result' property to tell user what happened during this mail transaction:
	//	Result = 0	:	No errors
	//	Result = 1	:	An error occurred
	//	Result = 2	:	Delivery failed to one or more recipients (see 'undelivered' HugeStringArray)

	if smtp.extendedErrorText <> "" then
		smtp.result := smtp.result.bitOr(CnSmtpConnection.Error_Occurred);
	endif;
	
	if not smtp.undelivered.isEmpty() then
		smtp.result := smtp.result.bitOr(CnSmtpConnection.Undelivered_Recipients);
	endif;

	//Close any open files

	smtp.deleteFileObjects;

	// Indicate to user that message has been sent

	smtp.setCompleted(true);
	smtp.causeEvent(CnSmtpConnection.Completion_Event_Type, true, null);	

end;
}
	)
	CnSmtpStateAUTH (
	jadeMethodSources
do235
{
do235(smtp: CnSmtpConnection input);
//V8 13.05.14 Provide SMTP authentication and TLS (Transport Layer Security)
vars

begin
    smtp.cnWrite(cnAnsiBinary("MAIL FROM: " & "<" & smtp.sendFromAddress & ">" & CrLf), smtp);		// V8
	smtp.changeState(CnSmtpStateMAIL);																// V8
	smtp.clearServerMessageAndRead(smtp);															// V8
end;
}
do334
{
do334(smtp: CnSmtpConnection input);
//V8 13.05.14 Provide SMTP authentication and TLS (Transport Layer Security)
vars

begin
    if  smtp.serverMessage.pos("VXNlcm5hbWU6",1) <> null then										// V8
        smtp.cnWrite(cnAnsiBinary(smtp.base64Encode(cnAnsiBinary(smtp.username))&CrLf), smtp);		// V8
        smtp.clearServerMessageAndRead(smtp);														// V8
		
    elseif
        smtp.serverMessage.pos("UGFzc3dvcmQ6",1) <> null then										// V8
        smtp.cnWrite(cnAnsiBinary(smtp.base64Encode(cnAnsiBinary(smtp.password))&CrLf), smtp);		// V8
        smtp.clearServerMessageAndRead(smtp);														// V8
    endif;																							// V8
end;
}
	)
	CnSmtpStateDATA (
	jadeMethodSources
do354
{
do354(smtp : CnSmtpConnection input);

//V2 29.03.00 Cater for lines that flow across a block boundary
//V4 20.06.00 Support for inline (embedded) objects, such as images; remove unnecessary 'get' method calls
//V5 21.09.2000 Changes for UNICODE
//V6 20.06.2001 Clear serverMessage before reading.

vars
      binaryBuffer		:	Binary;

      first,
      isTruncated		:	Boolean;	//V2
	  
      assembledMessage,
      editedMessage,
      reply,
      contentType		:	String;

begin

	on CnSmtpConnectionException do smtp.validationExceptionHandler(exception);

	smtp.buildMessageHeader;

 	// If the message is contained in a file, read each block from the file and send it
	if smtp.messageFileName <> null then				//V4

      	first	:=	true;
      	while not smtp.messageFileObject.endOfFile do	//V4
      		binaryBuffer			:=	smtp.messageFileObject.readBinary(smtp.blockSize);
      		smtp.validateMessage(binaryBuffer, editedMessage, smtp.encodingType, isTruncated, smtp.isUserEncoded);//V2

           	//If message validation failed, the validationExceptionHandler in the smtp object will be called

           	//The first block in the message is preceded by the RFC 822 header
           	if first then 
           		assembledMessage	:=	smtp.messageHeader & editedMessage;	
           		first				:=	false;
           	else
           		assembledMessage	:=	editedMessage;	//Not the first block
           	endif;
           	smtp.cnWrite(cnAnsiBinary(assembledMessage), smtp);	//V5	
     	endwhile;

		if not smtp.allInlines.isEmpty() then			// V4 If there are embedded objects, send them
			sendInlines(smtp);							// V4
        endif;											// V4

		if not smtp.myAttachments.isEmpty() then      	// V4 If there are attachments, send them 
			sendFileAttachments(smtp);
        endif;

        smtp.cnWrite(cnAnsiBinary(CrLf & "." & CrLf), smtp);	// V5 SMTP End of message sequence
        smtp.changeState(CnSmtpStateDATASent);
        smtp.clearServerMessageAndRead(smtp);			// V6 Now we expect a 250 reply to the block we've sent


	else    
      // Message is just a string in cnTcp.SmtpConnection.editedMessage

		assembledMessage	:=	smtp.messageHeader & smtp.editedMessage;	//V4

		smtp.cnWrite(cnAnsiBinary(assembledMessage), smtp);		// V5

		if not smtp.allInlines.isEmpty() then			// V4 If there are inlines, send them
			sendInlines(smtp);							// V4
        endif;											// V4

		if not smtp.myAttachments.isEmpty() then				// V4 If there are attachments, send them
			sendFileAttachments(smtp);	
        endif;	

		smtp.cnWrite(cnAnsiBinary(CrLf & "." & CrLf), smtp);	// V5 SMTP End of message sequence
		smtp.changeState(CnSmtpStateDATASent);
		smtp.clearServerMessageAndRead(smtp);			// V6 Now we expect a 250 reply to the message
      endif;
end;
}
getLastFilenameNode
{
getLastFilenameNode(pFileName:String input):String;

//V1

constants

	Slash = "\";

vars

	slashPos:Integer;

begin

	slashPos := pFileName.reversePos(Slash);
	if slashPos <> 0 then
		return pFileName[slashPos + 1:end];
	else
		return pFileName;
	endif;		

end;
}
sendFileAttachments
{
sendFileAttachments(smtp:CnSmtpConnection input);

//V2 Send last node of filename only - not the whole pathname
//V3 29.03.00 Cater for lines that flow across block boundaries
//V4 Remove unnecessary 'get' method calls and replace literals by constants; remove code that was sending one boundary too many;
//	 allow Content-Transfer-Encoding types other than Base64; send Content-Description.
//V5 21.09.2000 Changes for UNICODE
//V6 22.05.2002	Ensure base64 lines are no longer than 76 characters when appending text from new block (Note: we should check whether
//				sendInLines needs similar modifications).
//V7 04.09.2003	Allow for attachments with zero length.
//v8 30.01.2006 Remove trailing semicolon after content-disposition filename
//              and 'content-type: xxx; name=xxx'
//V9 09.11.2015 Ensure base64 lines are no longer than 76 characters when appending text from new block - common code
constants

	SemiColon		=	";";	//V4
	BoundaryDash 	= 	"--";	//V4

vars

	binaryBuffer		:	Binary;
	first				:	Boolean;
	isTruncated			:	Boolean;	//V3
	attachment			:	CnAttachment;
	attachmentCount		:	Integer;
	attachmentHeader	:	String;
	editedMessage		:	String;
	assembledMessage	:	String;
	contentType			:	String;
	lastFilenameNode	:	String;
	lowerEncodingType	:	String;		//V4
	msgLength			:	Integer;	//V6
	endsWithCrLf		:	Boolean;	//V6
	
begin

	on CnSmtpConnectionException do smtp.validationExceptionHandler(exception);

	foreach attachment in smtp.myAttachments do									//V4
		attachmentCount		:=	attachmentCount + 1;

		lastFilenameNode	:=	getLastFilenameNode(attachment.fileName);		//V2

		contentType			:=	Content_Type & attachment.contentType.toLower & SemiColon;	//V4

		attachmentHeader	:=	CrLf & BoundaryDash	&
								smtp.boundary		& CrLf &
								contentType			& CrLf & Tab &
								Name_Equals			& '"' &						//V4
//								lastFilenameNode	& '"' & SemiColon & CrLf; 	//V2 V4
								lastFilenameNode	& '"' & CrLf; 				//V2 V4 V8

		// Insert Content-Transfer-Encoding
		lowerEncodingType		:=	attachment.encodingType.toLower;			//V4
		if lowerEncodingType = CnSmtpConnection.None then		       			//V4
			attachmentHeader	:=	attachmentHeader & Content_Transfer & Content_Transfer_7Bit & CrLf;//V4
		else                                                            		//V4
			attachmentHeader	:=	attachmentHeader & Content_Transfer & lowerEncodingType & CrLf;    //V4
		endif;                                                                 	//V4

		if attachment.contentDescription <> null then
			attachmentHeader	:=	attachmentHeader	&	Content_Description	&	attachment.contentDescription	&	CrLf;	//V4
		endif;

		attachmentHeader	:= attachmentHeader & Content_Disposition_Attachment & CrLf; //V4
//		attachmentHeader	:= attachmentHeader & Tab & FileName_Equals & '"' & lastFilenameNode & '"' & SemiColon & CrLf & CrLf;	//V2 V4
		attachmentHeader	:= attachmentHeader & Tab & FileName_Equals & '"' & lastFilenameNode & '"' & CrLf & CrLf;	//V2 V4 V8
	    first := true;
	    while true do															//V7

	    	// Fetch, validate, and encode next block.
	    	// If message validation fails, the validationExceptionHandler in the smtp object will be called

			if not attachment.fileObject.endOfFile then 						//V7
				binaryBuffer := attachment.fileObject.readBinary(smtp.blockSize);	//V3 V4
			else 																//V7
				binaryBuffer := null;											//V7
			endif;																//V7
			
			smtp.validateMessage(binaryBuffer,editedMessage, attachment.encodingType, isTruncated, attachment.isUserEncoded);//V5 V3

	    	if attachment.fileObject.endOfFile then								//V4
	    		if attachmentCount = smtp.myAttachments.size then				//V4
	    			editedMessage := editedMessage & CrLf & BoundaryDash & smtp.boundary & BoundaryDash & CrLf;	//V4
	    		endif;	
	      	endif;

	      	assembledMessage := self.zHandleBase64Inline(editedMessage, attachmentHeader, lowerEncodingType, first, smtp);	//V6, V9
			if smtp.sendAttachmentsSync then
				smtp.cnWriteSync(cnAnsiBinary(assembledMessage));				// PAR #760, send email attachments synchronously 
			else
				smtp.cnWrite(cnAnsiBinary(assembledMessage), smtp);				//V5
	    	endif;
			
	    	if attachment.fileObject.endOfFile then								//V7
	    		break;															//V7
	    	endif;																//V7
	    endwhile;
	endforeach;	

end;
}
sendInlines
{
sendInlines(smtp:CnSmtpConnection input);

// V1 20.06.00
// V2 21.09.2000 Changes for UNICODE
// V3 30.01.2006 Remove trailing semicolon for 'content-disposition; filename=xx'
//               and 'content-type: xxx; name=xxx'
// V9 09.11.2015 Ensure base64 lines are no longer than 76 characters when appending text from new block - common code
constants

	Space			= " ";
	SemiColon		= ";";
	LeftAngle		= "<";
	RightAngle		= ">";
	BoundaryDash	= "--";

vars

	binaryBuffer		:	Binary;
	bStart				:	Integer;
	first				:	Boolean;
	isTruncated			:	Boolean;	
	inline				:	CnSmtpInline;
	inlineCount			:	Integer;
	inlineHeader		:	String;
	editedMessage		:	String;
	assembledMessage	:	String;
	contentType			:	String;
	lastFilenameNode	:	String;
	localContentID		:	String;
	localFileName		:	String;
	lowerEncodingType	:	String;
begin

	on CnSmtpConnectionException do smtp.validationExceptionHandler(exception);

	foreach inline in smtp.allInlines do
		inlineCount 		:= inlineCount + 1;

		lastFilenameNode	:= getLastFilenameNode(inline.fileName);	

		contentType			:= Content_Type & Space & inline.contentType.toLower & SemiColon;

		// Insert inline boundary, Content-Type and filename
		inlineHeader		:=	CrLf	&	BoundaryDash		&
								smtp.inlineBoundary	& CrLf	&
								contentType 		& CrLf	& Tab &
								Name_Equals			& '"'	&
//								lastFilenameNode	& '"' 	& SemiColon &  CrLf;
								lastFilenameNode	& '"' 	&  CrLf;					//V3

		// If a content id was supplied, use it: otherwise, generate a globally-unique content id
		if inline.contentID <> null then
			localContentID	:=	inline.contentID;
		else
			localContentID	:=	smtp.genUniqueCID(inlineCount);
		endif;		

		// Insert Content-Location - this defaults to the filename unless user supplied a specific contentLocation value
		inlineHeader 		:= 	inlineHeader & Content_Location & inline.contentLocation & CrLf;

		// Insert Content-ID
		inlineHeader		:=	inlineHeader & Content_ID & LeftAngle & localContentID & RightAngle & CrLf;

		// Insert Content-Transfer-Encoding
		lowerEncodingType		:=	inline.encodingType.toLower;				
		if lowerEncodingType = CnSmtpConnection.None then		       				
			inlineHeader		:=	inlineHeader & Content_Transfer & Content_Transfer_7Bit & CrLf;
		else                                                            			
			inlineHeader		:=	inlineHeader & Content_Transfer & lowerEncodingType & CrLf;    
		endif;                                                                 		

		// Insert Content-Description (if any)
		if inline.contentDescription <> null then
			inlineHeader		:=	inlineHeader	&	Content_Description	&	inline.contentDescription	&	CrLf;	//V4
		endif;

		// Insert Content-Disposition-Inline
		inlineHeader 		:= inlineHeader & Content_Disposition_Inline	& CrLf;

//		inlineHeader 		:= inlineHeader & Tab & FileName_Equals & '"' & lastFilenameNode & '"' & SemiColon & CrLf & CrLf;	
		inlineHeader 		:= inlineHeader & Tab & FileName_Equals & '"' & lastFilenameNode & '"' & CrLf & CrLf;		// V3	

	    first := true;

	    if inline.sourceIsFile = false then

	    	// Image is in the inline.binaryImage property

	    	if inline.sendAsOneBlock then

	    		// Send image as a single block
	    		smtp.validateMessage(inline.binaryImage, editedMessage, inline.encodingType, isTruncated, inline.isUserEncoded); //V2
	    		if inlineCount = smtp.allInlines.size then
					editedMessage	:= editedMessage & CrLf & BoundaryDash & smtp.inlineBoundary & BoundaryDash & CrLf;
   				endif;
   				assembledMessage	:= inlineHeader & editedMessage;
   				smtp.cnWrite(cnAnsiBinary(assembledMessage), smtp);	//V2

			else

	    		// Send image according to the CnSmtpConnection::blockSize parameter 
	    		bStart				:=	1;
	    		while bStart <= inline.binaryImage.length do
	    			binaryBuffer		:=	inline.binaryImage[bStart:smtp.blockSize];
	    			smtp.validateMessage(binaryBuffer, editedMessage, inline.encodingType, isTruncated, inline.isUserEncoded);	//V2
	    			bStart				:=	bStart	+	smtp.blockSize;

	    			if bStart > inline.binaryImage.length then
	    				if inlineCount = smtp.allInlines.size then
							editedMessage	:= editedMessage & CrLf & BoundaryDash & smtp.inlineBoundary & BoundaryDash & CrLf;
    					endif;
        			endif;

					assembledMessage := self.zHandleBase64Inline(editedMessage, inlineHeader, lowerEncodingType, first, smtp);	//V9
    				smtp.cnWrite(cnAnsiBinary(assembledMessage), smtp);	//V2
    			endwhile;
    		endif;		

    	else	

            // Image is in the file pointed to by inline.fileObject
		    while not inline.fileObject.endOfFile do

		    	// Fetch, validate, and encode next block.
		    	// If message validation fails, the validationExceptionHandler in the smtp object will be called

				binaryBuffer 	:= inline.fileObject.readBinary(smtp.blockSize);
				smtp.validateMessage(binaryBuffer,editedMessage, inline.encodingType, isTruncated, inline.isUserEncoded);	//V2

		    	if inline.fileObject.endOfFile then
		    		if inlineCount = smtp.allInlines.size then
		    			editedMessage	:= editedMessage & CrLf & BoundaryDash & smtp.inlineBoundary & BoundaryDash & CrLf;
		    		endif;	
		      	endif;

		      	assembledMessage := self.zHandleBase64Inline(editedMessage, inlineHeader, lowerEncodingType, first, smtp);	//V9
	      		smtp.cnWrite(cnAnsiBinary(assembledMessage), smtp);	//V2
	    	endwhile;
	    endif;	
	endforeach;	

end;
}
zHandleBase64Inline
{
zHandleBase64Inline(pEditedMessage,
					pHeader,
					pEncodingType	: String;
					pFirstOne		: Boolean io;
					pSMTP			: CnSmtpConnection) : String;
					
//V9 09.11.2015	Ensure base64 lines are no longer than 76 characters when appending text from new block
vars
	endsWithCrLf,
	smtpBase64			: Boolean;
	
	msgLength			: Integer;
	
	assembledMessage	: String;
begin
	smtpBase64			:= (pEncodingType = pSMTP.Base64);				//V9
    msgLength			:= pEditedMessage.length();						//V9
	if msgLength >= 2 then
		endsWithCrLf	:= (pEditedMessage[msgLength -1:end] = CrLf); 	//V9
	endif;	
	
	if pFirstOne then 
		pFirstOne := false;
		assembledMessage := pHeader & pEditedMessage;
		if smtpBase64								and					//V9
		   not endsWithCrLf							and					//V9
		   (assembledMessage.length mod 76 <> null)	then				//V9
			assembledMessage	:=	assembledMessage & CrLf;			//V9
		endif;															//V9
		
	else
		if smtpBase64								and					//V9
		   not endsWithCrLf							and					//V9
		   (msgLength mod 76 <> null)				then				//V9
			assembledMessage	:=	pEditedMessage & CrLf;				//V9
			
		else															//V9	
			assembledMessage 	:= 	pEditedMessage;						//V9
		endif;															//V9
	endif;																//V9
	
	return assembledMessage;
end;
}
	)
	CnSmtpStateDATASent (
	jadeMethodSources
do250
{
do250(smtp : CnSmtpConnection input);

//V2 25.06.04	Keep Connection Open
vars
	cc : CnCntrl;												// V2
begin
	if not smtp.keepConnectionOpen then							// V2
		sendQUIT(smtp);
		return;													// V2
	endif;														// V2
	
	smtp.changeState(CnSmtpStateTCPConnected);					// V2
	self.setCompleted(smtp);									// V2
	if smtp.loggingRequired then								// V2
		cc := app.myCnCntrl;									// V2
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & 		// V2
									" connection #" & 			// V2
									smtp.connectionNo.String & 	// V2
									" is now available", null);	// V2
	endif;
end;
}
	)
	CnSmtpStateHELO (
	jadeMethodSources
do250
{
do250(smtp : CnSmtpConnection input);

//V8 13.05.14 Provide SMTP authentication and TLS (Transport Layer Security)
//V5 20.06.2001 Clear serverMessage before reading.
//V4 21.09.2000 Changes for UNICODE
//V3 27.06.00	Use sendFromAddress instead of sendFromArray
//V2 Handle name + e-mail address in sendFrom

vars

begin
	if smtp.authenticate then																			// V8
		smtp.cnWrite(cnAnsiBinary("auth login" & CrLf), smtp);											// V8
		smtp.changeState(CnSmtpStateAUTH);																// V8
		smtp.clearServerMessageAndRead(smtp);															// V8
	
	else																								// V8
		smtp.cnWrite(cnAnsiBinary("MAIL FROM: " & "<" & smtp.sendFromAddress & ">" & CrLf), smtp);   	// V4 V3
		smtp.changeState(CnSmtpStateMAIL);
		smtp.clearServerMessageAndRead(smtp);		//V5 Now we expect a 250 reply to MAIL
	endif;																								// V8
end;
}
	)
	CnSmtpStateMAIL (
	jadeMethodSources
do250
{
do250(smtp : CnSmtpConnection input);

//V4 20.06.2001 Clear server message before reading
//V3 21.09.2000 Changes for UNICODE
//V2 23.06.00	Remove unnecessary 'get' method calls

vars

begin

	//Send RCPT to indicate the first recipient. Of course, this may be the only recipient.

	smtp.cnWrite(cnAnsiBinary("RCPT TO: " & "<" & smtp.recipientArray[1] & ">" & CrLf), smtp);		//V3
	smtp.setRecipientArrayIndex(1);

	smtp.setAtLeastOneValidRecipient(false);				// Assume no recipient is valid. This flag is changed to true if we get a 250 reply to a RCPT

	smtp.changeState(CnSmtpStateRCPT);
	smtp.clearServerMessageAndRead(smtp);					// V4 Now we expect a 250 reply to RCPT

	//Further RCPTs are sent from the SmtpStateRCPT::do250 method				
end;
}
	)
	CnSmtpStateQUIT (
	jadeMethodSources
do221
{
do221(smtp : CnSmtpConnection input);

//V2 06.08.2002	Delay sending completion notification until callback from cnClose is received.

vars

begin

	smtp.changeState(CnSmtpStateTCPDisconnected);
	smtp.cnClose(smtp);		//Close the TCP connection
    //setCompleted(smtp);	//V2
end;
}
	)
	CnSmtpStateRCPT (
	jadeMethodSources
cantDeliver
{
cantDeliver(smtp : CnSmtpConnection input);

vars

begin

	// The server can't deliver to the recipient for which we last sent a RCPT command. 
	// Insert this recipient, and the server message, into the 'undelivered' string array. 

	markAsUndelivered(smtp);

	// Continue to send RCPTs for the remaining recipients (if any).
	doRCPTandDATA(smtp);

end;
}
do250
{
do250(smtp : CnSmtpConnection input);

vars

begin

	// We got a positive ack that this recipient exists
	smtp.setAtLeastOneValidRecipient(true);

	// Now register next recipient (if any), and/or send DATA command
	doRCPTandDATA(smtp);
end;
}
do450
{
do450(smtp : CnSmtpConnection input);

vars

begin

	cantDeliver(smtp);		// The server can't deliver to the recipient last registered with RCPT

end;
}
do550
{
do550(smtp : CnSmtpConnection input);

vars

begin

	cantDeliver(smtp);		// The server can't deliver to the recipient last registered with RCPT

end;
}
do551
{
do551(smtp : CnSmtpConnection input);

vars

begin

	cantDeliver(smtp);		// The server can't deliver to the recipient last registered with RCPT

end;
}
do553
{
do553(smtp : CnSmtpConnection input);

vars

begin

	cantDeliver(smtp);		// The server can't deliver to the recipient last registered with RCPT

end;
}
do554
{
do554(smtp: CnSmtpConnection input);

// New method in CnSmtpConnection Version 16, to cater for behaviour of JungleDrum mail server.

// A 554 is a fatal error, so we mark the recipient as 'undelivered', and send a RSET.
vars

begin
	
	// The server can't deliver to the recipient for which we last sent a RCPT command. 
	// Insert this recipient, and the server message, into the 'undelivered' string array. 

	markAsUndelivered(smtp);
	
	defaultServerErrorHandler(smtp);
end;
}
doRCPTandDATA
{
doRCPTandDATA(smtp : CnSmtpConnection input);

//V4 20.06.2001 Clear server message before reading
//V3 21.09.2000 Changes for UNICODE
//V2 23.06.00	Remove unnecessary 'get' method calls

vars
 	size, index:Integer;
begin

	//Send RCPT for all recipients other than the first one (which was sent from SmtpStateMAIL::do250)

	size	:=	smtp.recipientArray.size;	//V2
	index	:=	smtp.recipientArrayIndex;	//V2
    index	:=	index + 1;
	smtp.setRecipientArrayIndex(index);

	if size > 1 and index <= size then

		//We only get here if there is more than one recipient. The next RCPT will be sent for the recipient indexed by 'index' in recipientArray
		smtp.cnWrite(cnAnsiBinary("RCPT TO: " & "<" & smtp.recipientArray[index] & ">" & CrLf), smtp);	//V3 V2
		smtp.clearServerMessageAndRead(smtp);		//V4 Now we expect a 250 reply to RCPT
		return;
	endif;

	//All recipients have been sent: now send DATA command

	//Send DATA, if at least one of the recipients that we registered exists

	if smtp.atLeastOneValidRecipient = true then			//V2
		smtp.cnWrite(cnAnsiBinary("DATA" &  CrLf), smtp);			//V3
		smtp.changeState(CnSmtpStateDATA);
		smtp.clearServerMessageAndRead(smtp);		//V4 Now we expect a 354 reply to DATA
	else
		sendRSET(smtp);			//Abort mail transaction if server can't deliver to any recipients
	endif;		
end;
}
	)
	CnSmtpStateRSET (
	jadeMethodSources
do250
{
do250(smtp : CnSmtpConnection input);

//V2 25.06.04	Keep Connection Open
vars
	cc : CnCntrl;												// V2
begin
	if not smtp.keepConnectionOpen then							// V2
		sendQUIT(smtp);
		return;													// V2
	endif;														// V2
	
	smtp.changeState(CnSmtpStateTCPConnected);					// V2
	self.setCompleted(smtp);									// V2
	if smtp.loggingRequired then								// V2
		cc := app.myCnCntrl;									// V2
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & 		// V2
									" connection #" & 			// V2
									smtp.connectionNo.String & 	// V2
									" is now available", null);	// V2
	endif;
end;
}
	)
	CnSmtpStateTCPConnected (
	jadeMethodSources
do220
{
do220(smtp: CnSmtpConnection input);

//V3	20.06.2001 Clear server message before reading
//V2	21.09.2000 Changes for UNICODE

vars

begin
	if smtp.authenticate then
		smtp.cnWrite(cnAnsiBinary("EHLO " & smtp.clientName & CrLf), smtp); // use Extended SMTP
	
	else
		smtp.cnWrite(cnAnsiBinary("HELO " & smtp.clientName & CrLf), smtp);	//V2
	endif;
	
	smtp.changeState(CnSmtpStateHELO);
	smtp.clearServerMessageAndRead(smtp);		// V3 Now we expect a 250 reply to HELO (or EHLO if Authenticating)

end;
}
	)
	CnStackDump (
	jadeMethodSources
closeDumpLog
{
closeDumpLog() clientExecution, updating;

vars

begin
	if self.myDumpFile <> null then
		self.myDumpFile.logClient(" ");
	endif;
end;
}
create
{
create() updating;

vars
	osPlatform		: Integer;
	osArchitecture	: Integer;
	osVersion		: String;
begin
	osPlatform	:= node.getOSPlatform(osVersion, osArchitecture);
	if osPlatform = node.OSUnixLinux or
	   osPlatform = node.OSUnixAIX 	 then
		self.endOfLine := Lf;
	
	else
		self.endOfLine := CrLf;
	endif;
end;
}
dumpArray
{
dumpArray(array : Array; name : String; level : Integer) updating;

vars
	cc					: CnCntrl;

	arrayClass			: Class;
	
	any					: Any;

	arrayIsObjectArray	: Boolean;
	
 	indent,
 	indx,
	len,
	maxElements,
	pos,
	rem					: Integer;
	
	sz					: Integer64;
	
	invObject,
	line,
	oidStr,																														// PAR 448
	str					: String;
begin
	cc 			:= app.myCnCntrl;
	maxElements	:= cc.maxArrayElementsInDump;
 	indent 		:= level * 5;

	sz 			:= array.size64();
	arrayClass	:= array.class;
	oidStr		:= self.getOidStringForObject(array);																			// PAR 448
	line := name & " (" & arrayClass.name & ", oid=" & oidStr & ", size=" & sz.String & ")  ";									// PAR 448
 	if sz = null then
 		line := line & " . . . . . (empty)";
 	endif;

 	while line.length < (115 - indent) do
 		line := line & " .";
 	endwhile;

 	writeLine(line, indent);
 	indx 				:= 1;
 	line				:= null;
	arrayIsObjectArray	:= array.isKindOf(ObjectArray);

 	foreach any in array do
		if arrayClass.inheritsFrom(StringArray)		or	 							// these first, for performance
			arrayClass.inheritsFrom(StringUtf8Array)or
			arrayClass.inheritsFrom(RealArray)		or
			arrayClass.inheritsFrom(DecimalArray) 	or
			arrayClass.inheritsFrom(IntegerArray)	or
			arrayClass.inheritsFrom(Integer64Array)	or
			arrayClass.inheritsFrom(BooleanArray)	or
			arrayClass.inheritsFrom(TimeArray)		or
			arrayClass.inheritsFrom(DateArray)		or
			arrayClass.inheritsFrom(TimeStampArray)	then
 			
			if cc.logStackDumpCensored then
				break;
			endif;

			str := any.String & "~~";

 		elseif arrayIsObjectArray then									// ObjectArray
 			invObject := null;
			if not app.isValidObject(any.Object) then
				invObject := "(Invalid Object)";
			endif;
			
 			str := app.cnGetClassAndOid(any.Object) & invObject & "~~";				// avoid touching object ... reference may be invalid

 		elseif arrayClass.inheritsFrom(HugeStringArray) then						// HugeStringArray
 			str := any.String;
 			pos := 1;
 			len := str.length;
 			if cc.logStackDumpCensored then
				writeLine(line, indent);
				line := null;
				str := null;
				break;
			endif;
			
			if len > 0 then
 				while true do
 					rem := len - (pos-1);
 					if rem > 0 then
 						if rem > (115 - indent) then
 							line := str[pos : 115 - indent] & "\";
 						else
 							line := str[pos : rem] & "~~";
 						endif;

 						writeLine(line, indent);
 						line := null;
 					else
 						break;
 					endif;

 					pos := pos + 115 - indent;
 				endwhile;

 				line := null;
 				str	 := null;
 			endif;

 		else
    		str := any.String & "~~";							// Other Arrays
    	endif;

        if (line.length + str.length) > 100 then
       		writeLine(line, indent);
       		line := str;
       	else
       		line := line & str;
       	endif;

        indx := indx + 1;

        if indx > maxElements then
        	line := line & "(truncated)";
        	break;
        endif;
   	endforeach;
	
	if line <> null then
		writeLine(line, indent);
	endif;
	line := null;
   	while line.length < (115 - indent) do
   		line := line & ". ";
   	endwhile;
   	writeLine(line, indent);
end;
}
dumpCallStack
{
dumpCallStack(logIt : Boolean; onServer : Boolean) : String updating;

vars
 	//  Method designed to be inserted into other methods for diagnostic purposes,
 	//  i.e. to provide a snapshot of the call stack at a particular point, for 
 	//  example to help find out who called a method.  
 	
 	//  if logIt=true then call stack is written into main cn_log,
 	//	and/or string returned for use in event or message box.  
 	//
 	//  Use with care, due to potential performance and log impact.
 	//	Not designed for use in exception state.								RWM 03 Oct 2000  

	meth	: Method;

	md		: MethodCallDesc;

	pc		: ProcessStackArray;
	
	i,
	patchNum,
	x		: Integer;

	line,
	modName,
	noteStr,
	source,
	sourceLine,
	str		: String;

	ts		: TimeStamp;
begin
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_AttemptedAccessViaNullRef, null, self.hadException);
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectNotFound, null, self.hadException);
	create pc transient;
	process.currentStack(pc);	
	i := 4;

	if logIt then
		writeLog("****  Call Stack Snapshot  ****", onServer);
	endif;

	while i <= pc.size do
		md		:= pc[i];
		meth	:= md.method;
		self.hadException := false;
		x := meth.edition;
		if not self.hadException then
			// new format in 3.7.01, now includes
			line := "     " & self.zGetMethodStackdumpLine(md, str); 
//			line := "     " & md.display & " (" & meth.class().name & ")"; 
			noteStr := noteStr & line & self.endOfLine;
			if logIt then
				writeLog(line, onServer);
			endif;

			ts := meth.cnGetModifiedTimeStamp();
			patchNum := meth.cnGetPatchNumber();
			self.hadException := false;
			modName := meth.cnGetModifierName();
			if self.hadException then
				modName := "<unknown>";
			endif;
			
			line := "         method modified by '" & modName &
					"' on " & ts.date.String &
					" " & ts.time.cnUserFormat($CnHHMMSS) & "." & ts.time.milliSecond().String;
			if patchNum > null then
				line := line & ", patch " & patchNum.String;
			endif;

			noteStr := noteStr & line & self.endOfLine;
			if logIt then
				writeLog(line, onServer);
			endif;

			line 	:= "         ++ Source line:  ";
			sourceLine := meth.cnGetSourceLine(md.position);// differently implemented depending on method type
			sourceLine := self.removeSensitiveDataFromArgs(sourceLine);
			line	:= line & sourceLine;
			noteStr := noteStr & line & self.endOfLine;
			if logIt then
				writeLog(line, onServer);
			endif;

		else
			line 	:= "Bad method object ..... can't analyse";
			if logIt then
				writeLog(line, onServer);
			endif;
			noteStr	:= noteStr & line & self.endOfLine;
		endif;

		i := i + 1;
	endwhile;
	
	return noteStr;
	
epilog
	pc.purge();
	delete pc;	
end;
}
dumpExceptionHandlerStack
{
dumpExceptionHandlerStack() updating;
/*
	This only dumps the exception stack in the context in which it has been run.
	If run from client method, then the exception stack is that armed on the client.
	If run from server execution method, then the exception stack is that armed on the server for this process.

*/
vars
	objArray		: ObjectArray;
	
	location		: String;
begin
	if node.isServerNode then
		location := "Server";
	
	else
		location := "Client";
	endif;
	
	location := location & " execution exception handler stack:";
	create objArray transient;
	process.getExceptionHandlerStack(objArray);
	self.zDumpExceptionHandlerStack(location, objArray);
epilog
	objArray.purge();		// contents are transient objects
	delete objArray;
end;
}
dumpExceptionHandlerStackAll
{
dumpExceptionHandlerStackAll() updating, clientExecution;
/*
	This dumps the exception stack for both client and server execution methods.

*/
vars
	objArray		: ObjectArray;
	
	location		: String;
begin
	location := "Client execution exception handler stack:";
	create objArray transient;
	process.getExceptionHandlerStack(objArray);
	self.zDumpExceptionHandlerStack(location, objArray);
	
	objArray.purge();
	location := "Server execution exception handler stack:";
	self.zServerExceptionHandlerStack(objArray);
	self.zDumpExceptionHandlerStack(location, objArray);

epilog
	objArray.purge(); // contents are transient objects
	delete objArray;
end;
}
dumpObjVars
{
dumpObjVars(dumpParent	: String;					// description of method or object that called this procedure
			obj 		: Object;					// object to be dumped
			level 		: Integer) updating; 		// drill-down level

vars
	propValue,
 	value		: Any;

 	class 		: Class;

	cc			: CnCntrl;
 
	jdo			: JadeDynamicObject;

 	prop		: Property;

 	coll		: PropertyColl;

	propType,
	type		: Type;

	truncateDump,																												// JCS NFS 936
	fileObject	: Boolean;

 	classNo,
 	indent,
 	indx,
	max,
	maxSz,
	propCount,
	x			: Integer;
	
	sz			: Integer64;
	
	classOidStr,																												// PAR 448
	errorOidStr,
	errorString,
 	line,
 	oidStr,
	propName,
 	str,
 	str2,
	str3		: String;
begin
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_AttemptedAccessViaNullRef, null, self.hadException);
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectNotFound, null, self.hadException);
 	indent				:= level * 5;
 	self.currentIndent 	:= indent;								// used by exceptionHandler

	cc 				:= app.myCnCntrl;
	oidStr 			:= self.getOidStringForObject(obj);
	classNo			:= currentSchema.getClassNumberForObject(obj);		// avoid touching the object
	class			:= currentSchema.getClassByNumber(classNo);
	truncateDump	:= cc.logStackDumpTruncateObjectString;																		// JCS NFS 936
	
	if class = null then
		self.writeLine(" <No class for object, oid=" & oidStr & ">", indent);													// PAR 1077
		return;
	endif;

	classOidStr 	:= class.name & "/" & oidStr;																				// PAR 448
	indx 			:= self.objectsDumpedArray.cnFind(classOidStr);																// PAR 1077
	if indx > 0 then
		self.writeLine(classOidStr & " already dumped : refer to " & self.objectsDumpedByArray[indx], indent);					// PAR 1077
		return;
	endif;

	if level < 3 then
		self.objectsDumpedArray.add(classOidStr);																				// PAR 448
		self.objectsDumpedByArray.add(dumpParent);
	endif;
	
	str := "[Object edition=" & obj.edition.String & ", creationTime=" & obj.creationTime.String & "." &
																		 obj.creationTime.time.milliSecond.String.padLeadingZeros(3);
	if obj.isKindOf(Collection) then
		sz := obj.Collection.size64();
		str	:= str & ", oid=" & oidStr & ", size=" & sz.String;																	// PAR 448
	
	elseif obj.isKindOf(JadeDynamicObject) then
		jdo := obj.JadeDynamicObject;
		propCount := jdo.propertyCount();
		str := str & ", oid=" & oidStr & ", propertyCount=" & propCount.String;													// PAR 448
	endif;

	if class.name[1:4] = "Xaml" then
		if not cc.dumpXamlObjectProperties then
			self.writeLine(str & ", Xaml properties suppressed]", indent);
			return;
		endif;
	endif;

	self.writeLine(str & "]", indent);
	
	coll	:= class.allProperties;
	
	on FileException do self.ehFileError(exception, obj, errorString);

    foreach prop in coll do
    	if prop.name[1:1] <> "_" then							// Jade system class properties
			value		:= null;
			errorString := null;
	    	value 		:= obj.getPropertyValue(prop.name);
			type		:= prop.getType();

	    	if value = null and errorString <> null then
				self.writeLineC(prop.name & " = <" & errorString & ">", line, indent);

	    	elseif type.isKindOf(PrimType) then					// Primitives
				str3	:= self.formatPrimType(type.PrimType, value);
	    		if cc.logStackDumpCensored then
						str2 := "<" & str3.length.String & ">";
				
				elseif str3.String.length > 75 and truncateDump then															// JCS NFS 936
					self.writeLine("Only the first '75' characters of error string will be dumped (as '.ini' file value 'LogStackDumpTruncateString'=true).", null);	// JCS NFS 936
					str2 := str3.String[1:75] & " .....";																		// JCS NFS 936
					
	    		else
	    			str2 := str3.String;
					if prop.name = "endOfLine" then
						if str2 = Cr then
							str2 := "Cr";
						
						elseif str2 = Lf then
							str2 := "Lf";
						
						elseif str2 = CrLf then
							str2 := "CrLf";
						endif;
					endif;
	    		endif;

				str := prop.name & " = " & str2;
				if fileObject then
					self.writeLine(str, indent);
				
				else
					self.writeLineC(str, line, indent);
				endif;

	   	 	elseif type.inheritsFrom(Array) then				// arrays
	   	 		self.writeLine(line, indent);
	   	 		line := null;
				self.hadException := false;
				x := value.Array.edition;
	   	 		if self.hadException then
	   	 			self.writeLine(prop.name  & " = null", indent);
					
	   	 		else
	   	 			self.dumpArray(value.Array, prop.name, level);
	   	 		endif;
	   	 		
			elseif type.inheritsFrom(Set)	then				// sets
	   	 		self.writeLine(line, indent);
	   	 		line := null;
				self.hadException := false;
				x := value.Set.edition;
	   	 		if self.hadException then
	   	 			self.writeLine(prop.name  & " = null", indent);
					
	   	 		else
					self.dumpSet(value.Set, prop.name, level);
	   	 		endif;
				
	   	 	elseif type.inheritsFrom(Collection) then				// arrays
	   	 		self.writeLine(line, indent);
	   	 		line := null;
				self.hadException := false;
				x := value.Collection.edition;
	   	 		if self.hadException then
	   	 			self.writeLine(prop.name  & " = null", indent);
	   	 		
				else
					oidStr := self.getObjectStringForObject(value.Collection);													// PAR 448
					if type.inheritsFrom(VirtualColl) then
						self.writeLine(prop.name  & " [VirtualColl, oid=" & oidStr & "]", indent);								// PAR 448
					
					else
						self.writeLine(prop.name & " [oid=" & oidStr & ", size=" & value.Collection.size64().String & "]", indent);	// PAR 448
					endif;
				endif;

	   	 	elseif value = null then
				self.writeLineC(prop.name & " = null", line, indent);
				
			else																					// other classes
	   	 		self.writeLine(line, indent);
	   	 		line := null;
				
				// handle 1046 whee object reference to class that has been deleted.
				errorOidStr := null;
				on SystemException do self.exceptionHandlerDeletedClass(exception, errorOidStr);
	   	 		str := prop.name & " = " & app.cnGetClassAndOid(value.Object);
				on SystemException do null;
				
				if errorOidStr <> null then
					self.writeLine(prop.name & " <Object reference to invalid class, oid=" & errorOidStr & ">", indent);
					
				else
					self.hadException := false;
					x := value.Object.edition;
					if self.hadException then
						self.writeLine(str & " <Invalid or null object reference>", indent);
						
					else 
						self.writeLine(str & " ------------> (" & (level + 1).String & ")", indent);
						if level < 2 then
							on Exception do exceptionHandler(exception);
							self.dumpObjVars("object dump for " & oidStr, value.Object, level + 1);
							on Exception do null;
						endif;
					endif;
				endif;
	   	 	endif;
	   	 endif;
    endforeach;

    self.writeLine(line, indent);
	
	if sz > null and obj.isKindOf(JadeBytes) then
		if sz > Max_String_Length then
			maxSz := Max_String_Length;
		
		else
			maxSz := sz.Integer;
		endif;
		
		self.writeLine("JadeBytes Content=" & obj.JadeBytes.getData(1, maxSz).String, indent);
	endif;
	
	if jdo <> null then
		max := propCount.min(self.Max_PropertyCount);
		str := "JadeDynamicObject Properties";
		if propCount > max then
			str := str & " (first " & self.Max_PropertyCount.String & " of " & propCount.String & " listed)";
		endif;
		
		str := str & ":";
		self.writeLine(str, indent);
		indent := indent + 4;
		foreach indx in 1 to max do
			propName := jdo.getPropertyName(indx);
			propValue := jdo.getPropertyValueByIndex(indx);
			propType  := jdo.getPropertyTypeByIndex(indx);
			if propType.isKindOf(PrimType) then																					// PAR 610
				str		:= self.formatPrimType(propType.PrimType, propValue);
				if cc.logStackDumpCensored then
					str := "<" & str.length.String & ">";
				endif;
				
				str2 := "[" & indx.String & "] name=" & propName & 
						", type=" & propType.name &
						", value=";
				if str.length > self.Max_String_Length then
					str2 := str2 & str[1:Max_String_Length] & "...[truncated : actual length=" & str.length.String & "]";
					
				else
					str2 := str2 & str;
				endif;
				
			else																												// PAR 610
				str2 := "[" & indx.String & "] name=" & propName & 																// PAR 610
						", type=" & propType.name &																				// PAR 610
						", value=" & propValue.String;																			// PAR 610
			endif;																												// PAR 610
			
			self.writeLine(str2, indent);
		endforeach;
		
	endif;
epilog
	delete coll;
end;
}
dumpSet
{
dumpSet(set : Set; name : String; level : Integer) updating;

vars
	cc				: CnCntrl;
	
	setClass		: Class;

	any				: Any;

	setIsObjectSet	: Boolean;

 	indent,
 	indx,
	maxElements		: Integer;
	
	sz				: Integer64;

	invObject,
 	line, 
	str				: String;
begin
	cc 			:= app.myCnCntrl;
	maxElements	:= cc.maxArrayElementsInDump;
 	indent 		:= level * 5;

	sz := set.size64();
	setClass			:= set.class();
	line := name & " (" & setClass.name & ", size=" & sz.String & ")  ";
 	if sz = null then
 		line := line & " . . . . . (empty)";
 	endif;

 	while line.length < (115 - indent) do
 		line := line & " .";
 	endwhile;

 	writeLine(line, indent);
 	indx 				:= 1;
 	line				:= null;
	setIsObjectSet		:= set.isKindOf(ObjectSet);

 	foreach any in set do
 		if setIsObjectSet then											// ObjectSet
			invObject := null;
			if not app.isValidObject(any.Object) then
				invObject := "(Invalid Object)";
			endif;
			
 			str := app.cnGetClassAndOid(any.Object) & invObject & "~~";				// avoid touching object ... reference may be invalid

 		else
    		str := any.String & "~~";									// Other Sets
    	endif;

        if (line.length + str.length) > 100 then
       		writeLine(line, indent);
       		line := str;
       	else
       		line := line & str;
       	endif;

        indx := indx + 1;

        if indx > maxElements then
        	line := line & "(truncated)";
        	break;
        endif;
   	endforeach;

   	writeLine(line, indent);
   	line := null;
   	while line.length < (115 - indent) do
   		line := line & ". ";
   	endwhile;
   	writeLine(line, indent);
   	line := null;
end;
}
dumpStack
{
dumpStack(pException : Exception) updating;

vars
	exceptionStack	: String;
begin
	self.zDumpStack(pException, exceptionStack);
end;
}
dumpStackPlus
{
dumpStackPlus(pException 		: Exception;
			  pExceptionDetails	: String output) updating;

vars

begin
	self.zDumpStack(pException, pExceptionDetails);
end;
}
ehFileError
{
ehFileError(pExObj : Exception; pObj : Object; pErrorStr : String output) : Integer;

vars
	errorCode	: Integer;
begin
	if not pObj.isKindOf(File) then
	    return Ex_Pass_Back;
	endif;
	
	if pExObj.errorObject <> pObj then
		return Ex_Pass_Back;
	endif;
	
	errorCode := pExObj.errorCode;
	if errorCode = Cn_RequestedFileNotFound 		or				// 5003
	   errorCode = Cn_RequestedAccessNotPermitted 	or				// 5002
	   errorCode = Cn_CannotOverwriteExistingFile 	then			// 5008
		pErrorStr := "File access error";
		return Ex_Resume_Next;
	endif;

	return Ex_Pass_Back;
end;
}
exceptionHandler
{
exceptionHandler(exObj : Exception) : Integer updating;

vars
	errorObj 	: Object;
	
	oidStr,
	str			: String;
begin
	self.hadException := true;
	errorObj := exObj.errorObject;
	str := ", exception=" & exObj.errorCode.String & ", resumable=" & exObj.resumable.String;
	if errorObj <> null then
		oidStr := app.cnGetClassAndOid(errorObj);
		writeLine(oidStr & " <Object not valid or not available" & str & ">", currentIndent);
		
	else
		writeLine("In " & method.cnGetMethodName() & ", exObj.errorObject was null" & str, currentIndent);
	endif; 

	if exObj.resumable then
		return Ex_Resume_Next;
	endif;
	
	writeLine("***** Fatal exception, not resumable, return Ex_Abort_Action ******", currentIndent);
	return Ex_Abort_Action;
end;
}
exceptionHandlerDeletedClass
{
exceptionHandlerDeletedClass(pExObj : Exception; pOidStr : String io) : Integer updating;

vars
	errorCode	: Integer;
begin
	errorCode := pExObj.errorCode;
	if errorCode <> Cn_InvalidClassNumber 			and				// 1046
	   errorCode <> Cn_InvalidAddress 				and				// 8
	   errorCode <> Cn_ClassOfObjectInvalidContext	then			// 1086
		return Ex_Pass_Back;
	endif;
	
	if errorCode = Cn_InvalidClassNumber then
		pOidStr := self.getObjectStringForObject(pExObj.errorObject);
	endif;

	return Ex_Resume_Next;
end;
}
formatPrimType
{
formatPrimType(type : PrimType; value : Any) : String;

vars
	typeName	: String;
	
	ts			: TimeStamp;
begin
	typeName := type.name;
	if value.String = "** not initialised **" then
		return "<not initialized>";
	endif;
	
	if typeName = CN_BINARY then
		if value.Binary = null then
			return "null";
		endif;
		
		return value.Binary.String;
	endif;
	
	if typeName = CN_TIME then
		return value.String & "." & value.Time.milliSecond.String.padLeadingZeros(3);
	endif;
		
	if typeName = CN_TIMESTAMP then
		ts		:= value.TimeStamp;
		return ts.String & "." & ts.time.milliSecond.String.padLeadingZeros(3);
	endif;
		
	if typeName = CN_STRINGUTF8 then
		if value.StringUtf8 = null then
			return "null";
		endif;
		
		return value.StringUtf8.asPlainText();
	endif;
		
	if typeName = CN_STRING and value = null then
		return "null";
	endif;
	
	return value.String;
end;
}
getFileExceptionDetails
{
getFileExceptionDetails(exObj : FileException) : String updating;

vars
	file		: File;
	log			: JadeLog;
	str			: String;
	obj			: Object;
	badObject	: Boolean;
	ed			: Integer;
begin
	obj		:= exObj.file;
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, obj, badObject);
	ed := obj.edition;
	if badObject then
		str := "invalid object";
	
	elseif obj.isKindOf(File) then 
		file	:= obj.File;
		if file <> null then 
			str := "file in error is '" & file.fileName & "'.";
			
		else
			str := "file in error not known (null File object).";
		endif;
		
	elseif obj.isKindOf(JadeLog) then
		log		:= obj.JadeLog;
		if log <> null then
			str	:= "JadeLog (file) in error : path=" & log.filePath & ", fileName=" & log.fileName & ".";
		else
			str	:= "file in error not known (null JadeLog object).";
		endif;
		
	else
		str		:= "Object returned from FileException::file method was " & obj.String;		
	endif;
	
	return "File Exception " & exObj.errorCode.String & " (" & exObj.text & ") : " & str;
end;
}
getTransientsOnClient
{
getTransientsOnClient() clientExecution;

vars
	cc	: CnCntrl;
begin
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " dumping transients on client...", null);
	app.cnCheckForTransients();
end;
}
getTransientsOnServer
{
getTransientsOnServer() serverExecution;

vars
	cc	: CnCntrl;
begin
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " dumping transients on server...", null);
	app.cnCheckForTransients();
end;
}
miniDumpToString
{
miniDumpToString(exObj : Exception) : String updating;

vars
 	cnApp			: Application;
	appArray		: ApplicationArray;
	
	cc  			: CnCntrl;
	kc				: CnKarmaCntrl;
	
	le				: LockException;
	
	meth			: Method;
	methodDescription 				: MethodCallDesc;
	
	obj				: Object;
	
	heldBy			: Process;
	targetLockedBy	: Process;
	processStack 				: ProcessStackArray;
	
	schemaArray		: StringArray;
	
	importedPackages,
	hadError,
	thinClient		: Boolean;
	
	d1, d2			: Decimal [20];
	
	ed				: Integer;	// used by exception handler
	
	int,
	osPlatform,
	osArchitecture,
	patchNum,
	pid,
	role,
	stackSize,
	startStackOffset: Integer;
	
	errorOidStr,
	hyphens,
	modName,
	nodeInfo,
	obtained,
	osVersion,
	returnStr,
	sourceLine,
	str, str2,
	target			: String;
	
	now,
	ts				: TimeStamp;
begin
	d1 := app.relativeMachineTime();
	cnApp := process.getProcessApp();
	create appArray transient;
	process.getAllApps(appArray);
	importedPackages := (appArray.size() > 1);
 	//
	//   The logged output of this method will be correctly formatted when printed using a fixed-pitch font.
	//   The output was designed to be printed using Notepad with Courier New, font pitch = 7, portrait.
	//   The starting point in the call stack can be (optionally) defined by the user prior to calling this
	//   method.
	//
	//   Note that this method now makes the decisions as to whether to (a) report the exception to JSM, and
	//   (b) actually take a stack dump.  Formerly, these decisions were made in the ::cnGlobalExceptionHandler.
   	//
   	//	 Class version 3.1 September 03, 2003, for JADE 6.0 or higher. 
   	//	 R. W. Mitchell, Systems Management Development Centre,
   	//   (c) 2003 Jade Software Corporation Limited, New Zealand.

	if app.cnApplicationType <> app.ApplicationType_SilverLight then
		app.mousePointer := Busy;
	endif;
	
	hyphens := "=====================================================================================================";
	cc 		:= app.myCnCntrl;
	kc		:= app.myCnKarmaCntrl;
	now		:= app.actualTimeAppServer;
	thinClient := process.isUsingThinClient;
	kc.getProcessId(pid);
	
	create processStack transient;
	process.currentStack(processStack);
	stackSize	:= processStack.size;
   	if stackSize < 4 then
   		startStackOffset := 1;
		
   	elseif self.stackStartIndex > 0 then
   		startStackOffset := self.stackStartIndex;					// application programmer specified stack start position
		
   	else
   		startStackOffset := self.zGetStartCallStackIndex(processStack);		// leave out process.currentStack, self.dumpStack, globalExceptionHandler
   	endif;

	//////////////////////////////   Take call stack dump, if required  //////////////////////////////////////

	cc.cnWriteLog(cc.CnLogErrors, "Application Exception " & exObj.errorCode.String &
				  "  : CnStackDump now providing mini stack dump for application " & cc.appName, null);

	str			:= null;
	str[32:110] := "S T A C K    D U M P                       S T A C K    D U M P                       S T A C K    D U M P";
	returnStr := hyphens & self.endOfLine & str & self.endOfLine & hyphens;
	returnStr := returnStr & self.endOfLine & "Application : " & cc.appName & "           Computer : " & app.cnComputerName & "          Error : " & exObj.errorCode.String &
			  "         Time : " & now.date.String & ", " & now.time.String & "." & now.time.milliSecond.String.padLeadingZeros(3) & " (local)";
	returnStr := returnStr & self.endOfLine & hyphens & self.endOfLine;
	str 	:= "Exception " & exObj.errorCode.String & "  (" & exObj.text & ")  in application " & cc.appName &
		  	   " (application type = " & app.cnGetApplicationType & "), extendedErrorText=" & exObj.extendedErrorText;
	returnStr := returnStr & self.endOfLine & str;
	
	str		:= "Exception occurred at " & now.String & "  (GMT=" & now.cnGMT.String & ") ";
	if node.isServerNode then
		str	:= str & " by database server clock.";
		
	elseif thinClient then
		str := str & " by app server clock.";
		
	else
		str := str & " by fat client clock.";
	endif;
	
	returnStr := returnStr & self.endOfLine & str;
	str		:= "Local times for participants : database server=" & app.cnGetServerTime.String;
	if thinClient then
		str	:= str & ", executing thin-client, app server=" & now.String;
	endif;
	
	if not app.cnIsServerApp then
		str := str & ", client=" & app.cnGetClientTime.String;
	endif;
	
	returnStr := returnStr & self.endOfLine & str;
	str := app.cnGetApplicationVersion();
	if str = null then
		str := "<not specified>";
	endif;
	
	returnStr := returnStr & self.endOfLine & "Application version is " & str;
	
	str := "Application is running from schema " & cnApp.class.schema.name & " that has ";
	if importedPackages then
		str := str & "imported one or more packages.";
	
	else
		str := str & "not imported any packages.";
	endif;
	
	returnStr := returnStr & self.endOfLine & str;
	if kc.thinClientComputerName <> null then
		if app.isPortableGui then
			str	:= CN_PORTABLE_GUI;
			
		else
			str	:= CN_JADE_EXE;
		endif;
		
		returnStr := returnStr & self.endOfLine & "Client is thin client " & str & " : computer name = " & kc.thinClientComputerName &
				  " (" & kc.networkAddressProcess & "), pid=" & pid.String & ",";		// PAR 536
	endif; 
	
	if node.isServerNode then
		nodeInfo	:= "server node, computer=" & app.cnComputerName;
		
	elseif node.isApplicationServer then
		nodeInfo	:= "application server node, computer=" & app.cnComputerNameAppServer;
		
	else
		if app.isPortableGui then
			str		:= CN_PORTABLE_GUI;
		else
			str		:= CN_JADE_EXE;
		endif;
		
		nodeInfo	:= "fat client node " & str & ", computer=" & app.cnComputerName;
	endif;
	 	
	returnStr := returnStr & self.endOfLine & "Stack dump is executing on " & nodeInfo & " (node address=" & kc.networkAddressNode & 	// PAR 441 node.networkAddress &
	          "), pid=" & pid.String & ", node name=" & node.name & ",";
	
	str				:= "Database is not an SDS system";
	role			:= system.getDatabaseRole();
	if role = SDS_RolePrimary then
		str			:= "Database is an SDS primary system.";
		
	elseif role = SDS_RoleSecondary then
		str			:= "Database is an SDS secondary system.";
	endif;
	
	returnStr := returnStr & self.endOfLine & str;

	osPlatform	:= node.getOSPlatform(osVersion, osArchitecture);		// gets node info - for thin-client this is jadapp server)
	str	:= "Platform type for this node=";
	if osPlatform = Node.OSWindows 				or
	   osPlatform = Node.OSWindowsEnterprise 	or
	   osPlatform = Node.OSWindowsHome 			then
		str	:= str & "Windows";
		
	elseif osPlatform = Node.OSUnixLinux 		then
		str	:= str & "Linux (" & cc.osDistribution & " " & cc.osVersion & ")";
		
	elseif osPlatform = Node.OSUnixAIX			then
		str := str & "AIX";
		
	else
		str	:= str & "<unknown OS platform>";
	endif;
	
	str	:= str & ", OS version=" & osVersion & ", platform architecture=";
	if osArchitecture = Node.Architecture_32Big_Endian then
		str	:= str & "Architecture_32Big_Endian";
		
	elseif osArchitecture = Node.Architecture_32Little_Endian then
		str	:= str & "Architecture_32Little_Endian";
		
	elseif osArchitecture = Node.Architecture_Gui then
		str	:= str & "Architecture_Gui (currently Windows 32 bit little endian)";
	endif;
	
	returnStr := returnStr & self.endOfLine & str;

	if thinClient then
		str := "Thin-client platform type=";
		if app.cnThinClientOSIsWindows()	then
			str	:= str & "Windows";
			
		elseif app.cnThinClientOSIsWindowsMobile() then
			str	:= str & "Windows Mobile";
		
		else
			str	:= str & "<unknown OS platform '" & app.cnThinClientOSPlatform.String & "'>";
		endif;
		
		str	:= str & ", OS version=" & app.cnThinClientOSVersion & ", architecture=";
		if app.cnThinClientOSArchitecture = Node.Architecture_32Big_Endian then
			str	:= str & "Architecture_32Big_Endian";
			
		elseif app.cnThinClientOSArchitecture = Node.Architecture_32Little_Endian then
			str	:= str & "Architecture_32Little_Endian";
			
		elseif app.cnThinClientOSArchitecture = Node.Architecture_Gui then
			str	:= str & "Architecture_Gui (currently Windows 32 bit little endian)";
		endif;

		returnStr := returnStr & self.endOfLine & str;
	endif;
	
	returnStr := returnStr & self.endOfLine & "process=" & process.String & ", process usercode=" & process.userCode & ", process signOnUsercode=" & process.signOnUserCode & ", process signOnTime=" & process.signOnTime.String & ".";
	returnStr := returnStr & self.endOfLine & "Database path=" & app.dbPath & ", app.userName=" & app.userName & ".";
	returnStr := returnStr & self.endOfLine & "Only the first " & cc.maxArrayElementsInDump.String & " elements of any arrays will be dumped.";

	str := "CardSchema Class Library Version " & app.cnGetCardSchemaVersion() & ", JADE version " & app.getSystemVersion();
	if app.isUnicode then
		str := str & " (Unicode)";
		
	else
		str := str & " (ANSI)";
	endif;
	
	returnStr := returnStr & self.endOfLine & str;
	
	if exObj.errorCode = 1081 then								// deadlock
		obtained:= app.cnGetClassAndOid(exObj.DeadlockException.obtainedLock);
 		heldBy	:= exObj.DeadlockException.targetLockedBy;
		target	:= app.cnGetClassAndOid(exObj.DeadlockException.lockTarget);
		
 		if heldBy <> null then													// JADE can't always report all the details
		 	str :=  "Deadlock Exception : locktype=" & exObj.DeadlockException.lockType.String &
				    ", locktarget=" & target & ", " &
				    "currently held by " &  heldBy.String & " " &
				    "(app=" & heldBy.persistentApp.name & ", " &
				    "ipAddress=" & heldBy.networkAddress & ", " &
				    "usercode=" & heldBy.userCode & ")  " &
				    "who is trying to lock " & obtained & " (which this process already has locked).";

		else
		 	str := "Deadlock exception : no targetLockedBy information available from JADE, " &
		 		   ", locktype=" & exObj.DeadlockException.lockType.String &
	 			   ", target=" & target &
	 			   ", other user is trying to lock " & obtained & " (which this process already has locked)."; 
		endif;

		returnStr := returnStr & self.endOfLine & str;
	endif;
	
	if exObj.isKindOf(LockException) and exObj.errorCode = 1027 then					// lock exception
		le				:= exObj.LockException;
		targetLockedBy	:=	le.targetLockedBy;
		str				:= "Exception=" & le.errorCode.String & " : " & le.text & ", lockTarget=" &
						    le.lockTarget.String;
		self.hadException := false;
		ed := targetLockedBy.edition;
		if not self.hadException then
			str			:= str & ", locked by " & targetLockedBy.userCode & " on node " &
						    targetLockedBy.node.name & " (locking process app name=" & targetLockedBy.persistentApp.name &  
						    ", process=" & targetLockedBy.String & ") : aborted after multiple retries.";
						    
		elseif targetLockedBy <> null then
			str			:= str & ", targetLockedBy was an invalid reference : locking process must have gone away.";
			
		else
			str			:= str & ", targetLockedBy is null : possible JADE problem.";
		endif;
		
		returnStr := returnStr & self.endOfLine & str;
	endif; 
	
	if exObj.isKindOf(FileException) then
		returnStr := returnStr & self.endOfLine & getFileExceptionDetails(exObj.FileException);
	endif;

	on Exception do exceptionHandler(exception);

	//// Now get the call stack history ////

    returnStr := returnStr & self.endOfLine & self.endOfLine & "======================================  Exception Summary  ===============================================";
	str	:= "Exception Type: " & exObj.class.name & " (" & exObj.errorCode.String & " : " & exObj.text & ")";
	if not exObj.continuable then
		str2	:= "  (Not continuable, ";
		
	else
		str2	:= "  (Continuable, ";
	endif;
	
	if not exObj.resumable then
		str2	:= str2 & "not resumable)";
	else
		str2	:= str2 & "resumable)";
	endif;
	
	returnStr := returnStr & self.endOfLine & self.endOfLine & str & str2;
	if exObj.extendedErrorText <> null then
		returnStr := returnStr & self.endOfLine & "Extended Text : " & exObj.extendedErrorText;
	endif;
	
	str	:= "Error Item: ";
	if exObj.errorItem <> null then
     	returnStr := returnStr & self.endOfLine & str & exObj.errorItem;
    
	else
    	returnStr := returnStr & self.endOfLine & str & "<Not available>";
    endif;

	str	:= "Error Object: ";
	// handle 1046 whee object reference to class that has been deleted.
	errorOidStr := null;
	on SystemException do self.exceptionHandlerDeletedClass(exception, errorOidStr);
	str := str & app.cnGetClassAndOid(exObj.errorObject);
	on SystemException do null;
	
	if errorOidStr <> null then
		str := str & "<Object reference to invalid class, oid=" & errorOidStr & ">";
	
	else
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_AttemptedAccessViaNullRef, null, self.hadException);
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectNotFound, null, self.hadException);
		self.hadException := false;
		ed := exObj.errorObject.edition;
		if self.hadException then
			str := str & " (Invalid object reference)";
		endif;
	endif;

	returnStr := returnStr & self.endOfLine & str;
	returnStr := returnStr & self.endOfLine & "Caused By:";
	str := "     Receiver: ";
	self.hadException := false;
	ed := exObj.currentMethodDesc.edition;
	if self.hadException then 
		str := str & "<No currentMethodDesc, receiver details not available>";

	else
		str := str & exObj.currentMethodDesc.receiverAsString;
	endif;

	returnStr := returnStr & self.endOfLine & str;
	
	str := "     Method: ";
	if self.hadException then 
		str := str & "<No currentMethodDesc, method details not available>";

	else
		str := str & exObj.currentMethodDesc.display;
	endif;
	
	returnStr := returnStr & self.endOfLine & str;
		
	returnStr := returnStr & self.endOfLine & "Reported By: ";
	self.hadException := false;
	ed := exObj.reportingMethodDesc.edition;
	str := "     Receiver: ";
	if self.hadException then 
		str := str & "<No reportingMethodDesc, receiver details not available>";

	else
		str := str & exObj.reportingMethodDesc.receiverAsString;
	endif;

	returnStr := returnStr & self.endOfLine & str;
	
	str := "     Method: ";
	if self.hadException then 
		str := str & "<No reportingMethodDesc, method details not available>";
	
	else
		str := str & exObj.reportingMethodDesc.display;
	endif;
	
	returnStr := returnStr & self.endOfLine & str & self.endOfLine;
	
	str := "Call Stack History";
   	if stackSize < 4 then
   		returnStr := returnStr & self.endOfLine & "############ Unexpectedly short call stack : stack size = " & stackSize.String & ", will list entire stack  ##########";
		
   	elseif self.stackStartIndex > 0 then
		str := str & " (startIndex=" & self.stackStartIndex.String & ")";
   	endif;

	returnStr := returnStr & self.endOfLine & str & ":";

	if importedPackages then
		create schemaArray transient;
	endif;
	
	int := startStackOffset;
    while int <= stackSize do
		methodDescription := processStack[int];
		self.hadException := false;
		ed := methodDescription.edition;
		if not self.hadException then
			if importedPackages then			// we want to keep track of which schema a method has been invoked for
				obj := methodDescription.getReceiver();		// so that we only explode the pertinent application objects.
				str := obj.class.schema.name;	// Ideally, we should know the specific application object but not available yet (PAR 46275)
				if not schemaArray.includes(str) then
					schemaArray.add(str);
				endif;
			endif;
			
			meth := methodDescription.method;
			self.hadException := false;
			ed := meth.edition;
			if not self.hadException then
				returnStr := returnStr & self.endOfLine & "     " & methodDescription.display & " (" & meth.class.name & ")";
				on SystemException do app.cnGenericExceptionHandler(exception, 1090, null, hadError);
				ts := meth.cnGetModifiedTimeStamp();
				patchNum := meth.cnGetPatchNumber();
				hadError := false;
				modName := meth.cnGetModifierName();
				if hadError then
					modName := "<unknown>";
				endif;
				
				on SystemException do null;				// pop exception stack
				str := " method modified by '" & modName &
						"' on " & ts.date.String &
						" " & ts.time.cnUserFormat($CnHHMMSS) & "." & ts.time.milliSecond().String;
				if patchNum > null then
					str := str & ", patch " & patchNum.String;
				endif;
					
				returnStr := returnStr & self.endOfLine & "        " & str;
				str 	:= "         ++ Source line:  ";

				sourceLine := meth.cnGetSourceLine(methodDescription.position);
				sourceLine := self.removeSensitiveDataFromArgs(sourceLine);
				
				returnStr := returnStr & self.endOfLine & str & sourceLine;

			else
				returnStr := returnStr & self.endOfLine & "Bad method object ..... can't analyse";
			endif;

		else
			returnStr := returnStr & self.endOfLine & "Bad MethodCallDesc object ...... can't analyse";
		endif;

		int := int + 1;
	endwhile;

	returnStr := returnStr & self.endOfLine & self.endOfLine & "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  End of Mini Dump  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%";
	
	return returnStr;
epilog
	delete appArray;
	delete schemaArray;
	if processStack <> null then
		processStack.purge();
		delete processStack;
	endif;
	
	if app.cnApplicationType <> app.ApplicationType_SilverLight then
		app.mousePointer := Idle;
	endif;
	d2 := app.relativeMachineTime();
	cc.cnWriteLog(cc.CnLogComment, "Mini Stack dump to string completed, elapsed time = " & (d2-d1).String & "ms", null);
end;
}
removeSensitiveDataFromArgs
{
removeSensitiveDataFromArgs(pValue : String) : String;
/*
	Purpose:
	
	Remove any sensitive userdata from incoming string 
	if ini file [AppExceptions] LogStackDumpCensored=true.
	
*/

vars
	cc	: CnCntrl;
	
	str	: String;
begin
	cc 				:= app.myCnCntrl;
	if not cc.logStackDumpCensored then
		return pValue;
	endif;
	
	str := pValue;
	
	// first replace any strings with the length that they take
	str := self.zRemoveStringLiteralsFromArgs(str);
	
	// then replace any numeric items with the display length
	str := self.zRemoveNumericLiteralsFromArgs(str);
	
	return str;
end;
}
reportException
{
reportException(pStartStackOffset : Integer; pPSA : ProcessStackArray; pExObj : Exception; pDumpFileName : String) updating;

vars
	cc			: CnCntrl;

	kc			: CnKarmaCntrl;
	
	emsg		: CnExceptionAdvice;

	msg, 
	newmsg		: CnMessage;

	meth		: Method;

	md			: MethodCallDesc;
	
	cnt,
	index,
	x			: Integer;

	logStr,
	str			: String;
begin
	kc		:= app.myCnKarmaCntrl;
	cc		:= app.myCnCntrl;
	cnt		:= 1;
	
	create msg transient;
	msg.createNewMsg(msg.Advice, 
						msg.Exception_Advice, 
						kc.localFQDN, 																							// PAR 891
						kc.localIpAddress, 																						// PAR 891
						cc.Application_Process, 
						cc.JossCommsMgr_Process, 
						newmsg);		
	emsg					:= newmsg.CnExceptionAdvice;
	emsg.setEnvironmentId(kc.environmentId);
	emsg.setManagedEnvironmentName(kc.environmentId);
	emsg.exceptionCode		:= pExObj.errorCode;
	emsg.extendedErrorText	:= pExObj.extendedErrorText[1:1024];
	if pExObj.errorCode = Cn_NotifySubscriberNotFound then			// 1227 notification exception
		emsg.stackDumpFileName	:= "<no dump taken>";
	
	else
		emsg.stackDumpFileName	:= pDumpFileName;
	endif;
	
	emsg.timestamp			:= app.actualTimeAppServer().cnGMT;
	emsg.setThinClientComputerName(app.cnComputerName);				// PAR 159
	
	if process.isUsingThinClient then
		emsg.setThinClientComputerIpAddress(kc.networkAddressProcess);	// PAR 441	process.networkAddress);
	else
		emsg.setThinClientComputerIpAddress(kc.networkAddressNode);		// PAR 441 	node.networkAddress);
	endif;
	
	if pExObj.isKindOf(FileException) then
		emsg.exceptionComment	:= self.getFileExceptionDetails(pExObj.FileException);
	endif;

	if pExObj.errorCode = Cn_NotifySubscriberNotFound then			// 1227 notification exception								// PAR 598
		// place info in methodA & B to ensure detail gets reported in the reliability report									// PAR 598
		// and updates same Tracker call when these two items match																// PAR 598
		emsg.errorMethodA		:= "<subscriber=" &				 																// PAR 598
									app.cnGetClassForObject(pExObj.errorObject).name & ">";										// PAR 598
		emsg.errorMethodB		:= "<target=" & 																				// PAR 598
									app.cnGetClassForObject(pExObj.NotificationException.notificationTarget).name & ">";		// PAR 598
		emsg.exceptionComment	:= "subscriber=" & app.cnGetClassAndOid(pExObj.errorObject) & 									// PAR 598
									", target=" & app.cnGetClassAndOid(pExObj.NotificationException.notificationTarget);		// PAR 598
		
	else								// PAR 598
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_AttemptedAccessViaNullRef, null, self.hadException);
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectNotFound, null, self.hadException);
	
		foreach md in pPSA do
			index := index + 1;
			if index < pStartStackOffset then
				continue;
			endif;
			
			self.hadException := false;
			x := md.edition;
			if not self.hadException then
				meth := md.method;
				self.hadException := false;
				x := meth.edition;
				if not self.hadException then
					if cnt = 1 then 
						emsg.errorMethodA		:= meth.cnGetMethodName();
						emsg.codePositionA		:= md.position;
						self.hadException := false;
						x := pExObj.currentMethodDesc.edition;
						if self.hadException then
							emsg.receiver		:= "<No currentMethodDesc, receiver details not available>";
							
						else
							str					:= app.cnGetClassAndOid(pExObj.currentMethodDesc.getReceiver);
							emsg.receiver		:= str;
						endif;
						
					elseif cnt = 2 then
						emsg.errorMethodB		:= meth.cnGetMethodName();
						emsg.codePositionB		:= md.position;
					endif;
				else
					str							:= "<Bad method object : analysis not available>";
					if cnt = 1 then
						emsg.errorMethodA		:= str;
						
					elseif cnt = 2 then
						emsg.errorMethodB		:= str;
					endif;
				endif;
				
			else
				str				:= "<Bad MethodCallDesc object : analysis not available>";
				if cnt = 1 then
					emsg.errorMethodA			:= str;
					
				elseif cnt = 2 then
					emsg.errorMethodB			:= str;
				endif;
			endif;
	
			cnt	:= cnt + 1;
			if cnt > 2 then
				break;
			endif;
		endforeach;
	endif;																														// PAR 598
	
	logStr := "Errorcode=" & pExObj.errorCode.String & 
				", text=" & pExObj.extendedErrorText[1:1024] &
				", comment=" & emsg.exceptionComment &
				", methodA=" & emsg.errorMethodA & " (" & emsg.codePositionA.String & ")" &
				", methodB=" & emsg.errorMethodB & " (" & emsg.codePositionB.String & ")" &										// PAR 957
				", stack offset=" & pStartStackOffset.String;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & logStr, null);
	emsg.sendMessage(app.myCnKarmaCntrl.myParentTcp);
epilog
	delete msg;
	delete emsg;	
end;
}
showDumpProgressForm
{
showDumpProgressForm(exObj : Exception; size : Integer) clientExecution, updating;

vars
	frm 		: CnDumpForm;
begin
	if exObj.errorCode = 14063 then				// GUI resource error
		return;
	endif;
	
	if not self.zShowDumpProgressFormOK() then
		return;
	endif;

	create frm;
	frm.userPicture	:= app.cnGetExceptionDisplayPicture();		// can be reimplemented in subschema
	frm.exObj := exObj;
	frm.centreWindow;
	frm.pgBar.partsInJob := size;
	frm.show;
	frm.refreshNow;												// repaint
end;
}
unloadDumpProgressForm
{
unloadDumpProgressForm() clientExecution, updating;

vars
	frm : CnDumpForm;
begin	
	if not self.zShowDumpProgressFormOK() then
		return;
	endif;

	frm := null;
	frm := app.getForm(CnDumpForm.name).CnDumpForm;
	if frm <> null then
		frm.unloadForm;
	endif;
end;
}
updateDumpProgressForm
{
updateDumpProgressForm(partsDone : Integer) clientExecution, updating;

vars
	frm : CnDumpForm;
begin	
	if not self.zShowDumpProgressFormOK() then
		return;
	endif;

  	frm := app.getForm(CnDumpForm.name).CnDumpForm;
  	if frm <> null then
    	frm.pgBar.partsDone := partsDone;
    endif;	
end;
}
writeLine
{
writeLine(str : String; indent : Integer) clientExecution, updating;

vars
 	log	: JadeLog;								// This method used when dumping stack to log file	
 	line : String;	
 	ind	: Integer;	
 	cc	: CnCntrl;				
begin
	if str = null then
		return;
	endif;

	log := myDumpFile;
	ind := indent + 1;
	line[ind : str.length + 2] := str & self.endOfLine;

	log.infoClient(line);
end;
}
writeLineC
{
writeLineC(str : String; line : String io; indent : Integer) clientExecution, updating;

	//  Conditionally writes dump line to log  ////

vars
 	slen, llen	: Integer;
begin
	slen 	:= str.length;
	llen  	:= line.length;

	if llen = 0 then
		line := str;
		slen := 0;
	elseif llen < 33 and slen < 70 then
		line[35:slen] := str;
		slen := 0;
	elseif llen < 68 and slen < 35 then
		line[70:slen] := str;
		slen := 0;
	else
		writeLine(line, indent);
		line := null;

		if slen > 0 then
			line := str;
		endif;
	endif;
end;
}
writeLog
{
writeLog(text : String; onServer : Boolean);

vars
	cc 	: CnCntrl;
begin
	if app.dbServerComputerName <> app.cnComputerNameAppServer then
		app.cnWriteServerLog(text);
	else 
		cc	:= app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogDiag, text, null);
	endif;	
end;
}
zDumpExceptionHandlerStack
{
zDumpExceptionHandlerStack(pLocation : String; pObjectArray : ObjectArray) protected, updating;

vars
	obj,
	objLast			: Object;
	
	exHandlerDesc	: ExceptionHandlerDesc;
	
	armingMethod,
	exMethod		: Method;
	
	parameters		: ParameterColl;
	
	param			: Parameter;
	
	cc				: CnCntrl;
	
	methodName,
	modName,
	str				: String;
	
	appl			: Application;
	
	receiver		: Object;
	
	count,
	patchNum		: Integer;
	
	ts				: TimeStamp;
	
	hadError		: Boolean;
begin
	cc := app.myCnCntrl;
	if pObjectArray.isEmpty() then
		str := pLocation & " no exception handlers currently armed.";
		if self.myDumpFile <> null then
			self.writeLine(str, null);
		
		else
			cc.cnWriteLog(cc.CnLogComment, str, null);
		endif;
		
		return;
	endif;

	objLast := pObjectArray.last();
	if self.myDumpFile <> null then
		self.writeLine(pLocation, null);
	
	else
		cc.cnWriteLog(cc.CnLogComment, pLocation, null);
	endif;

	on SystemException do app.cnGenericExceptionHandler(exception, 1090, null, hadError);
	foreach obj in pObjectArray do
		exHandlerDesc := obj.ExceptionHandlerDesc;
		// don't list exception handlers armed within dumpstack
		armingMethod := exHandlerDesc.armingMethod;
		if armingMethod <> null and armingMethod.qualifiedName() = "CnStackDump::dumpStack" then
			continue;
		endif;
		
		if exHandlerDesc.isGlobal then
			str := "Global ";
		
		else
			str := "Local ";
		endif;
		
		exMethod := exHandlerDesc.exceptionHandlerMethod;
		methodName := exMethod.cnGetMethodName();
		str := str & 
				exHandlerDesc.exceptionClass.name &
				", " & methodName &
				" (";
		receiver := exHandlerDesc.exceptionHandlerReceiver;
		parameters := exMethod.cnGetParameters();
		foreach param in parameters do
			str := str & param.name & ", ";
		endforeach;
		
		str := str[1:(str.length()-2)] & ")";
		if self.myDumpFile <> null then
			self.writeLine(str, 4);
	
		else
			cc.cnWriteLog(cc.CnLogComment, "    " & str, null);
		endif;

		if obj = objLast and methodName = "Schema::nonGUIGlobalExceptionHandler" then			// kludge as attempting to access atr of this causes dump to cease
			continue;
		endif;
		
		ts := exMethod.cnGetModifiedTimeStamp();
		patchNum := exMethod.cnGetPatchNumber();
		hadError := false;
		modName := exMethod.cnGetModifierName();
		if hadError then
			modName := "<unknown>";
		endif;

		str := "method modified by '" & modName &
				"' on " & ts.date.String &
				" " & ts.time.cnUserFormat($CnHHMMSS) & "." & ts.time.milliSecond().String;
		if patchNum > null then
			str := str & ", patch " & patchNum.String;
		endif;

		str := null;
		if receiver <> app then
			str := "receiver=" & receiver.String;
		endif;
		
		count := exHandlerDesc.invocationCount;
		if count > null then
			if str = null then
				str := "invocationCount=" & count.String;
			
			else
				str := str & ", invocationCount=" & count.String;
			endif;
		endif;
		
		appl := exHandlerDesc.armingApplication;
		if appl <> app then
			if str = null then
				str := "armed by " & exHandlerDesc.armingApplication.name;
			
			else
				str := str & "; armed by " & exHandlerDesc.armingApplication.name;
			endif;
			
			if armingMethod <> null then
				str := str & " in " & armingMethod.cnGetMethodName();
			endif;
		
		elseif armingMethod <> null then
			if str = null then
				str := "armed in " & armingMethod.cnGetMethodName();
			
			else
				str := str & "; armed in " & armingMethod.qualifiedName();
			endif;
		endif;

		if str <> null then
			if self.myDumpFile <> null then
				self.writeLine(str, 8);
		
			else
				cc.cnWriteLog(cc.CnLogComment, "        " & str, null);
			endif;
		endif;
	endforeach;
end;
}
zDumpStack
{
zDumpStack(pException 			: Exception;
			pExceptionDetails	: String output) updating, protected;

constants
	Censored_String	: String	= "<<< censored >>>>";
vars
	applic,
	cnApp					: Application;

	methodClass				: Class;

	cc  					: CnCntrl;

	kc						: CnKarmaCntrl;
	
	localvar 				: JadeLocalVar;

	dumpFile				: JadeLog;

	le						: LockException;

	meth					: Method;

 	methodDescription 		: MethodCallDesc;
	
	obj						: Object;

	param					: Parameter;

	heldBy,
	targetLockedBy			: Process;

	appArray				: ApplicationArray;

	processStack 			: ProcessStackArray;

	schemaArray				: StringArray;

	value					: Any;

	bool,
	hadError,
	importedPackages,
	invObj,
	miniDump,
	thinClient				: Boolean;

	d1, 
	d2						: Decimal [20];

	i,
	int,
	level,
	msTs,
	osArchitecture,
	osPlatform,
	patchNum,
	pid,
	role,
	stackSize,
	startStackOffset,
	x						: Integer;	// used by exception handler

	appUserName,
	computerName,
	computerNameAppServer,
	dumpFileName,
	errorOidStr,
	ipAddress,
	hyphens,
	line,
	methodName,
	methodNameAndPosition,																										// PAR 969
	methodClassName,
	modName,
	nodeInfo,
	nodeIpAddress,
	nodeName,
	noteStr,
	obtained,
	osVersion,
	processIpAddress,
	processSignOnUserCode,
	processUserCode,
	sourceLine,
	str, 
	str2,
	target,
	thinClientComputerName,
	usercode				: String;

	alertTime,
	now,
	ts,
	tstateTs				: TimeStamp;
begin
	d1 := app.relativeMachineTime();
	
	cnApp := process.getProcessApp();
	create appArray transient;
	process.getAllApps(appArray);
	importedPackages := (appArray.size() > 1);
 	//
	//   The logged output of this method will be correctly formatted when printed using a fixed-pitch font.
	//   The output was designed to be printed using Notepad with Courier New, font pitch = 7, portrait.
	//   The starting point in the call stack can be (optionally) defined by the user prior to calling this
	//   method.
	//
	//   Note that this method now makes the decisions as to whether to (a) report the exception to JSM, and
	//   (b) actually take a stack dump.  Formerly, these decisions were made in the ::cnGlobalExceptionHandler.
   	//
   	//	 Class version 3.1 September 03, 2003, for JADE 6.0 or higher. 
   	//	 R. W. Mitchell, Systems Management Development Centre,
   	//   (c) 2003 Jade Software Corporation Limited, New Zealand.

	app.mousePointer := Busy;
	hyphens := "=====================================================================================================";
	cc 		:= app.myCnCntrl;
	kc		:= app.myCnKarmaCntrl;
	if node.isServerNode() then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " stackdump is executing on Server Node (" & node.String & ")", null);
	
	else
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " stackdump is executing on Client Node (" & node.String & ")", null);
	endif;
	
//	self.getTransientsOnClient();
//	self.getTransientsOnServer();
	now		:= app.actualTimeAppServer;
	thinClient := process.isUsingThinClient;
	if cc.logStackDumpCensored then
		appUserName					:= Censored_String;
		computerName 				:= Censored_String;
		computerNameAppServer		:= Censored_String;
		nodeIpAddress				:= Censored_String;
		nodeName					:= Censored_String;
		processSignOnUserCode		:= Censored_String;
		processUserCode				:= Censored_String;
		if kc.thinClientComputerName <> null then
			thinClientComputerName 	:= Censored_String;
			processIpAddress 		:= Censored_String;
		endif;
		
	else
		appUserName					:= app.userName;
		computerName 				:= app.cnComputerName();
		computerNameAppServer 		:= app.cnComputerNameAppServer();
		nodeIpAddress				:= kc.networkAddressNode;
		nodeName					:= node.name;
		processSignOnUserCode		:= process.signOnUserCode;
		processUserCode				:= process.userCode;
		if kc.thinClientComputerName <> null then
			thinClientComputerName 	:= kc.thinClientComputerName;
			processIpAddress 		:= kc.networkAddressProcess;
		endif;
	endif;

	kc.getProcessId(pid);

/*	// removed as a result of JADE contact 60596 and discussion with Richard Mitchell on 14th Oct 2013.
	// 3049 exception:
	//	- the dumps are now of limited use
	//	- the impact of these dumps no longer warrants this patch being kept
	//	- a patch for this 3049 issue is being schedule for the 7.1 release of JADE given the rare nature and that
	//	  presenting the transaction again is unlikely to encounter the same issue.

	if pException.errorCode = Cn_ObjectEditionOutOfDate then
		alertTime := app.actualTimeServer;
		app.cnRaiseAlert("3049 exception forcing process dumps : " & cc.appName &  " of " & kc.environmentId.toUpper() & " on " & app.cnComputerName,
						 "3049 (Object edition out of date) exception has occurred and is forcing server node and client node processdump." &
						 "This will render " & kc.environmentId.toUpper() & " inactive while dumps are happening.",
						 "N",
						 alertTime,
						 cc.appName,
						 kc.localFQDN,
						 kc.networkAddressNode);		// PAR 441 node.networkAddress);
		kc.dumpNodeServer();
		kc.dumpNodeClient();
		app.cnRaiseAlert("3049 exception forcing process dumps : " & cc.appName &  " of " & kc.environmentId.toUpper() & " on " & app.cnComputerName,
						 "3049 (Object edition out of date) exception process dumps have completed. Open fault to environment's developer.",
						 "R",
						 alertTime,
						 cc.appName,
						 kc.localFQDN,
						 kc.networkAddressNode);		// PAR 441 node.networkAddress);
	endif;
*/	
	create processStack transient;
	process.currentStack(processStack);
	stackSize	:= processStack.size;
	if cc.logCallStackDump then
		dumpFileName 		:= "cn_dump_" & 
								now.date.cnUserFormat($CnCCYYMMDD_ns) & CN_UNDERSCORE & 
								now.time.cnUserFormat($CnHHMMSS_ns) &
						   	   now.time.milliSecond.String.padLeadingZeros(3) & CN_UNDERSCORE &
							   cnGetInstanceId(process).String;
		if thinClient then
			dumpFileName	:= dumpFileName & CN_UNDERSCORE & app.cnComputerName;
		endif;
		
		dumpFileName		:= dumpFileName & " [" & pException.errorCode.String & "].log";
		dumpFileName		:= dumpFileName.cnRemoveInvalidFileNameChars();			// PAR 727
	endif;

   	if stackSize < 4 then
   		startStackOffset := 1;
		
   	elseif self.stackStartIndex > 0 then
   		startStackOffset := self.stackStartIndex;					// application programmer specified stack start position
		
   	else
   		startStackOffset := self.zGetStartCallStackIndex(processStack);		// leave out process.currentStack, self.dumpStack, globalExceptionHandler
   	endif;

	if cc.karmaControl and (cc.reportExceptions or cc.reportExceptionsAll) then
		self.reportException(startStackOffset, processStack, pException, dumpFileName);								// report exception to JADECare Systems Manager
	endif;
	
	if not cc.logCallStackDump or self.noDump then
		if not cc.logCallStackDump then
			str	:= "LogCallStackDump not set in [AppExceptions] section of ini file.";
		else
			str := "dump not appropriate for this type of exception.";
		endif;
		
		cc.cnWriteLog(cc.CnLogComment, "Stack dump not taken - " & str, null);
		app.setCnStackDumpFileName(null);
		return;
	endif;
	
	//////////////////////////////   Take call stack dump, if required  //////////////////////////////////////

	create dumpFile;
	dumpFile.filePath		:= cc.logPath;
	dumpFile.fileName		:= dumpFileName;
	dumpFile.versionFile	:= false;
	dumpFile.formatOutput	:= false;
	dumpFile.bufferOutput	:= true;
	
	dumpFileName			:= cc.logPath & CN_SLASH & dumpFileName;
	dumpFileName.replaceChar(CN_BACK_SLASH, CN_SLASH);
	app.setCnStackDumpFileName(dumpFileName);
	myDumpFile				:= dumpFile;

	cc.cnWriteLog(cc.CnLogErrors, "Application Exception " & pException.errorCode.String &
				  "  : CnStackDump now taking stack dump for application " & cc.appName &
				  " : dump file = " & dumpFileName, null);

	self.writeLine(hyphens, null);
	str			:= "";
	str[32:110] := "S T A C K    D U M P                       S T A C K    D U M P                       S T A C K    D U M P";
	self.writeLine(str, null);
	self.writeLine(hyphens, null);

	self.writeLine("Application : " & cc.appName & "           Computer : " & computerName & "          Error : " & pException.errorCode.String &
			  "         Time : " & now.date.String & ", " & now.time.String & "." & now.time.milliSecond.String.padLeadingZeros(3) & " (local)", null);
	self.writeLine(hyphens, null);
	self.writeLine(null, null);
	str 	:= "Exception " & pException.errorCode.String & "  (" & pException.text & ")  in application " & cc.appName &
		  	   " (application type = " & app.cnGetApplicationType & "), extendedErrorText=" & pException.extendedErrorText;
	self.writeLine(str, null);
	
	pExceptionDetails	:= "Exception " & pException.errorCode.String & "  (" & pException.text & ")" & CrLf &
							"Application " & cc.appName & " (application type = " & app.cnGetApplicationType & ")" & CrLf &
							"ExtendedErrorText=" & pException.extendedErrorText;
	
	str		:= "Exception occurred at " & now.String & "  (GMT=" & now.cnGMT.String & ") ";
	if node.isServerNode then
		str	:= str & " by database server clock.";
		
	elseif thinClient then
		str := str & " by app server clock.";
		
	else
		str := str & " by fat client clock.";
	endif;
	
	self.writeLine(str, null);
	str		:= "Local times for participants : database server=" & app.cnGetServerTime.String;
	if thinClient then
		str	:= str & ", executing thin-client, app server=" & now.String;
	endif;
	
	if not app.cnIsServerApp then
		str := str & ", client=" & app.cnGetClientTime.String;
	endif;
	
	self.writeLine(str, null);
	str := app.cnGetApplicationVersion();
	if str = null then
		str := "<not specified>";
	endif;
	
	self.writeLine("Application version is " & str, null);
	
	str := "Application is running from schema " & cnApp.class.schema.name & " that has ";
	if importedPackages then
		str := str & "imported one or more packages.";
	
	else
		str := str & "not imported any packages.";
	endif;
	
	self.writeLine(str, null);
	if thinClientComputerName <> null then
		if app.isPortableGui then
			str	:= CN_PORTABLE_GUI;
			
		else
			str	:= CN_JADE_EXE;
		endif;
		
		self.writeLine("Client is thin client " & str & " : computer name = " & thinClientComputerName &
				  " (" & processIpAddress & "), pid=" & pid.String & ",", 0);		// PAR 536
	endif; 
	
	if node.isServerNode then
		nodeInfo	:= "server node, computer=" & computerName;
		
	elseif node.isApplicationServer then
		nodeInfo	:= "application server node, computer=" & computerNameAppServer;
		
	else
		if app.isPortableGui then
			str		:= CN_PORTABLE_GUI;
		else
			str		:= CN_JADE_EXE;
		endif;
		
		nodeInfo	:= "fat client node " & str & ", computer=" & computerName;
	endif;
	 	
	self.writeLine("Stack dump is executing on " & nodeInfo & " (node address=" & nodeIpAddress & 	// PAR 441 node.networkAddress &
	          "), pid=" & pid.String & ", node name=" & nodeName & ",", null);
	
	str				:= "Database is not an SDS system";
	role			:= system.getDatabaseRole();
	if role = SDS_RolePrimary then
		str			:= "Database is an SDS primary system.";
		
	elseif role = SDS_RoleSecondary then
		str			:= "Database is an SDS secondary system.";
	endif;
	
	self.writeLine(str, null);

	osPlatform	:= node.getOSPlatform(osVersion, osArchitecture);		// gets node info - for thin-client this is jadapp server)
	str	:= "Platform type for this node=";
	if osPlatform = Node.OSWindows 				or
	   osPlatform = Node.OSWindowsEnterprise 	or
	   osPlatform = Node.OSWindowsHome 			then
		str	:= str & "Windows";
		
	elseif osPlatform = Node.OSUnixLinux 		then
		str	:= str & "Linux (" & cc.osDistribution & " " & cc.osVersion & ")";
		
	elseif osPlatform = Node.OSUnixAIX			then
		str := str & "AIX";
		
	else
		str	:= str & "<unknown OS platform>";
	endif;
	
	str	:= str & ", OS version=" & osVersion & ", platform architecture=";
	if osArchitecture = Node.Architecture_32Big_Endian then
		str	:= str & "Architecture_32Big_Endian";
		
	elseif osArchitecture = Node.Architecture_32Little_Endian then
		str	:= str & "Architecture_32Little_Endian";
		
	elseif osArchitecture = Node.Architecture_64Little_Endian then
		str	:= str & "Architecture_64Little_Endian";

	elseif osArchitecture = Node.Architecture_64Big_Endian then
		str	:= str & "Architecture_64Big_Endian";

	elseif osArchitecture = Node.Architecture_Gui then
		str	:= str & "Architecture_Gui (currently Windows 32 bit little endian)";
	endif;
	
	self.writeLine(str, null);

	if thinClient then
		str := "Thin-client platform type=";
		if app.cnThinClientOSIsWindows()	then
			str	:= str & "Windows";
			
		elseif app.cnThinClientOSIsWindowsMobile() then
			str	:= str & "Windows Mobile";
		
		else
			str	:= str & "<unknown OS platform '" & app.cnThinClientOSPlatform.String & "'>";
		endif;
		
		str	:= str & ", OS version=" & app.cnThinClientOSVersion & ", architecture=";
		if app.cnThinClientOSArchitecture = Node.Architecture_32Big_Endian then
			str	:= str & "Architecture_32Big_Endian";
			
		elseif app.cnThinClientOSArchitecture = Node.Architecture_32Little_Endian then
			str	:= str & "Architecture_32Little_Endian";
			
		elseif app.cnThinClientOSArchitecture = Node.Architecture_64Big_Endian then
			str	:= str & "Architecture_64Big_Endian";
			
		elseif app.cnThinClientOSArchitecture = Node.Architecture_64Little_Endian then
			str	:= str & "Architecture_64Little_Endian";
			
		elseif app.cnThinClientOSArchitecture = Node.Architecture_Gui then
			str	:= str & "Architecture_Gui (currently Windows 32 bit little endian)";
		endif;

		self.writeLine(str, null);
	endif;
	
	self.writeLine("process=" & process.String & ", process usercode=" & processUserCode & ", process signOnUsercode=" & processSignOnUserCode & ", process signOnTime=" & process.signOnTime.String & ".", null);
	tstateTs := process.cnGetTransactionStartTime(msTs);
	if process.isInTransactionState() then
		str := "Process is in transaction state, transaction state started at " & tstateTs.cnFormat_DDMMYY_hhmmsscc() & " (" & msTs.userNumberFormat($CnWholeNumbers) & "ms ago)";
	
	else
		str := "Process is not in transaction state";
	endif;
	
	self.writeLine(str, null);
	self.writeLine("Database path=" & app.dbPath & ", app.userName=" & appUserName & ".", null);
	self.writeLine("Initialization file=" & app.getIniFileName() & ".", null);
	self.writeLine("Only the first " & cc.maxArrayElementsInDump.String & " elements of any arrays will be dumped.", null);

	str := "CardSchema Class Library Version " & app.cnGetCardSchemaVersion() & ", JADE version " & app.getSystemVersion();
	if app.isUnicode then
		str := str & " (Unicode)";
		
	else
		str := str & " (ANSI)";
	endif;
	
	self.writeLine(str, null);
	
	if cc.appName[1:2] <> "KC" then								
		miniDump	:= cc.logMiniStackDump;
		
	else
		miniDump	:= false;									// Always do full stack dump for CardSchema apps
	endif;
	
	if pException.errorCode = 1284 or								// user sign-on disabled
	   pException.errorCode = 4021 or								// method needs compilation - can't access some method stuff
	   pException.errorCode = 4035 or								// user interrupted method execution
	   pException.errorCode = 1201 or								// kernel stack overflow
	   pException.errorCode = 1018 or								// no memory for buffers
	   pException.errorCode = 14135 then								// app server stack overflow
		miniDump := true;
		self.writeLine("Stack dumper won't provide stack analysis for this exception type (" & pException.errorCode.String & ") : method calls only will be displayed.", 0);
	endif;
	
	if pException.errorCode = 1081 then								// deadlock
		obtained:= app.cnGetClassAndOid(pException.DeadlockException.obtainedLock);
 		heldBy	:= pException.DeadlockException.targetLockedBy;
		target	:= app.cnGetClassAndOid(pException.DeadlockException.lockTarget);
		on SystemException do app.cnHandleNullOrInvObjectRef(exception, heldBy, invObj);											// PAR 695
		usercode := heldBy.userCode;																								// PAR 695
		on SystemException do null;	
 		if invObj then														// JADE can't always report all the details
		 	str := "Deadlock exception : no targetLockedBy information available from JADE, " &
		 		   ", locktype=" & pException.DeadlockException.lockType.String &
	 			   ", target=" & target &
	 			   ", other user is trying to lock " & obtained & " (which this process already has locked)."; 
			pExceptionDetails := pExceptionDetails & CrLf &																		// PAR 969
								"Deadlock exception : no targetLockedBy information available from JADE" & CrLf &				// PAR 969
								   "    Locktype=" & pException.DeadlockException.lockType.String &								// PAR 969
								   ", target=" & target &																		// PAR 969
								   ", other user is trying to lock " & obtained & " (which this process already has locked)."; 	// PAR 969
		
		else
			if app.getSystemVersion.cnMarkReleaseCut() > 6216 then			// Network address is meaningless until 6.2.17
				ipAddress := "ipAddress=" & heldBy.networkAddress & ", ";
			endif;
	
		 	str :=  "Deadlock Exception : locktype=" & pException.DeadlockException.lockType.String &
				    ", locktarget=" & target & ", " &
				    "currently held by " &  heldBy.String & " " &
				    "(app=" & heldBy.persistentApp.name & ", " &
				    ipAddress &
				    "usercode=" & usercode & ")  " &
				    "who is trying to lock " & obtained;
			pExceptionDetails	:= pExceptionDetails & CrLf &																	// PAR 969
					"Deadlock Exception : locktype=" & pException.DeadlockException.lockType.String &							// PAR 969
				    ", locktarget=" & target & CrLf &																			// PAR 969
				    "    Currently held by " &  heldBy.String & " " &															// PAR 969
				    "(app=" & heldBy.persistentApp.name & ", " &																// PAR 969
				    ipAddress &																									// PAR 969
				    "usercode=" & usercode & ")  " &																			// PAR 969
				    "who is trying to lock " & obtained;																		// PAR 969
		endif;

		self.writeLine(str, null);
	endif;
	
	if pException.isKindOf(LockException) and pException.errorCode = 1027 then					// lock exception
		le				:= pException.LockException;
		targetLockedBy	:=	le.targetLockedBy;
		str				:= "Exception=" & le.errorCode.String & " : " & le.text & ", lockTarget=" &
						    le.lockTarget.String;
		pExceptionDetails	:= pExceptionDetails & CrLf & str;																	// PAR 969
		self.hadException := false;
		x := targetLockedBy.edition;
		if not self.hadException then
			str			:= str & ", locked by " & targetLockedBy.userCode & " on node " &
						    targetLockedBy.node.name & " (locking process app name=" & targetLockedBy.persistentApp.name &  
						    ", process=" & targetLockedBy.String & ") : aborted after multiple retries.";
						    
		elseif targetLockedBy <> null then
			str			:= str & ", targetLockedBy was an invalid reference : locking process must have gone away.";
			
		else
			str			:= str & ", targetLockedBy is null : possible JADE problem.";
		endif;
		
		self.writeLine(str, null);
		
		if cc.logMiniStackDumpForLocks then
			miniDump	:= true;
			self.writeLine("LogMiniStackDumpForLocks=true : will only perform mini stack dump for this exception.", 0);
		endif;
	endif; 
	
	if pException.isKindOf(FileException) then
		str	:= self.getFileExceptionDetails(pException.FileException);															// PAR 969
		self.writeLine(str, 0);																									// PAR 969
		pExceptionDetails	:= pExceptionDetails & CrLf & str;																	// PAR 969
	endif;

	on Exception do exceptionHandler(exception);

	//// Now get the call stack history ////

	if app.cnApplicationType <> app.ApplicationType_Web_Enabled and		// not a web session
	   app.cnApplicationType <> app.ApplicationType_Non_GUI_Web then	// not non-GUI web										// PAR 666
		self.showDumpProgressForm(pException, stackSize + 1);						// shows crying frog screen, if not suppressed

	elseif not pException.isKindOf(LockException) then			// if it's a lock then we will already have displayed a form 
		app.cnShowExceptionWebForm(pException);					// in cnGlobalLockExceptionHandler itself
	endif;

    self.writeLine (null, null);
    self.writeLine("======================================  Exception Summary  ===============================================", 0);
	self.writeLine(null, null);
	str	:= "Exception Type: " & pException.class.name & " (" & pException.errorCode.String & " : " & pException.text & ")";
	if not pException.continuable then
		str2	:= "  (Not continuable, ";
		
	else
		str2	:= "  (Continuable, ";
	endif;
	
	if not pException.resumable then
		str2	:= str2 & "not resumable)";
	else
		str2	:= str2 & "resumable)";
	endif;
	
	self.writeLine(str & str2, null);
	if pException.extendedErrorText <> null then
		self.writeLine("Extended Text : " & pException.extendedErrorText, 0);
	endif;
	
	str	:= "Error Item: ";
	if pException.errorItem <> null then
     	self.writeLine(str & pException.errorItem, null);
    
	else
    	self.writeLine(str & "<Not available>", null);
    endif;

	str	:= "Error Object: ";
	// handle 1046 whee object reference to class that has been deleted.
	errorOidStr := null;
	on SystemException do self.exceptionHandlerDeletedClass(exception, errorOidStr);
	str := str & app.cnGetClassAndOid(pException.errorObject);
	on SystemException do null;
	
	if errorOidStr <> null then
		str := str & "<Object reference to invalid class, oid=" & errorOidStr & ">";
	
	else
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_AttemptedAccessViaNullRef, null, self.hadException);
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectNotFound, null, self.hadException);
		self.hadException := false;
		x := pException.errorObject.edition;
		if self.hadException then
			str := str & " (Invalid object reference)";
		endif;
		
		on SystemException do null;
		on SystemException do null;
	endif;

	self.writeLine(str, null);
	self.writeLine("Caused By:", null);
	str := "     Receiver: ";
	self.hadException := false;
	x := pException.currentMethodDesc.edition;
	if self.hadException then 
		str := str & "<No currentMethodDesc, receiver details not available>";

	else
		str := str & pException.currentMethodDesc.receiverAsString;
	endif;

	self.writeLine(str, null);
	
	str := "     Method: ";
	if self.hadException then 
		methodNameAndPosition	:= "<No currentMethodDesc>";																	// PAR 969
		str := str & "<No currentMethodDesc, method details not available>";
		
	else
		str := str & self.zGetMethodStackdumpLine(pException.currentMethodDesc, methodNameAndPosition);							// PAR 969
	endif;
	
	self.writeLine(str, null);
		
	self.writeLine("Reported By: ", null);
	self.hadException := false;
	x := pException.reportingMethodDesc.edition;
	str := "     Receiver: ";
	if self.hadException then 
		str := str & "<No reportingMethodDesc, receiver details not available>";

	else
		str := str & pException.reportingMethodDesc.receiverAsString;
	endif;

	self.writeLine(str, null);
	
	str := "     Method: ";
	if self.hadException then 
		str := str & "<No reportingMethodDesc, method details not available>";
	
	else
		str := str & pException.reportingMethodDesc.display;
	endif;
	
	self.writeLine(str, null);
	self.writeLine(" ", null);
	
	////  Start building notification string for unhandled exception note  ////

	noteStr := app.cnComputerName & "^" &
			   cc.appName & "^" &
			   pException.errorCode.String & "^" &
			   pException.text & "^";

   	if pException.extendedErrorText <> null then
   		noteStr := noteStr & pException.extendedErrorText & "^";
		
   	else
   		noteStr := noteStr & "No extended error text" & "^";
   	endif;
   	
	str := "Call Stack History:";
   	if stackSize < 4 then
   		self.writeLine("############ Unexpectedly short call stack : stack size = " & stackSize.String & ", will list entire stack  ##########", 0);
		
   	elseif self.stackStartIndex > 0 then
		str := str & " (startIndex=" & self.stackStartIndex.String & ")";
   	endif;

	self.writeLine(str & ":", null);
	pExceptionDetails := pExceptionDetails & CrLf & str;																		// PAR 969

	if importedPackages then
		create schemaArray transient;
	endif;
	
	i := startStackOffset;
    while i <= stackSize do
		methodDescription := processStack[i];
		self.hadException := false;
		x := methodDescription.edition;
		if not self.hadException then
			if importedPackages then			// we want to keep track of which schema a method has been invoked for
				obj := methodDescription.getReceiver();		// so that we only explode the pertinent application objects.
				str := obj.class.schema.name;	// Ideally, we should know the specific application object but not available yet (PAR 46275)
				if not schemaArray.includes(str) then
					schemaArray.add(str);
				endif;
			endif;
			
			meth := methodDescription.method;
			self.hadException := false;
			x := meth.edition;
			if not self.hadException then
				str := self.zGetMethodStackdumpLine(methodDescription, methodNameAndPosition);									// PAR 969
				pExceptionDetails := pExceptionDetails & CrLf & methodNameAndPosition;											// PAR 969
				self.writeLine("     " & str, null);
				on SystemException do app.cnGenericExceptionHandler(exception, 1090, null, hadError);
				ts := meth.cnGetModifiedTimeStamp();
				patchNum := meth.cnGetPatchNumber();
				hadError := false;
				modName := meth.cnGetModifierName();
				if hadError then
					modName := "<unknown>";
				endif;
				
				on SystemException do null;				// pop exception stack
				str := " method modified by '" & modName &
						"' on " & ts.date.String &
						" " & ts.time.cnUserFormat($CnHHMMSS) & "." & ts.time.milliSecond().String;
				if patchNum > null then
					str := str & ", patch " & patchNum.String;
				endif;
					
				self.writeLine(str, 8);
				if i = 4 then
					noteStr	:= noteStr & methodDescription.display & "^"; 
				endif;
				
				str 	:= "         ++ Source line:  ";
				sourceLine := meth.cnGetSourceLine(methodDescription.position);
				sourceLine := self.removeSensitiveDataFromArgs(sourceLine);
				self.writeLine(str & sourceLine, 0);
				if i = 4 then
					sourceLine := meth.cnGetSourceLine(methodDescription.position);
					sourceLine := self.removeSensitiveDataFromArgs(sourceLine);
					noteStr := noteStr & sourceLine & "^";
				endif;

			else
				self.writeLine("Bad method object ..... can't analyse", 0);
				if i = 4 then
					noteStr	:= noteStr & "Method not available^Source line not available^"; 
				endif;
			endif;

		else
			self.writeLine("Bad MethodCallDesc object ...... can't analyse", 0);
		endif;

		i := i + 1;
	endwhile;

	if noteStr = null then												// indicates we had a problem with methodcalldesc 
		noteStr := app.cnComputerName & "^" &
				   cc.appName & "^" &
				   pException.errorCode.String & "^" &
				   pException.text & "^" & 
				   "Extended error text not available^" &
				   "Method name not available^" &
				   "Source line not available^";
	endif;  

	process.causeEvent(Cn_Unhandled_Exception, true, noteStr);			// issue notification to subscribers

	if pException.errorCode <> 14063 then
		updateDumpProgressForm(1);			// crying frog screen
	endif;

    self.writeLine (" ", null);
	self.writeLine("=======================================  Exception Stack  ================================================", 0);
	self.dumpExceptionHandlerStack();
 
	if not miniDump then
		self.writeLine(null, null);
		self.writeLine("==========   APP   =======  APP   =======  APP   =======  APP   =======  APP   =======  APP   =======  APP   =======", 0);
		if importedPackages then
			self.writeLine("Process has " & appArray.size().String & " application context objects defined.", null);
			self.writeLine("Process Application " & app.cnGetClassAndOid(cnApp) & " -----------> (1)", null);		// dump app and global
			self.dumpObjVars("APP", cnApp, 1);
			int := null;
			foreach applic in appArray do
				int := int + 1;
				if cnApp = applic then
					continue;
				endif;
				
				str := applic.class.schema.name;
				if schemaArray.includes(str) then
					self.writeLine("Package Application #" & int.String & " " & app.cnGetClassAndOid(applic) & " -----------> (1)", null);			// dump app and global
					self.dumpObjVars("APP", applic, 1);
				endif;
			endforeach;

		else
			self.writeLine(app.cnGetClassAndOid(app) & " -----------> (1)", 0);				// dump app and global
			self.dumpObjVars("APP", app, 1);
		endif;
		
		self.writeLine(null, null);

	    self.writeLine("===============================  Detailed Call Stack Analysis   ================================================", 0);
	    
    	if stackSize < 4 then
   			self.writeLine("############ Unexpectedly short call stack : stack size = " & stackSize.String & ", will list entire stack  ##########", 0);
   			i := 1;
			
   		else
   			i := 4;								// leave out process.currentStack, self.dumpStack, globalExceptionHandler
   		endif; 
	    
		while i <= stackSize do
			if pException.errorCode <> 14063 then
				if thinClient then
					if i mod 4 = null then
						updateDumpProgressForm(i + 1);
					endif;
			
				else
					updateDumpProgressForm(i + 1);
				endif;
			endif;
			
			methodDescription:= processStack[i];
			self.hadException := false;
			x := methodDescription.edition;
			if not self.hadException then
				self.writeLine(null, null);
				meth := methodDescription.method;
				methodName := meth.cnGetMethodName();
				level := 0;
                if meth.isKindOf(JadeMethod) then			// find my level if method exists elsewhere in stack					
                	foreach int in 1 to i - 1 do
                		if processStack[int].method = meth then		
                			level := level + 1;
                		endif;
                	endforeach;	
                endif;

				self.hadException := false;
				x := meth.edition;
				if not self.hadException then
					methodClassName := meth.class().name;
					self.writeLine("****************  Method call = " & self.zGetMethodStackdumpLine(methodDescription, methodNameAndPosition) & "  ***********************", 0);
//					self.writeLine("****************  Method call = " & methodDescription.display & " (" & methodClass.name & ")  ***********************", 0);
					if i = 4 then
						str := "Source position = " & methodDescription.position.String & ", error object = " & app.cnGetClassAndOid(pException.errorObject);
						self.hadException := false;
						x := pException.errorObject.edition;
						if self.hadException then
							str := str & " (invalid object reference)";
						endif;

						self.writeLine("Method position=" & methodDescription.position.String, 0);
						sourceLine := meth.cnGetSourceLine(methodDescription.position);
						sourceLine := self.removeSensitiveDataFromArgs(sourceLine);
						str := ">>>> Source code line >>>>>  " & sourceLine;
						self.writeLine(str, null);

					else
						sourceLine := meth.cnGetSourceLine(methodDescription.position);
						sourceLine := self.removeSensitiveDataFromArgs(sourceLine);
						str := ">>>> Source code line >>>>>   " & sourceLine;
			          	self.writeLine(str, null);
					endif;

					line := null;

			        if methodClassName = JadeMethod.name and not miniDump then
			        	self.writeLine("====================  Parameters for method " & methodName & " (" & methodClassName & ")  ===============================", 0);
				        foreach param in meth.cnGetParameters do
							self.zExpandVariable(level, meth, param.name, param.type, line, "parameters");				// PAR 729
				        endforeach;

				        self.writeLine(line, 0);
				       	line := null;
						self.writeLine("=============================  Local Vars for method " & methodName & " (" & methodClassName & ")  ===============================", 0);
						foreach localvar in meth.JadeMethod.cnGetLocalVars do
							self.zExpandVariable(level, meth, localvar.name, localvar.type, line, "local vars");		// PAR 729
						endforeach;
						
						if line <> null then
							self.writeLine(line, 0);
							line	:= null;
						endif;
						
//						if i >= (stackSize -1) then						// commented for test : PAR 258
							obj	:= methodDescription.getReceiver();
//							if obj.isKindOf(Form) or not (obj.isKindOf(Form) and i = stackSize) then
								self.writeLine(" ", 0);
								self.writeLine("=============================  Receiver details for method " & methodName & " (" & methodClassName & ")  ===============================", 0);
								self.writeLine("Receiver = " & app.cnGetClassAndOid(obj) & " -------------> (1)", 0);
								self.dumpObjVars("Receiver details for method " & meth.name, obj, 1);
//							endif;
//						endif;

					elseif not miniDump then										// external method
						self.writeLine(meth.cnGetSourceLine(methodDescription.position), 0);
			        endif;

					self.writeLine(line, 0);
					line := null;
				endif;
				
			else
				self.writeLine("Invalid MethodCallDesc object .... can't analyse", 0);
			endif;
			
			i := i + 1;
		endwhile;
		
	else
		self.writeLine(" ", 0);
		self.writeLine("Mini-dump only was requested, or full stack dump not applicable to exception type.", 0);
	endif;		

	self.writeLine(" ", 0);
	self.writeLine(d1.cnGetElapsedTimeString(), 0);																				// PAR 1077
	self.writeLine("%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  End of Stack Dump  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%", 0);
	cc.cnWriteLog(cc.CnLogComment, "Stack dump completed : see file '" & dumpFile.fileName & "' on " & app.cnComputerNameAppServer, null);
epilog
	delete appArray;
	delete schemaArray;
	if processStack <> null then
		processStack.purge();
		delete processStack;
	endif;
	
	self.closeDumpLog;									// clientExecution
	delete dumpFile;
	if pException.errorCode <> 14063 then 
   		self.unloadDumpProgressForm;  	        			// clientExecution
   	endif;
	
	app.mousePointer := Idle;
	d2 := app.relativeMachineTime();
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " stack dump elapsed time = " & (d2-d1).String & "ms", null);
//	self.getTransientsOnClient();
//	self.getTransientsOnServer();
end;
}
zExpandVariable
{
zExpandVariable(pLevel 		: Integer; 
				pMeth 		: Method;
				pVarName	: String;
				pType		: Type;
				pLine		: String io;
				pEntityType	: String) updating, protected;

vars
	cc		: CnCntrl;
	
	obj		: Object;
	
	value	: Any;
	
	bool	: Boolean;
	
	x		: Integer;
	
	str,
	str2	: String;
	
	typeName : String;
begin
	cc := app.myCnCntrl;
	value := null;
	if pLevel = 0 then
		bool := pMeth.JadeMethod.getValue(pVarName, value);
		
	else
		bool := pMeth.JadeMethod._getValue(pLevel, pVarName, value);
	endif;

	if not bool then
		writeLineC(pVarName & " = <not initialized>", pLine, 0);

	elseif value = null and not pType.isKindOf(PrimType) then										
		writeLineC(pVarName & " = null", pLine, 0);
		
	elseif pType.isKindOf(PrimType) then 					// Primitives
		str		:= self.formatPrimType(pType.PrimType, value);
		
		if cc.logStackDumpCensored then
			str := "<" & str.length.String & ">";
			writeLineC(pVarName & " = " & str, pLine, 0);
		
		elseif str.length > Max_String_Length then
			str2 := str[1:Max_String_Length] & "...[truncated : actual length=" & str.length.String & "]";
			writeLineC(pVarName & " = " & str2, pLine, 0);
			
		else
			writeLineC(pVarName & " = " & str, pLine, 0);
		endif;

	elseif pType.isKindOf(Class) or pType.isKindOf(JadeInterface) then //877
		// we don't handle PseudoType yet, does it matter ?
		obj := value.Object;
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_AttemptedAccessViaNullRef, null, self.hadException);
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectNotFound, null, self.hadException);
		self.hadException := false;
		x := obj.edition;
		if not self.hadException then
			if obj.isKindOf(Array) then							// Arrays
				self.dumpArray(obj.Array, pVarName, 0);

			else												// all other objects
				writeLine(pLine, 0);
				pLine := null;
				str := pVarName & " = " & app.cnGetClassAndOid(value.Object) & " -------------> (1)";
				writeLine(str, 0);
				self.dumpObjVars(pEntityType & " for " & pMeth.cnGetMethodName(), obj, 1);
			endif; 

		else
			str := app.cnGetClassAndOid(obj);
			if str <> null and str <> "<null>" then 
				writeLine(pVarName & " = " & str & " <Invalid or null object reference>", 0);
			endif;
		endif;
	endif;   
end;
}
zGetMethodStackdumpLine
{
zGetMethodStackdumpLine(pMethodCallDesc 		: MethodCallDesc;
						pMethodNameAndPosition 	: String output) : String protected;

vars
	meth			: Method;
	
	methodName,
	methodNameAndPosition,
	methodPosition,
	oidStr			: String;
begin
	meth 			:= pMethodCallDesc.method;
	methodName		:= meth.cnGetMethodName();
	methodPosition	:= pMethodCallDesc.position.String;
	methodNameAndPosition	:= methodName & " (" & methodPosition & ")";
	oidStr 			:= app.cnGetClassAndOid(pMethodCallDesc.getReceiver());
	pMethodNameAndPosition	:= methodNameAndPosition;
	return "<<" & oidStr & ">> " &
			methodNameAndPosition & "  (" &
			meth.class().name & ")"; 
end;
}
zGetStartCallStackIndex
{
zGetStartCallStackIndex(pProcessStackArray : ProcessStackArray input) : Integer protected, updating;

vars
	objArray				: ObjectArray;
	
	obj						: Object;
	
	exHandlerDesc,
	invokedExHandlerDesc	: ExceptionHandlerDesc;
	
	md 						: MethodCallDesc;
	
	armingMethod,
	exMethod				: Method;
	
	cc						: CnCntrl;
	
	methodName,
	str						: String;
	
	count,
	index,
	invokedCount,
	maxSize,
	startIndex,
	x						: Integer;
begin
	cc := app.myCnCntrl;
	if not process.isInExceptionState() then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " not in exception state, stack offset default to 4", null);
		return 4;
	endif;
	
	create objArray transient;
	process.getExceptionHandlerStack(objArray);
	if objArray.isEmpty() then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " no exception handlers currently armed, stack offset default to 4", null);
		return 4;
	endif;

	on SystemException do app.cnGenericExceptionHandler(exception, Cn_AttemptedAccessViaNullRef, null, self.hadException);
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectNotFound, null, self.hadException);
	
	// we need to identify the exception handler that is invoked, ie the one with highest invocation count
	foreach obj in objArray do
		exHandlerDesc := obj.ExceptionHandlerDesc;
		// don't list exception handlers armed within dumpstack
		armingMethod := exHandlerDesc.armingMethod;
		if armingMethod <> null and armingMethod.qualifiedName() = "CnStackDump::dumpStack" then
			continue;
		endif;
		
		count := exHandlerDesc.invocationCount;
		if count = null then
			continue;
		endif;
		
/*		str := " invoked=" & count.String & ", ";
		if exHandlerDesc.isGlobal then
			str := str & "Global";
		
		else
			str := str & "Local";
		endif;
		
		str := str & 
				" " &
				exHandlerDesc.exceptionClass.name &
				", " & methodName;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & str, null);
*/		if count >= invokedCount then																							// PAR 582
			invokedCount := count;
			invokedExHandlerDesc := exHandlerDesc;

			exMethod := exHandlerDesc.exceptionHandlerMethod;
			methodName := exMethod.qualifiedName();
		endif;
	endforeach;

	if invokedExHandlerDesc = null then
		str := " No exception handlers invoked.";
		return 4;
	endif;
		
	str := " located exception stack : invoked=" & invokedCount.String & ", ";
	if invokedExHandlerDesc.isGlobal then
		str := str & "Global";
	
	else
		str := str & "Local";
	endif;
	
	exMethod := invokedExHandlerDesc.exceptionHandlerMethod;
	methodName := exMethod.qualifiedName();
	str := str & 
			" " &
			invokedExHandlerDesc.exceptionClass.name &
			", " & methodName;
	
	on Exception do exceptionHandler(exception);
    foreach md in pProcessStackArray do
		index := index + 1;
		self.hadException := false;
		x := md.edition;
		if self.hadException then
			continue;
		endif;
		
		if md.getName = methodName then
			str := str & ", match at index " & index.String;
			startIndex := index + 1;
			break;
		endif;
	endforeach;
	
	if startIndex > null then
		maxSize := pProcessStackArray.size();
		if startIndex > maxSize then
			str := str & " stack offset of " & startIndex.String & " exceeds process stack array size " & maxSize.String & ", default to 4.";
			return 4;
		endif;
		
		str := str & ", return " & startIndex.String;
		return startIndex;
	endif;
	
	str := str & " no match found, default to 4.";
	return 4;
epilog
	if objArray <> null then
		objArray.purge();
		delete objArray;
	endif;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & str, null);
end;
}
zRemoveNumericLiteralsFromArgs
{
zRemoveNumericLiteralsFromArgs(pStr : String) : String protected;
/*
	Purpose	:
	
	Remove numeric from source code and replace with the string length required to represent the item.
	This method assumes that string literal variations have already been stripped (using zRemoveStringLiteralsFromArgs)
*/

constants
	My_Debug	: Boolean	= false;
vars
	argCount,
	count,
	posClose,
	posHold,
	posOpen,
	pos1,
	pos2,
	sz			: Integer;

	newString,
	newSubString,
	subString,
	strToScan,
	token		: String;
begin
	pos1 := 1;
	strToScan := pStr;
	// look for opening parenthesis which starts any arguments
	pos1 := strToScan.pos(CN_LEFT_PARENTHESES, 1);
	
	// if none found then bail out here
	if pos1 = null then
		return pStr;
	endif;

	posOpen := pos1;
	if My_Debug then
		write "Open ( at pos=" & posOpen.String;
	endif;
	
	// increment past opening parenthesis
	pos1 := pos1 + 1;
	posHold := pos1;

	// so we've found the opening parenthesis, 
	// ensure there are no more
	while true do
		pos1 := strToScan.pos(CN_LEFT_PARENTHESES, pos1);
		if pos1 = null then
			break;
		endif;
		
		// keep count of how many as there needs to be a reciprocal number of closing parentheses
		count := count + 1;
		pos1 := pos1 + 1;
	endwhile;
	
	if My_Debug then
		write "Located a further " & count.String & " (";
	endif;
	
	// now find the closing parenthesis
	pos1 := posHold;
	pos2 := posHold;
	while count > null do
		pos2 := strToScan.pos(CN_RIGHT_PARENTHESES, pos2);
		if pos2 = null then
			break;
		endif;
		
		posHold := pos2;
		if My_Debug then
			write "Located ) at pos " & pos2.String & " for count " & count.String;
		endif;
		
		pos2 	:= pos2 + 1;
		count 	:= count - 1;
	endwhile;
	
	pos2 := posHold + 1;
	if My_Debug then
		write "Count=" & count.String & ", pos2=" & pos2.String;
	endif;
	
	pos2 := strToScan.pos(CN_RIGHT_PARENTHESES, pos2);
	if pos2 = null then
		return pStr;
	endif;
	
	posClose := pos2;
	if My_Debug then
		write "Closing ) pos=" & posClose.String;
	endif;
	
	sz := posClose - posOpen;
	if sz = null then
		if My_Debug then
			write "Size is null";
		endif;
		
		return pStr;
	endif;
	
	// so we've now found the arguments
	subString := strToScan[posOpen+1:posClose-posOpen-1];
	if My_Debug then
		write subString & Tab & "posOpen=" & posOpen.String & Tab & "posClose=" & posClose.String;
	endif;
	
	pos1 := 1;
	while true do
		subString.scanWhile(CN_SPACE & Tab & Cr & Lf, pos1);
		posHold := pos1;
		token := subString.scanUntil(CN_COMMA, pos1);
		if token <> null then
			argCount := argCount + 1;
			if My_Debug then
				write "[" & argCount.String & "] " & token;
			endif;
			
			pos2 := 1;
			// numeric item can include following and variations thereof
			//	- (123/10)
			//  - 123*10
			//	- 123 div 10 - not handled
			//	- 123 + 10
			//	- 123 - 10
			//	- 123**2
			//	- (123*10)+(124/5)
			token.scanWhile("0123456789" 			& 
							CN_PERIOD 				& 
							CN_PLUS 				& 
							CN_ASTERISK 			& 
							CN_SPACE 				& 
							CN_HYPHEN 				& 
							CN_SLASH				&
							CN_RIGHT_PARENTHESES	&
							CN_LEFT_PARENTHESES, pos2);
			if pos2 = null then
				if My_Debug then
					write "Token is numeric";
				endif;
				
				newString := "<" & token.length.String & ">";
				if posHold > 1 then
					newSubString := subString[1:posHold-1] & newString;
				
				else
					newSubString := newString;
				endif;
				
				if pos1 > null then
					newSubString := newSubString & subString[pos1:end];
					pos1 := posHold + newString.length();
				endif;
				
				subString := newSubString;
				if My_Debug then
					write subString;
					write "new pos1=" & pos1.String;
				endif;
			
			elseif My_Debug then
				write "Token not numeric";
			endif;
		endif;
		
		if pos1 = null then
			break;
		endif;
		
		subString.scanWhile(CN_COMMA & CN_SPACE, pos1);
	endwhile;
	
	return strToScan[1:posOpen] & subString & strToScan[posClose:end];
epilog
end;
}
zRemoveStringLiteralsFromArgs
{
zRemoveStringLiteralsFromArgs(pStr : String) : String protected;

constants
	My_Debug	: Boolean	= false;
vars
	pos1,
	pos2,
	strLen 		: Integer;
	
	quoteChar,
	str1,
	str2 		: String;
begin
	str1 := pStr;
	while true do
		pos1 := str1.pos(CN_DOUBLE_QUOTE,1);
		pos2 := str1.pos(CN_QUOTE,1);
		
		if pos1 = null and 
		   pos2 = null then
			break;
		endif;
		
		if pos1 = null then
			quoteChar := CN_QUOTE;
			pos1 := pos2;
	
		elseif pos2 = null then
			quoteChar := CN_DOUBLE_QUOTE;
	
		elseif pos1 < pos2 then
			quoteChar := CN_DOUBLE_QUOTE;
			
		else
			quoteChar := CN_QUOTE;
			pos1 := pos2;
		endif;
		
		pos2 := str1.pos(quoteChar,pos1+1);
		if pos2 = null then																										// PAR 854
			break;																												// PAR 854
		endif;																													// PAR 854
		
		strLen := pos2-pos1-1;
		str2 := "<" & strLen.String & ">";
		str1 := str1[1:pos1-1] & str2 & str1[pos2+1:end];
	endwhile;
	
	return str1;
end;
}
zServerExceptionHandlerStack
{
zServerExceptionHandlerStack(pObjArray : ObjectArray input) protected, serverExecution;

vars

begin
	process.getExceptionHandlerStack(pObjArray);
end;
}
zShowDumpProgressFormOK
{
zShowDumpProgressFormOK() : Boolean protected;

vars
	cc	: CnCntrl;

	cem	: CnExternalMethods;
begin
	cc := app.myCnCntrl;
	
	if app.cnApplicationType <> app.ApplicationType_GUI then		// conditions changed for PAR 352			
		return false;
	endif;

	if app.cnIsServerApp then
		return false;
	endif;
	
	if cc.suppressManagementDialogs then							// PAR 470 - change order so that this condition
		return false;												// PAR 470 - precedes the thin-client test
	endif;
	
	if process.isUsingThinClient() then
		return true;
	endif;
	
	// so must be other than thin-client
	create cem transient;
	if cem.emIsService()	then
		return false;
	endif;
	
	return true;
epilog
	delete cem;
end;
}
	)
	CnFunctionAgent (
	jadeMethodSources
cnGetTakeoverStateString
{
cnGetTakeoverStateString(pTakeoverProgress : Integer) : String;

vars

begin
	if pTakeoverProgress = SDS_RoleUndefined then
		return "role is undefined";
	endif;
	
	if pTakeoverProgress = SDS_PrimaryRoleActive then
		return "primary role active";
	endif;
	
	if pTakeoverProgress = SDS_SecondaryRoleActive then
		return "secondary role active";
	endif;

	if pTakeoverProgress = SDS_TakeoverInitiated then
		return "negotiated takeover initiated";
	endif;
	
	if pTakeoverProgress = SDS_HostileTakeoverInitiated then
		return "hostile takeover initiated";
	endif;
	
	if pTakeoverProgress = SDS_RelinquishPrimaryRole then
		return "relinquishing primary role";
	endif;

	if pTakeoverProgress = SDS_RelinquishSecondaryRole then
		return "relinquishing secondary role";
	endif;
	
	if pTakeoverProgress = SDS_TakeoverFailure then
		return "takeover failure";
	endif;
	
	if pTakeoverProgress = SDS_TakeoverAbandoned then
		return "hostile takeover initiated";
	endif;
	
	if pTakeoverProgress = SDS_HostileTakeoverInitiated then
		return "hostile takeover initiated";
	endif;
	
	if pTakeoverProgress = SDS_WaitForQuietPoint then
		return "waiting for quiet point";
	endif;
	
	if pTakeoverProgress = SDS_WaitForQuietPoint then
		return "waiting for quiet point";
	endif;
	
	if pTakeoverProgress = SDS_WaitForTakeoverDisposition then
		return "waiting for takeover disposition";
	endif;
	
	if pTakeoverProgress = SDS_PrimaryRoleRelinquished then
		return "primary role relinquished";
	endif;
	
	if pTakeoverProgress = SDS_SecondaryRoleRelinquished then
		return "secondary role relinquished";
	endif;
	
	return "unknown takeover state : " & pTakeoverProgress.String;
end;
}
cnHandleRoleChangeProgressEvent
{
cnHandleRoleChangeProgressEvent(pRoleChangeProgress : Integer;
								pInTakeoverState,
								pHostileTakeover	: Boolean io);

vars
	cc					: CnCntrl;
begin
	cc := app.myCnCntrl;
	if pInTakeoverState then
		// inTakeoverState will also be reset when RoleChange event is received.
		if pRoleChangeProgress = SDS_TakeoverFailure 	or
		   pRoleChangeProgress = SDS_TakeoverAbandoned 	then
			pInTakeoverState := false;
			pHostileTakeover := false;
		endif;
		
	else
		if pRoleChangeProgress = SDS_TakeoverInitiated 			or
		   pRoleChangeProgress = SDS_HostileTakeoverInitiated 	then
			pInTakeoverState := true;
			pHostileTakeover := (pRoleChangeProgress = SDS_HostileTakeoverInitiated);
		endif;
	endif;
		
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " takeover = " & pInTakeoverState.String & ", takeover state change : " & self.cnGetTakeoverStateString(pRoleChangeProgress), null);
end;
}
cnSDSStructureStatePrimUpdate
{
cnSDSStructureStatePrimUpdate(	pDbFileNamesArray 		: CnStringArray;
								pDbFileStatusArray		: IntegerArray;
								pPartitionIdArray		: Integer64Array;
								pFileExcludeFromBackup,
								pFrozenArray,
								pOfflineArray			: BooleanArray);						
/*
	This method is executed from 3 possible locations:
	
	  1) CnSDSDatabaseAdmin::zCnSDSStructureState_Check() 
	  2) CnDatabaseAdmin::zBackupCommonGetStructDetails()
	  3) CnDatabaseAdmin::zCompactWorkersTerminated()
*/
constants
	Status_Offline	: Integer = DbFile.Status_Offline;
	Status_Resident	: Integer = DbFile.Status_Resident;					
vars
	cc				: CnCntrl;
	
	cnRoot			: CnRoot;

	cnSDSss			: CnSDSStructureState;

	name			: String;
	
	role,
	dbFileStatus	: Integer;
	
	partitionId		: Integer64;
	
	iterDbFileStatus,
	iterPartitionId,
	iterExclude,
	iterFrozen,
	iterOffline		: Iterator;
	
	exclude,
	frozen,
	offline			: Boolean;
	
	tx				: CnTransactionAgent;
begin
	cc := app.myCnCntrl;
	if system.getDatabaseRole() <> SDS_RolePrimary then					// only relevant for Primary databases
		return;
	endif;
	
	cnRoot				:= app.myCnRoot;
	iterDbFileStatus	:= pDbFileStatusArray.createIterator();
	iterPartitionId 	:= pPartitionIdArray.createIterator();
	iterExclude			:= pFileExcludeFromBackup.createIterator();
	iterFrozen			:= pFrozenArray.createIterator();
	iterOffline			:= pOfflineArray.createIterator();
	
	executeWhen Cn_Debug_SDSStructureState;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " number of entries=" & pDbFileNamesArray.size.String, null);
	endExecuteWhen;
	
	create tx transient;
	foreach name in pDbFileNamesArray do
		iterDbFileStatus.next(dbFileStatus);
		iterPartitionId.next(partitionId);
		iterExclude.next(exclude);
		iterFrozen.next(frozen);
		iterOffline.next(offline);
		executeWhen Cn_Debug_SDSStructureState;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " name=" & name &
														", dbFileStatus=" & dbFileStatus.String &
														", partitionId=" & partitionId.String &
														", exclude=" & exclude.String &
														", frozen=" & frozen.String &
														", offline=" & offline.String, null);
		endExecuteWhen;

		cnSDSss := cnRoot.allSDSStructureState[name, partitionId]; 		// does an entry currently exists in CnSDSStructureState?
		// check to see if this file/partition is instantiated, if not then continue
		// an offline file is not considered resident yet we want this offline status to still be replicated to the Secondary
		if dbFileStatus <> Status_Resident 	and
		   dbFileStatus <> Status_Offline 	then
			executeWhen Cn_Debug_SDSStructureState;
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " structure=" & name & ", partitionId=" & partitionId.String &
													" file status " & dbFileStatus.String & ", structure ignored.", null);
			endExecuteWhen;
			
			if cnSDSss <> null then										// SDS entry exists remove it
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " structure=" & name & ", partitionId=" & partitionId.String & 
														" SDS item deleted : " & self.getObjectStringForObject(cnSDSss), null);
				tx.sdsStructureState_delete(cnSDSss);
			endif;

			continue;
		endif;
		
		if exclude then
			executeWhen Cn_Debug_SDSStructureState;
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " structure=" & name & ", partitionId=" & partitionId.String & " exclude", null);
			endExecuteWhen;
			
			if cnSDSss <> null then										// SDS entry exists remove it
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " structure=" & name & ", partitionId=" & partitionId.String & 
														" SDS item deleted : " & self.getObjectStringForObject(cnSDSss), null);
				tx.sdsStructureState_delete(cnSDSss);
			endif;
			
			continue;
		endif;
		
		if frozen 	or 
		   offline 	then
			executeWhen Cn_Debug_SDSStructureState;
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " structure=" & name & ", partitionId=" & partitionId.String & 
																" is frozen and/or offline", null);
			endExecuteWhen;
			if cnSDSss = null then
				// nothing currently exists so create a new entry
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " creating SDS structure entry for " & " structure=" & name & ", partitionId=" & partitionId.String &
																		", frozen=" & frozen.String & ", offline=" & offline.String, null);
				tx.sdsStructureState_create(name, partitionId, frozen, offline);
				
			elseif cnSDSss.frozen <> frozen or
			       cnSDSss.offline <> offline then
				// this already exists, compare the frozen & offline states and update accordingly
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " updating SDS structure entry for " & " structure=" & name & ", partitionId=" & partitionId.String &
																	", frozen=" & frozen.String & ", offline=" & offline.String &
																	", SDS item updated : " & self.getObjectStringForObject(cnSDSss), null);
				tx.sdsStructureState_update(cnSDSss, frozen, offline);
			endif;
		
		elseif cnSDSss <> null then										// SDS entry exists remove it
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " structure=" & name & ", partitionId=" & partitionId.String & 
													" SDS item deleted : " & self.getObjectStringForObject(cnSDSss), null);
			tx.sdsStructureState_delete(cnSDSss);
		endif;
	endforeach;
epilog
	delete iterDbFileStatus;
	delete iterPartitionId;
	delete iterExclude;
	delete iterFrozen;
	delete iterOffline;
	delete tx;
end;
}
cnSDSStructureState_DHandler
{
cnSDSStructureState_DHandler(pDbFile : DbFile);

vars
	cnRoot 			: CnRoot;
	
	cnSDSss			: CnSDSStructureState;
	
	errorCode		: Integer;
	
	errorText		: String;
begin
	on SystemException do self.ehGeneralExceptionHandler(exception, errorCode, errorText);
	on SystemException do self.ehBackupReorgExceptionHandler(exception);
	
	cnRoot	:= app.myCnRoot;
	cnSDSss := cnRoot.allSDSStructureState[pDbFile.name, null];
	if cnSDSss <> null then										// we found an entry in CnSDSStructureState
		if cnSDSss.frozen			and
		   not pDbFile.isFrozen		then						// CnSDSStructureState object is frozen but physical file isn't
			self.zCnSDSStructureState_Freeze(pDbFile);

		elseif pDbFile.isFrozen		and
		   not cnSDSss.frozen		then						// physical file is frozen but CnSDSStructureState object isn't
			self.zCnSDSStructureState_Thaw(pDbFile);
		endif;
		
	else
		if pDbFile.isFrozen then								// no entry found for this file in CnSDSStructureState so it should be thawed if the physical file is frozen
			self.zCnSDSStructureState_Thaw(pDbFile);
		endif;
	endif;
epilog
	if errorCode <> null then
		self.raiseJossAlert(pDbFile, errorText, errorCode);
	endif;
end;
}
cnSDSStructureState_PHandler
{
cnSDSStructureState_PHandler(pDbFile : DbFile; pDbPartition : JadeDbFilePartition);

vars
	cnRoot			: CnRoot;

	cnSDSss 		: CnSDSStructureState;
	
	errorCode		: Integer;

	errorText		: String;
begin
	on SystemException do self.ehGeneralExceptionHandler(exception, errorCode, errorText);
	on SystemException do self.ehBackupReorgExceptionHandler(exception);
	cnRoot	:= app.myCnRoot;
	cnSDSss := cnRoot.allSDSStructureState[pDbFile.name, pDbPartition.partitionID];
	if cnSDSss <> null then											// we found an entry in CnSDSStructureState
		if cnSDSss.offline				and
		   not pDbPartition.isOffline	then						// CnSDSStructureState object is offline but physical partitioned file isn't
			self.zCnSDSStructureState_Offline(pDbPartition);
			
		elseif pDbPartition.isOffline	and
		   not cnSDSss.offline			then						// physical partitioned file is offline but CnSDSStructureState object is online
			self.zCnSDSStructureState_Online(pDbPartition);
		endif;
		
		if errorText <> null then
			return;
		endif;

		if cnSDSss.frozen				and
		   not pDbPartition.isFrozen	then						// CnSDSStructureState object is frozen but physical partitioned file isn't
			self.zCnSDSStructureState_Freeze(pDbPartition);
			
		elseif pDbPartition.isFrozen	and
		   not cnSDSss.frozen			then						// physical partitioned file is frozen but CnSDSStructureState object is thawed
			self.zCnSDSStructureState_Thaw(pDbPartition);
		endif;

	else
		if pDbPartition.isOffline		then						// no entry found for this partition in CnSDSStructureState so it should be online if the physical file is offline
			self.zCnSDSStructureState_Online(pDbPartition);
		endif;
		
		if errorText <> null then
			return;
		endif;		
		
		if pDbPartition.isFrozen		then						// no entry found for this partition in CnSDSStructureState so it should be thawed if the physical file is frozen
			self.zCnSDSStructureState_Thaw(pDbPartition);
		endif;
	endif;
epilog
	if errorCode <> null then
		self.raiseJossAlert(pDbPartition, errorText, errorCode);
	endif;
end;
}
cnSDSStructureState_Sync
{
cnSDSStructureState_Sync()updating;

vars
	cndba				: CnJadeDatabaseAdmin;
	
	dbFile				: DbFile;
	
	dbFileArray			: DbFileArray;
	
	dbPartition			: JadeDbFilePartition;
	
	dbPartitionArray	: JadeDbFilePartitionArray;
begin	
	create cndba transient;
	create dbFileArray transient;
	create dbPartitionArray transient;	
	cndba.getAllDbFiles(dbFileArray);
	foreach dbFile in dbFileArray do
		if dbFile.excludeFromBackup then
			continue;
		endif;
		
		if dbFile.name = "_rpstrans" then	// added in JADE 2018																// PAR 1019
			continue;																											// PAR 1019
		endif;																													// PAR 1019
		
		if dbFile.isPartitioned then
			dbPartitionArray.clear();
			dbFile.getPartitions(dbPartitionArray, null);
			foreach dbPartition in dbPartitionArray do
				self.cnSDSStructureState_PHandler(dbFile, dbPartition);
			endforeach;
		endif;		

		self.cnSDSStructureState_DHandler(dbFile);
	endforeach;
epilog
	delete cndba;
	delete dbFileArray;
	delete dbPartitionArray;
end;
}
ehBackupReorgExceptionHandler
{
ehBackupReorgExceptionHandler(pExObj : SystemException) : Integer;

vars
	cc			: CnCntrl;
	
	errorCode	: Integer;
	
	reason		: String;
begin
	cc	:= app.myCnCntrl;
	errorCode := pExObj.errorCode;
	if errorCode <> Cn_CannotPerformInBackupState 	and
	   errorCode <> Cn_DatabaseFileLockedForReorg 	and
	   errorCode <> Cn_DatabaseLockedForReorganize 	then
		return Ex_Pass_Back;
	endif;
	
	if errorCode = Cn_CannotPerformInBackupState 		then
		reason := "database is in 'backup state' ";
		
	elseif errorCode <> Cn_DatabaseFileLockedForReorg 	then
		reason := "database file is in 'locked for reorg' ";
		
	elseif errorCode <> Cn_DatabaseLockedForReorganize 	then
		reason := "database is 'locked for reorg' ";
	endif;
	
	cc.cnWriteLog(cc.CnLogErrors, "Structure replicate operation failed while " & reason & ", starting timer to re-synch later.", null);
	self.zStructureState_StartSyncTimer();
	return Ex_Abort_Action;	
end;
}
ehGeneralExceptionHandler
{
ehGeneralExceptionHandler(pExObj : SystemException; pErrorCode : Integer output; pErrorText : String output) : Integer;

vars
	cc	: CnCntrl;
	
	sd	: CnStackDump;
begin
	cc	:= app.myCnCntrl;
	if cc <> null then																											// PAR 1089
		cc.cnWriteLog(cc.CnLogErrors, "Exception " & pExObj.errorCode.String & " (" & pExObj.text & ") encountered when processing command.", null);	// PAR 1089
		create sd transient;																									// PAR 1089
		sd.dumpCallStack(true, true);																							// PAR 1089
	endif;																														// PAR 1089
	
	pErrorCode	:= pExObj.errorCode;
	pErrorText	:= pExObj.text;																									// PAR 1089
	return Ex_Resume_Next;
end;
}
getAllSchemas
{
getAllSchemas(pSchemaSet : ObjectSet input);

vars
	subSchemas	: SchemaNDict;
	
	objArray	: ObjectArray;
	
	objSet		: ObjectSet;
	
	obj			: Object;

	scm			: Schema;
	
	count		: Integer;
	
	scmName		: String;
begin
	create subSchemas transient;
	create objArray transient;
	create objSet transient;
	scm := rootSchema;
	scm.getSubschemas(subSchemas);
	subSchemas.copy(objArray);
	subSchemas.copy(objSet);
	write scm.name & " has " & subSchemas.size().String & " subschemas";
	while count < objArray.size do
		count := count + 1;
		scm := objArray[count].Schema;
		subSchemas.clear();
		scm.getSubschemas(subSchemas);
		subSchemas.copy(objArray);
		subSchemas.copy(objSet);
		write scm.name & " has " & subSchemas.size().String & " subschemas";
	endwhile;
	
	objSet.copy(pSchemaSet);
epilog
	delete subSchemas;
	delete objArray;
	delete objSet;
end;
}
parseUserAppliedSchemaPatches
{
parseUserAppliedSchemaPatches(pSchemaPatches : String; pSchemaElementColl : CnSchemaElementDict input);
/*
	This method analyses and loads the SchemaElement object with information about which schema files
	(RootSchema, JadeSchema, JadeMonitorSchema, DumpLoadSchema, user schemas) have been loaded into the referenced
	JADE environment. 

	Version 3 	22/06/04 RWM		Handle changed format for ::getAppliedPatches in 6.0.19					
	Version 2 	24/11/03 RWM     	Allow for commas in file path
*/
constants
	COMMA 	: Character = ",";

vars
	fDate,
	fName,
	fShortName,
	fTime,
	fType,
	fVersion,
	schemaName,
	str2,
	str3,
	versionTag	: String;

	epos,
	ix,
	len,
	ptr,
	ptr2,
	spos,
	tpos		: Integer;

	se			: CnSchemaElement;

	ts			: TimeStamp;
	
	d			: Date;
	
	t			: Time;

	fTypeChar	: Character;
	
	patchLength	: Integer64;		

	cc			: CnCntrl;
	
	newFormat	: Boolean;
	
	d1			: Decimal [23];
begin
	d1 := app.relativeMachineTime();
	patchLength := pSchemaPatches.length();
	cc	:= app.myCnCntrl;
//	cc.cnWriteLog(cc.CnLogDiag, pSchemaPatches, null);

	if pSchemaPatches = null then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " no patches applied", null);
		return;
	endif;
	
	ix	:= 1;
	len	:= pSchemaPatches.length;
	while ix < len do
		spos	:= ix;
		ix		:= pSchemaPatches.pos(CrLf, spos);
		if ix = null then
			break;
		endif;
		
		str2		:= pSchemaPatches[spos : ix + 2 - spos];
		ptr			:= 1;
		ptr			:= str2.pos("Patches:", ptr);
		if ptr > null then
			ptr			:= 1;
			schemaName	:= str2.scanUntil(" ", ptr); 
			ix := ix + 2;
			continue;
		endif;
		
		newFormat	:= false;
		ptr			:= 1;									// pointer
		fType		:= str2.scanUntil(COMMA, ptr).toLower;
		ptr			:= ptr + 1;
		epos		:= str2.reversePos(COMMA);				// scan backwards to find start of timestamp (possibly)
		
		str3		:= str2[epos + 1 : end];
		tpos		:= str3.pos(".", 1);
		if tpos > null then									// we have a hot fix package id at the end of the string (6.0.19 +)
			versionTag	:= str3;
			tpos		:= epos - 1;
			epos		:= str2.reversePosIndex(COMMA, tpos); // reverse to prior comma, which should be just before date
			newFormat	:= true;
			
		else
			versionTag	:= null;
		endif;		

		ptr2		:= epos + 1;							// point to start of date						
		epos		:= epos - 1;							// point to end of version
		fDate		:= str2.scanUntil(" ", ptr2);
		ptr2		:= ptr2 + 1;
		
		if newFormat then
			fTime	:= str2.scanUntil(COMMA, ptr2);
		else
			fTime	:= str2.scanUntil(CrLf, ptr2);
		endif;
		
		epos		:= str2.reversePosIndex(COMMA, epos);	// find comma 
		ptr2		:= epos + 1;
		fVersion	:= str2.scanUntil(COMMA, ptr2);			// not used by JSM in this version
		fName		:= str2[ptr : epos - ptr];				// full file path name
		
		if fType = "schema" then
			fTypeChar	:= "S";
		elseif fType = "ddb" then
			fTypeChar	:= "D";
		else
			fTypeChar	:= "U";			// unknown
		endif;
		
		fName.replaceChar("\", "/");	
		ptr			:= fName.reversePos("/");
		if ptr > null then
			fShortName	:= fName[ptr + 1 : end];
			
		else
			fShortName	:= fName;
		endif;
		
		d	:= fDate.Date;			// CCYY/MM/DD format
		t	:= fTime.Time;
		ts.setDate(d);
		ts.setTime(t);
		
		create se transient;
		se.loadSelf(schemaName, fShortName, versionTag, fTypeChar, ts);
		pSchemaElementColl.add(se);
		ix	:= ix + 2;
	endwhile;
epilog
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " patch string length = " & patchLength.userNumberFormat($CnWholeNumbers) & 
														", schema elements derived = " & pSchemaElementColl.size().userNumberFormat($CnWholeNumbers) & 
														" (" & d1.cnGetElapsedTimeString() & ")", null);
end;
}
raiseJossAlert
{
raiseJossAlert(	pObject 	: Object;
				pErrorText 	: String;
				pErrorCode	: Integer);
vars
 	kc 		: CnKarmaCntrl;
 	
	cc		: CnCntrl;
	
	dbFile	: DbFile;
	
	dbPart	: JadeDbFilePartition;
	
	name	: String;
begin
	kc := app.myCnKarmaCntrl;
	cc := app.myCnCntrl;
	if pObject.isKindOf(DbFile) then
		dbFile := pObject.DbFile;
		name := dbFile.getName();
		
	else
		dbPart := pObject.JadeDbFilePartition;
		name := dbPart.dbFile.getName() & "." & dbPart.getName();
	endif;
	
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : An exception (" & pErrorCode.String & " : " & pErrorText & ") occurred trying to replicate structure state for " & name &
								", raising regular JOSS alert now.", null);
	app.cnRaiseJossAlert(Cn_Karma_Alert
						,"SDS Secondary structure state replication problem for environment " & kc.environmentId
						,"A problem occurred attempting to replicate the state of structure '" & name & "'" & CrLf & pErrorCode.String & " : " & pErrorText
						,"N"
						,app.actualTime
						,cc.appName
						,kc.managedEnvironmentName
						,app.cnComputerNameAppServer
						,null
						,null);
end;
}
zCnSDSStructureState_Freeze
{
zCnSDSStructureState_Freeze(pObject : Object) protected;

vars
	cc				: CnCntrl;
	
	dbFile			: DbFile;
	
	dbPartition		: JadeDbFilePartition;
	
	structureName	: String;
begin
	cc := app.myCnCntrl;
	if pObject.isKindOf(DbFile) then
		dbFile := pObject.DbFile;
		structureName := dbFile.getName();
		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : freezing " & structureName, null);
		dbFile.freeze();
		
	else
		dbPartition := pObject.JadeDbFilePartition;
		structureName := dbPartition.dbFile.getName() & "." & dbPartition.getName();
		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : freezing " & structureName, null);
		dbPartition.freeze();
	endif;
	
	cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " structure " & structureName & " now frozen", null);
end;
}
zCnSDSStructureState_Offline
{
zCnSDSStructureState_Offline(pDbPartition : JadeDbFilePartition) protected;

vars
	cc				: CnCntrl;
	
	dbPartition 	: JadeDbFilePartition;
	
	structureName	: String;
begin
	cc := app.myCnCntrl;
	dbPartition := pDbPartition;
	structureName := dbPartition.dbFile.getName() & "." & dbPartition.getName();
	cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : taking " & structureName & " offline...", null);
	dbPartition.markOffline();
	cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : " & structureName & " is offline", null);
end;
}
zCnSDSStructureState_Online
{
zCnSDSStructureState_Online(pDbPartition : JadeDbFilePartition) protected;

vars
	cc				: CnCntrl;
	
	dbPartition 	: JadeDbFilePartition;
	
	structureName	: String;
begin
	cc := app.myCnCntrl;
	dbPartition := pDbPartition;
	structureName := dbPartition.dbFile.getName() & "." & dbPartition.getName();
	cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : bringing " & structureName & " online...", null);
	dbPartition.markOnline();
	cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : " & structureName & " is online", null);
end;
}
zCnSDSStructureState_Thaw
{
zCnSDSStructureState_Thaw(pObject : Object) protected;

vars
	cc				: CnCntrl;
	
	dbFile			: DbFile;
	
	dbPartition		: JadeDbFilePartition;
	
	structureName	: String;
begin
	cc := app.myCnCntrl;
	if pObject.isKindOf(DbFile) then
		dbFile := pObject.DbFile;
		structureName := dbFile.getName();
		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : thawing " & structureName, null);
		dbFile.thaw();
		
	else
		dbPartition := pObject.JadeDbFilePartition;
		structureName := dbPartition.dbFile.getName() & "." & dbPartition.getName();
		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : thawing " & structureName, null);
		dbPartition.thaw();
	endif;
	
	cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : " & structureName & " now thawed", null);
end;
}
zStructureState_StartSyncTimer
{
zStructureState_StartSyncTimer() protected;

vars
	cc				: CnCntrl;
	
	option,
	timeRemaining	: Integer;
begin
	cc := app.myCnCntrl;
	if self.getTimerStatus(Cn_SDSStructure_Sync_Request, option, timeRemaining) then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " Cn_SDSStructure_Sync_Request (" & Cn_SDSStructure_Sync_Request.String & ") timer is already running, time remaining " & timeRemaining.userNumberFormat($CnWholeNumbers) & "ms", null);
	
	else
		// timer is started as a one-shot as the sync will either work or incur another
		// exception which will restart the timer if a backup or compact error.
		// Note that the timer is started on the CnSDSDatabaseAdmin transient as this remains
		// for the whole session.
		app.myCnSDSDbAdmin.beginTimer(30000, Timer_OneShot, Cn_SDSStructure_Sync_Request);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " started Cn_SDSStructure_Sync_Request timer (" & Cn_SDSStructure_Sync_Request.String & ")", null);
	endif;
end;
}
	)
	CnIniFileAgent (
	jadeMethodSources
getSSLDetails
{
getSSLDetails(pRpcEncryptionEnabled,
				pSSLCertFileResident,
				pSSLCertAuthFileResident	: Boolean output;
				pSSLSecurePort,
				pSSLCertFileName,
				pSSLCertFileSubject,
				pSSLCertAuthFileName,
				pSSLCertAuthFileSubject,
				pSSLMethodName				: String output;
				pSSLCertFileExpiry,
				pSSLCertAuthFileExpiry		: Date output;
				pSSLCiphers					: StringArray input);

vars
	cc						: CnCntrl;
	
	csm						: CnSecurityManager;
	
	file					: File;
	
	certAuthFilePaths,
	sslCiphers				: StringArray;
	
	certAuthFilePath,
	certAuthFilePathsStr,
	sslCipherStr			: String;
begin
	cc	:= app.myCnCntrl;
	
	// all accesses to inifile are to the AppServer ini file and automatically
	// returns the named section info (if defined) or the default section info
	pRpcEncryptionEnabled 	:= app.getProfileStringAppServer(self.iniFileName, CN_JADEAPPSERVER, CN_RPCENCRYPTIONENABLED, false.String).Boolean;
	pSSLSecurePort		 	:= app.getProfileStringAppServer(self.iniFileName, CN_JADEAPPSERVER, CN_SSL_SECURE_PORT, null);
	pSSLMethodName		 	:= app.getProfileStringAppServer(self.iniFileName, CN_JADEAPPSERVER, CN_SSL_METHODNAME, null);
	pSSLCertFileName		:= app.getProfileStringAppServer(self.iniFileName, CN_JADEAPPSERVER, CN_SSL_CERTIFICATEFILE, null);
	pSSLCertAuthFileName	:= app.getProfileStringAppServer(self.iniFileName, CN_JADEAPPSERVER, CN_SSL_CERTIFICATEAUTHFILE, null);
	sslCipherStr		 	:= app.getProfileStringAppServer(self.iniFileName, CN_JADEAPPSERVER, CN_SSL_CIPHERNAMES, null);

	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " [" & CN_JADEAPPSERVER & "] " & CN_RPCENCRYPTIONENABLED & "=" & pRpcEncryptionEnabled.String, null);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " [" & CN_JADEAPPSERVER & "] " & CN_SSL_SECURE_PORT & "=" & pSSLSecurePort, null);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " [" & CN_JADEAPPSERVER & "] " & CN_SSL_METHODNAME & "=" & pSSLMethodName, null);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " [" & CN_JADEAPPSERVER & "] " & CN_SSL_CERTIFICATEFILE & "=" & pSSLCertFileName, null);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " [" & CN_JADEAPPSERVER & "] " & CN_SSL_CERTIFICATEAUTHFILE & "=" & pSSLCertAuthFileName, null);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " [" & CN_JADEAPPSERVER & "] " & CN_SSL_CIPHERNAMES & "=" & sslCipherStr, null);
	
	create sslCiphers transient;
	if sslCipherStr <> null then
		sslCiphers.cnGetTokens(sslCipherStr, CN_COLON, false);
	endif;
	
	sslCiphers.copy(pSSLCiphers);
	
	pSSLCertFileExpiry := null;
	pSSLCertAuthFileExpiry := null;
	create file transient;
	file.usePresentationFileSystem := false;
	if pSSLCertFileName <> null then
		pSSLCertFileName.replaceChar(CN_BACK_SLASH, CN_SLASH);
		file.fileName := pSSLCertFileName;
		pSSLCertFileResident := file.isAvailable();
	endif;

	if pSSLCertAuthFileName <> null then
		pSSLCertAuthFileName.replaceChar(CN_BACK_SLASH, CN_SLASH);
		file.fileName := pSSLCertAuthFileName;
		pSSLCertAuthFileResident := file.isAvailable();
	endif;

	if app.cnOSPlatformIsWindows() then
		create csm transient;
		if pSSLCertFileResident then
			csm.getCertificateDetails(pSSLCertFileName, pSSLCertFileSubject, pSSLCertFileExpiry);
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " certFileSubject=" & pSSLCertFileSubject & ", certFileExpiry=" & pSSLCertFileExpiry.String, null);
		endif;

		if pSSLCertAuthFileName <> null then
			if pSSLCertAuthFileName[2:2] <> ":/" then 		// must be a relative name, need to check auth file paths
				certAuthFilePathsStr	 := app.getProfileString(self.iniFileName, CN_JADEAPPSERVER, CN_SSL_CERTIFICATEAUTHPATHS, null);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " [" & CN_JADEAPPSERVER & "] " & CN_SSL_CERTIFICATEAUTHPATHS & "=" & certAuthFilePathsStr, null);
				if certAuthFilePathsStr = null then
					pSSLCertAuthFileResident := false;
				
				else
					if pSSLCertAuthFileName[1] = CN_SLASH then
						pSSLCertAuthFileName := pSSLCertAuthFileName[2:end];		// drop leading slash
					endif;
					
					certAuthFilePathsStr.replaceChar(CN_BACK_SLASH, CN_SLASH);
					create certAuthFilePaths transient;
					certAuthFilePaths.cnGetTokens(certAuthFilePathsStr, CN_SEMICOLON, false);
					foreach certAuthFilePath in certAuthFilePaths do
						if certAuthFilePath[certAuthFilePath.length()] <> CN_SLASH then
							certAuthFilePath := certAuthFilePath & CN_SLASH;
						endif;
						
						file.fileName := certAuthFilePath & pSSLCertAuthFileName;
						if file.isAvailable() then
							pSSLCertAuthFileName := file.fileName;
							pSSLCertAuthFileResident := true;
							break;
						endif;
					endforeach;
				endif;
			
			else
				file.fileName := pSSLCertAuthFileName;
				if file.isAvailable() then
					pSSLCertAuthFileResident := true;
				endif;
			endif;
			
			if pSSLCertAuthFileResident then
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " certAuthFileName=" & pSSLCertAuthFileName, null);
				csm.getCertificateDetails(pSSLCertAuthFileName, pSSLCertAuthFileSubject, pSSLCertAuthFileExpiry);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " certAuthFileSubject=" & pSSLCertFileSubject & ", certAuthFileExpiry=" & pSSLCertFileExpiry.String, null);
			
			else
				pSSLCertAuthFileName 	:= null;
				pSSLCertAuthFileSubject := null;
				pSSLCertAuthFileExpiry 	:= null;
			endif;
		endif;
	endif;
epilog
	delete file;
	delete csm;
	delete sslCiphers;
	delete certAuthFilePaths;
end;
}
	)
	CnProfilingAgent (
	jadeMethodSources
fileMethodProfileDetails
{
fileMethodProfileDetails();

vars
	file		: File;
	
	child,
	jdo			: JadeDynamicObject;
	
	mth			: Method;
	
	scm			: Schema;
	
	truncated	: Boolean;
	
	calls,
	clockTime	: Integer64;
	
	mthName,
	mthType		: String;
	
	ts			: TimeStamp;
begin
	create file transient;
	file.fileName := "c:\temp\Method_Profile_" & ts.date.cnUserFormat($CnCCYYMMDD_ns) & "_" & ts.time.cnUserFormat($CnHHMMSS_ns) & ".csv";
	file.mode := file.Mode_Output;
	file.open();
	file.writeLine("Method Type" & CN_COMMA &
					"Method Name" & CN_COMMA &
					"Calls" & CN_COMMA &
					"Clocktime");
	create jdo transient;
	process.getMethodProfileInfo(jdo, truncated);
	foreach child in jdo.children do
		mth := child.getPropertyValue("method").Method;
		scm := mth.getSchema();
		mthName := scm.name & "::" & mth.qualifiedName();
		calls := child.getPropertyValue("calls").Integer64;
		clockTime := child.getPropertyValue("clockTimeInMethod").Integer64;
		if mth.isKindOf(ExternalMethod) then
			mthType := "EXTERNAL";
		elseif mth.isKindOf(JadeMethod) then
			mthType := "JADE";
		else
			mthType := "OTHER";
		endif;
		
		file.writeLine(mthType & CN_COMMA &
						mthName & CN_COMMA &
						calls.String & CN_COMMA & 
						clockTime.String);
	endforeach;

	file.close();
	process.removeMethodProfileInfo();
epilog
	delete file;
	if jdo <> null then
		jdo.children.purge();
		delete jdo;
	endif;
end;
}
logMethodProfileDetails
{
logMethodProfileDetails();

vars
	cc			: CnCntrl;
	
	child,
	jdo			: JadeDynamicObject;
	
	mth			: Method;
	
	scm			: Schema;
	
	truncated	: Boolean;
	
	calls,
	clockTime	: Integer64;
	
	mthName,
	mthType		: String;
begin
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & "------------------------- Method Profile Details -------------------------------------", null);
	create jdo transient;
	process.getMethodProfileInfo(jdo, truncated);
	foreach child in jdo.children do
		mth := child.getPropertyValue("method").Method;
		scm := mth.getSchema();
		mthName := scm.name & "::" & mth.qualifiedName();
		calls := child.getPropertyValue("calls").Integer64;
		clockTime := child.getPropertyValue("clockTimeInMethod").Integer64;
		if mth.isKindOf(ExternalMethod) then
			mthType := "EXTERNAL METHOD";
		elseif mth.isKindOf(JadeMethod) then
			mthType := "JADE METHOD";
		else
			mthType := "OTHER METHOD";
		endif;
		
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & mthType.padBlanks(18) & 
																mthName.padBlanks(60) & 
																("Calls=" & calls.userNumberFormat($CnWholeNumbers)).padBlanks(15) & 
																"ClockTime=" & clockTime.String, null);
	endforeach;
	
	process.removeMethodProfileInfo();
epilog
	if jdo <> null then
		jdo.children.purge();
		delete jdo;
	endif;
end;
}
	)
	CnTransactionAgent (
	jadeMethodSources
sdsCauseEventCommon
{
sdsCauseEventCommon(pName : String);

vars
	
begin
	if system.getDatabaseRole() = SDS_RolePrimary then
		beginTransaction;
		system.sdsCauseEvent(Cn_SDS_PreTakeOver_Request, false, null);	// send an acknowledgement request to all Secondaries
		commitTransaction;
		return;
	endif;
	
	system.sdsCauseEvent(Cn_SDS_PreTakeOver_Response, true, pName);		// send an acknowledgement back to Primary
end;
}
sdsStructureState_create
{
sdsStructureState_create(	pName			: String;
							pPartitionId	: Integer64;
							pFrozen,
							pOffline		: Boolean) updating;

vars
	cnRoot	: CnRoot;

	cnSDSss : CnSDSStructureState;
begin
	cnRoot	:= app.myCnRoot;
	exclusiveLock(cnRoot.allSDSStructureState);
	beginTransaction;
	create cnSDSss;
	cnSDSss.setName(pName);
	cnSDSss.setPartitionId(pPartitionId);
	cnSDSss.setFrozen(pFrozen);
	cnSDSss.setOffline(pOffline);
	cnSDSss.setMyCnRoot(cnRoot);
	commitTransaction;
end;
}
sdsStructureState_delete
{
sdsStructureState_delete(pCnSDSStructureState : CnSDSStructureState);

vars
	cnSDSss	: CnSDSStructureState;
begin
	exclusiveLock(app.myCnRoot.allSDSStructureState);
	cnSDSss := pCnSDSStructureState;
	beginTransaction;
	delete cnSDSss;
	commitTransaction;
end;
}
sdsStructureState_update
{
sdsStructureState_update(	pCnSDSStructureState 	: CnSDSStructureState;
							pFrozen,
							pOffline				: Boolean) updating;

vars
	cnSDSss	: CnSDSStructureState;
begin
	cnSDSss := pCnSDSStructureState;
	if pFrozen <> cnSDSss.frozen or
	   pOffline <> cnSDSss.offline then
	   	exclusiveLock(app.myCnRoot.allSDSStructureState);
		beginTransaction;
		cnSDSss.setFrozen(pFrozen);
		cnSDSss.setOffline(pOffline);
		commitTransaction;
	endif;
end;
}
	)
	CnValidateMethodAgent (
	jadeMethodSources
handleAnyException
{
handleAnyException(exObj : Exception) : Integer;

vars
	cc : CnCntrl;
begin
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " incurred exception " & exObj.errorCode.String & " (" & exObj.text & ")", null);
	beginTransientTransaction;
	parameters.add("result=" & exObj.errorCode.String);
	commitTransientTransaction;
	
	return Ex_Abort_Action;
end;
}
run
{
run();

vars
	cc 		: CnCntrl;
	
	cnu		: CnUtility;
begin
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " ....", null);
	on Exception do self.handleAnyException(exception);
	create cnu transient;
	cnu.validateMethods();
	
	// if we get to here then completed with no errors
	beginTransientTransaction;
	self.parameters.add("result=0");
	commitTransientTransaction;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " result=0", null);
epilog	
	delete cnu;
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;

vars
	cc : CnCntrl;
begin
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " ....", null);
	self.run();
epilog
	delete self;
	app.cnTerminate();
end;
}
	)
	CnBackup (
	jadeMethodSources
backupDirInclusions
{
backupDirInclusions():String updating, serverExecution;

vars
	cc				: CnCntrl;

	cnDba			: CnDatabaseAdmin;
	
	d1,
	d2				: Decimal[23];
		
	ff,
	ff2				: FileFolder;
	
	fn				: FileNode;

	file			: File;
	
	int				: Integer;

	str,
	inclusion,
	errorText,
	backup_Dir,
	iniFileName,	
	include_Dir,
	include_SubDir	: String;
	
	fileNameArray	: CnStringArray;
	
	fileSizeArray	: Integer64Array;
	
	notify			: Boolean;
begin
	cc 		:= app.myCnCntrl;
	cnDba	:= app.myCnDba;
	notify	:= not cnDba.disableBackupNotify;

	app.cnManagerLog("Scanning for user specified inclusions:");
	create fileNameArray transient;
	create fileSizeArray transient;
	
	self.includeDirArray.clear();
	iniFileName	:= app.getIniFileNameAppServer();
	foreach int in 1 to 999 do
		include_Dir := app.getProfileStringAppServer(iniFileName, CN_KCDATABASEBACKUP, "IncludeDir" & int.String, null);
		if include_Dir = null then
			break;
		endif;
		include_Dir.replaceChar("\","/");
		self.includeDirArray.add(include_Dir);	
		app.cnManagerLog("Marked include dir '" & include_Dir & "' for backup");
	endforeach;
	
	self.includeSubDirArray.clear();
	foreach int in 1 to 999 do
		include_SubDir := app.getProfileStringAppServer(iniFileName, CN_KCDATABASEBACKUP, "IncludeSubDir" & int.String, null);
		if include_SubDir = null then
			break;
		endif;
		include_SubDir.replaceChar("\","/");
		self.includeSubDirArray.add(include_SubDir);
		app.cnManagerLog("Marked include dir '" & include_SubDir & "' (plus sub dirs) for backup");
	endforeach;
	
	create ff	transient;
	create ff2	transient;
	create file transient;

	// INCLUDE FILES ONLY FROM THE INCLUDE DIR ARRAY		
	foreach inclusion in self.includeDirArray do
		if app.cnOSPlatformIsWindows then
			backup_Dir := self.backupDirectory & "/_drive_" & inclusion[1:1] & "/" & inclusion[4 : end];
			
		else
			backup_Dir := self.backupDirectory & "/_includedir_";
			if inclusion[1 : 1] <> "/" then
				backup_Dir := backup_Dir & "/";
			endif;
			
			backup_Dir := backup_Dir & inclusion;
		endif;
	
		ff.fileName := backup_Dir;
		if not ff.isAvailable() then
			ff.make();
		endif;
		
		str := "Backing up files in inclusion '" & inclusion & "'...";
		if notify then // only send notifications if 'DisableBackupNotifications=false' in the environments .ini file
			cnDba.buildUserInfoNonManagedBackup(fileNameArray, fileSizeArray, Cn_Backup_Inclusions, str); // raise notification to user application	
		endif;
		app.cnManagerLog(str);
		ff2.fileName := inclusion;
		foreach fn in ff2.files do
			if fn.isKindOf(FileFolder) then				// we are only interested in files within this single directory node
				continue;
			endif;
			file.fileName := inclusion & "/" & fn.name;	
			if notify then								// only send notifications if 'DisableBackupNotifications=false' in the environments .ini file
				fileNameArray.add(file.fileName);
				fileSizeArray.add(file.cnGetFileLength64());
				d2 := app.relativeMachineTime();
				if fileNameArray.size() > 500 	or			
				  (d2 - d1) > 1000				then	// don't raise an event on every single file as this could be expensive, update periodically
					cnDba.buildUserInfoNonManagedBackup(fileNameArray, fileSizeArray, Cn_Backup_NonDbFile_Start, "Backing up file... ");
					fileNameArray.clear();
					fileSizeArray.clear();
					d1 := d2;
				endif;
			endif;
			
			app.cnManagerLog("Backing up file " & file.fileName & " as " & backup_Dir & "/" & fn.name);
			file.cnCopyFile(backup_Dir & "/" & fn.name, false, errorText);
			if errorText <> null then					// return error, pResult will contain the error string for reporting in the calling method
				return errorText;
			endif;
		endforeach;
		
		if notify then									// only send notifications if 'DisableBackupNotifications=false' in the environments .ini file
			cnDba.buildUserInfoNonManagedBackup(fileNameArray, fileSizeArray, Cn_Backup_NonDbFile_Start, "Backing up file... "); // send any queued copy notifications before proceeding to the next inclusion
			fileNameArray.clear();
			fileSizeArray.clear();
		endif;
	endforeach;
	
	// INCLUDE FILES AND DIRECTORIES FROM THE INCLUDE SUB DIR ARRAY	
	foreach inclusion in self.includeSubDirArray do
		if app.cnOSPlatformIsWindows then
			backup_Dir := self.backupDirectory & "/_drive_" & inclusion[1:1] & inclusion[3 : end];
		else
			backup_Dir := self.backupDirectory & "/_includedir_";
			if inclusion[1 : 1] <> "/" then
				backup_Dir := backup_Dir & "/";
			endif;
			backup_Dir := backup_Dir & inclusion;
		endif;
		
		str := "Backing up files and sub directories in inclusion '" & inclusion & "'...";
		if notify then									// only send notifications if 'DisableBackupNotifications=false' in the environments .ini file
			cnDba.buildUserInfoNonManagedBackup(fileNameArray, fileSizeArray, Cn_Backup_Inclusions, str); // raise notification to user application
		endif;
		
		app.cnManagerLog(str);
		ff2.fileName := inclusion;
		self.copyFilesFromDirectory(ff2, backup_Dir, true, true, true, errorText);
		if errorText <> null then		// cause an error event
			return errorText;	
		endif;
	endforeach;
	
	return CN_OK; // no errors
epilog
	delete fileNameArray;
	delete fileSizeArray;
	delete ff;
	delete ff2;
	delete file;
end;
}
copyFilesFromDirectory
{
copyFilesFromDirectory(pFileFolder					: FileFolder;
					   pDestDir 					: String;
					   pCreateDirectoryIfNotFound,
					   pIncludeSubDirectories,
					   pVerifyIntegrity 			: Boolean;
					   pErrText						: String output):Boolean updating;
/*
	NOTE		:	This is a localised copy of the cnCopyFilesFromDirectory method located on CardSchemas FileFolder class. The reason
					we have created a local copy is to provide file copy events to user applications that have subscribed to the
					non-managed backup multi-worker process.

	Purpose		:	Copy all files from a the directory specified by this file folder. 
					Optionally allow copy of all subdirectories.
					Optionally allow validation of each file written by doing an MD5 hash over the input file and checking it against
					that derived from the file just copied.
					
	Parameters	:	self.fileName				-	expected to be the name of the file folder that is the starting point for the copy
	
					pDestDir					-	the destination directory into which copy is to be done
					
					pCreateDirectoryIfNotFound	-	true	- if destination directory doesn't exist, create it
													false	- if destination directory doesn't exist, then error
													
					pIncludeSubDirectories		-	true	- execute same actions for all sub-directories
													false	- don't apply action to sub-directories

					pVerifyIntegrity			-	true	- any files copied are subjected to MD5 hash check to verify integrity of copy process
													false	- no checks done on output file
													
					pErrText					-	if result is false, this contains the error message that caused the failure

	Result			true	- copy was successful
					false	- copy failed, pErrText contains failure reason					
*/
vars
	kc : CnKarmaCntrl;
begin
	kc := app.myCnKarmaCntrl;
	on FileException do kc.fileExceptionHandler(exception);
    kc.setHadFileException(false);
    kc.setFileRetryNo(0);

	if not self.zCopyFilesFromDirectory(pFileFolder, pDestDir, pCreateDirectoryIfNotFound, pIncludeSubDirectories, pVerifyIntegrity, pErrText) then
		return false;
	endif;
	
	if kc.hadFileException then
		pErrText := "Exception occurred during copy : " & kc.exceptionFileName & ", exception=" & kc.exceptionErrorCode.String & " (" & kc.exceptionText & ")";
		return false;
	endif;

	return true;
end;
}
interpretBackupInfo
{
interpretBackupInfo(	pEventType			: Integer;
						pBackupInfo 		: Binary;
						pAdviceType			: String			output;
						pTimeStamp			: TimeStamp 		output;
						pCurrentFileName	: String 			output;
						pFileSize,
						pTotalSize			: Integer64			output;
						pPercentProgress	: Integer			output;
						pErrorText			: String			output;
						pStartLogNo,
						pEndLogNo,
						pBackupWorkerId		: Integer			output;
						pPhase				: Character			output;
						pNonDbFileNameArray : CnStringArray 	input;
						pNonDbFileSizeArray	: Integer64Array 	input;
						pStatusTag			: Integer			output;
						pStatusText			: String			output) updating;
vars
	cnMsg			: CnMessage;
	
	mapFiles,
	droppedFiles	: CnStringArray;

	fileName,
	mapFileName		: String;

	mapSizes		: CnDecimalArray;

	nsi				: CnNameSizeInfo;
	
	nsiArray		: CnNameSizeInfoArray;
	
    nsiDict     	: CnNameSizeInfoBySizeDict;	

	len,
	indx,
	endPos,
	numFiles		: Integer;

	fileSize		: Integer64;	
	
	fileNameArray	: CnStringArray;
begin
	create cnMsg transient;
	cnMsg.setPos(1);
	cnMsg.setArchitectureRemote(app.cnOSArchitecture);																			// PAR 696
	if pEventType = Cn_Backup_Progress_Update then
		create mapFiles 	transient;
		create mapSizes		transient;
		create droppedFiles transient;
		
		pAdviceType				:= cnMsg.getField(pBackupInfo, 8).ansiToString.trimRight;
		pTimeStamp				:= cnMsg.byteOrderTimeStamp(cnMsg.getField(pBackupInfo, 8));
		len						:= cnMsg.byteOrderInteger(cnMsg.getField(pBackupInfo, 4));
	
		if len > null then
			pCurrentFileName	:= cnMsg.getField(pBackupInfo, len).ansiToString;
		endif;
	
		pPercentProgress		:= cnMsg.byteOrderInteger(cnMsg.getField(pBackupInfo, 4));
		pFileSize				:= cnMsg.byteOrderInteger64(cnMsg.getField(pBackupInfo, 8));			// note: this really a place holder in the binary, it's never actually setup, futher down we obtain the real filesize
		len						:= cnMsg.byteOrderInteger(cnMsg.getField(pBackupInfo, 4));
		if len > null then
			pErrorText			:= cnMsg.getField(pBackupInfo, len).ansiToString;
		endif;
		
		numFiles				:= cnMsg.byteOrderInteger(cnMsg.getField(pBackupInfo, 4));				// number of structure names
		foreach indx in 1 to numFiles do
			len := cnMsg.byteOrderInteger(cnMsg.getField(pBackupInfo, 4));
			if len > null then
				mapFiles.add(cnMsg.getField(pBackupInfo, len).ansiToString);						// add each mapfile
			endif;
		endforeach;
	
		// next block is mapsizes
		foreach indx in 1 to numFiles do
			mapSizes.add(cnMsg.byteOrderInteger64(cnMsg.getField(pBackupInfo, 8)));						// add each mapfile size
		endforeach;
	
		// next block is dropped mapfiles
		numFiles				:= cnMsg.byteOrderInteger(cnMsg.getField(pBackupInfo, 4));				// number of dropped files
		foreach indx in 1 to numFiles do
			len := cnMsg.byteOrderInteger(cnMsg.getField(pBackupInfo, 4));
			if len > null then
				droppedFiles.add(cnMsg.getField(pBackupInfo, len).ansiToString);						// each dropped mapfile
			endif;
		endforeach;
		
		pEndLogNo				:= cnMsg.byteOrderInteger(cnMsg.getField(pBackupInfo, 4));
		pStartLogNo				:= cnMsg.byteOrderInteger(cnMsg.getField(pBackupInfo, 4));
		pBackupWorkerId			:= cnMsg.byteOrderInteger(cnMsg.getField(pBackupInfo, 4));
		pPhase					:= cnMsg.getField(pBackupInfo, 1).Character;
		
		if pAdviceType = cnMsg.Advice_Type_Backup_Starting then								// only update the arrays on self when the advice type is BKST, this is the only time the information is available
			create nsiArray transient;														// CnNameSizeInfo is used in order to format the mapFileSizes in descending size order
			indx := 0;
			foreach mapFileName in mapFiles do
				indx := indx + 1;
				create nsi transient;
				nsi.loadSelf(mapFileName, mapSizes[indx]);
				nsiArray.add(nsi);
			endforeach;
	
			self.mapFileNames.clear();														// these arrays are cleared in case the user utilises the same CnBackup transient
			self.mapFileSizes.clear();
			self.droppedFileNames.clear();
			self.numberOfWorkers.clear();
			self.totalSize := null;															// initialize
			create nsiDict transient;
			nsiArray.copy(nsiDict);
	
			foreach nsi in nsiDict do
				self.mapFileNames.add(nsi.name);											// these arrays will now be available for the duration of the transient CnBackup class 
				self.mapFileSizes.add(nsi.size);
				self.totalSize := self.totalSize + nsi.size.Integer64;
			endforeach;
			droppedFiles.copy(self.droppedFileNames);
		endif;
		
		pTotalSize := self.totalSize;
		indx := self.mapFileNames.indexOf(pCurrentFileName);								// obtain the filesize for the current map file
		if indx > null then
			pFileSize := self.mapFileSizes[indx].Integer64;
		endif;
		
		if self.numberOfWorkers.includes(pBackupWorkerId) then
			return;
		endif;
		
		if pBackupWorkerId <> null then														// it's possible during the 1st few notifications that backupWorkerId = null
			self.numberOfWorkers.add(pBackupWorkerId);
		endif;
		
		return;
	endif;

	if pEventType = Cn_Backup_Status_Change then
		create fileNameArray transient;
	
		pTimeStamp		:= cnMsg.byteOrderTimeStamp(cnMsg.getField(pBackupInfo, 8));
		endPos			:= cnMsg.byteOrderInteger(cnMsg.getField(pBackupInfo, 4)) + cnMsg.pos;
		fileNameArray	:= cnMsg.getField(pBackupInfo, endPos-cnMsg.pos).ansiToString.cnGetTokens("|");
		foreach fileName in fileNameArray do
			pNonDbFileNameArray.add(fileName);
		endforeach;
		
		endPos			:= cnMsg.byteOrderInteger(cnMsg.getField(pBackupInfo, 4)) + cnMsg.pos;
		while cnMsg.pos < endPos do
			fileSize	:= cnMsg.byteOrderInteger64(cnMsg.getField(pBackupInfo, 8));
			pNonDbFileSizeArray.add(fileSize);
			self.totalSize := self.totalSize + fileSize;
		endwhile;

		pTotalSize 		:= self.totalSize;
		pStatusTag		:= cnMsg.byteOrderInteger(cnMsg.getField(pBackupInfo, 4));		
		len				:= cnMsg.byteOrderInteger(cnMsg.getField(pBackupInfo, 4));
		if len > null then
			pStatusText	:= cnMsg.getField(pBackupInfo, len).ansiToString;
		endif;
	endif;
	
epilog
	delete cnMsg;
	delete mapFiles;
	delete mapSizes;
	delete droppedFiles;
	delete nsiDict;
	delete fileNameArray;
	if nsiArray <> null then
		nsiArray.purge();
		delete nsiArray;
	endif;
end;
}
removeDirectory
{
removeDirectory(pBackupDir : String) : String updating;
/*
	Purpose		:	Remove the directory specified.
					Remove will be attempted up to 4 times before failure returned.
					NOTE: The directory specified by self.fileName is expected to be in standard form.
	
	Parameters	:	Backup folder to remove
	
	Result		:	OK			- directory was successfully removed
					<error msg>	- error while trying to remove directory	
*/
vars
	cc			: CnCntrl;

	kc			: CnKarmaCntrl;
	
	ff			: FileFolder;

	result,
	backupDir	: String;
	
	char		: Character;
	
	len			: Integer;
	
	cem			: CnExternalMethods;
begin
	cc 			:= app.myCnCntrl;
	kc 			:= app.myCnKarmaCntrl;
	backupDir 	:= pBackupDir;
	if app.cnOSPlatformIsWindows() then
		backupDir.replaceChar("/", "\");
	else
		backupDir.replaceChar("\", "/");
	endif;

	len := backupDir.length();		// remove any trailing slash of the backupDir path
	char := backupDir[len];			// this is required for parsing backupDir into the resetReadOnly flags external method
	if char = "/" or 
	   char = "\" then
		backupDir := backupDir[1 : len-1];
	endif;

	create ff transient;
	ff.fileName := backupDir;
	if not ff.isAvailable() then
		return CN_OK;
	endif;
	
	create cem transient;
	cem.emResetReadOnly(backupDir);	
	return self.zRemoveDirectory(ff);
epilog
	delete ff;
	delete cem;
	process.sleep(500);				// Allow NTFS to be updated after deleting everything.
									// otherwise if we try to use the directory to soon we can
									// get errors. ie in renameDirectory returned Access is denied.
end;
}
removeFile
{
removeFile(pFile : File) : String;
/*
	Purpose		: purges file from disk. 
				  Allows for up to 4 attempts before failing.
				  If successful, OK is return otherwise failure reason is returned.
*/

vars
	kc 			: CnKarmaCntrl;
	
	cc			: CnCntrl;
	
	errStr		: String;
	
	retries		: Integer;
begin
	kc := app.myCnKarmaCntrl;
	cc := app.myCnCntrl;

	on FileException do kc.fileExceptionHandler(exception);

	while true do
	    kc.setHadFileException(false);
	    kc.setFileRetryNo(0);
	
		pFile.purge();
		if not kc.hadFileException then
			return CN_OK;
		endif;

		errStr := kc.exceptionFileName & " exception=" & kc.exceptionErrorCode.String & " (";
		if kc.exceptionErrorCode = Cn_FileInUseByAnotherProcess or 
		   kc.exceptionErrorCode = Cn_FileAccessNotPermitted then
			errStr := errStr & kc.exceptionText;
		endif;
		
		errStr := errStr & ")";
		if retries = self.Retry_Limit then
			return errStr & ", retry limit exceeded";
		endif;

		retries := retries + 1;
		errStr := errStr & ", retrying remove";
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & errStr, null);

		process.sleep(self.Retry_Wait_Interval);
	endwhile;
end;
}
runUnixCommand
{
runUnixCommand(pCommand : String) : String updating;

vars
	// Wraps command in shell script and executes it modally

	cc			: CnCntrl;
	
	str			: String;
	
	len,
	retry,
	result,
	exitCode	: Integer;
	
	bin			: Binary;
	
	cem			: CnExternalMethods;
begin
	cc	:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, "Joss::runUnixCommand : commandLine=" & pCommand, null);
	create cem transient;
	
	while true do
		result := cem.emCreateProcessReturnResults(pCommand, null, exitCode, len, bin);
		
		if result = null and exitCode = null then
			return CN_OK;
		endif;
			
		if exitCode = 127 and retry < 5 then
			retry	:= retry + 1;
	
			cc.cnWriteLog(cc.CnLogDiag, "Joss::runUnixCommand : exitCode 127 : will retry...", null);
			process.sleep(2000);
			
		else
			str	:= null;
			if len > 0 then
				str := bin[1:len].String;
			endif;
			
			return "Error : result=" & result.String & ", exitCode=" & exitCode.String & ", stdOut=" & str;
		endif;
	endwhile;
epilog
	delete cem;
end;
}
validateParsedParams
{
validateParsedParams(	pStrArray				: HugeStringArray;
						pEnvironmentId,
						pBackupDirectory,
						pBackupWorkers			: String output;
						pCompressFiles,
						pQuiesce,
						pDisableBackupNotify	: Boolean output):Boolean updating, serverExecution;

vars	
	cc					: CnCntrl;
	
	jdo					: JadeDynamicObject;

	keyName,
	str,
	keyValue,
	disableBackupNotify,
	environmentId,
	backupDirectory,
	backupWorkers,
	iniFileName			: String;
	
	equalsPos			: Integer;

	compressFiles,
	keyNotDefined,
	quiesce,
	useIniSettings		: Boolean;
begin
	cc					:= app.myCnCntrl;
	iniFileName			:= app.getIniFileNameAppServer();
	disableBackupNotify	:= app.getProfileStringAppServer(iniFileName, CN_KCDATABASEBACKUP, CN_DISABLEBACKUPNOTIFICATIONS, null);	
	if disableBackupNotify = null then // create and set the default to 'false'
		disableBackupNotify := false.String;
		app.setProfileString(iniFileName, CN_KCDATABASEBACKUP, CN_DISABLEBACKUPNOTIFICATIONS, disableBackupNotify);
	endif;

	useIniSettings		:= (pStrArray = null or 
						   (pStrArray <> null and pStrArray.isEmpty()));
	if useIniSettings then
		environmentId	:= app.getProfileStringAppServer(iniFileName, CN_KCDATABASEBACKUP, CN_ENVIRONMENTID, null);
		backupDirectory	:= app.getProfileStringAppServer(iniFileName, CN_KCDATABASEBACKUP, CN_BACKUPDIRECTORY, null);
		backupWorkers	:= app.getProfileStringAppServer(iniFileName, CN_KCDATABASEBACKUP, CN_BACKUPWORKERS, "1");
		compressFiles	:= app.getProfileStringAppServer(iniFileName, CN_KCDATABASEBACKUP, CN_COMPRESSFILES, "false").Boolean;		
		quiesce			:= app.getProfileStringAppServer(iniFileName, CN_KCDATABASEBACKUP, CN_QUIESCE, "false").Boolean;
		
		if environmentId = null then
			app.cnManagerLog("Expected [" & CN_KCDATABASEBACKUP & "] " & CN_ENVIRONMENTID & " in ini file.");
			return true;
		endif;
		
		if backupDirectory = null then
			app.cnManagerLog("Expected [" & CN_KCDATABASEBACKUP & "] " & CN_BACKUPDIRECTORY & " in ini file.");
			return true;
		endif;

	else
		//PAR 923 - reworked to remove parameter order dependency and added defaults for optional parameters (instead of throwing an error)
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_RequestedPropertyNotDefined, jdo, keyNotDefined);
		
		create jdo transient;
		foreach str in pStrArray do
			equalsPos := str.pos("=", 1);
			if equalsPos = 0 or equalsPos = 1 then
				app.cnManagerLog("Invalid parameter specification:" & str);
				continue;
			endif;
			if str.length() > equalsPos then
				keyName := str[1:equalsPos-1].toLower();
				keyValue := str[equalsPos+1:end];
				jdo.addProperty(keyName, String);
				jdo.setPropertyValue(keyName, keyValue);
			
			else
				app.cnManagerLog("Invalid parameter specification:" & str);
			endif;
		endforeach;
		
		//Required parameters...
		
		keyNotDefined := false;
		environmentId := jdo.getPropertyValue(CN_ENVIRONMENTID.toLower()).String;
		if keyNotDefined then
			app.cnManagerLog("'" & CN_ENVIRONMENTID & "' not defined.");
			return true;
		endif;
		
		backupDirectory := jdo.getPropertyValue(CN_BACKUPDIRECTORY.toLower()).String;
		if keyNotDefined then
			app.cnManagerLog("'" & CN_BACKUPDIRECTORY & "' not defined.");
			return true;
		endif;
		
		//Optional parameters from here...
		
		backupWorkers := jdo.getPropertyValue(CN_BACKUPWORKERS.toLower()).String;
		if 	keyNotDefined or
			not backupWorkers.cnIsNumeric() then 
			backupWorkers := "1";
		endif;
		
		keyNotDefined := false;
		compressFiles := jdo.getPropertyValue(CN_COMPRESSFILES.toLower()).Boolean;
		if keyNotDefined then
			compressFiles := false;
		endif;
		
		keyNotDefined := false;
		quiesce := jdo.getPropertyValue(CN_QUIESCE.toLower()).Boolean;
		if keyNotDefined then
			quiesce := false;
		endif;
	endif;
		
	pEnvironmentId 			:= environmentId;
	pBackupDirectory		:= backupDirectory;
	self.backupDirectory	:= backupDirectory & "/" & environmentId; // required for inclusions
	pBackupWorkers			:= backupWorkers;
	pCompressFiles			:= compressFiles;
	pQuiesce				:= quiesce;	
	pDisableBackupNotify	:= disableBackupNotify.Boolean;	
epilog
	delete jdo;
	
	if process.isInExceptionState() then
		app.cnTerminate();
	endif;
end;
}
zCopyFilesFromDirectory
{
zCopyFilesFromDirectory(pFileFolder					: FileFolder;
						pDestDir 					: String;
						pCreateDirectoryIfNotFound,
						pIncludeSubDirectories,
						pVerifyIntegrity 			: Boolean;
						pErrText					: String output):Boolean updating, protected;
/*
	NOTE		:	This is a localised copy of the zCnCopyFilesFromDirectory method located on CardSchemas FileFolder class. The reason
					we have created a local copy is to provide file copy events to user applications that have subscribed to the
					non-managed backup multi-worker process.
					
	Purpose		:	Copy all files from a the directory specified by this file folder. 
					Optionally allow copy of all subdirectories.
					Optionally allow validation of each file written by doing an MD5 hash over the input file and checking it against
					that derived from the file just copied.
					
	Parameters	:	self.fileName				-	expected to be the name of the file folder that is the starting point for the copy
	
					pDestDir					-	the destination directory into which copy is to be done
					
					pCreateDirectoryIfNotFound	-	true	- if destination directory doesn't exist, create it
													false	- if destination directory doesn't exist, then error
													
					pIncludeSubDirectories		-	true	- execute same actions for all sub-directories
													false	- don't apply action to sub-directories

					pVerifyIntegrity			-	true	- any files copied are subjected to MD5 hash check to verify integrity of copy process
													false	- no checks done on output file
													
					
*/
constants
	Continue_If_File_Exists	: Boolean = false;
vars
	d1,
	d2				: Decimal[23];

	cnDba			: CnDatabaseAdmin;
	
	fileNode		: FileNode;

	str,
	thisFileName,
	newFileName		: String;
	
	ff,
	fileFolder		: FileFolder;

	kc				: CnKarmaCntrl;
	
	fileSize		: Integer64; 
	
	fileNameArray	: CnStringArray;
	
	fileSizeArray	: Integer64Array;
	
	notify			: Boolean;
begin
	cnDba			:= app.myCnDba;
	notify			:= not cnDba.disableBackupNotify;
	fileFolder		:= pFileFolder;
	if not fileFolder.isAvailable then
		pErrText := "Source directory '" & fileFolder.fileName & "' does not exist";
		return false;
	endif;

	create ff transient;
	ff.fileName := pDestDir;
	if not ff.isAvailable then
		if pCreateDirectoryIfNotFound then
			ff.make();
		
		else
			pErrText := "Directory '" & pDestDir & "' does not exist";
			return false;
		endif;
	endif;
	
	create fileNameArray transient;
	create fileSizeArray transient;
	
	foreach fileNode in fileFolder.files do
		thisFileName 	:= fileNode.cnGetSimpleFileName();
		newFileName 	:= pDestDir & "/" & thisFileName;
		if fileNode.isKindOf(File) then
			fileSize := fileNode.File.cnGetFileLength64();
			self.totalSize := self.totalSize + fileSize;
			if notify then								// only send notifications if 'DisableBackupNotifications=false' in the environments .ini file
				fileNameArray.add(thisFileName);
				fileSizeArray.add(fileSize);
				d2 := app.relativeMachineTime();
				if fileNameArray.size() > 500 	or	
				  (d2 - d1) > 1000 				then	// don't raise an event on every single file as this could be expensive, update periodically
					cnDba.buildUserInfoNonManagedBackup(fileNameArray, fileSizeArray, Cn_Backup_NonDbFile_Start, "Backing up file... ");
					fileNameArray.clear();
					fileSizeArray.clear();
					d1 := d2;
				endif;
			endif;
			
			app.cnManagerLog("Backing up " & fileNode.name & " as " & newFileName);			
			if not fileNode.File.cnCopyFilePlus(newFileName, pVerifyIntegrity, Continue_If_File_Exists, pErrText) then
				return false;
			endif;
			
		elseif pIncludeSubDirectories then
			if notify then								// only send notifications if 'DisableBackupNotifications=false' in the environments .ini file
				str := "Backing up all files in inclusion sub directory '" & fileNode.FileFolder.name & "'...";
				cnDba.buildUserInfoNonManagedBackup(fileNameArray, fileSizeArray, Cn_Backup_Inclusions, str); // raise notification to user application
			endif;
			
			if not self.zCopyFilesFromDirectory(fileNode.FileFolder, newFileName, pCreateDirectoryIfNotFound, pIncludeSubDirectories, pVerifyIntegrity, pErrText) then
				return false;
			endif;
		endif;
	endforeach;
	
	if notify then										// only send notifications if 'DisableBackupNotifications=false' in the environments .ini file
		cnDba.buildUserInfoNonManagedBackup(fileNameArray, fileSizeArray, Cn_Backup_NonDbFile_Start, "Backing up file... "); // send any queued notification updates through now
	endif;
	
	return true;
epilog
	delete ff;
	delete fileNameArray;
	delete fileSizeArray;
end;
}
zRemoveDirectory
{
zRemoveDirectory(pFileFolder : FileFolder) : String updating, protected;

vars	
	cc			: CnCntrl;

	fileNode	: FileNode;
	
	ff			: FileFolder;
	
	pos			: Integer;
	
	result,
	command		: String;
begin
	ff := pFileFolder;
	if app.cnOSPlatformIsWindows() then
		// delete all files and directories within this directory
		foreach fileNode in ff.files do
			if fileNode.isKindOf(File) then
				result := self.removeFile(fileNode.File);
				if result <> CN_OK then
					return result;
				endif;
			else
			
				result := self.zRemoveDirectory(fileNode.FileFolder);
				if result <> CN_OK then
					write result;
					return result;
				endif;
			endif;
		endforeach;
		
		ff.files.purge(); // delete transient instances of file and filefolder
		ff.purge();
		return CN_OK;
	endif;

	// must be Linux
	cc := app.myCnCntrl;
	if ff.fileName.length() < 5 then
		app.cnRaiseNormalException(Cn_General_Error, "FileFolder remove directory error", method.cnGetMethodName() & " remove directory requested at too high a level : dir=" & ff.fileName, false);
		return CN_NOT_OK;
	endif;

	if ff.fileName[1:5] <> "/opt/" then
		app.cnRaiseNormalException(Cn_General_Error, "FileFolder remove directory error", method.cnGetMethodName() & " remove directory must start with /opt/... : dir=" & ff.fileName, false);
		return CN_NOT_OK;
	endif;

	pos := 1;
	pos := ff.fileName.pos("/", pos);
	if pos = null then
		app.cnRaiseNormalException(Cn_General_Error, "FileFolder remove directory error", method.cnGetMethodName() & " remove directory requested at too high a level : dir=" & ff.fileName, false);
		return CN_NOT_OK;
	endif;
	
	pos := pos + 1;
	pos := ff.fileName.pos("/", pos);
	if pos = null then
		app.cnRaiseNormalException(Cn_General_Error, "FileFolder remove directory error", method.cnGetMethodName() & " remove directory requested at too high a level : dir=" & ff.fileName, false);
		return CN_NOT_OK;
	endif;

	command := "rm -fR " & ff.fileName;
	return self.runUnixCommand(command);
end;
}
	)
	CnExternalMethods (
	jadeMethodSources
cnCauseFault
{
cnCauseFault() protected;
/*
	Internal usage only, hence protected.
*/
vars
	cc	: CnCntrl;
begin
	cc := app.myCnCntrl;
	if cc <> null then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " now forcing Dr Danyo fault!", null);
	endif;
	
	self.emCauseFault();
end;
}
cnGetCopyToClipboardErrorText
{
cnGetCopyToClipboardErrorText(pErrorCode : Integer) : String;

constants
	CouldNotOpenClipboard_Start 					: Integer	= 70000;
	CouldNotOpenClipboard_End 						: Integer	= 99999;
	
	CouldNotSetClipboardData_Start					: Integer	= 100000;
	CouldNotSetClipboardData_End					: Integer	= 199999;
	
	CouldNotEmptyClipboardOfExistingData_Start		: Integer	= 200000;
	CouldNotEmptyClipboardOfExistingData_End		: Integer	= 299999;
	
	CouldNotCloseTheClipboard_Start					: Integer	= 300000;
	CouldNotCloseTheClipboard_End					: Integer	= 399999;
	
	CouldNotAllocateGlobalMemory_Start				: Integer	= 400000;
	CouldNotAllocateGlobalMemory_End				: Integer	= 499999;

	CouldNotLockGlobalMemory_Start					: Integer	= 500000;
	CouldNotLockGlobalMemory_End					: Integer	= 599999;

	CouldNotUnlockGlobalMemory_Start				: Integer	= 600000;
	CouldNotUnlockGlobalMemory_End					: Integer	= 699999;
	
	CouldNotOpenTheClipboard_Start					: Integer	= 700000;
	CouldNotOpenTheClipboard_End					: Integer	= 799999;

vars	
	windowsErrorCode	: Integer;
begin
	if pErrorCode = null then
		// no error
		return null;
	endif;
	
	if pErrorCode >= CouldNotOpenClipboard_Start and
	   pErrorCode <= CouldNotOpenClipboard_End	 then
		windowsErrorCode := pErrorCode - CouldNotOpenClipboard_Start;
		return "Could not open the clipboard : Windows error code " & windowsErrorCode.String;
	endif;
	
	if pErrorCode >= CouldNotSetClipboardData_Start and
	   pErrorCode <= CouldNotSetClipboardData_End	 then
		windowsErrorCode := pErrorCode - CouldNotSetClipboardData_Start;
		return "Could not set clipboard data : Windows error code " & windowsErrorCode.String;
	endif;
	
	if pErrorCode >= CouldNotEmptyClipboardOfExistingData_Start and
	   pErrorCode <= CouldNotEmptyClipboardOfExistingData_End	 then
		windowsErrorCode := pErrorCode - CouldNotEmptyClipboardOfExistingData_Start;
		return "Could not empty clipboard of existing data : Windows error code " & windowsErrorCode.String;
	endif;	
	
	if pErrorCode >= CouldNotCloseTheClipboard_Start and
	   pErrorCode <= CouldNotCloseTheClipboard_End	 then
		windowsErrorCode := pErrorCode - CouldNotCloseTheClipboard_Start;
		return "Could not close the clipboard : Windows error code " & windowsErrorCode.String;
	endif;	

	if pErrorCode >= CouldNotAllocateGlobalMemory_Start and
	   pErrorCode <= CouldNotAllocateGlobalMemory_End	 then
		windowsErrorCode := pErrorCode - CouldNotAllocateGlobalMemory_Start;
		return "Could not allocate global memory : Windows error code " & windowsErrorCode.String;
	endif;	
	
	if pErrorCode >= CouldNotLockGlobalMemory_Start and
	   pErrorCode <= CouldNotLockGlobalMemory_End	 then
		windowsErrorCode := pErrorCode - CouldNotLockGlobalMemory_Start;
		return "Could not lock global memory : Windows error code " & windowsErrorCode.String;
	endif;	
	
	if pErrorCode >= CouldNotUnlockGlobalMemory_Start and
	   pErrorCode <= CouldNotUnlockGlobalMemory_End	 then
		windowsErrorCode := pErrorCode - CouldNotUnlockGlobalMemory_Start;
		return "Could not unlock global memory : Windows error code " & windowsErrorCode.String;
	endif;
	
	if pErrorCode >= CouldNotOpenTheClipboard_Start and
	   pErrorCode <= CouldNotOpenTheClipboard_End	 then
		windowsErrorCode := pErrorCode - CouldNotOpenTheClipboard_Start;
		return "Could not open the clipboard : Windows error code " & windowsErrorCode.String;
	endif;

	// error code is not documented.
	return "Unknown error code : " & pErrorCode.String;
end;
}
cnGetErrorText
{
cnGetErrorText( pErrorRoutine	: String;
				pErrorCode 		: Integer) : String;

vars

begin
	if pErrorRoutine = Cn_CreateProcess then
		return self.zErrCreateProcess(pErrorCode);
		
	elseif pErrorRoutine = Cn_CreateProcessReturnResults then
		return self.zErrCreateProcessReturnResults(pErrorCode);
	
	else
		return "Unknown error routine '" & pErrorRoutine & " error code " & pErrorCode.String;
	endif;
end;
}
cnGroupCheck
{
cnGroupCheck(pUserName, pGroupName : String; pResult : Integer output) : Boolean;

vars

begin
	return self.emGroupCheck(pUserName, pGroupName, pResult);
end;
}
cnUserCheck
{
cnUserCheck(pUserName, pPassword : String; pResult : Integer output) : Boolean;

vars

begin
	return self.emUserCheck(pUserName, pPassword, pResult);
end;
}
zErrCreateProcess
{
zErrCreateProcess(pErrorCode : Integer) : String protected;

vars

begin
	if pErrorCode = 1 then
		return "One of the parameters has a wrong type";
	
	elseif pErrorCode = 2 then
		return "The command could not be started";
		
	elseif pErrorCode = 3 then
		return "The exit code could not be retrieved";
		
	elseif pErrorCode = 4 then
		return "Illegal combination of parameter settings";
	
	elseif pErrorCode = 5 then
		return "Error creating stdout pipe";
	
	elseif pErrorCode = 6 then
		return "Error redirecting stdout pipe";

	elseif pErrorCode = 7 then
		return "Error duplicating stdout pipe handle";

	elseif pErrorCode = 8 then
		return "Error creating stdin pipe";

	elseif pErrorCode = 9 then
		return "Error redirecting stdin pipe";

	elseif pErrorCode = 10 then
		return "Error duplicating stdin pipe handle";

	elseif pErrorCode = 11 then
		return "Error restoring calling process's stdin";
	
	elseif pErrorCode = 12 then
		return "Error restoring calling processes stdout";
	
	elseif pErrorCode = 13 then
		return "Error closing WRITE end of stdout pipe";

	elseif pErrorCode = 14 then
		return "Error writing to child process's stdin pipe";

	elseif pErrorCode = 15 then
		return "Error closing WRITE end of stdin pipe";

	else
		return "Unknown error " & pErrorCode.String & " for method " & method.name;
	endif;
end;
}
zErrCreateProcessReturnResults
{
zErrCreateProcessReturnResults(pErrorCode : Integer) : String protected;

vars

begin
	if pErrorCode = 16 then
		return "Error too much stdout text - truncated";
		
	else
		return self.zErrCreateProcess(pErrorCode);
	endif;
end;
}
	externalMethodSources
emBase64Decode
{
emBase64Decode(
			pMessage: String input; 
			pDecodedMessage: Binary output): Integer is "emBase64Decode" in "karma" updating, number = 1059;
}
emBase64Encode
{
emBase64Encode(pMessage: Binary input): String is "emBase64Encode" in "karma" updating, number = 1060;
}
emCauseFault
{
emCauseFault() : Boolean is emCauseFault in karma protected;
}
emCreateFolder
{
emCreateFolder(pFolderName : String) : Integer is emCreateFolder in karma;
}
emCreateProcessReturnResults
{
emCreateProcessReturnResults(command: String; 
							childStdIn: String; 
							childExitCode: Integer output; 
							binLength: Integer output; 
							binStdOut: Binary output): Integer is emCreateProcessReturnResults in karma;
}
emGetAdministratorsGroup
{
emGetAdministratorsGroup() : String is emGetAdministratorsGroup in karma;
}
emGetDomainName
{
emGetDomainName(
			type: Integer output; 
			name: String output): String is "emGetDomainName" in "karma" number = 1028;
}
emGetDomainNameEx
{
emGetDomainNameEx(type: Integer output; 
				  name: String output) : String is emGetDomainNameEx in karma;

				  
/*
	Difference between this entry point and 'emGetDomainName' is that this entry point will
	return a 'type' of 4 when the server is a Domain Controller.
*/
}
emGetEnvironmentVariable
{
emGetEnvironmentVariable(pVariable : String) : String is emGetEnvironmentVariable in karma;
}
emGetErrorText
{
emGetErrorText( pErrorCode: Integer; 
				pErrorText: String output;
				pMaxLength : Integer): Integer is emGetErrorText in karma;
}
emGetHostByAddress
{
emGetHostByAddress(
			ipAddress: String; 
			hostName: String output): Integer is "emGetHostByAddr" in "karma" number = 1156;
}
emGetHostByName
{
emGetHostByName(hostName: String; 
				maxNum: Integer io; 
				addresses: String output): Integer is emGetHostByName in karma;
}
emGetUserName
{
emGetUserName(userName : String output;
			  maxLength : Integer io) : Integer is emGetUserName in karma;
}
emGroupCheck
{
emGroupCheck(pUserName, pGroup : String; pResult : Integer output) : Boolean is emGroupCheck in karma protected;
}
emIsProcessRunning
{
emIsProcessRunning(pProcessName : String) : Boolean is emIsProcessRunning in karma;
}
emIsService
{
emIsService(): Boolean is emIsService in karma;
}
emQPDecode
{
emQPDecode(pEncoded : String; pDecoded : Binary output) : String is emQPDecode in karma;
}
emQPEncode
{
emQPEncode(nData : Binary; qpEncoded : String output) : String is emQPEncode in karma;

/*
Expected to be used by SMTP messaging
*/
}
emResetReadOnly
{
emResetReadOnly(pDirectory : String) : Boolean is emResetReadOnly in karma;
}
emSendStdOut
{
emSendStdOut(str: String): Integer is "emSendStdOut" in "karma" number = 1001;
}
emUserCheck
{
emUserCheck(pUserName, pPassword : String; pResult : Integer output) : Boolean is emUserCheck in karma protected;
}
	)
	CnIpAddress (
	jadeMethodSources
checkFormat
{
checkFormat(pValue : String) : Integer updating;
// Returns : 4   -- valid vn 4 address
//           6   -- valid vn 6 address
//          -1   -- invalid format
vars
	c         	: Character;

	doubleColon,
	mixed     	: Boolean;
	
	i,
	lgth,
	rtn,
	numTally,
	numValue,
	state,
	tokenType,
	xVersion   	: Integer;			// avoid use of 'version' as this is a RootSchema method applicable to all objects

	numString 	: String;
begin
	xVersion	:= version;
	rtn 		:= null;
	self.errorMessage := null;	
	xVersion 	:= null;
	numTally 	:= null;
	doubleColon := false;
	mixed 		:= false;
	state 		:= STARTING;
	lgth 		:= pValue.length();
	i 			:= null;
	while rtn = null do
		i := i + 1;
		if i > lgth then
			c := null;
			tokenType := END;
			
		else
			c := pValue[i:1].Character;
			if c >= '0' and c <= '9' then
				tokenType := DECDIGIT;
				
			elseif c >= 'A' and c <= 'F' or c >= 'a' and c <= 'f' then
				tokenType := HEXDIGIT;
				
			elseif c = ' '  then
				tokenType := SPACE;
				
			elseif c = ':' then
				tokenType := COLON;
				
			elseif c = '.' then
				tokenType := DOT;
				
			else
				tokenType := OTHER;
			endif;
		endif;
		
		if tokenType = OTHER then
			rtn := -1;
			self.errorMessage := 'Invalid character "' & c & '"';
			
		elseif state = STARTING then
			if tokenType = HEXDIGIT then
				xVersion := 6;  // only version 6 allows hexadecimal
			endif;
			
			if tokenType = HEXDIGIT or tokenType = DECDIGIT then
				numString := c;
				state := GOTDIGIT;
				
			elseif tokenType = COLON then
				xVersion := 6;
				state := GOTLEADINGCOLON;
				
			elseif tokenType = END then
				rtn := -1;
				self.errorMessage := "no text";
				
			elseif tokenType = SPACE then
			
			else
				rtn := -1;
				self.errorMessage := 'Invalid initial character "' & c & '"';
			endif;
			
		elseif state = GOTLEADINGCOLON then
			if tokenType = COLON then
				doubleColon := true;
				numTally := 1;
				state := GOT2NDCOLON;
				
			else
				rtn := -1;
				self.errorMessage := "A single leading colon is not allowed";
			endif;
			
		elseif state = GOT2NDCOLON then
			if tokenType = DOT then
				rtn := -1;
				self.errorMessage := 'A decimal value must always precede "."';
				
			elseif tokenType = HEXDIGIT or tokenType = DECDIGIT then
				numString := c;
				state := GOTDIGIT;
				
			elseif tokenType = END then
				rtn := 6;
				
			else // was SPACE
				state := GOTSPACE;
			endif;
			
		elseif state = GOTDIGIT then
			if tokenType = HEXDIGIT then
				if xVersion = 4 then
					rtn := -1;
					self.errorMessage := "Hexadecimal values are only allowed in version 6 addresses";
					
				else
					xVersion := 6;
				endif;
			endif;
			
			if tokenType = DECDIGIT or tokenType = HEXDIGIT then
				numString := numString & c;
				
			else
				if tokenType = COLON then
					if xVersion = 4 then
						rtn := -1;
						self.errorMessage := "Colons are only allowed in version 6 addresses";
						
					else
						xVersion := 6;
					endif;
				endif;
				
				if rtn <> -1 then					
					// COLON, END, SPACE, DOT
					numValue := checkNumString ( numString , xVersion );
					if numValue < 0 then
						rtn := -1;
						self.errorMessage := 'Invalid numeric value "' & numString & '"';
						
					else
						numTally := numTally + 1;  // total number of values received
						if tokenType = DOT then // must be decimal, < 256
							if not numString.isInteger() or numString.Integer > 255 then
								rtn := -1;
								self.errorMessage := 'Value preceding "." must be decimal and less than 256';
								
							elseif xVersion = 6 then
								// a vn 4 address following the first six vn 6 values
								if numTally > 7 then
									rtn := -1;
									self.errorMessage := "Only 6 values allowed before the version 4 address";
									
								elseif not doubleColon and numTally <> 7 then
									rtn := -1;
									self.errorMessage := "There must be 6 values before the version 4 address";
									
								else
									numTally := 1;
									xVersion := 4;
									mixed := true;
									state := GOTDOT;
								endif;
								
							elseif xVersion = 4 then
								if numTally >= 4 then
									rtn := -1;
									self.errorMessage := "Only 4 values are allowed";
									
								else
									state := GOTDOT;
								endif;
								
							else // version not yet known
								xVersion := 4; // must be 4 if we get a dot
								state := GOTDOT;
							endif;
							
						elseif tokenType = COLON then
							xVersion := 6;
							if numTally >= 8 then
								rtn := -1;
								self.errorMessage := "Only 8 values are allowed in a version 6 address";
								
							else
								state := GOTCOLON;
							endif;
							
						elseif tokenType = END or tokenType = SPACE then
							if xVersion = 4 then
								if numTally <> 4 then
									rtn := -1;
									self.errorMessage := "A version 4 address must have four values";
									
								elseif tokenType = END then
									rtn := 4;
									
								else
									state := GOTSPACE;
								endif;
								
							elseif xVersion = 6 then
								if numTally > 8 then
									rtn := -1;
									self.errorMessage := "Only 8 values are allowed in a version 6 address";
									
								elseif not doubleColon and numTally <> 8 then
									rtn := -1;
									self.errorMessage := "A version 6 address must have six values";
									
								elseif tokenType = END then
									rtn := 6;
									
								else
									state := GOTSPACE;
								endif;
								
							else // unknown version
								rtn := -1;
								self.errorMessage := "An address must contain more than one value";
							endif;
						endif; // ...tokenType = END or SPACE
					endif; // ...numeric value is valid
				endif;  // rtn <> -1
			endif; // ...tokenType not DIGIT or HEXDIGIT
			
		elseif state = GOTSPACE then
			if tokenType = END then
				rtn := xVersion;
				
			elseif tokenType <> SPACE then
				rtn := -1;
				self.errorMessage := "Extraneous text";
			endif;
			
		elseif state = GOTDOT then
			if tokenType = HEXDIGIT then
				rtn := -1;
				self.errorMessage := "Version 4 address cannot contain hexadecimal values";
				
			elseif tokenType = DECDIGIT then
				numString := c;
				state := GOTDIGIT;
				
			elseif tokenType = SPACE or tokenType = END then
				rtn := -1;
				self.errorMessage := 'Value missing after final "."';
				
			elseif tokenType = DOT then
				rtn := -1;
				self.errorMessage := 'The sequence ".." is not allowed';
				
			else // was COLON
				rtn := -1;
				self.errorMessage := "Colons are not allowed in version 4 addresses";
			endif;
			
		elseif state = GOTCOLON then
			if tokenType = HEXDIGIT or tokenType = DECDIGIT then
				numString := c;
				state := GOTDIGIT;
				
			elseif tokenType = COLON then
				if doubleColon then
					rtn := -1;
					self.errorMessage := 'Only one "::" sequence is allowed';
					
				else
					doubleColon := true;
					numTally := numTally + 1;
					state := GOT2NDCOLON;
				endif;
				
			elseif tokenType = DOT then
				rtn := -1;
				self.errorMessage := 'A "." must always be preceded by a decimal value';
				
			elseif tokenType = SPACE or tokenType = END then
				rtn := -1;
				self.errorMessage := 'Value missing after final ":"';
			endif;
			
		else
			rtn := -1;
			self.errorMessage := "*INTERNAL ERROR* Unknown state : " & state.String;
		endif;
	endwhile;
	
	if mixed and rtn = 4 then
		rtn := 6;  // was mixed format : i.e. 6 vn 6 numbers followed by 4 vn 4
	endif;
	
	return rtn;		
end;
}
checkNumString
{
checkNumString(pValue : String; pVersion : Integer) : Integer updating , protected;
// checks out a string containing a number. The number can be
// decimal or hexadecimal.
// 'pVersion' determines the current TCP/IP address version. Version 4 uses
// decimal numbers, 0 to 255. Version 6 uses hexadecimal numbers, 0000 to
// FFFF.
vars
	num : Integer;
begin
	if pValue = null then
		return -1;
	endif;
	
    if pVersion = 4 then
    	if not pValue.isInteger() then
    		return -1;
		endif;

		num := pValue.Integer;
		if num > 255 then
			return -1;
		endif;
			
		return num;
   	endif;

	if pVersion = 6 then
		if not pValue.cnIsHex() then
			return -1;
		endif;
		
		if pValue.cnTrimLeadingZeros.length() > 4 then
			return -1;
		endif;
		
		return pValue.cnHexToInteger();
	endif;

	// don't know if it is vn 4 or vn 6
	if pValue.cnTrimLeadingZeros.length() > 4 then
		return -1;  // too long, in ALL cases
	endif;
	
	if not pValue.isInteger then
		return pValue.cnHexToInteger();
	endif;
	
	return pValue.Integer;
end;
}
convertIPv4toIPv6
{
convertIPv4toIPv6(pIPv4 : String):String;

vars
	ipv6		: String;

	strArray	: CnStringArray;
begin
	create strArray transient;
	strArray := pIPv4.cnGetTokens(CN_PERIOD);
	if strArray.size <> 4 then
		return "Attempt to process an invalid IPv4 address. Format should be xxx.xxx.xxx.xxx, please try again.";
	endif;
	
	ipv6 := ipv6 & strArray[1].cnDecimalToHex(2);
	ipv6 := ipv6 & strArray[2].cnDecimalToHex(2) & ":";
	ipv6 := ipv6 & strArray[3].cnDecimalToHex(2);
	ipv6 := ipv6 & strArray[4].cnDecimalToHex(2);
	return ipv6;
epilog
	delete strArray;
end;
}
convertIPv6toIPv4
{
convertIPv6toIPv4(pIPv6 : String):String;

/*
	This method takes nodes 7 & 8 of an IPv6 address and converts them back into IPv4 format.
	
	Note that the type casting is used to remove unwanted string padding for example: using '#25'.cnHexToDecimal(3) will return 037,
	the	typecasting removes the need to strip the leading '0'
*/
constants
	Common_ErrTxt_Start	= "Attempt to process an invalid IPv6 address. ";
	Common_ErrTxt_End	= ", please try again.";
vars
	int1,
	int2,
	int3,
	int4		: Integer;

	node1,
	node2,
	ipv4		: String;

	strArray	: CnStringArray;
begin
	create strArray transient;
	strArray := pIPv6.cnGetTokens(CN_COLON);
	if strArray.size <> 8 then
		return Common_ErrTxt_Start & "Format should be xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx" & Common_ErrTxt_End;
	endif;

	node1	:= strArray[7];
	if node1.length <> 4 then
		return Common_ErrTxt_Start & "Node 7 of this ip address should contain 4 characters but only contains " & node1.length.String & Common_ErrTxt_End;
	endif;
	
	int1	:= node1[1:2].cnHexToDecimal(3).Integer;
	int2	:= node1[3:2].cnHexToDecimal(3).Integer;

	node2	:= strArray[8];
	if node2.length <> 4 then
		return Common_ErrTxt_Start & "Node 8 of this ip address should contain 4 characters but only contains " & node2.length.String & Common_ErrTxt_End;
	endif;
	
	int3	:= node2[1:2].cnHexToDecimal(3).Integer;
	int4	:= node2[3:2].cnHexToDecimal(3).Integer;
	
	ipv4	:= int1.String & "." &
			   int2.String & "." &
			   int3.String & "." &
			   int4.String ;
	return ipv4;
epilog
	delete strArray;
end;
}
getErrorMessage
{
getErrorMessage() : String ;

vars

begin
	return self.errorMessage ;
end;
}
hexToDisplay
{
hexToDisplay( hexString : String ) : String;
// Vn 4 TCP/IP address = 8  characters , result = n.n.n.n (decimal values)
// Vn 6 TCP/IP address = 32 characters, result = n:n:n:n:n:n:n:n (hexadecimal values)
// All display values have leading zeros removed
vars
    displayString : String;
begin
	if not hexString.cnIsHex() then
		return null;
	endif;
	
	if hexString.length() = 8 then
		return hexString[1:2].cnHexToDecimal(0) & "." & hexString[3:2].cnHexToDecimal(0) & "." &
		       hexString[5:2].cnHexToDecimal(0) & "." & hexString[7:2].cnHexToDecimal(0);
	endif;
	
	if hexString.length() = 32 then
		return hexString[1:4].cnTrimLeadingZeros() & ":" & hexString[5:4].cnTrimLeadingZeros() & ":" &
		       hexString[9:4].cnTrimLeadingZeros() & ":" & hexString[13:4].cnTrimLeadingZeros() & ":" &
		       hexString[17:4].cnTrimLeadingZeros() & ":" & hexString[21:4].cnTrimLeadingZeros() & ":" &
		       hexString[25:4].cnTrimLeadingZeros() & ":" & hexString[29:4].cnTrimLeadingZeros();
	endif;
	
	return null;
end;
}
v4DisplayToHex
{
v4DisplayToHex(pValue : String) : String updating;

vars
	sValues   : StringArray;

	error,
	gotItAll  : Boolean;

	c         : Character;

	i,
	lgth,
	numTally,
	numValue,
	state,
	tokenType : Integer;
	
	numString,
	sReturn   : String;
	
begin
	create sValues transient;
	self.errorMessage := null;	
	numTally := 0;
	state := STARTING;
	lgth := pValue.length();
	i := 0;
	while not gotItAll and not error do
		i := i + 1;
		if i > lgth then
			c := null;
			tokenType := END;
			
		else
			c := pValue[i:1].Character;
			if c >= '0' and c <= '9' then
				tokenType := DECDIGIT;
				
			elseif c = ' '  then
				tokenType := SPACE;
				
			elseif c = '.' then
				tokenType := DOT;
				
			else
				tokenType := OTHER;
			endif;
		endif;
		
		if tokenType = OTHER then
			error := true;
			self.errorMessage := 'Invalid character "' & c & '"';
			
		elseif state = STARTING then
			if tokenType = DECDIGIT then
				numString := c;
				state := GOTDIGIT;
				
			elseif tokenType = END then
				error := true;
				self.errorMessage := "no text";
				
			elseif tokenType = SPACE then
			
			else
				error := true;
				self.errorMessage := 'Invalid initial character "' & c & '"';
			endif;
			
		elseif state = GOTDIGIT then
			if tokenType = DECDIGIT then
				numString := numString & c;
				
			else
				// END, SPACE, DOT
				numValue := self.checkNumString(numString, 4);
				if numValue < 0 then
					error := true;
					self.errorMessage := 'Invalid numeric value "' & numString & '"';
					
				else
					numTally := numTally + 1;  // total number of values received
					sValues[numTally] := numString;
					if tokenType = DOT then // must be decimal, < 256
						if not numString.isInteger() or numString.Integer > 255 then
							error := true;
							self.errorMessage := 'Value preceding "." must be decimal and less than 256';
							
						elseif numTally >= 4 then
							error := true;
							self.errorMessage := "Only 4 values are allowed";
							
						else
							state := GOTDOT;
						endif;
						
					elseif tokenType = END or tokenType = SPACE then
						if numTally <> 4 then
							error := true;
							self.errorMessage := "A version 4 address must have four values";
							
						elseif tokenType = END then
							gotItAll := true;
							
						else
							state := GOTSPACE;
						endif;
					endif; // ...tokenType is END or SPACE
				endif;  // ...numeric value is valid
			endif; // ...tokenType not DIGIT
			
		elseif state = GOTSPACE then
			if tokenType = END then
				gotItAll := true;
				
			elseif tokenType <> SPACE then
				error := true;
				self.errorMessage := "Extraneous text";
			endif;
			
		elseif state = GOTDOT then
			if tokenType = DECDIGIT then
				numString := c;
				state := GOTDIGIT;
				
			elseif tokenType = SPACE or tokenType = END then
				error := true;
				self.errorMessage := 'Value missing after final "."';
				
			elseif tokenType = DOT then
				error := true;
				self.errorMessage := 'The sequence ".." is not allowed';
			endif;
			
		elseif state = GOTCOLON then
			if tokenType = DECDIGIT then
				numString := c;
				state := GOTDIGIT;
				
			elseif tokenType = DOT then
				error := true;
				self.errorMessage := 'A "." must always be preceded by a decimal value';
				
			elseif tokenType = SPACE or tokenType = END then
				error := true;
				self.errorMessage := 'Value missing after final ":"';
			endif;
			
		else
			error := true;
			self.errorMessage := "*INTERNAL ERROR* Unknown state : " & state.String;
		endif;
	endwhile;
	
	if error then
		sReturn := null;
		
	else
		i := 1;
		while i <= 4 do 
			sReturn := sReturn & sValues[i].cnDecimalToHex(2);
			i := i + 1;
		endwhile;
	endif;
	
	return sReturn;
epilog
	delete sValues;
end;
}
v6DisplayToHex
{
v6DisplayToHex(s : String ) : String updating;

vars
	sValues   	: StringArray;

	doubleColon,
	error,
	gotItAll,
	mixed     	: Boolean;

	c			: Character;

	i,
	j,
	lgth,
	numTally,
	numValue,
	state,
	tokenType,
	xVersion,								// don't use variable of 'version' as this is a RootSchema item
	v4Start		: Integer;

	numString,
	sReturn		: String;
begin
	error 		:= false;
	gotItAll 	:= false;
	self.errorMessage := null;	
	xVersion 	:= 6;
	numTally 	:= null;
	doubleColon := false;
	error 		:= false;
	gotItAll 	:= false;
	mixed 		:= false;
	create sValues transient;
	state 		:= STARTING;
	lgth 		:= s.length();
	i 			:= null;
	while not gotItAll and not error do
		i := i + 1;
		if i > lgth then
			c := null;
			tokenType := END;
			
		else
			c := s[i:1].Character;
			if c >= '0' and c <= '9' then
				tokenType := DECDIGIT;
				
			elseif c >= 'A' and c <= 'F' or c >= 'a' and c <= 'f' then
				tokenType := HEXDIGIT;
				
			elseif c = ' '  then
				tokenType := SPACE;
				
			elseif c = ':' then
				tokenType := COLON;
				
			elseif c = '.' then
				tokenType := DOT;
				
			else
				tokenType := OTHER;
			endif;
		endif;
		
		if tokenType = OTHER then
			error := true;
			self.errorMessage := 'Invalid character "' & c & '"';
			
		elseif state = STARTING then
			if tokenType = HEXDIGIT or tokenType = DECDIGIT then
				numString := c;
				state := GOTDIGIT;
				
			elseif tokenType = COLON then
				state := GOTLEADINGCOLON;
				
			elseif tokenType = END then
				error := true;
				self.errorMessage := "no text";
				
			elseif tokenType = SPACE then
			
			else
				error := true;
				self.errorMessage := 'Invalid initial character "' & c & '"';
			endif;
			
		elseif state = GOTLEADINGCOLON then
			if tokenType = COLON then
				doubleColon := true;
				sValues.add ( "::" );
				numTally := 1;
				state := GOT2NDCOLON;
				
			else
				error := true;
				self.errorMessage := "A single leading colon is not allowed";
			endif;
			
		elseif state = GOT2NDCOLON then
			if tokenType = DOT then
				error := true;
				self.errorMessage := 'A decimal value must always precede "."';
				
			elseif tokenType = HEXDIGIT or tokenType = DECDIGIT then
				numString := c;
				state := GOTDIGIT;
				
			elseif tokenType = END then
				gotItAll := true;
				
			else // was SPACE
				state := GOTSPACE;
			endif;
			
		elseif state = GOTDIGIT then
			if tokenType = HEXDIGIT then
				if xVersion = 4 then
					error := true;
					self.errorMessage := "Hexadecimal values are only allowed in the version 6 part of the address";
				endif;
			endif;
			
			if tokenType = DECDIGIT or tokenType = HEXDIGIT then
				numString := numString & c;
				
			else
				if tokenType = COLON then
					if xVersion = 4 then
						error := true;
						self.errorMessage := "Colons are only allowed in the version 6 part of the address";
					endif;
				endif;
				
				if not error then					
					// COLON, END, SPACE, DOT
					numValue := self.checkNumString(numString, xVersion);
					if numValue < 0 then
						error := true;
						self.errorMessage := 'Invalid numeric value "' & numString & '"';
						
					else
						numTally := numTally + 1;  // total number of values received
						if tokenType = DOT then // must be decimal, < 256
							if not numString.isInteger() or numString.Integer > 255 then
								error := true;
								self.errorMessage := 'Value preceding "." must be decimal and less than 256';
								
							elseif xVersion = 6 then
								// a vn 4 address following the first six vn 6 values
								if numTally > 7 then
									error := true;
									self.errorMessage := "Only version 6 values allowed before the version 4 address";
									
								elseif not doubleColon and numTally <> 7 then
									error := true;
									self.errorMessage := "There must be version 6 values before the version 4 address";
									
								else
									numTally := 1;
									xVersion := 4;
									mixed := true;
									sValues.add ( "v4" );
									sValues.add ( numString.toUpper() );
									state := GOTDOT;
								endif;
								
							else // it was version 4
								if numTally >= 4 then
									error := true;
									self.errorMessage := "Only 4 values are allowed";
									
								else
									sValues.add ( numString.toUpper() );
									state := GOTDOT;
								endif;
							endif;
							
						elseif tokenType = COLON then
							if numTally >= 8 then
								error := true;
								self.errorMessage := "Only 8 values are allowed in a version 6 address";
								
							else
								sValues.add ( numString.toUpper() );
								state := GOTCOLON;
							endif;
							
						elseif tokenType = END or tokenType = SPACE then
							if xVersion = 4 then
								if numTally <> 4 then
									error := true;
									self.errorMessage := "A version 4 address must have four values";
									
								elseif tokenType = END then
									sValues.add ( numString.toUpper() );
									gotItAll := true;
									
								else
									sValues.add ( numString.toUpper() );
									state := GOTSPACE;
								endif;
								
							else // it is version 6
								if numTally > 8 then
									error := true;
									self.errorMessage := "Only 8 values are allowed in a version 6 address";
									
								elseif not doubleColon and numTally <> 8 then
									error := true;
									self.errorMessage := "A version 6 address must have six values";
									
								elseif tokenType = END then
									sValues.add ( numString.toUpper() );
									gotItAll := true;
									
								else
									sValues.add ( numString.toUpper() );
									state := GOTSPACE;
								endif;
							endif;
						endif; // ...tokenType = END or SPACE
					endif; // ...numeric value is valid
				endif;  // not error
			endif; // ...tokenType not DIGIT or HEXDIGIT
			
		elseif state = GOTSPACE then
			if tokenType = END then
				gotItAll := true;
				
			elseif tokenType <> SPACE then
				error := true;
				self.errorMessage := "Extraneous text";
			endif;
			
		elseif state = GOTDOT then
			if tokenType = HEXDIGIT then
				error := true;
				self.errorMessage := "The version 4 portion of the address cannot contain hexadecimal values";
				
			elseif tokenType = DECDIGIT then
				numString := c;
				state := GOTDIGIT;
				
			elseif tokenType = SPACE or tokenType = END then
				error := true;
				self.errorMessage := 'Value missing after final "."';
				
			elseif tokenType = DOT then
				error := true;
				self.errorMessage := 'The sequence ".." is not allowed';
				
			else // was COLON
				error := true;
				self.errorMessage := "Colons are not allowed in the version 4 part of the address";
			endif;
			
		elseif state = GOTCOLON then
			if tokenType = HEXDIGIT or tokenType = DECDIGIT then
				numString := c;
				state := GOTDIGIT;
				
			elseif tokenType = COLON then
				if doubleColon then
					error := true;
					self.errorMessage := 'Only one "::" sequence is allowed';
					
				else
					doubleColon := true;
					numTally := numTally + 1;
					sValues.add ( "::" );
					state := GOT2NDCOLON;
				endif;
				
			elseif tokenType = DOT then
				error := true;
				self.errorMessage := 'A "." must always be preceded by a decimal value';
				
			elseif tokenType = SPACE or tokenType = END then
				error := true;
				self.errorMessage := 'Value missing after final ":"';
			endif;
			
		else
			error := true;
			self.errorMessage := "*INTERNAL ERROR* Unknown state : " & state.String;
		endif;
	endwhile;
	
	if error then
		sReturn := null;
		
	elseif not mixed and not doubleColon then
		if sValues.size() <> 8 then
			sReturn := null;
			self.errorMessage := "*INTERNAL ERROR* Internal value array is inconsistent";
			
		else
			i := 1;
			while i <= 8 do
				if sValues[i].length() = 4 then
					sReturn := sReturn & sValues[i];
					
				elseif sValues[i].length() > 4 then
					sReturn := sReturn & sValues[i][sValues[i].length()-4 : 4];
					
				else
					sReturn := sReturn & sValues[i].padLeadingZeros(4);
				endif;
				
				i := i + 1;
			endwhile;
		endif;
		
	elseif not doubleColon then // it is a MIXED address
	    if sValues.size() <> 11 or sValues[7] <> "v4" then
	     	sReturn := null;
	       	self.errorMessage := "*INTERNAL ERROR* Internal value array is inconsistent";
			
	    else
	    	i := 1;
	    	while i <= 6 do
	    		if sValues[i].length() = 4 then
					sReturn := sReturn & sValues[i];
					
				elseif sValues[i].length() > 4 then
					sReturn := sReturn & sValues[i][sValues[i].length()-4 : 4];
					
				else
					sReturn := sReturn & sValues[i].padLeadingZeros(4);
				endif;
				
				i := i + 1;
			endwhile;
			
			i := i + 1;
			while i <= 11 do
				sReturn := sReturn & sValues[i].cnDecimalToHex(2);
				i := i + 1;
			endwhile;
		endif;
		
	elseif not mixed then // just a double colon present
		if sValues.size() > 8 then
			sReturn := null;
			self.errorMessage := "*INTERNAL ERROR* Internal value array is inconsistent";
			
		else
			numTally := 0;
			i := 1;
			while i <= sValues.size() do
				if sValues[i] = "::" then
					j := 1;
					while j <= 9 - sValues.size() do
						sReturn := sReturn & "0000";
						j := j + 1;
					endwhile;
					
				else
					if sValues[i].length() = 4 then
						sReturn := sReturn & sValues[i];
						
					elseif sValues[i].length() > 4 then
						sReturn := sReturn & sValues[i][sValues[i].length()-4 : 4];
						
					else
						sReturn := sReturn & sValues[i].padLeadingZeros(4);
					endif;
				endif;
				
				i := i + 1;
			endwhile;
		endif;
		
	else // it is mixed AND a double colon is present
		if sValues.size() > 11 or sValues[sValues.size()-4] <> "v4" then
			sReturn := null;
			self.errorMessage := "*INTERNAL ERROR* Internal value array is inconsistent";
			
		else
			i := 1;
			v4Start := sValues.size() - 4;
			while i < v4Start do
				if sValues[i] = "::" then
					j := 1;
					while j <= 8 - v4Start do
						sReturn := sReturn & "0000";
						j := j + 1;
					endwhile;
					
				else
					if sValues[i].length() = 4 then
						sReturn := sReturn & sValues[i];
						
					elseif sValues[i].length() > 4 then
						sReturn := sReturn & sValues[i][sValues[i].length()-4 : 4];
						
					else
						sReturn := sReturn & sValues[i].padLeadingZeros(4);
					endif;
				endif;
				
				i := i + 1;
			endwhile;
			
			i := i + 1;
			while i <= sValues.size() do
				sReturn := sReturn & sValues[i].cnDecimalToHex(2);
				i := i + 1;
			endwhile;
		endif;
	endif;
	
	return sReturn;	
epilog
	delete sValues;
end;
}
	)
	CnJadeApplication (
	jadeMethodSources
loadSelf
{
loadSelf(pSchemaName, pApplicationName : String) updating;

vars
	cc : CnCntrl;
begin
	self.schemaName 		:= pSchemaName;
	self.applicationName 	:= pApplicationName;
	self.ignoreRegistrationFailure := true;						// PAR 542
	self.myCnKarmaCntrl		:= app.myCnKarmaCntrl;
	if Cn_Debug_NodeProcessMonitoring then
		cc := app.myCnCntrl;									// PAR 1033
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " NODE_MONITOR created " & self.String & 
														   ", schema=" & pSchemaName &
														   ", app=" & pApplicationName, null);
	endif;
end;
}
setAlertTimeStamp
{
setAlertTimeStamp(pTimeStamp : TimeStamp) updating;

vars

begin
	self.alertTimeStamp := pTimeStamp;
end;
}
setIgnoreRegistrationFailure
{
setIgnoreRegistrationFailure(pBool : Boolean) updating;

vars

begin
	self.ignoreRegistrationFailure := pBool;
end;
}
	)
	CnJadeNode (
	jadeMethodSources
delete
{
delete() updating;

vars
	cc	: CnCntrl;
	sd	: CnStackDump;
begin
	if not Cn_Debug_NodeProcessMonitoring then
		return;
	endif;
	
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " NODE_MONITOR deleting " & self.String, null);

	create sd transient;
	sd.dumpCallStack(true, true);
epilog
	delete sd;
end;
}
getNodeTypeString
{
getNodeTypeString() : String;

vars
	type	: Integer;
	
	str		: String;
begin
	type := self.nodeType;
	str := "<unknown nodeType : " & type.String & ">";
	if type = 1 then
		str := "Database Server";
		
	elseif type = 2 then
		str := "Application Server";
	
	elseif type = 3 then
		str := "Single-user Application Server";
		
	elseif type = 4 then
		str := "Standard Fat-Client";
		
	elseif type = 5 then
		str := "SingleUser Fat-Client";
	endif;
	
	return str;
end;
}
loadSelf
{
loadSelf(pInstanceId : Integer; pJadeNode : Node) updating;

vars
	cc			: CnCntrl;
	
	derivedType	: Character;
begin
	cc := app.myCnCntrl;
	self.nodeId 		:= pInstanceId;
	self.osID			:= pJadeNode.osID;
	self.nodeType		:= pJadeNode.nodeType;
	cc.deriveNodeId(pJadeNode, null, derivedType, self.nodeName);
	self.isDefaultValue := true;
	self.maxLocalProcesses := cc.nodeMonitoringMaxProcessDef;
	self.alertTimeStamp	:= null;

	self.myCnKarmaCntrl := app.myCnKarmaCntrl;
	
	if Cn_Debug_NodeProcessMonitoring then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " NODE_MONITOR created " & self.String & 
														   ", instanceId=" & pInstanceId.String &
														   ", osId=" & self.osID.String &
														   ", type=" & self.nodeType.String &
														   ", nodeName=" & self.nodeName, null);
	endif;
end;
}
setAlertTimeStamp
{
setAlertTimeStamp(pTimeStamp : TimeStamp) updating;

vars

begin
	self.alertTimeStamp := pTimeStamp;
end;
}
setIsDefaultValue
{
setIsDefaultValue(pBool : Boolean) updating;

vars

begin
	self.isDefaultValue := pBool;
end;
}
setMaxLocalProcesses
{
setMaxLocalProcesses(pValue : Integer) updating;

vars

begin
	self.maxLocalProcesses := pValue;
end;
}
	)
	CnJadeProcess (
	jadeMethodSources
delete
{
delete() updating;

vars
	cc	: CnCntrl;
	sd	: CnStackDump;
begin
	if not Cn_Debug_NodeProcessMonitoring then
		return;
	endif;
	
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " NODE_MONITOR deleting " & self.String, null);
	create sd transient;
	sd.dumpCallStack(true, true);
epilog
	delete sd;
end;
}
getName
{
getName(): String;

vars

begin
	return self.myCnJadeApplication.schemaName & "," & self.myCnJadeApplication.applicationName;
end;
}
loadSelf
{
loadSelf(pJadeProcess 		: Process; 
		 pCnJadeNode 		: CnJadeNode; 
		 pCnJadeApplication : CnJadeApplication;
		 pKCCMgrStartUp		: Boolean) updating;

vars
	cc			: CnCntrl;
	
	nowSignedOn	: Boolean;
	
	str			: String;

	ts			: TimeStamp;
begin
	cc := app.myCnCntrl;
	// when process is first created, it may not yet be signed on as the logAndValidate user may
	// not yet have been completed. Note that the logon could be some period after the process create.
	nowSignedOn					:= (pJadeProcess.number <> null);
	
	self.processId				:= self.cnGetInstanceId(pJadeProcess);
	self.ipAddress				:= pJadeProcess.networkAddress;
	self.usingThinClient		:= pJadeProcess.isUsingThinClient();
	// attribute signOnTimeServer is a workaround as we are unable to determine the UTC bias for the
	// process, given that the signOnTime is the timestamp local to the workstation (thinclient) or 
	// server (fat-client). Refer to JADE #56295.
	//
	// As KCCMgr will be running most of the time, this timestamp will reflect the actual time when
	// the IDE logon completed (as notification processed by KCCMgr)
	// But note that when KCCMgr is restarted, the signOnTimeServer timestamp reflects when KCCMgr
	// started rather than when the IDE started. This is highlighted by an * in KCCMgr column
	if nowSignedOn and 
	   not self.signedOn then
		self.signOnTimeServer		:= ts;
	endif;
	
	if not self.kccmgrStartUp then
		self.kccmgrStartUp := pKCCMgrStartUp;
	endif;
	
	self.signedOn				:= nowSignedOn;
	self.signOnTime				:= pJadeProcess.signOnTime;
	self.signOnUserCode			:= pJadeProcess.signOnUserCode;
	self.type					:= pJadeProcess.type.Integer;
	self.userCode				:= pJadeProcess.userCode;
	
	if self.myCnJadeApplication = null then						// this allows update to pass null node and appl
		self.myCnJadeApplication	:= pCnJadeApplication;
		self.myCnJadeNode			:= pCnJadeNode;
		self.myCnKarmaCntrl			:= app.myCnKarmaCntrl;
	endif;
	
	if not Cn_Debug_NodeProcessMonitoring then
		return;
	endif;
	
	if pCnJadeNode = null then
		str		:= " updated ";
		
	else
		str		:= " created ";
	endif;
	
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " NODE_MONITOR" & str & self.String & 
													   ", instanceId=" & self.processId.String &
													   ", schema,app='" & self.getName() & "'" &
													   ", node oid=" & self.myCnJadeNode.String &
													   ", node PID=" & self.myCnJadeNode.osID.String &
													   ", node id=" & self.myCnJadeNode.nodeName &
													   ", nowSignedOn=" & nowSignedOn.String &
													   ", process.number=" & pJadeProcess.number.String, null);
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;

vars
	cc			: CnCntrl;
	
	kc			: CnKarmaCntrl;
	
	alertTime	: TimeStamp;
	
	alertType	: Character;
	
	applName,
	nodeName,
	schemaName,
	str			: String;
	
	pid			: Integer;
	
begin
	if eventTag <> CN_PROCESSREGISTRATION_TIMER then
		return;
	endif;
		
	cc := app.myCnCntrl;
	kc := app.myCnKarmaCntrl;
	
	self.notRegistered := true;
	schemaName 	:= self.myCnJadeApplication.schemaName;
	applName	:= self.myCnJadeApplication.applicationName;
	nodeName	:= self.myCnJadeNode.nodeName;
	pid			:= self.myCnJadeNode.osID;
	if self.myCnJadeApplication.ignoreRegistrationFailure then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " NODE_MONITOR " & str & " ignoring registration failure " & self.String & 
															", SOA not yet received for " & schemaName & 
															"::" & applName & 
															" instance " & self.processId.String &
															" running in node " & nodeName &
															" (PID=" & pid.String & ")", null);
		return;
	endif;

	if self.myCnJadeApplication.alertTimeStamp = null then
		alertType := "N";
		self.myCnJadeApplication.setAlertTimeStamp(alertTime);
		str := "create";
	
	else
		alertType := "R";
		alertTime := self.myCnJadeApplication.alertTimeStamp;
		str := "repeat";
	endif;
														
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " NODE_MONITOR " & str & " alert for " & self.String & 
														", SOA not yet received for " & schemaName & 
														"::" & applName & 
														" instance " & self.processId.String &
														" running in node " & nodeName &
														" (PID=" & pid.String & ")", null);
	app.cnRaiseJossAlert(Cn_Karma_Alert,
						 kc.environmentId.toUpper() & " application has not registered and cannot be managed.",
						 schemaName & "::" & applName & " instance " & self.processId.String & 
						 " from node " & nodeName & " (PID=" & pid.String & ") detected as running but has not activated Karma Control." & CrLf &
						 "Open Priority B incident and assign to development group to rectify.",
						 alertType,
						 alertTime,
						 cc.appName,
						 kc.managedEnvironmentName,																				// JSM PAR 8367
						 kc.localFQDN,
						 kc.localIpAddress,
						 kc.myParentTcp);
end;
}
	)
	CnJadeTestCaseListenerIf (
	jadeMethodSources
addTest
{
addTest(pObject : Object);

vars
	duplicate,
	validObject	: Boolean;
begin
	validObject := pObject.isKindOf(Class);
	if not validObject then
		if not pObject.isKindOf(Method) then
			self.writeLog(method.cnGetMethodName() & " invalid object type for unit test : " & pObject.getName() & " " & pObject.String);
			return;
		endif;
	endif;
	// check to see test does not already exist by adding to set first.
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectAlreadyInCollection, self.allTestSet, duplicate);
	self.allTestSet.add(pObject);
	
	if duplicate then
		self.writeLog(method.cnGetMethodName() & " duplicate object : " & pObject.getName());
		return;
	endif;
	
	self.logDebugInfo(method, "adding " & pObject.getName() & " to tests", false);
	self.allTests.add(pObject);
end;
}
addTests
{
addTests();

vars

begin
//	inheritMethod();
//	self.addTest(CardSchemaTestCase_FileMethods);
//	self.addTest(CardSchemaTestCase_karma_lib);
end;
}
create
{
create() updating;

vars
	iniFileName,
	str				: String;
begin
	create self.myLog transient;
	create self.myTestRunner transient;
	app.myJadeTestCaseListener := self;
	iniFileName := app.getIniFileName();
	str := app.getProfileString(iniFileName, CN_CARDLOG, CN_UNITTEST_DEBUG, null);
	if str = null then
		app.setProfileString(iniFileName, CN_CARDLOG, CN_UNITTEST_DEBUG, false.String);
	
	else
		self.setDebug(str.Boolean);
	endif;
end;
}
delete
{
delete() updating;

vars

begin
	delete self.myTestRunner;
	delete self.myLog;
end;
}
finish
{
finish(pElapsedTime : Time; pTestsFailed : Integer; pTestsSkipped : Integer; pTestsSucceeded : Integer);

	/*
		this method stub has been automatically generated by Jade to satisfy interface implementation requirements
	*/

constants
	Pad_Blanks	: Integer	= 7;
vars
	sz		: Integer64;
	
	str		: String;
begin
	self.writeLog("============================================================================");
	if pTestsSkipped > null then
		self.writeLog("Tests Skipped:");
		foreach str in self.testsSkipped do
			self.writeLog("    " & str);
		endforeach;
		
		self.writeLog(null);
	endif;
	
	if pTestsFailed > null then
		self.writeLog("Tests Failed:");
		foreach str in self.testsFailed do
			self.writeLog("    " & str);
		endforeach;
		
		self.writeLog(null);
		self.zCreateErrorFileSentinel(pTestsFailed);				// as unable to set process.userExitCode due to UE 1265 
	endif;

	if self.debug and
	   pTestsSucceeded > null then
		self.writeLog("Tests Succeeded:");
		foreach str in self.testsSucceeded do
			self.writeLog("    " & str);
		endforeach;
		
		self.writeLog(null);
	endif;
	
	self.writeLog("Summary:");
	self.writeLog("    Completed test run     : elapsed " & pElapsedTime.userFormat($CnHHMMSS) & "." & 
														pElapsedTime.milliSecond().String.padLeadingZeros(3));
	self.writeLog("    Tests failed           : " & pTestsFailed.String.padBlanks(Pad_Blanks));
	self.writeLog("    Tests skipped          : " & pTestsSkipped.String.padBlanks(Pad_Blanks));
	self.writeLog("    Total asserts executed : " & self.assertCountTotal.String.padBlanks(Pad_Blanks));
	self.writeLog("    Tests succeeded        : " & pTestsSucceeded.String.padBlanks(Pad_Blanks));
end;
}
logDebugInfo
{
logDebugInfo(pMethod		: Method;
			 pMessage		: String;
			 pSingleTestApp : Boolean);

vars

begin
	if self.debug then
		/*	if pSingleTestApp and
			   app.name <> "JossSingleTestRunner" then
				return;
			endif;
		*/	
		self.writeLog(pMethod.cnGetMethodName() & " - " & pMessage);
	endif;
end;
}
message
{
message(messageText : String);

	/*
		this method stub has been automatically generated by Jade to satisfy interface implementation requirements
	*/

vars
	len	: Integer;
begin
	len := messageText.length();
	if messageText[len-5:end] = " start" or
	   messageText[len-3:end] = " end" 	then
		return;
	endif;
	
	self.writeLog("Message : " & messageText);
end;
}
methodSuccess
{
methodSuccess(testMethodName : String) updating;

	/*
		this method stub has been automatically generated by Jade to satisfy interface implementation requirements
	*/

vars
	str	: String;
begin
	str := testMethodName.padBlanks(84) & "asserts = " & self.assertCount.userNumberFormat($CnWholeNumbers);
	self.testsSucceeded.add(str);
	self.logDebugInfo(method, str, false);
	self.assertCount := null;
end;
}
preStart
{
preStart();
/*
*/
vars
	file	: File;
	
	path	: String;
begin
	path := path.cnGetServerMiscPathFromAppDbpath();
	create file transient;
	file.fileName := path & CN_BACK_SLASH & app.name & ".err";
	file.mode := file.Mode_Input;
	file.cnRemoveFile(5, 1000);
epilog
	delete file;
end;
}
runTests
{
runTests() updating;

vars
	ts	: TimeStamp;
begin
	self.preStart();
	self.setMyLogFileName();
	self.logDebugInfo(method, "Setting up for unit tests...", false);

	self.addTests();
	if self.allTests.isEmpty() then
		self.writeLog("No unit tests to execute");
		return;
	endif;
	
	self.logDebugInfo(method, "Starting unit tests...", false);
	self.myTestRunner.setTestListener(self);
	self.myTestRunner.runTests(self.allTests);
	self.logDebugInfo(method, "End of unit tests.", false);
end;
}
setDebug
{
setDebug(pValue : Boolean) updating;

vars

begin
	self.debug := pValue;
end;
}
setMyLogFileName
{
setMyLogFileName() updating;

vars
	ts	: TimeStamp;
begin
	self.myLog.fileName := app.name 								& CN_UNDERSCORE &
							"unitTestResults" 						& CN_UNDERSCORE &
							ts.date().cnUserFormat($CnCCYYMMDD_ns) 	& CN_UNDERSCORE &
							ts.time().cnUserFormat($CnHHMMSS_ns);
	self.myLog.formatOutput := false;
end;
}
start
{
start(numberOfTestMethods : Integer);

	/*
		this method stub has been automatically generated by Jade to satisfy interface implementation requirements
	*/

vars

begin
	self.writeLog("Starting unit test run (" & app.name & ") : " & numberOfTestMethods.String & " tests to execute");
end;
}
testFailure
{
testFailure(testMethodName : String; callStack : String; failureReason : String);

	/*
		this method stub has been automatically generated by Jade to satisfy interface implementation requirements
	*/

vars

begin
	self.writeLog(null);
	self.writeLog(">>>> Test failed : at assert #" & (self.assertCount + 1).String & " in " & testMethodName);
	self.writeLog(">>>>     Reason : " & failureReason);
	self.writeLog(">>>>     Call Stack : " & callStack);
	self.writeLog(null);
	if not self.testsFailed.includes(testMethodName) then
		self.testsFailed.add(testMethodName);
	endif;
end;
}
testSkipped
{
testSkipped(testMethodName : String);

	/*
		this method stub has been automatically generated by Jade to satisfy interface implementation requirements
	*/

vars

begin
	self.testsSkipped.add(testMethodName);
	self.logDebugInfo(method, "### Test skipped : " & testMethodName, false);
end;
}
testSuccess
{
testSuccess(testMethodName : String) updating;

	/*
		this method stub has been automatically generated by Jade to satisfy interface implementation requirements
	*/

vars

begin
	self.assertCount 		:= self.assertCount + 1;
	self.assertCountTotal 	:= self.assertCountTotal + 1;
//	self.logDebugInfo(method, testMethodName & " : assert #" & self.assertCount.String & " succeeded", false);
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;

vars

begin
	self.runTests();
epilog
	delete self;
	terminate;
end;
}
writeLog
{
writeLog(pText	: String);

vars
	line	: String;
	
	ts		: TimeStamp;
begin
	line := ts.date().cnUserFormat($CnCCYYMMDD) & " " &
			ts.time().cnUserFormat($CnHHMMSS) & "." &
			ts.time().milliSecond().String.padLeadingZeros(3) & " " &
			pText;
	self.myLog.info(line);
end;
}
zCreateErrorFileSentinel
{
zCreateErrorFileSentinel(pTestsFailed : Integer) protected;

vars
	file	: File;
	
	path	: String;
begin
	path := path.cnGetServerMiscPathFromAppDbpath();
	create file transient;
	file.fileName := path & CN_BACK_SLASH & app.name & ".err";
	file.mode := file.Mode_Output;
	file.open();
	file.writeLine(pTestsFailed.String & " tests failed");
	file.close();
epilog
	delete file;
end;
}
	)
	CnLockCheck (
	jadeMethodSources
exceptionHandler
{
exceptionHandler(exObj : Exception; pError : Boolean output) : Integer;

vars
	cc		: CnCntrl;

	obj		: Object;
begin
	cc		:= app.myCnCntrl;
	obj		:= exObj.errorObject;
	
	if obj.isKindOf(Lock) or
	   obj.isKindOf(Process) then
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " : " & obj.String & " no longer valid ... skipping", null);
		pError	:= true;
		return Ex_Resume_Next;
	endif;
	
	return Ex_Pass_Back;
end;
}
getIniFileValues
{
getIniFileValues(pLogValues,
				 pLogValuesIfDifferent	: Boolean) updating;
/*
	Purpose : 
	
	Get ini file values depending on the database role.
	If the ini file items have'nt been defined yet, initialize with default values.
*/
vars
	cc								: CnCntrl;
	
	changedValues,
	newCheckShareLocks,
	oldCheckShareLocks				: Boolean;
	
	databaseRole,
	newLockCheckInterval,
	newMaxLocks,
	newMaxLockTime,
	oldLockCheckInterval,
	oldMaxLocks,
	oldMaxLockTime					: Integer;

	iniFileName,
	iniFileUpdating,
	iniVerb_CheckShareLocks,
	iniVerb_LockCheckInterval,
	iniVerb_MaxLocksRequested,
	iniVerb_MaxLockTimeBeforeAlarm,
	str								: String;
begin
	cc					:= app.myCnCntrl;
	oldCheckShareLocks	:= self.checkShareLocks;
	oldLockCheckInterval:= self.lockCheckInterval;
	oldMaxLocks			:= self.maxLocksRequested;
	oldMaxLockTime		:= self.maxLockTimeBeforeAlarm;
	databaseRole		:= self.zGetIniFileVerbsBasedOnDatabaseRole(iniVerb_CheckShareLocks,
																	 iniVerb_LockCheckInterval,
																	 iniVerb_MaxLocksRequested,
																	 iniVerb_MaxLockTimeBeforeAlarm);
	iniFileName 		:= app.getIniFileName();
	iniFileUpdating		:= "Updated " & iniFileName & " : [" & CN_APPEXCEPTIONS & "] ";
	str 				:= app.getProfileString(iniFileName, CN_APPEXCEPTIONS, iniVerb_CheckShareLocks, null);
	if str = null then
		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " " & iniFileUpdating & iniVerb_CheckShareLocks & 
																	" not defined, updating and defaulting to false", null);
		newCheckShareLocks	:= false;
		app.setProfileString(iniFileName, CN_APPEXCEPTIONS, iniVerb_CheckShareLocks, newCheckShareLocks.String);				// PAR 1091

	else
		newCheckShareLocks := str.Boolean;
	endif;
	
	str					:= app.getProfileString(app.getIniFileName, CN_APPEXCEPTIONS, iniVerb_LockCheckInterval, null);
	if str = null then
		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " " & iniFileUpdating & iniVerb_LockCheckInterval & 
																	" not defined, updating and defaulting to 0", null);
		newLockCheckInterval	:= null;
		app.setProfileString(app.getIniFileName, CN_APPEXCEPTIONS, iniVerb_LockCheckInterval, newLockCheckInterval.String);		// PAR 1091
	
	else
		newLockCheckInterval	:= str.Integer * 1000;	// convert to millisecs													// PAR 1091
	endif;
		
	str					:= app.getProfileString(iniFileName, CN_APPEXCEPTIONS, iniVerb_MaxLocksRequested, null);
	if str = null then
		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " " & iniFileUpdating & iniVerb_MaxLocksRequested & 
																	" not defined, updating and defaulting to 10,000", null);
		newMaxLocks 		:= 10000;
		app.setProfileString(iniFileName, CN_APPEXCEPTIONS, iniVerb_MaxLocksRequested, newMaxLocks.String);
	
	else
		newMaxLocks 		:= str.Integer;																						// PAR 1091
		if newMaxLocks < 10000 then																								// PAR 1091
			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " " & iniFileUpdating & iniVerb_MaxLocksRequested & 		// PAR 1091
														" invalid value : " & str & ", updating with minimum value 10,000", null);	// PAR 1091
			newMaxLocks 		:= 10000;																						// PAR 1091
			app.setProfileString(iniFileName, CN_APPEXCEPTIONS, iniVerb_MaxLocksRequested, newMaxLocks.String);					// PAR 1091
		endif;																													// PAR 1091
	endif;

	str					:= app.getProfileString(app.getIniFileName, CN_APPEXCEPTIONS, iniVerb_MaxLockTimeBeforeAlarm, null);
	if str = null then
		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " " & iniFileUpdating & iniVerb_MaxLockTimeBeforeAlarm & 
																		" not defined, updating and defaulting to 60", null);
		newMaxLockTime		:= 60;
		app.setProfileString(app.getIniFileName, CN_APPEXCEPTIONS, iniVerb_MaxLockTimeBeforeAlarm, newMaxLockTime.String);		// PAR 1091
	
	else
		newMaxLockTime		:= str.Integer;
		if newMaxLockTime < 60 then																								// PAR 1091
			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " " & iniFileUpdating & iniVerb_MaxLockTimeBeforeAlarm & 	// PAR 1091
														" invalid value : " & str & ", updating with minimum value 60", null);	// PAR 1091
			newMaxLockTime 		:= 60;																							// PAR 1091
			app.setProfileString(iniFileName, CN_APPEXCEPTIONS, iniVerb_MaxLockTimeBeforeAlarm, newMaxLockTime.String);			// PAR 1091
		endif;																													// PAR 1091
	endif;
	
	if newCheckShareLocks <> oldCheckShareLocks 	or
	   newLockCheckInterval	<> oldLockCheckInterval or
	   newMaxLocks			<> oldMaxLocks 			or
	   newMaxLockTime		<> oldMaxLockTime		then
		changedValues := true;
		beginTransientTransaction;
		self.checkShareLocks		:= newCheckShareLocks;
		self.lockCheckInterval		:= newLockCheckInterval;																	// PAR 1091
		self.maxLocksRequested		:= newMaxLocks;
		self.maxLockTimeBeforeAlarm	:= newMaxLockTime;
		commitTransientTransaction;
	endif;
epilog
	if pLogValues	then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " [" & CN_APPEXCEPTIONS & "] lock check values are:" &
																		iniVerb_CheckShareLocks & "=" & newCheckShareLocks.String & ", " &
																		iniVerb_LockCheckInterval & "=" & newLockCheckInterval.String & ", " &
																		iniVerb_MaxLocksRequested & "=" & newMaxLocks.String & ", " &
																		iniVerb_MaxLockTimeBeforeAlarm & "=" & newMaxLockTime.String, null);
	
	elseif pLogValuesIfDifferent then
		if changedValues	then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " [" & CN_APPEXCEPTIONS & "] lock check values have changed:", null);					// PAR 1091
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & "    - " & iniVerb_CheckShareLocks & "=" & newCheckShareLocks.String & 				// PAR 1091
																			", was=" & oldCheckShareLocks.String, null);								// PAR 1091
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & "    - " & iniVerb_LockCheckInterval & "=" & (newLockCheckInterval div 1000).String & 	// PAR 1091
																			", was=" & (oldLockCheckInterval div 1000).String, null);					// PAR 1091
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & "    - " & iniVerb_MaxLocksRequested & "=" & newMaxLocks.String & 						// PAR 1091
																			", was=" & oldMaxLocks.String, null);										// PAR 1091
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & "    - " & iniVerb_MaxLockTimeBeforeAlarm & "=" & newMaxLockTime.String & 				// PAR 1091
																			", was=" & oldMaxLockTime.String, null);									// PAR 1091
		endif;
	endif;
end;
}
startLockCheckIfRequired
{
startLockCheckIfRequired() updating;
/*
	Purpose :
	
	This method is executed by KCCMgr on start up.
	If the LockCheckInterval is greater than zero then start up KCLockCheck
*/
vars
	cc				: CnCntrl;
	
	checkShareLocks : Boolean;
	
	lockCheckInterval,
	maxLocks,
	maxLockTime 	: Integer;
begin
	cc				:= app.myCnCntrl;
	if not app.isMultiUser() then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " single user, ignore lock checking", null);
		return;
	endif;
	
	self.getIniFileValues(true, false);
	if self.lockCheckInterval > null then
		// As from 3.8.09, if extended lock checking is required we now unconditionally start KCLockCheck application.			// PAR 977
		// Previously, if the maximum locks requested exceeded 10,000 (the default) then the extended lock checks was			// PAR 977
		// performed by KCCMgr. This meant that KCCMgr was busy doing extended lock checks while notifications and				// PAR 977	
		// TCP messages were queuing.
		cc.cnWriteLog(cc.CnLogComment, "Extended lock check interval has been specified, starting " & CN_KCLOCKCHECK, null);
		app.startApplication(CN_CARDSCHEMA, CN_KCLOCKCHECK);
    	
    else
     	cc.cnWriteLog(cc.CnLogComment, "Lock checking is NOT active.", null);
    endif;
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;

vars
	cc					: CnCntrl;
begin
	cc := app.myCnCntrl;
	
	if eventTag <> CN_LOCK_CHECK_TIMER then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " unexpected timer : eventTag=" & eventTag.String, null);
		return;
	endif;
	
	//
	//  This code is executed by KCLockCheck if LockCheckInterval > 0 in the [AppExceptions] section of 
	//  its ini file.  See end of CardSchema::cnInitialiseKCLockCheck for start up code. 
	//
	if self.inTakeoverState then																								// PAR 1003
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " takeover occurring, ignoring extended lock checks.", null);		// PAR 1003
	
	else																														// PAR 1003
		self.zCheckLockStatus();
	endif;																														// PAR 1003
	
	if self.lockCheckInterval <> null then
		self.beginTimer(self.lockCheckInterval, Timer_OneShot, CN_LOCK_CHECK_TIMER);	
	endif;
end;
}
userNotification
{
userNotification(eventType: Integer; theObject: Object; eventTag: Integer; userInfo: Any) updating;

vars
	cc					: CnCntrl;
	
	functionAgent		: CnFunctionAgent;																						// PAR 1003
	
	proc				: Process;
	
	error,
	isHostileTakeover,																											// PAR 1003
	takeOverState		: Boolean;			
	
	constName			: String;
begin
	cc := app.myCnCntrl;
	if eventType = CN_LOCK_CHECKS_EVENT_DISABLE then
		constName	:= "CN_DISABLE_LOCK_CHECKS_EVENT";
		
	elseif eventType = CN_LOCK_CHECKS_EVENT_ENABLE then
		constName	:= "CN_ENABLE_LOCK_CHECKS_EVENT";
		
	elseif eventType = SDS_RoleChangeEvent then																					// PAR 1003
		constName	:= "SDS_RoleChangeEvent";																					// PAR 1003

	elseif eventType = SDS_RoleChangeProgress then																				// PAR 1003
		constName	:= "SDS_RoleChangeProgress";																				// PAR 1003
		
	else
		constName	:= "<unknown : " & eventType.String & ">";
	endif;

	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " eventType=" & eventType.String & " (" &
								constName & "), userInfo=" & userInfo.Binary.ansiToString, null);

	//////////////////////////  Lock Checks Disable Event  /////////////////////////////////////////////////
	
	if eventType = CN_LOCK_CHECKS_EVENT_DISABLE then
		proc	:= theObject.Process;
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectAlreadyInCollection, self.processesWithNoLockChecks, error);
		self.processesWithNoLockChecks.add(proc);
		if not error then
			cc.cnWriteLog(cc.CnLogComment, "Lock checks disabled for " & proc.String & " (app=" & proc.persistentApp.name & 
										" on node " & proc.node.name & ")", null);
		endif;
		
		return;
	endif;			

	//////////////////////////  Lock Checks Enable Event  /////////////////////////////////////////////////
	
	if eventType = CN_LOCK_CHECKS_EVENT_ENABLE then
		proc	:= theObject.Process;
		exclusiveLock(self.processesWithNoLockChecks);
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_EntryNotFoundInCollection, self.processesWithNoLockChecks, error);
		self.processesWithNoLockChecks.remove(proc);
		if not error then
			cc.cnWriteLog(cc.CnLogComment, "Lock checks enabled for " & proc.String & " (app=" & proc.persistentApp.name & 
										" on node " & proc.node.name & ")", null);
		endif;
		
		return;
	endif;
	
	// PAR 1003. Extended lock checking is to be suspended during a take over													// PAR 1003
	if eventType = SDS_RoleChangeEvent then					// 22																// PAR 1003
		if self.inTakeoverState then																							// PAR 1003
			beginTransientTransaction;																							// PAR 1003
			self.inTakeoverState := false;																						// PAR 1003
			self.hostileTakeover := false;																						// PAR 1003
			commitTransientTransaction;																							// PAR 1003
			
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " takeover completed, database role changed to " & userInfo.String, null);	// PAR 1003
		endif;																													// PAR 1003
		
		return;																													// PAR 1003
	endif;																														// PAR 1003
	
	// PAR 1003. Extended lock checking is to be suspended during a take over													// PAR 1003
	if eventType = SDS_RoleChangeProgress then					// 17387														// PAR 1003
		create functionAgent transient;																							// PAR 1003
		takeOverState	:= self.inTakeoverState;																				// PAR 1003
		isHostileTakeover := self.hostileTakeover;																				// PAR 1003
		functionAgent.cnHandleRoleChangeProgressEvent(userInfo.Integer, takeOverState, isHostileTakeover);						// PAR 1003
		if takeOverState <> self.inTakeoverState then																			// PAR 1003
			beginTransientTransaction;																							// PAR 1003
			self.inTakeoverState := takeOverState;																				// PAR 1003
			self.hostileTakeover := isHostileTakeover;																			// PAR 1003
			commitTransientTransaction;																							// PAR 1003
		endif;																													// PAR 1003
		
		return;																													// PAR 1003
	endif;																														// PAR 1003
epilog																															// PAR 1003
	delete functionAgent;																										// PAR 1003
end;
}
zCheckLockStatus
{
zCheckLockStatus() updating, protected;

vars
	cc					: CnCntrl;

	kc					: CnKarmaCntrl;
	
	lock				: Lock;

	nod					: Node;
	
	lockTarget			: Object;
	
	proc				: Process;

	sArray				: CnStringArray;

	array				: LockArray;
	
	error				: Boolean;

	d1,
	d2,
	d3					: Decimal[23];


	count,
	duration,
	secs				: Integer;

	procAppName,																												// PAR 919
	str,
	str2				: String;

	time				: Time;
begin
	d1 					:= app.relativeMachineTime();
	cc					:= app.myCnCntrl;
	kc					:= app.myCnKarmaCntrl;
	self.getIniFileValues(false, true);																							// PAR 1003
	create array transient;
	create sArray transient;
	d2 := app.relativeMachineTime();
	system.getLocks(array, self.maxLocksRequested);
	d3 := app.relativeMachineTime();
	on SystemException do self.exceptionHandler(exception, error);
	
	foreach lock in array do
		error				:= false;
		duration			:= lock.duration.Integer;
		if error then
			continue;
		endif;
		
		if duration <> Transaction_Duration then
			continue;
		endif;
		
		if lock.kind <> lock.Kind_Normal then
			continue;
		endif;
		//
		// CardSchema holds Session Duration locks on CnLockTarget, and we aren't interested in locks on stable objects
		//
		if lock.lockedBy <> null then
			continue;
		endif;
		
		if checkShareLocks 					or 
		   lock.type.Integer <> Share_Lock	then
			count		:= count + 1;
			time		:= lock.elapsedTime;
			secs		:= time.hour * 3600 + time.minute * 60 + time.second;

			if secs <= self.maxLockTimeBeforeAlarm then
				continue;
			endif;
			
			proc		:= lock.requestedBy;
			nod			:= proc.node;
			if error then
				continue;
			endif;
			
			// Now get the lock target and reference it (using .edition).
			// This will check to see if the target object being locked is still in existence.
			// Refer to JADECare Start PAR #793 and JADE contact #59116.
			lockTarget 	:= lock.target();
			if not app.isValidObject(lockTarget) then
				continue;
			endif;
			
			procAppName := proc.persistentApp.name;																			// PAR 919
			str			:= "- App=" & procAppName & "/" & cnGetInstanceId(proc).String &									// PAR 1081
						   ", node=" & nod.name & 																			// PAR 1081
						   ", sign-on user=" & proc.signOnUserCode & 														// PAR 1081
						   ", usercode=" & proc.userCode & 																	// PAR 1081
						   " : " & lock.getLockType() & " " & lock.target.String & " locked for " & time.String;			// PAR 1081
			if processesWithNoLockChecks.includes(proc) then																// PAR 1081
				cc.cnWriteLog(cc.CnLogComment, "Process disabled lock check " & str, null);									// PAR 1081
				continue;																									// PAR 1081
			endif;																											// PAR 1081
			
			if procAppName <> "JadePrimaryServerAgentApp" 	and																// PAR 320, 1081
			   procAppName <> "JadeLoaderNonGui"			and																// PAR 919
			   procAppName <> "JadeFileLoaderNonGui"		then															// PAR 974
				sArray.add(str);																							// PAR 1081
			endif;
		endif;
	endforeach;

	if not sArray.isEmpty() then
		str2	:= "The following applications in this system have extended locks:" & CrLf;
		foreach str in sArray do
			str2	:= str2 & str & CrLf;
		endforeach;
		
		cc.cnWriteLog(cc.CnLogErrors, str2 & " : raising alert to JSM.", null);
		app.cnRaiseJossAlert(Cn_Karma_Alert,
							 Cn_ExtendedLockAlarm & " for environment " & kc.environmentId.toUpper() & " on " & nod.cnGetComputerName,	// PAR 7040
					     	 str2,
					     	 "N",
					     	 app.actualTime,
					     	 cc.appName,
					     	 kc.managedEnvironmentName,																			// JSM PAR 8367
					     	 nod.cnGetComputerName,
					     	 nod.networkAddress,
					     	 kc.myParentTcp);
	endif;

	cc. cnWriteLog(cc.CnLogComment, "Extended locks check completed, " & 
									d1.cnGetElapsedTimeString() & 
									", getLocks elapsed " & (d3-d2).userNumberFormat($CnWholeNumbers) & "ms" &
									", actual locks " & array.size().userNumberFormat($CnWholeNumbers) &
									", Normal Locks " & count.userNumberFormat($CnWholeNumbers), null);
									
	if self.lockCheckInterval = null 	and
	   app.name <> CN_KCCMGR			then
		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " lock check interval set to zero, terminating ....", null);
		app.cnTerminate();
	endif;
epilog
	array.purge();
	delete array;
	delete sArray;
end;
}
zGetIniFileVerbsBasedOnDatabaseRole
{
zGetIniFileVerbsBasedOnDatabaseRole(pIniVerb_CheckShareLocks,
									pIniVerb_LockCheckInterval,
									pIniVerb_MaxLocksRequested,
									pIniVerb_MaxLockTimeBeforeAlarm : String output) : Integer protected;

vars
	databaseRole	: Integer;
begin
	databaseRole	:= system.getDatabaseRole();
	if databaseRole = SDS_RoleSecondary then
		pIniVerb_CheckShareLocks		:= CN_CHECKSHARELOCKS_SECONDARY;
		pIniVerb_LockCheckInterval		:= CN_LOCKCHECKINTERVAL_SECONDARY;
		pIniVerb_MaxLocksRequested		:= CN_MAXLOCKSREQUESTED_SECONDARY;
		pIniVerb_MaxLockTimeBeforeAlarm	:= CN_MAXLOCKTIMEBEFOREALARM_SECONDARY;
		
	else
		pIniVerb_CheckShareLocks		:= CN_CHECKSHARELOCKS;
		pIniVerb_LockCheckInterval		:= CN_LOCKCHECKINTERVAL;
		pIniVerb_MaxLocksRequested		:= CN_MAXLOCKSREQUESTED;
		pIniVerb_MaxLockTimeBeforeAlarm	:= CN_MAXLOCKTIMEBEFOREALARM;
	endif;
	
	return databaseRole;
end;
}
	)
	CnManagerClass (
	jadeMethodSources
cnDefineTransientsToIgnore
{
cnDefineTransientsToIgnore(pObjectArray : ObjectArray input);

//		add user-logic to add those transient instances to input array that are to be ignored when doing transient checks


vars

begin
	if app.myTransientCnIpAddress <> null then
		pObjectArray.add(app.myTransientCnIpAddress);
	endif;
end;
}
	)
	CnBatchMgr (
	jadeMethodSources
create
{
create() updating;

vars
	
begin
	//  Note that you can't put code in here that references other classes e.g. app,
	//  because the constructor gets called even when you use _executeMethod via JADLOADB.
end;
}
doAuditStopTracking
{
doAuditStopTracking(reason : Integer);
/*   
	Do not mark as protected.
	
	This method is executed externally by JSA via JADLOADB during off-line deployments to SDS primaries,
	to stop tracking all.
	
	Used in:
	Srv_Transition::run

*/
vars
	journal : Integer;
	offset	: Integer;
	dba		: JadeDatabaseAdmin;
begin
	create dba transient;
	dba.sdsAuditStopTracking(SDS_AuditStopTrackingAll, reason, journal, offset);
	
epilog
	delete dba;
end;
}
exceptionHandler
{
exceptionHandler(exObj : Exception) : Integer;

vars
	sd			: CnStackDump;
	callStack	: String;
begin
	self.log(">>> Exception " & exObj.errorCode.String & " (" & exObj.text() & "; " & exObj.extendedErrorText & ") <<<");
	create sd transient;
	callStack := sd.dumpCallStack(false, false);	// false means no logging into app.myCnCntrl
	self.log(callStack);
	abortTransaction;
	abortTransientTransaction;
	return Ex_Abort_Action;
epilog
	delete sd;
end;
}
exceptionHandler_CreateRpsDatabase
{
exceptionHandler_CreateRpsDatabase(exObj : Exception; hadException : Boolean output) : Integer;

vars
	sd			: CnStackDump;
	callStack	: String;
begin
	self.log(">>> Exception " & exObj.errorCode.String & " (" & exObj.text & ") <<<");
	create sd transient;
	callStack := sd.dumpCallStack(false, false);	// false means no logging into app.myCnCntrl
	self.log(callStack);
	return Ex_Resume_Next;
epilog
	delete sd;
end;
}
exceptionHandler_rpsExtract
{
exceptionHandler_rpsExtract(exObj : Exception) : Integer;

vars
	sd			: CnStackDump;
	callStack	: String;
begin
	if exObj.errorCode = JErr_RpsExtractRequestError then
		self.zReportError("RPS Extract Exception : " & exObj.extendedErrorText);
	
	else
		self.log(">>> Exception " & exObj.errorCode.String & " (" & exObj.text() & "; " & exObj.extendedErrorText & ") <<<");
		create sd transient;
		callStack := sd.dumpCallStack(false, false);	// false means no logging into app.myCnCntrl
		self.log(callStack);
	endif;
	
	return Ex_Resume_Next;
end;
}
initialize
{
initialize() updating;

/*
	Purpose:
	
	Refer to PAR 1072.
	
	If [CardLog] LogPath specified an invalid path then this would cause the 
	initialization to incur an unhandled exception and immediately terminate.
*/
vars
	cem				: CnExternalMethods;
	
	ff				: FileFolder;
	
	date			: Date;
	
	pos				: Integer;
	
	dbPath,
	envName,
	logPath,
	newLogPath		: String;
begin
	app.myCnManagerClass := self;
	dbPath			:= app.dbPath;
	dbPath.replaceChar(CN_BACK_SLASH, CN_SLASH);
	pos				:= 2;					// skip /opt if Linux
	dbPath.scanUntil(CN_SLASH, pos);
	pos				:= pos + 1;
	envName			:= dbPath.scanUntil(CN_SLASH, pos);
	logPath			:= app.getProfileString(app.getIniFileName, "CardLog", "LogPath", dbPath[1:pos] & "logs");
	create ff transient;
	ff.fileName := logPath;
	if not ff.isAvailable() then
		newLogPath := dbPath[1:pos] & "logs";
		if logPath <> newLogPath then
			create cem transient;
			cem.emSendStdOut("[CardLog] logpath '" & logPath & "' doesn't exist, default to '" & newLogPath & "'" & CrLf);
		endif;
		
		logPath := newLogPath;
		ff.fileName := logPath;
		if not ff.isAvailable() then
			ff.make();
		endif;
	endif;
	
	self.environmentName	:= envName;
	create self.myLog transient;
	self.myLog.mode		:= File.Mode_Append;
	self.myLog.fileName	:= logPath & "/cn_batchcontrol_" & date.userFormat($CnCCYYMMDD_ns) & ".log";
	self.log("------------------ Application start up  --------------------------");
epilog
	delete ff;
	delete cem;
end;
}
log
{
log(text : String) clientExecution;

vars
	log		: File;
	s		: String;
	t		: TimeStamp;
begin
	log		:= myLog;
	t		:= app.actualTimeAppServer();
	s 		:= t.date.userFormat($CnCCYYMMDD) & " " & 
			   t.time.String & "." & t.time.milliSecond.String.padLeadingZeros(3) & ": " &
	           app.name & 						// leave app.name as is, CnBatchMgr doesn't instantiate app.myCnCntrl
			   "/" & cnGetInstanceId64(process).String & ": " & text;
	log.writeLine(s);
end;
}
sendResponse
{
sendResponse(msg : Binary);

vars
	tcp		: CnDeployMgrTcpConnection;
begin
	create tcp;
	tcp.message	:= msg;
	tcp.myCnBatchMgr	:= self;
	self.log("Opening connection to JSA on port " & KCDEPLOY_TO_JSA_PORT.String & "....");
	tcp.cnOpen("localhost", KCDEPLOY_TO_JSA_PORT, tcp);
end;
}
setDeploymentStatus
{
setDeploymentStatus(status : Integer) updating;
/*   
	Do not mark as protected.
	
	This method is executed externally by JSA via JADLOADB during off-line deployments to SDS primaries,
	 to insert deployment status indicators for secondaries.
	 
	Used in:
	Srv_InstallStart::run
	Srv_LoadJadeUpgrade::run
	Srv_LoadMisc::run
	Srv_PostLoadE::run
	Srv_RunPreScript0::run
	Srv_Transition::run
*/
vars
	root	: CnRoot;
	dba		: JadeDatabaseAdmin;
	journal	: Integer;
	offset	: Integer;
begin
	//   This method is executed externally by JSA via JADLOADB during off-line deployments to SDS primaries,
	//	 to insert deployment status indicators for secondaries.
	//
	if system.getDatabaseRole() <> SDS_RolePrimary then
		return;
	endif;

	root	:= CnRoot.firstInstance;		
	beginTransaction;						
	root.setDeploymentStatus(status);
	commitTransaction;

	if status > null then						// status = 0 is a reset at the very start of installation, so
		//									// we don't want to stop tracking
		create dba transient;
		dba.sdsAuditStopTracking(SDS_AuditStopTrackingAll, status, journal, offset);
	
		beginTransaction;					// Do this extra update AFTER the sdsAuditStopTracking, to force
		root.setDeploymentStatus(status);	// immediate transfer of the block to the secondary
		commitTransaction;
	endif;
	
epilog
	delete dba;
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;

vars
	databaseRole,																												// PAR 1089
	pos				: Integer;

	action,
	str,
	sdsSecs			: String;
begin
//	self.zValidateUser();					// Check usercode

	on Exception do self.exceptionHandler(exception) global;
	
	if eventTag = Cn_SDS_PreTakeOver_Timeout then
		foreach str in self.secondaryNameArray do
			sdsSecs := sdsSecs & str & CrLf;
		endforeach;
		
		self.zReportError("SDS preTakeOver action failed. No response from :" & CrLf & sdsSecs);
		terminate;
	endif;
	
	if eventTag = CN_WAIT_TAKEOVER_ROLECHANGE then																				// PAR 1089
		databaseRole := system.getDatabaseRole;																					// PAR 1089
		if databaseRole = SDS_RoleSecondary then																				// PAR 1089
			self.log("Database role has changed to Secondary, takeover completed");												// PAR 1089
			terminate;																											// PAR 1089
		endif;																													// PAR 1089
		
		self.log("Database role is still primary, waiting for role change...");													// PAR 1089
		return;																													// PAR 1089
	endif;																														// PAR 1089
	
	if initParams = null then
		self.zReportError("No parameters located");
		terminate;
	endif;
	
	str		:= initParams.first;			// should only be one element in array, for current implementation
	pos		:= 1;
	pos		:= str.pos("action=", pos);
	if pos > 0 then
		pos	:= pos + 7;
		action	:= str.scanUntil(" ", pos).toLower;
	endif;
	
	log("Now processing requested action '" & action & "'...");	
	
	self.zHandleActions(action);			// this method execution allows the method to be re-implemented in JSM/JSA etc
	
epilog
	if process.isInExceptionState then
		self.zReportError(method.cnGetMethodName() & " process.isInExceptionState=true");
		terminate;
	endif;
end;
}
userNotification
{
userNotification(eventType: Integer; theObject: Object; eventTag: Integer; userInfo: Any) updating;

vars
	function		: CnFunctionAgent;																							// PAR 1089
	
	index,
	takeOverState	: Integer;																									// PAR 1089
	
	connName,
	str				: String;																									// PAR 1089
begin
	on Exception do self.exceptionHandler(exception) global;

	if eventType = Process_TDB_Analysis_Event then
		self.userNotification_zTransientFileAnalysis(theObject.Process, userInfo.String);
		return;
	endif;
	
	if eventType = Process_TDB_Info_Event then
		self.userNotification_zTransientFileInfo(theObject.Process, userInfo.String);
		app.cnTerminate();
	endif;
	
	if eventType = Cn_SDS_PreTakeOver_Response then
		connName := userInfo.String;
		self.secondaryNameArray.remove(connName.toLower());
		index := self.secondaryNameHoldArray.indexOf(connName.toLower());
		self.log("Received PreTakeOver response from " & connName & " [" & index.String & "].");
		
		if self.secondaryNameArray.isEmpty() then
			self.endTimer(Cn_SDS_PreTakeOver_Timeout); // stop the timeout timer
			if self.negotiatedTakeOverRequest then
				self.log("PreTakeOver request completed, starting negotiated takeover...");										// PAR 1089
				self.zInitiateSDSNegotiatedTakeOver();
				self.log("Waiting for role change...");																			// PAR 1089
				
			else
				self.log("PreTakeOver request completed.");
				terminate;																										// PAR 1089
			endif;
		endif;
	endif;
	
	if eventType = SDS_RoleChangeProgress then																					// PAR 1089
		takeOverState := userInfo.Integer;																						// PAR 1089
		create function transient;																								// PAR 1089
		str := function.cnGetTakeoverStateString(takeOverState);																// PAR 1089
		self.log("RoleChangeProgress event (" & SDS_RoleChangeProgress.String & ") : " & str);									// PAR 1089
		if takeOverState = SDS_TakeoverAbandoned then																			// PAR 1089
			self.zReportError("Takeover has been abandoned");																	// PAR 1089
			terminate;																											// PAR 1089
		endif;																													// PAR 1089
		
		if takeOverState = SDS_TakeoverFailure then																				// PAR 1089
			self.zReportError("Takeover has failed");																			// PAR 1089
			terminate;																											// PAR 1089
		endif;																													// PAR 1089
	endif;																														// PAR 1089
	
	if eventType = Process.RPS_EXTRACT_FAILED_EVENT then
		self.zReportError("RPS Data Extract failed, refer to jommsg and datapump logs");
		app.cnTerminate();
	endif;

	if eventType = Process.RPS_EXTRACT_FINISHED_EVENT then
		self.log("RPS Data Extract completed");
		app.cnTerminate();
	endif;
epilog
	delete function;																											// PAR 1089
	if process.isInExceptionState then
		self.zReportError(method.cnGetMethodName() & " process.isInExceptionState=true");
		terminate;
	endif;
end;
}
userNotification_zAnalyzeTransients
{
userNotification_zAnalyzeTransients(pProcess : Process; pUserInfo : String) protected;

vars
	cc				: CnCntrl;
	
	file			: File;
	
	iCreatedCnCntrl	: Boolean;
	
	oidStr,
	transientUsage,
	str,
	str2			: String;
	
	ts				: TimeStamp;
begin
	cc				:= app.myCnCntrl;
	if cc = null then
		create cc transient;
		iCreatedCnCntrl := true;
	endif;
	
	oidStr			:= self.getOidStringForObject(pProcess);
	create file transient;
	file.fileName 	:= cc.logPath & CN_BACK_SLASH & "transient_usage_" & oidStr & "_" & ts.cnFormat_CCYYMMDD_hhmmss() & ".log";
	self.log("Received notification from " & oidStr & ", file " & file.fileName);
	file.mode		:= file.Mode_Output;
	file.writeLine(transientUsage);
	file.close();
	self.log("Written " & transientUsage.length().cnConvertToByteString() & " to file " & file.fileName);
epilog
	delete file;
	if iCreatedCnCntrl then
		delete cc;
	endif;
end;
}
userNotification_zTransientFileAnalysis
{
userNotification_zTransientFileAnalysis(pProcess : Process; pUserInfo : String) protected;

vars
	cc						: CnCntrl;
	
	file					: File;
	
	tokens					: CnSmallStringArray;
	
	iCreatedCnCntrl			: Boolean;
	
	notificationsExpected,
	notificationNumber,
	pos						: Integer;
	
	str,
	trailer,
	transientFileProcessOid,
	transientUsage			: String;
	
	ts						: TimeStamp;
begin
	cc						:= app.myCnCntrl;
	if cc = null then
		create cc transient;
		iCreatedCnCntrl := true;
	endif;
	
	transientUsage			:= pUserInfo;
	pos						:= transientUsage.reversePos(CN_LEFT_BRACKET);
	trailer					:= transientUsage[pos+1:end];
	transientUsage			:= transientUsage[1:pos-1];
	
	create tokens transient;
	tokens.cnGetTokens(trailer, CN_COLON, false);
	if tokens.size() = 3 then
		transientFileProcessOid := tokens[1];
		notificationNumber		:= tokens[2].Integer;
		notificationsExpected	:= tokens[3].Integer;
	endif;
	
	create file transient;
	file.fileName 	:= cc.logPath & CN_BACK_SLASH & "transientFileAnalysis_" & transientFileProcessOid & ".log";
	self.log("Received Process_TDB_Analysis_Event notification for transient file of process " & transientFileProcessOid & "; " & notificationNumber.String & " of " & notificationsExpected.String);
	if notificationNumber = 1 then
		file.mode		:= file.Mode_Input;
		if file.isAvailable() then
			file.mode	:= file.Mode_Append;
			str			:= "Appended ";
		
		else
			file.mode	:= file.Mode_Output;
			str			:= "Output ";
		endif;
		
		file.writeLine(">>> Process_TDB_Analysis_Event notification received at " & ts.cnFormat_DDMMYY_hhmmss());
	
	else
		file.mode		:= file.Mode_Append;
	endif;
	
	file.writeLine(transientUsage);
	file.close();
	self.log(str & transientUsage.length().cnConvertToByteString() & " to file " & file.fileName);
	
	if notificationNumber = notificationsExpected then
		file.writeLine("");
		app.cnTerminate();
	endif;
epilog
	delete file;
	delete tokens;
	if iCreatedCnCntrl then
		delete cc;
	endif;
end;
}
userNotification_zTransientFileInfo
{
userNotification_zTransientFileInfo(pProcess : Process; pUserInfo : String) protected;

vars
	cc						: CnCntrl;
	
	file					: File;
	
	tokens					: CnStringArray;
	
	iCreatedCnCntrl			: Boolean;
	
	transientFileLength		: Integer64;
	
	str,
	transientFileProcessOid,
	transientFileName,
	transientUsage			: String;
	
	ts						: TimeStamp;
begin
	cc						:= app.myCnCntrl;
	if cc = null then
		create cc transient;
		iCreatedCnCntrl := true;
	endif;
	
	create tokens transient;
	tokens.cnGetTokens(pUserInfo, CN_COLON, false);
	if tokens.size() = 3 then
		transientFileProcessOid := tokens[1];
		transientFileName		:= tokens[2];
		transientFileLength		:= tokens[3].Integer64;
	endif;
	
	create file transient;
	file.fileName 	:= cc.logPath & CN_BACK_SLASH & "transientFileAnalysis_" & transientFileProcessOid & ".log";
	self.log("Received Process_TDB_Info_Event notification for transient file of process " & transientFileProcessOid);
	file.mode		:= file.Mode_Input;
	if file.isAvailable() then
		file.mode	:= file.Mode_Append;
		str			:= "Appended ";
	
	else
		file.mode	:= file.Mode_Output;
		str			:= "Output ";
	endif;

	file.writeLine(">>> Process_TDB_Info_Event notification received at " & ts.cnFormat_DDMMYY_hhmmss());
	file.writeLine("Transient file process oid : " & transientFileProcessOid);
	file.writeLine("Transient file name        : " & transientFileName);
	file.writeLine("Transient file size        : " & transientFileLength.cnConvertToByteString());
	file.writeLine("");
	file.close();
	self.log(str & file.fileName);
	app.cnTerminate();
epilog
	delete file;
	delete tokens;
	if iCreatedCnCntrl then
		delete cc;
	endif;
end;
}
zActivateDeltaDb
{
zActivateDeltaDb() protected;

constants
	Delta_Inactive	: Integer	= 1;
vars
	deltaStatus	: Integer;
begin
	deltaStatus := system.getDeltaDatabaseStatus();
	if deltaStatus <> Delta_Inactive then	
		self.zReportError("Delta database not inactive : " & system.cnGetDeltaDatabaseStatusString(deltaStatus));
		return;
	endif;
	
	system.activateDeltaDatabase(true, null);
end;
}
zCloseCurrentJournal
{
zCloseCurrentJournal() protected;

vars
	jdba	: JadeDatabaseAdmin;
begin
	create jdba transient;
	
	// from Hugh McColl 2Feb2011
	// A call to closeCurrentJournal is performed as inline synchronous code, 
	// thus guaranteeing that a journal switch record is written to the current
	// journal before the line of code returns. It is an atomic operation that 
	// preps the new journal and increments the currentJournal number as accessed
	// by getCurrentJournalNumber.
	jdba.closeCurrentJournal();
epilog
	delete jdba;
end;
}
zCreateRpsDatabase
{
zCreateRpsDatabase() protected;
/*
	Purpose :
	
	Provide a batch facility to be able to create RPS database.
	Refer to JADE PAR #53778 and JADECare Start #996.
	Use JadeDatabase method createRpsDatabase.
	
	Command line example:
	%env_binpath%\jadclient.exe path=%env_systempath% ini=%env_inifile% schema=CardSchema app=KCBatch endJade
		action=createRpsDatabase backupDir=d:\tstjk602r\server\c_system schema=TestPT rpsMapping=MFJ_FirstAttempt rpsStorageMode=0 verifyFiles=true overWriteFiles=true quiesce=false
*/
vars
	kc						: CnKarmaCntrl;
	
	ff						: FileFolder;
	
	jdba					: JadeDatabaseAdmin;
	
	obj						: Object;
	
	relationalView			: RelationalView;
	
	schema					: Schema;
	
	schemaColl				: SchemaColl;
	
	overwriteFiles,
	quiesce,
	verifyFiles				: Boolean;

	databaseRole,
	pos,
	rpsStorageMode,
	sz						: Integer;
	
	action,
	backupDir,
	overwriteFilesStr,
	quiesceStr,
	result,
	rpsMapping,
	rpsStorageModeStr,
	schemaName,
	str,
	str2,
	verifyFilesStr			: String;
begin
	kc						:= app.myCnKarmaCntrl;
	// this function can only be performed on a SDS Primary.
	create jdba transient;
	if not jdba.sdsIsRunning() then
		self.zReportError("Database " & kc.environmentId & " is either not SDS capable or the SDS Service is not active");
		return;
	endif;
	
	databaseRole			:= jdba.sdsGetDatabaseRole();
	if databaseRole <> SDS_RolePrimary then
		self.zReportError("Database " & kc.environmentId & " is not defined as SDS Primary (role=" & databaseRole.String & ")");
		return;
	endif;

	// check that we've explicitly defined all 8 arguments.
	sz 						:= self.initParams.size();
	if sz <> 8 then
		self.zReportError("Require 8 input parameters, " & sz.String & " parameters provided");
		return;
	endif;
	
	// get all 8 arguments
	foreach str2 in self.initParams do
		str := str2.toLower();
		pos := 1;
		action := str.scanUntil(CN_EQUAL, pos);
		if action = "action" then
			// ignore action command
			
		elseif action = "backupdir" then
			pos 		:= pos + 1;
			backupDir	:= str2[pos:end];
		
		elseif action = "schema" then
			pos 		:= pos + 1;
			schemaName	:= str2[pos:end];
			
		elseif action = "rpsmapping" then
			pos 		:= pos + 1;
			rpsMapping	:= str2[pos:end];

		elseif action = "rpsstoragemode" then
			pos 		:= pos + 1;
			rpsStorageModeStr	:= str[pos:end].trimBlanks();

		elseif action = "verifyfiles" then							// optional
			pos 		:= pos + 1;
			verifyFilesStr	:= str[pos:end].trimBlanks();
			
		elseif action = "overwritefiles" then						// optional
			pos 		:= pos + 1;
			overwriteFilesStr	:= str[pos:end].trimBlanks();

		elseif action = "quiesce" then								// optional
			pos 		:= pos + 1;
			quiesceStr	:= str[pos:end];

		else
			self.zReportError("Unknown command line parameter : " & str2);
			return;
		endif;
	endforeach;
	
	// verify that the schema name specified is known
	create schemaColl transient;
	rootSchema.allSubschemas(schemaColl);
	foreach obj in schemaColl do
		if obj.Schema.name = schemaName then
			schema := obj.Schema;
			break;
		endif;
	endforeach;
	
	if schema = null then
		self.zReportError("Schema '" & schemaName & "' is unknown");
		return;
	endif;
	
	// check the RPS Mapping is valid for schema
	relationalView := schema.rpsDatabases[rpsMapping];
	if relationalView = null then
		self.zReportError("RPS Mapping '" & rpsMapping & "' not defined for schema '" & schemaName & "'");
		return;
	endif;
	
	// validate RPS Storage Mode - only Full and Mapped Extent valid for JADECare
	if rpsStorageModeStr = "0" 	or
	   rpsStorageModeStr = "1" 	then
		rpsStorageMode	:= rpsStorageModeStr.Integer;
	
	elseif rpsStorageModeStr = "2" then
		self.zReportError("RPS storage mode of 2 (Working Set) not supported by JADECare Managed Service");
		return;
	
	else
		self.zReportError("Unknown RPS Storage Mode (" & rpsStorageModeStr & ")");
		return;
	endif;
	
	// validate boolean arguments
	result := verifyFilesStr.cnIsTrueOrFalse(verifyFiles);
	if result <> CN_OK then
		self.zReportError("VerifyFiles argument " & result.toLower());
		return;
	endif;

	result := overwriteFilesStr.cnIsTrueOrFalse(overwriteFiles);
	if result <> CN_OK then
		self.zReportError("OverwriteFiles argument " & result.toLower());
		return;
	endif;
	
	result := quiesceStr.cnIsTrueOrFalse(quiesce);
	if result <> CN_OK then
		self.zReportError("Quiesce argument " & result.toLower());
		return;
	endif;
	
	// now check that RPS directory is a valid directory name
	create ff transient;
	ff.fileName := backupDir;
	if not ff.isAvailable() then
		self.zReportError("BackupDir directory '" & backupDir & "' is not available");
		return;
	endif;
	
	// so start the process off. We assume if there are any errors that this will result in an unhandled exception of some sort
	jdba.createRpsDatabase(backupDir, schema, relationalView, rpsStorageMode, verifyFiles, overwriteFiles, quiesce);
epilog
	delete jdba;
	delete schemaColl;
	delete ff;
end;
}
zCycleKCCMgr
{
zCycleKCCMgr() protected;

vars
	allOK	: Boolean;
begin
	allOK := self.zStopKCCMgr();
	if allOK then
		log("KCCMgr has stopped, restarting KCCMgr....");
		allOK := self.zRestartKCCMgr();
		if allOK then
			log("KCCMgr has been restarted.");
		
		else
			self.zReportError("KCCMgr restarted but does not appear to be running.");
		endif;
	
	else
		self.zReportError("KCCMgr stop requested, unable to confirm.");
	endif;
end;
}
zDeactivateDeltaDb
{
zDeactivateDeltaDb() protected;
/*
	Command line :  ...... endjade action=deactivateDeltaDb [<timeout=nnn>] [restartKCCMgr=<true|false>]
	
	Note that timeout is optional and if not specified then default to 60 secs (also JADE default)
*/
constants
	Delta_Active		: Integer	= 2;
vars
	cc					: CnCntrl;
	
	proc				: Process;
	
	root				: CnRoot;
	
	restartKCCMgr,
	deactivateFailed	: Boolean;
	
	deltaStatus,
	pos,
	timeout,
	tries				: Integer;
	
	action,
	str,
	str2				: String;
begin
	create cc transient;
	root := CnRoot.firstInstance();
	if root = null then
		root := CnRoot.firstSharedTransientInstance();
	endif;
	
	if root = null then
		self.zReportError("Unable to locate CnRoot singleton");
		return;
	endif;

	app.setMyCnRoot(root);
	
	deltaStatus := system.getDeltaDatabaseStatus();
	if deltaStatus <> Delta_Active then	
		self.zReportError("Delta database not active : " & system.cnGetDeltaDatabaseStatusString(deltaStatus));
		return;
	endif;

	if self.initParams.size() > 1 then
		foreach str2 in self.initParams do
			str := str2.toLower();
			pos := 1;
			action := str.scanUntil(CN_EQUAL, pos);
			if action = "action" then
				// ignore action command
			
			elseif action = "timeout" then
				pos := pos + 1;
				timeout := str[pos:end].Integer;
			
			elseif action = "restartkccmgr" then
				pos := pos + 1;
				restartKCCMgr := str[pos:end].Boolean;
			
			else
				self.zReportError("Unknown command line parameter : " & str2);
				return;
			endif;
		endforeach;
	endif;

	if timeout = null then
		timeout := 60;
	endif;

	// force KCCMgr to close down
	self.log("Causing KCCMgr shutdown event...");
	system.causeEvent(Cn_Process_Shutdown_Command, true, null);
	
	// now wait for KCCMgr to shutdown
	while tries < 10 do
		tries := tries + 1;
		process.sleep(1000);
		proc := cc.getProcessForLock(CN_CARDSCHEMA, CN_KCCMGR, true);
		if proc = null then
			break;
		endif;
		
		self.log("KCCMgr process still running, retrying...");
	endwhile;

	if proc <> null then
		self.log("KCCMgr shutdown requested but is still running, trying deactivate of delta...");
	endif;
	
	self.log("Starting deactivate of delta database (timeout=" & timeout.String & ", restartKCCMgr=" & restartKCCMgr.String & ") ...");
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_CouldNotChangeDeltaDbMode, null, deactivateFailed);
	system.activateDeltaDatabase(false, timeout);
	
	if restartKCCMgr then
		self.log("Restart KCCMgr...");
		self.zRestartKCCMgr();
	endif;
	
	if deactivateFailed then
		self.zReportError("Exception 1163 - could not change delta database mode because not all processes are idle");
	endif;
epilog
	delete cc;
end;
}
zExtractDatabaseStructureInfo
{
zExtractDatabaseStructureInfo() protected, serverExecution;

vars
	cnu	: CnUtility;
begin
	create cnu transient;
	cnu.extractDatabaseStructureInfo();
epilog
	delete cnu;
end;
}
zExtractRpsData
{
zExtractRpsData() protected;
/*
	Purpose :
	
	Provide a batch facility to be able to extract the RPS tables data
	
	Command line example:
	%env_binpath%\jadclient.exe path=%env_systempath% ini=%env_inifile% schema=CardSchema app=KCBatch endJade
		action=extractRPSData schema=TestPT rpsMapping=MFJ_FirstAttempt executeLocation=server
		scriptFilePath=t:\testing\SQLScripts
		dataFilesPath=t:\testing\SQLdata
		rdbmsDataFilesPath=d:\tstjk602r\SQLData
		relationalDatabaseName=TSTJK602R
		extractHistoricalTables=false
		rdbmsServer=cnwsqls101
		extractWorkers=5
		userDataPumpSchema=
		userDataPumpApp=
*/
vars
	kc				: CnKarmaCntrl;
	
	ff				: FileFolder;
	
	jdba			: JadeDatabaseAdmin;
	
	obj				: Object;
	
	extractProcess	: Process;
	
	relationalView 	: RelationalView;
	
	schema			: Schema;
	
	schemaColl		: SchemaColl;
	
	extractHistoricalTables : Boolean;
	
	databaseRole,
	databaseSubrole,
	executeLocation,
	extractWorkers,
	pos,
	sz				: Integer;
	
	action,
	dataFilesPath,
	executeLocationString,
	extractHistoricalTablesString,
	extractWorkersString,
	param,
	paramCased,
	rdbmsDataFilesPath,
	rdbmsServer,
	relationDbName,
	rpsMapping,
	schemaName,
	scriptFilePath,
	userDataPumpAppName,
	userDataPumpSchemaName	: String;
begin
	kc						:= app.myCnKarmaCntrl;
	on Exception do self.exceptionHandler_rpsExtract(exception);
	
	// this function can only be performed on a SDS Secondary Relational.
	create jdba transient;
	if not jdba.sdsIsRunning() then
		self.zReportError("Database " & kc.environmentId & " is either not SDS capable or the SDS Service is not active");
		return;
	endif;
	
	databaseRole			:= jdba.sdsGetDatabaseRole();
	if databaseRole <> SDS_RoleSecondary then
		self.zReportError("Database " & kc.environmentId & " is not defined as SDS Secondary (role=" & databaseRole.String & ")");
		return;
	endif;

	databaseSubrole			:= jdba.sdsGetDatabaseSubrole();
	if databaseSubrole <> SDS_SubroleRelational then
		self.zReportError("Database " & kc.environmentId & " is not defined as Relation subrole (subrole=" & databaseSubrole.String & ")");
		return;
	endif;

	// check that we've explicitly defined all 5 arguments.
	sz 						:= self.initParams.size();
	if sz < 10 then
		self.zReportError("Require minimum of 10 input parameters, " & sz.String & " parameters provided");
		return;
	endif;
	
	if sz > 13 then
		self.zReportError("Maximum of 13 input parameters allowed, " & sz.String & " parameters provided");
		return;
	endif;

	// get all 12 arguments if provided.
	// optional arguments are:
	//	- extract workers - defaults to 1
	//	- userDataPumpSchema - optional, required if userDataPumpApp is specified
	//	- userDataPumpApp - optional, required if userDataPumpSchema is specified
	foreach paramCased in self.initParams do
		param := paramCased.toLower();
		pos := 1;
		action := param.scanUntil(CN_EQUAL, pos);
		if action = "action" then
			// ignore action command
			
		elseif action = "schema" then
			pos 		:= pos + 1;
			schemaName	:= paramCased[pos:end].trimBlanks();
			
		elseif action = "rpsmapping" then
			pos 		:= pos + 1;
			rpsMapping	:= paramCased[pos:end].trimBlanks();
			
		elseif action = "executelocation" then
			pos			:= pos + 1;
			executeLocationString	:= paramCased[pos:end];

		elseif action = "scriptfilepath" then
			pos 			:= pos + 1;
			scriptFilePath	:= paramCased[pos:end].trimBlanks();

		elseif action = "datafilespath" then
			pos 			:= pos + 1;
			dataFilesPath	:= paramCased[pos:end].trimBlanks();

		elseif action = "rdbmsdatafilespath" then
			pos 			:= pos + 1;
			rdbmsDataFilesPath	:= paramCased[pos:end].trimBlanks();
			
		elseif action = "relationaldatabasename" then																			// PAR 1093
			pos 			:= pos + 1;
			relationDbName	:= paramCased[pos:end].trimBlanks();
			
		elseif action = "rdbmsserver" then
			pos 			:= pos + 1;
			rdbmsServer		:= paramCased[pos:end].trimBlanks();
			
		elseif action = "extracthistoricaltables" then
			pos 			:= pos + 1;
			extractHistoricalTablesString	:= paramCased[pos:end].trimBlanks();
			
		elseif action = "extractworkers" then
			pos 			:= pos + 1;
			extractWorkersString	:= paramCased[pos:end].trimBlanks();
			
		elseif action = "userdatapumpschema" then
			pos 			:= pos + 1;
			userDataPumpSchemaName	:= paramCased[pos:end].trimBlanks();
			
		elseif action = "userdatapumpapp" then
			pos 			:= pos + 1;
			userDataPumpAppName	:= paramCased[pos:end].trimBlanks();

		else
			self.zReportError("Unknown command line parameter : " & paramCased);
			return;
		endif;
	endforeach;
	
	if schemaName = null then
		self.zReportError("Schema has not been specified");
		return;
	endif;
	
	if rpsMapping = null then
		self.zReportError("RPS Mapping has not been specified");
		return;
	endif;
	
	if relationDbName = null then
		self.zReportError("Relational Database Name has not been specified");
		return;
	endif;
	
	if executeLocationString.toLower() = "server" then
		executeLocation := RelationalView.Load_ServerExecute;
	
	elseif executeLocationString.toLower() = "client" then
		executeLocation := RelationalView.Load_ClientExecute;
		
	else
		self.zReportError("Execute Location '" & executeLocationString & "' is invalid, must be 'client' or 'server'");
		return;
	endif;
	
	if extractHistoricalTablesString.toLower() = true.String then
		extractHistoricalTables := true;
	
	elseif extractHistoricalTablesString.toLower() = false.String then
		extractHistoricalTables := false;
		
	else
		self.zReportError("Extract Historical Tables Location '" & extractHistoricalTablesString & "' is invalid, must be 'true' or 'false'");
		return;
	endif;
	
	if extractWorkersString = null then
		extractWorkers := 1;
	
	elseif extractWorkersString.cnIsNumeric() then
		extractWorkers := extractWorkersString.Integer;
	
	else
		self.zReportError("Extract Workers '" & extractWorkersString & "' must be numeric");
		return;
	endif;
	
	// both userdatapump schema and app name must be specified or left as null to use default JADE datapump
	if userDataPumpSchemaName = null then
		if userDataPumpAppName <> null then
			self.zReportError("UserDataPump App specified '" & userDataPumpAppName & "', UserDataPump Schema must also be specified");
			return;
		endif;
	
	elseif userDataPumpAppName = null then
		self.zReportError("UserDataPump Schema specified '" & userDataPumpSchemaName & "', UserDataPump App must also be specified");
		return;
	endif;
	
	if rdbmsServer = null then
		self.zReportError("RDBMS Server not specified");
		return;
	endif;
		
	if scriptFilePath = null then
		self.zReportError("Script File Path not specified");
		return;
	endif;

	if dataFilesPath = null then
		self.zReportError("Data Files Path not specified");
		return;
	endif;

	if rdbmsDataFilesPath = null then
		self.zReportError("RDBMS Data Files Path not specified");
		return;
	endif;
	
	create ff transient;
	if not ff.isValidPathName(scriptFilePath) then
		self.zReportError("Script File Path is invalid '" & scriptFilePath & "'");
		return;
	endif;

	if not ff.isValidPathName(dataFilesPath) then
		self.zReportError("Data Files Path is invalid '" & dataFilesPath & "'");
		return;
	endif;

	if not ff.isValidPathName(rdbmsDataFilesPath) then
		self.zReportError("RDBMS Data Files Path is invalid '" & rdbmsDataFilesPath & "'");
		return;
	endif;

	// verify that the schema name specified is known
	create schemaColl transient;
	rootSchema.allSubschemas(schemaColl);
	foreach obj in schemaColl do
		if obj.Schema.name = schemaName then
			schema := obj.Schema;
			break;
		endif;
	endforeach;
	
	if schema = null then
		self.zReportError("Schema '" & schemaName & "' is unknown");
		return;
	endif;
	
	// check the RPS Mapping is valid for schema
	relationalView := schema.rpsDatabases[rpsMapping];
	if relationalView = null then
		self.zReportError("RPS Mapping '" & rpsMapping & "' not defined for schema '" & schemaName & "'");
		return;
	endif;

	// if userDataPumpSchema specified then verify that the schema is known
	if userDataPumpSchemaName <> null then
		schema := null;
		foreach obj in schemaColl do
			if obj.Schema.name = schemaName then
				schema := obj.Schema;
				break;
			endif;
		endforeach;
		
		if schema = null then
			self.zReportError("UserDataPump Schema '" & schemaName & "' is unknown");
			return;
		endif;	
	endif;
	
	extractProcess := relationalView.extractDataAll(executeLocation,
													scriptFilePath,
													dataFilesPath,
													rdbmsDataFilesPath,
													relationDbName,
													extractHistoricalTables,
													rdbmsServer,
													extractWorkers,
													relationalView.ExtractOrderDefault,
													null,
													userDataPumpSchemaName,
													userDataPumpAppName);
													
	beginNotification(extractProcess, extractProcess.RPS_EXTRACT_FAILED_EVENT, Response_Cancel, null);
	beginNotification(extractProcess, extractProcess.RPS_EXTRACT_FINISHED_EVENT, Response_Cancel, null);
epilog
	delete jdba;
	delete schemaColl;
	delete ff;
	if process.isInExceptionState() then
		app.cnTerminate();
	endif;
end;
}
zForceUnhandledException
{
zForceUnhandledException() protected;
/*
	This method deliberately forces an exception. Valid types are :
	- 1090
	- 4
*/
vars
	cnfa1,
	cnfa2	: CnFunctionAgent;
	
	ue1090,
	ue4		: Boolean;
	
	pos		: Integer;
	
	action,
	str,
	str2,
	value	: String;
begin
	if not app.isMultiUser then
		self.zReportError("ForceUnHandledException function is only valid in multiUser mode");
		return;
	endif;
	
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	foreach str2 in self.initParams do
		str := str2.toLower();
		pos := 1;
		action := str.scanUntil(CN_EQUAL, pos);
		if action = "action" then
			// ignore action command
		
		elseif action = "ue" then
			pos := pos + 1;
			value := str2[pos:end];
		
		else
			self.zReportError("Unknown command line parameter : " & str2);
			return;
		endif;
	endforeach;
	
	if value = "4" then
		ue4 := true;
	
	else
		ue1090 := true;
	endif;
		
	if ue1090 then
		// force exception 1090 by referencing a object that hasn't been initialized or assigned
		cnfa1.edition;
		
	else
		// force exception 4 by creating an object, setting a reference to this object, deleting the object and then accessing the reference
		create cnfa1 transient;
		cnfa2 := cnfa1;
		delete cnfa1;
		cnfa2.edition;
	endif;
end;
}
zGenerateRpsTableCreationScript
{
zGenerateRpsTableCreationScript() protected;
/*
	Purpose :
	
	Provide a batch facility to be able to generate the RPS tables definition
	
	Command line example:
	%env_binpath%\jadclient.exe path=%env_systempath% ini=%env_inifile% schema=CardSchema app=KCBatch endJade
		action=generateRpsTableCreationScript schema=TestPT rpsMapping=MFJ_FirstAttempt relationDatabaseName=TSTJK602R
		scriptFileName=t:\testing\SQLScripts\generateTables.sql
*/
vars
	kc				: CnKarmaCntrl;
	
	scriptFile		: File;
	
	jdba			: JadeDatabaseAdmin;
	
	obj				: Object;
	
	relationalView 	: RelationalView;
	
	schema			: Schema;
	
	schemaColl		: SchemaColl;
	
	databaseRole,
	databaseSubrole,
	pos,
	sz				: Integer;
	
	action,
	param,
	paramCased,
	relationDbName,
	rpsMapping,
	schemaName,
	scriptFileName		: String;
begin
	kc						:= app.myCnKarmaCntrl;
	// this function can only be performed on a SDS Secondary Relational.
	create jdba transient;
	if not jdba.sdsIsRunning() then
		self.zReportError("Database " & kc.environmentId & " is either not SDS capable or the SDS Service is not active");
		return;
	endif;
	
	databaseRole			:= jdba.sdsGetDatabaseRole();
	if databaseRole <> SDS_RoleSecondary then
		self.zReportError("Database " & kc.environmentId & " is not defined as SDS Secondary (role=" & databaseRole.String & ")");
		return;
	endif;

	databaseSubrole			:= jdba.sdsGetDatabaseSubrole();
	if databaseSubrole <> SDS_SubroleRelational then
		self.zReportError("Database " & kc.environmentId & " is not defined as Relation subrole (subrole=" & databaseSubrole.String & ")");
		return;
	endif;

	// check that we've explicitly defined all 5 arguments.
	sz 						:= self.initParams.size();
	if sz <> 5 then
		self.zReportError("Require 5 input parameters, " & sz.String & " parameters provided");
		return;
	endif;
	
	// get all 8 arguments
	foreach paramCased in self.initParams do
		param := paramCased.toLower();
		pos := 1;
		action := param.scanUntil(CN_EQUAL, pos);
		if action = "action" then
			// ignore action command
			
		elseif action = "schema" then
			pos 		:= pos + 1;
			schemaName	:= paramCased[pos:end];
			
		elseif action = "rpsmapping" then
			pos 		:= pos + 1;
			rpsMapping	:= paramCased[pos:end];

		elseif action = "scriptfile" then
			pos 			:= pos + 1;
			scriptFileName	:= paramCased[pos:end].trimBlanks();

		elseif action = "relationaldatabasename" then																			// PAR 1093
			pos 			:= pos + 1;
			relationDbName	:= paramCased[pos:end].trimBlanks();
			
		else
			self.zReportError("Unknown command line parameter : " & paramCased);
			return;
		endif;
	endforeach;
	
	if schemaName = null then
		self.zReportError("Schema name must be supplied");
		return;
	endif;
	
	if rpsMapping = null then
		self.zReportError("RPS Mapping name must be supplied");
		return;
	endif;
	
	if scriptFileName = null then
		self.zReportError("Script File Name must be supplied");
		return;
	endif;
	
	if relationDbName = null then
		self.zReportError("Relational Database Name must be supplied");
		return;
	endif;
	
	// verify that the schema name specified is known
	create schemaColl transient;
	rootSchema.allSubschemas(schemaColl);
	foreach obj in schemaColl do
		if obj.Schema.name = schemaName then
			schema := obj.Schema;
			break;
		endif;
	endforeach;
	
	if schema = null then
		self.zReportError("Schema '" & schemaName & "' is unknown");
		return;
	endif;
	
	// check the RPS Mapping is valid for schema
	relationalView := schema.rpsDatabases[rpsMapping];
	if relationalView = null then
		self.zReportError("RPS Mapping '" & rpsMapping & "' not defined for schema '" & schemaName & "'");
		return;
	endif;
	
	create scriptFile transient;
	scriptFile.kind := scriptFile.Kind_ANSI;
	scriptFile.fileName := scriptFileName;
	if scriptFile.isAvailable() then
		scriptFile.purge();
	endif;
	
	relationalView.generateRpsTableCreationScript(relationDbName, scriptFile, relationalView.RpsScript_UserAndJadeTables, null);
	
	scriptFile.close;
	//app.logMessage(method.qualifiedName & " Finished");
epilog
	delete scriptFile;
	delete jdba;
	delete schemaColl;
end;
}
zGetApplicationCount
{
zGetApplicationCount() protected;

/*
	command line syntax:
	
	jadclient path=<system path> ini=<ini file> schema=CardSchema app=KCBatch server=multiUser endJade
		action=applicationCount schemaName=<schema name> appName=<applicationName>
	exitcode values:
	<other value> - count of JADE applications running with this schema and app name.
*/
vars
	appl	: Application;
	
	proc	: Process;
	
	invalid	: Boolean;

	count,
	pos		: Integer;
	
	action,
	appName,
	schemaName,
	str,
	str2	: String;
begin
	if self.initParams.size() <> 3 then
		self.zReportError("Expected 3 command line parameters");
		return;
	endif;
	
	foreach str2 in self.initParams do
		str := str2.toLower();
		pos := 1;
		action := str.scanUntil(CN_EQUAL, pos);
		if action = "action" then
			// ignore action command
		
		elseif action = "schemaname" then
			pos := pos + 1;
			schemaName := str2[pos:end];
		
		elseif action = "appname" then
			pos := pos + 1;
			appName := str2[pos:end];
		
		else
			self.zReportError("Unknown command line parameter : " & str2);
			return;
		endif;
	endforeach;
	
	on SystemException do app.cnGenericExceptionHandler(exception, 1090, null, invalid);
	on SystemException do app.cnGenericExceptionHandler(exception, 4, null, invalid);
	foreach proc in Process.instances do
		invalid := false;
		if proc.schema.name <> schemaName then
			continue;
		endif;
		if invalid then
			continue;
		endif;
		
		appl := proc.persistentApp;
		if invalid then
			continue;
		endif;
		
		count := count + (appl.name = appName).Integer;
	endforeach;


	beginTransaction;
	node.userExitCode := count;
	commitTransaction;
end;
}
zGetDeltaDatabaseStatus
{
zGetDeltaDatabaseStatus() protected;

vars
	status	: Integer;
begin
	status := system.getDeltaDatabaseStatus();
	beginTransaction;
	node.userExitCode := status;
	commitTransaction;
end;
}
zGetProductionMode
{
zGetProductionMode() protected;

/*
	exitcode values:
	1 - production mode is false
	2 - production mode is true
	<other value> - exception
*/
vars

begin
	beginTransaction;
	node.userExitCode := app.productionMode.Integer + 1;
	commitTransaction;
end;
}
zGetStatus
{
zGetStatus() protected;

vars
	tracking					: Boolean;
	trackingStoppedReason		: Integer;
	rpsTransitionHaltCode		: Integer;
	msg							: Binary;
begin
	self.zGetTrackingStatus(tracking, trackingStoppedReason, rpsTransitionHaltCode);
	
	msg		:= cnAnsiBinary("STAT") 						& 
			   cnAnsiBinary(self.environmentName.padBlanks(30))	&
			   cnAnsiBinary(tracking.Character) 			& 
			   trackingStoppedReason.Binary					&
			   rpsTransitionHaltCode.Binary					;
			   
	self.sendResponse(msg);
end;
}
zGetTrackingStatus
{
zGetTrackingStatus(tracking 				: Boolean output; 
				  trackingStoppedReason 	: Integer output;
				  rpsTransitionHaltCode 	: Integer output) protected;

vars
	dba		: JadeDatabaseAdmin;
	jdo		: JadeDynamicObject;
begin
	create dba transient;
	create jdo transient;
	dba.sdsGetMyServerInfo(jdo);
	
	tracking		:= jdo.getPropertyValue("tracking").Boolean;
	if tracking then
		trackingStoppedReason	:= 0;
		rpsTransitionHaltCode	:= -1;
	else
		trackingStoppedReason	:= jdo.getPropertyValue("reasonTrackingStopped").Integer;
		if trackingStoppedReason = SDS_ReasonRpsReorgHalt then
			rpsTransitionHaltCode	:= jdo.getPropertyValue("rpsTransitionHaltCode").Integer;
		else
			rpsTransitionHaltCode	:= -1;
		endif;
	endif;
	
	self.log(method.cnGetMethodName() & " : tracking=" & tracking.String & ", trackingStoppedReason=" & trackingStoppedReason.String &
		", rpsTransitionHaltCode=" & rpsTransitionHaltCode.String);
epilog
	delete dba;
	delete jdo;
end;
}
zHandleActions
{
zHandleActions(pAction : String) updating, protected;

vars
	cc			: CnCntrl;
	
	allOK,
	jsa,
	jsm,
	userEnv		: Boolean;
begin
	cc			:= app.myCnCntrl;
	jsm 		:= (app.name.cnStartsWithJoss());
	if not jsm then
		jsa 	:= (app.name.cnStartsWithKarma());
	endif;
	
	userEnv 	:= not jsm and not jsa;
	if pAction = "cyclekccmgr" then
		if userEnv then
			self.zCycleKCCMgr();
		
		else
			self.zReportError(pAction & " invalid for JSM/JSA");
		endif;
		
		terminate;
	endif;
	
	if pAction = "restartkccmgr" then
		if userEnv then
			allOK := self.zRestartKCCMgr();
			if allOK then
				log("KCCMgr has been restarted.");
			
			else
				self.zReportError("KCCMgr restarted but does not appear to be running.");
			endif;
			
		else
			self.zReportError(pAction & " invalid for JSM/JSA");
		endif;
		
		terminate;
	endif;
	
	if pAction = "stopkccmgr" then
		if userEnv then
			self.zStopKCCMgr();
			
		else
			self.zReportError(pAction & " invalid for JSM/JSA");
		endif;
		
		terminate;
	endif;

	if pAction = "getstatus" then
		self.zGetStatus();
		// don't terminate as we are executing
		// asynch methods on tcp object
		return;
	endif;
		
	if pAction = "resumetracking" then
		self.zStartTracking();
		terminate;
	endif;
		
	if pAction = "activatedeltadb" 			or
	   pAction = "activatedeltadatabase"	then
		if userEnv then
			self.zActivateDeltaDb();
			
		else
			self.zReportError(pAction & " invalid for JSM/JSA");
		endif;
		
		terminate;
	endif;
	
	if pAction = "deactivatedeltadb" 		or
	   pAction = "deactivatedeltadatabase" 	then
		if userEnv then
			self.zDeactivateDeltaDb();

			else
			self.zReportError(pAction & " invalid for JSM/JSA");
		endif;
		
		terminate;
	endif;
	
	if pAction = "getdeltadatabasestatus" then
		if userEnv then
			self.zGetDeltaDatabaseStatus();
			
		else
			self.zReportError(pAction & " invalid for JSM/JSA");
		endif;
		
		terminate;
	endif;

	if pAction = "closecurrentjournal" then
		self.zCloseCurrentJournal();
		terminate;
	endif;
	
	if pAction = "switchjournal" then																							// NFS 887
		self.zSwitchJournal();																									// NFS 887
		terminate;																												// NFS 887
	endif;																														// NFS 887
		
	if pAction = "pretakeover" then
		self.zInitiateSDSPreTakeOver();
			// terminates when timeout or all secondaries have responded
		return;
	endif;
		
	if pAction = "negotiatedtakeover" then
		self.negotiatedTakeOverRequest := true;
		self.zInitiateSDSPreTakeOver();
		// terminates when timeout or all secondaries have responded
		return;
	endif;
		
	if pAction = "extractdatabasestructureinfo" then
		self.zExtractDatabaseStructureInfo();
		terminate;
	endif;
		
	if pAction = "getproductionmode" then
		self.zGetProductionMode();
		terminate;
	endif;
	
	if pAction = "applicationcount" then
		self.zGetApplicationCount();
		terminate;
	endif;

	if pAction = "validateuser" then
		self.zValidateUser();
		terminate;
	endif;

	if pAction = "forceunhandledexception" then
		self.zForceUnhandledException();
		terminate;
	endif;
	
	if pAction = "transientanalysis" then
		self.zTransientAnalysis();
		// the receipt of notifications will cause the application to terminate
		return;
	endif;

	if pAction = "transientinfo" then
		self.zTransientInfo();
		// the receipt of single notification will cause the application to terminate
		return;
	endif;

	if pAction = "transientfilecompact" then
		self.zTransientFileCompact();
		terminate;
	endif;
	
	if pAction = "suspend_appservermonitor" then
		if not cc.isInTestMode() then
			self.zReportError("Invalid option, must be in test mode");
			terminate;
		endif;
		
		self.zSendAppServerNotification();
		terminate;
	endif;
	
	if pAction = "createrpsdatabase" then
		self.zCreateRpsDatabase();
		terminate;
	endif;
	
	if pAction = "generaterpstablecreationscript" then
		self.zGenerateRpsTableCreationScript();
		terminate;
	endif;

	if pAction = "extractrpsdata" then
		self.zExtractRpsData();
		// termination occurs on:
		// - exception in method
		// - notification of failed event
		// - notification of finished event
		return;
	endif;

	if pAction = "resetuserappliedpatches" then
		self.zResetUserAppliedPatches();
		terminate;
	endif;
	
	if pAction = "verifycardschemaversion" then
		self.zVerifyCardSchemaVersion();
		terminate;
	endif;

	self.zReportError("Unrecognized pAction '" & pAction & "'");
	terminate;
epilog
	if process.isInExceptionState then
		beginTransaction;
		node.userExitCode := -1;
		commitTransaction;
		terminate;
	endif;
end;
}
zInitiateSDSNegotiatedTakeOver
{
zInitiateSDSNegotiatedTakeOver() protected;

vars
	cc			: CnCntrl;

	root		: CnRoot;
	
	str,
	str2,
	action,
 	secondary,
	errorText	: String;
	
	pos			: Integer;
	
	cnSDSdba	: CnSDSDatabaseAdmin;
	
	fx			: CnFunctionAgent;
	
	errorCode	: Integer;
begin
	create cc transient;
	root := CnRoot.firstInstance();
	if root = null then
		root := CnRoot.firstSharedTransientInstance();
	endif;
	
	app.setMyCnRoot(root);
	
	if self.initParams.size() > 1 then
		foreach str2 in self.initParams do
			str := str2.toLower();
			pos := 1;
			action := str.scanUntil(CN_EQUAL, pos);
			if action = "action" then
				// ignore action command
				
			elseif action = "timeout" then
				// ignore timeout, used for PreTakeOver
			
			elseif action = "secondary" then
				pos 		:= pos + 1;
				secondary	:= str[pos:end];
				
			else
				errorCode := Cn_Edit_Error;
				errorText := "Unknown command line parameter : " & str2;
				return;
			endif;
		endforeach;
	endif;
	
	if secondary = null then
		self.zReportError("Required 'secondary' parameter missing, unable to continue.");
		terminate;
	endif;
	
	self.log("Starting negotiated takeover to new SDS Primary '" & secondary & "'");
	
	create fx transient;
	create cnSDSdba transient;
	on SystemException do fx.ehGeneralExceptionHandler(exception, errorCode, errorText);
	// subscribe to role change progress so we can log but maily to see if takeover was abandoned or failed						// PAR 1089
	self.beginNotification(system, SDS_RoleChangeProgress, Response_Continuous, null);											// PAR 1089
	cnSDSdba.sdsInitiateTakeover(SDS_TakeoverConditional, secondary);
	
	// now we wait for role to change or for notification that takeover abandoned or failed.									// PAR 1089
	self.beginTimer(1000, Timer_Continuous, CN_WAIT_TAKEOVER_ROLECHANGE);														// PAR 1089
epilog
	if errorText <> null then
		self.zReportError("Negotiated Takeover request incurred an exception, errorCode=" & errorCode.String & ", errorText=" & errorText);
	endif;
	
	delete cc;
	delete fx;
	delete cnSDSdba;
end;
}
zInitiateSDSPreTakeOver
{
zInitiateSDSPreTakeOver() protected;
/*
	Command line :  ...... endjade action=preTakeOver [<timeout=nnn>]
	
	Note that timeout is optional and if not specified then default to 60 secs (also JADE default)
*/
vars
	cc				: CnCntrl;
	
	root			: CnRoot;
		
	cnSDSdba		: CnSDSDatabaseAdmin;
	
	tx				: CnTransactionAgent;

	pos,
	sz,
	timeout,
	connState		: Integer;
	
	action,
	str,
	str2,
	connName		: String;
	
	jdo				: JadeDynamicObject;
	
	jdoArray		: JadeDynamicObjectArray;
begin
	if system.getDatabaseRole() <> SDS_RolePrimary then
		if self.negotiatedTakeOverRequest then
			self.zReportError("NegotiatedTakeOver request is only available for SDS Primary database, request ignored.");
		
		else
			self.zReportError("PreTakeOver request is only available for SDS Primary database, request ignored.");
		endif;
		
		return;
	endif;

	create cc transient;
	root := CnRoot.firstInstance();
	if root = null then
		root := CnRoot.firstSharedTransientInstance();
	endif;
	app.setMyCnRoot(root);
	
	if self.initParams.size() > 1 then
		foreach str2 in self.initParams do
			str := str2.toLower();
			pos := 1;
			action := str.scanUntil(CN_EQUAL, pos);
			if action = "action" then
				// ignore action command
				continue;
			endif;
			
			if action = "timeout" then
				pos 		:= pos + 1;
				timeout		:= str[pos:end].Integer;
				continue;
			endif;

			if action = "secondary" then
				// ignore secondary command, may be specified as part of the negotiatedTakeOver command
				continue;
			endif;
				
			self.zReportError("Unknown command line parameter : " & str2);
			terminate;
		endforeach;
	endif;

	if timeout = null then
		timeout := 60;
		self.log("Timeout was not specified, defaulting to 60 seconds.");
		
	else
		self.log("Timeout specified (" & timeout.String & ").");
	endif;

	self.log("Forcing synchronization.");
	create cnSDSdba transient;
	cnSDSdba.cnSDSStructureState_Check();
	self.log("Synchronization completed.");
		
	create jdoArray transient;
	cnSDSdba.sdsGetSecondaryProxies(jdoArray);
	self.log("Number of secondaries detected = " & jdoArray.size64().String);
	foreach jdo in jdoArray do
		connName	:= jdo.getPropertyValue("myName").String;
		connState 	:= jdo.getPropertyValue("connectionState").Integer;
		if connState <> SDS_Connected then
			self.log(connName & " is not connected to the Primary and has been ignored.");
			continue;
		endif;
		
		self.secondaryNameArray.add(connName.toLower());
		sz := sz + 1;
		self.log("[" & sz.String & "] Send PreTakeOver request to " & connName);
	endforeach;
	
	if self.secondaryNameArray.isEmpty() then
		if self.negotiatedTakeOverRequest then																					// PAR 1089
			str := "NegotiatedTakeOver";																						// PAR 1089
		
		else																													// PAR 1089
			str := "PreTakeOver";																								// PAR 1089
		endif;																													// PAR 1089
		
		self.zReportError("No Secondary databases are connected to the Primary, " & str & " request has been ignored.");		// PAR 1089
		terminate;
	endif;
	
	self.secondaryNameArray.copy(self.secondaryNameHoldArray);
	self.beginNotification(system, Cn_SDS_PreTakeOver_Response, Response_Continuous, null);	// subscribe to acknowledgments coming back from the Secondaries
	self.beginTimer(timeout*1000, Timer_OneShot, Cn_SDS_PreTakeOver_Timeout);			// start a timeout expiry timer, all secondaries must respond within this timeframe to be deemed successful
	create tx transient;
	tx.sdsCauseEventCommon(null);	
epilog
	delete cc;
	delete jdoArray;
	delete cnSDSdba;
	delete tx;
end;
}
zReportError
{
zReportError(pErrorMsg : String) protected;

vars
	cem	: CnExternalMethods;
begin
	beginTransaction;
	node.userExitCode := -1;
	commitTransaction;
	self.log("ERROR : " & pErrorMsg);
	
	create cem transient;
	cem.emSendStdOut("ERROR : " & pErrorMsg & CrLf);
epilog
	delete cem;
end;
}
zResetUserAppliedPatches
{
zResetUserAppliedPatches() protected;

vars
	cnu		: CnUtility;
begin
	if system.getDatabaseRole() = SDS_RoleSecondary then
		self.zReportError("Unable to perform 'resetUserAppliedPatches' on SDS Secondary");
		return;
	endif;
	
	self.log("Resetting user applied patches...");
	create cnu transient;
	cnu.resetUserAppliedPatchesAll();
	self.log("User applied patches has been reset");
epilog
	delete cnu;
end;
}
zRestartKCCMgr
{
zRestartKCCMgr() : Boolean protected, serverExecution;
/*
	Executed by following commandline:
	
	
	<binpath>/jadclient path=<syspath> ini=<inifile> server=multiUser name=<commandline name> schema=CardSchema app=KCDeployMgr endJade action=restartKCCMgr
*/
vars
	proc	: Process;
begin
	proc	:= Process.firstInstance;
	beginTransaction;
	proc.adminInfo	:= null;			// clear possible 'System Stopping' indicator
	commitTransaction;
	
	proc := app.startApplication(CN_CARDSCHEMA, CN_KCCMGR);
	
	// we wait for 10 seconds to let KCCMgr initialize
	process.sleep(10000);
	
	// now check to see if KCCmgr is still running
	return app.isValidObject(proc);
end;
}
zSendAppServerNotification
{
zSendAppServerNotification() protected;

/*
	command line syntax:
	
	jadclient path=<system path> ini=<ini file> schema=CardSchema app=KCBatch server=multiUser endJade
		action=suspend_appServerMonitor process=<nn> sleep=<nnn>
	
	Causes AppServerMonitor applications with matchng name to execute a process.sleep for the nominated sleep time (secs)
*/
vars
	appl	: Application;
	
	proc	: Process;
	
	invalid	: Boolean;

	count,
	pos,
	sleepTimeSecs	: Integer;
	
	action,
	appName,
	str,
	str2	: String;
begin
	if self.initParams.size() <> 3 then
		self.zReportError("Expected 3 command line parameters");
		return;
	endif;
	
	foreach str2 in self.initParams do
		str := str2.toLower();
		pos := 1;
		action := str.scanUntil(CN_EQUAL, pos);
		if action = "action" then
			// ignore action command
		
		elseif action = "processname" then
			pos := pos + 1;
			appName := str2[pos:end];
		
		elseif action = "sleep" then
			pos := pos + 1;
			sleepTimeSecs := str2[pos:end].Integer;
		
		else
			self.zReportError("Unknown command line parameter : " & str2);
			return;
		endif;
	endforeach;
	
	if appName[1:16].toLower() <> "appservermonitor" then
		self.zReportError("Application must start with 'AppServerMonitor' : " & str2);
		return;
	endif;
	
	on SystemException do app.cnGenericExceptionHandler(exception, 1090, null, invalid);
	on SystemException do app.cnGenericExceptionHandler(exception, 4, null, invalid);
	foreach proc in Process.instances do
		invalid := false;
		if proc.schema.name <> CN_CARDSCHEMA then
			continue;
		endif;
		
		if invalid then
			continue;
		endif;
		
		appl := proc.persistentApp;
		if invalid then
			continue;
		endif;
		
		if appl.name = appName then
			count := count + 1;
			proc.causeEvent(CN_QUAL_APPSERVERMONITOR_SUSPEND, true, sleepTimeSecs);
			log("Issued 'suspend' notification to " & appl.name & " " & self.getOidStringForObject(proc));
		endif;
	endforeach;

	log("Issued 'suspend' notification to " & count.String & " processes");
end;
}
zStartTracking
{
zStartTracking() protected, serverExecution;

vars
	dba		: JadeDatabaseAdmin;
begin
	//
	//  Note that this method is probably redundant, because late in the 3.1 development cycle
	//  it was decided to always resume tracking via JADLOADB executeMethod in order to avoid problems
	//  encountered at transition when CardSchema's own classes were versioned.
	//
	create dba transient;
	
	if system.getDatabaseSubrole = SDS_SubroleRelational then
		self.log("Restarting data pump....");
		dba.rpsStartDataPump(null, null);
		self.log("Data pump and tracker have been restarted.");
		
	else
		dba.sdsStartTracking();
		self.log("Tracking has been restarted.");
	endif;
epilog
	delete dba;
end;
}
zStopKCCMgr
{
zStopKCCMgr() : Boolean protected;

vars
	cc		: CnCntrl;
	
	proc	: Process;
	
	root	: CnRoot;
	
	tries	: Integer;
begin
	create cc transient;
	root := CnRoot.firstInstance();
	if root = null then
		root := CnRoot.firstSharedTransientInstance();
	endif;

	if root = null then
		self.zReportError("Unable to locate CnRoot singleton");
		return false;
	endif;
	
	app.setMyCnRoot(root);
	proc := cc.getProcessForLock(CN_CARDSCHEMA, CN_KCCMGR, true);
	if proc = null then
		self.log("KCCMgr process was not running, stop request not required.");
		return true;
	endif;
	
	// force KCCMgr to close down
	self.log("Causing KCCMgr shutdown event...");
	system.causeEvent(Cn_Process_Shutdown_Command, true, null);
	
	// now wait for KCCMgr to shutdown
	while tries < 10 do
		tries := tries + 1;
		process.sleep(1000);
		proc := cc.getProcessForLock(CN_CARDSCHEMA, CN_KCCMGR, true);
		if proc = null then
			break;
		endif;
		
		self.log("KCCMgr process still running, retrying...");
	endwhile;

	if proc <> null then
		self.zReportError("KCCMgr process is still running.");
		return false;
	endif;
	
	return true;
epilog
	delete cc;
end;
}
zSwitchJournal
{
zSwitchJournal() protected;
/*
	Method provided by JADE Support as a result of JADE PAR #62850.
	
	Aim is to switch the current journal and check that we don't have an outstanding
	transaction as this causes issues with the JADE 7 migration when tring to convert the
	control file (as the abort journal is prior to the current journal).
	
	If we detect that the abort journal is less than the current journal then we
	set the exit-code to -2.
	
	
*/
vars
	dba					:	JadeDatabaseAdmin;
	
	abortJournal		:	Integer;

	chkpointJournal,
	chkpointOffset,
	lastChkpointJournal	:	Integer64;
begin
	create dba;

	// grab last checkpoint journal
	dba.getLastCheckpoint(chkpointJournal, chkpointOffset);
	lastChkpointJournal := chkpointJournal;

	// switch to a new write journal
	dba.closeCurrentJournal();

	// kick off a checkpoint to cause recovery LSN evaluation
	dba.doCheckpoint();

	// wait for the checkpoint (a job queued to the database worker thread) to complete
	while chkpointJournal = lastChkpointJournal do
		process.sleep(500);		// wait 1/2 a sec
		dba.getLastCheckpoint(chkpointJournal, chkpointOffset);
	endwhile;

	// we can't create a quiet point so small transactions could be interleaved with
	// what we are doing. we just can't tell. we can notice if a transaction was and
	// is still active, and warn about that
	abortJournal := dba.getAbortJournalNumber();
	self.log("Abort journal      : " & abortJournal.String);
	self.log("Checkpoint journal : " & chkpointJournal.String);
	if abortJournal < chkpointJournal then
		beginTransaction;
		node.userExitCode := -2;
		commitTransaction;
		self.log("*** Warning: Abort journal(" & abortJournal.String & ") is not the latest checkpoint journal(" & chkpointJournal.String & ")");
		self.log("Exitcode = -2");
		
	else
		self.log("All OK. Abort journal has moved to at least checkpoint journal(" & chkpointJournal.String & ")");
	endif;

epilog
	delete dba;
end;
}
zTransientAnalysis
{
zTransientAnalysis() protected;

/*
	command line syntax:
	
	jadclient path=<system path> ini=<ini file> schema=CardSchema app=KCBatch server=multiUser endJade
		action=transientAnalysis process=<process oid> 
		
	exitcode values:
	0	- successful, process transients analyzed and placed in file <log dir>\logs
	1  	- unable to locate process defined
*/
vars
	cc				: CnCntrl;
	
	file			: File;
	
	proc,
	procFound		: Process;
	
	invalid			: Boolean;
	
	pos				: Integer;
	
	action,
	oidStr,
	processOid,
	transientUsage,
	str,
	str2			: String;
	
	ts				: TimeStamp;
begin
	cc				:= app.myCnCntrl;
	if self.initParams.size() <> 2 then
		self.zReportError("Expected 2 command line parameters");
		app.cnTerminate();
	endif;
	
	foreach str2 in self.initParams do
		str 		:= str2.toLower();
		pos 		:= 1;
		action 		:= str.scanUntil(CN_EQUAL, pos);
		if action = "action" then
			// ignore action command
		
		elseif action = "process" then
			pos 	:= pos + 1;
			processOid := str2[pos:end];
		
		else
			self.zReportError("Unknown command line parameter : " & str2);
			app.cnTerminate();
		endif;
	endforeach;

	if not processOid.cnIsDecimalAndNotNegative(true) then
		self.zReportError("Invalid process oid : " & processOid);
		app.cnTerminate();
	endif;
	
	pos := 1;
	if processOid.scanUntil(CN_PERIOD, pos).Integer <> 187 then
		self.zReportError("Invalid process oid, class should be 187 : " & processOid);
		app.cnTerminate();
	endif;
	
	on SystemException do app.cnGenericExceptionHandler(exception, 1090, null, invalid);
	on SystemException do app.cnGenericExceptionHandler(exception, 4, null, invalid);
	foreach proc in Process.instances do
		invalid 	:= false;
		oidStr		:= self.getOidStringForObject(proc);
		if invalid then
			continue;
		endif;
		
		if processOid = oidStr then
			procFound := proc;
			break;
		endif;
	endforeach;

	if procFound = null then
		self.zReportError("Process oid " & processOid & " is not running");
		app.cnTerminate();
	endif;

	beginNotification(process, Process_TDB_Analysis_Event, Response_Continuous, null);
	procFound.sendTransientFileAnalysis();
	self.log("Sent 'transientFileAnalysis' request to " & processOid);
epilog
	delete file;
end;
}
zTransientFileCompact
{
zTransientFileCompact() protected;

/*
	command line syntax:
	
	jadclient path=<system path> ini=<ini file> schema=CardSchema app=KCBatch server=multiUser endJade
		action=transientFileCompact process=<process oid> 
		
	exitcode values:
	0	- successful, process transients analyzed and placed in file <log dir>\logs
	1  	- unable to locate process defined
*/
vars
	cc				: CnCntrl;
	
	file			: File;
	
	proc,
	procFound		: Process;
	
	invalid			: Boolean;
	
	pos				: Integer;
	
	action,
	oidStr,
	processOid,
	transientUsage,
	str,
	str2			: String;
	
	ts				: TimeStamp;
begin
	cc				:= app.myCnCntrl;
	if self.initParams.size() <> 2 then
		self.zReportError("Expected 2 command line parameters");
		app.cnTerminate();
	endif;
	
	foreach str2 in self.initParams do
		str 		:= str2.toLower();
		pos 		:= 1;
		action 		:= str.scanUntil(CN_EQUAL, pos);
		if action = "action" then
			// ignore action command
		
		elseif action = "process" then
			pos 	:= pos + 1;
			processOid := str2[pos:end];
		
		else
			self.zReportError("Unknown command line parameter : " & str2);
			app.cnTerminate();
		endif;
	endforeach;

	if not processOid.cnIsDecimalAndNotNegative(true) then
		self.zReportError("Invalid process oid : " & processOid);
		app.cnTerminate();
	endif;
	
	pos := 1;
	if processOid.scanUntil(CN_PERIOD, pos).Integer <> 187 then
		self.zReportError("Invalid process oid, class should be 187 : " & processOid);
		app.cnTerminate();
	endif;
	
	on SystemException do app.cnGenericExceptionHandler(exception, 1090, null, invalid);
	on SystemException do app.cnGenericExceptionHandler(exception, 4, null, invalid);
	foreach proc in Process.instances do
		invalid 	:= false;
		oidStr		:= self.getOidStringForObject(proc);
		if invalid then
			continue;
		endif;
		
		if processOid = oidStr then
			procFound := proc;
			break;
		endif;
	endforeach;

	if procFound = null then
		self.zReportError("Process oid " & processOid & " is not running");
		app.cnTerminate();
	endif;

	procFound.causeEvent(CN_COMPACT_TRANSIENT_FILE, true, null);
	self.log("Sent 'compact transient file' request to " & processOid);
epilog
	delete file;
end;
}
zTransientInfo
{
zTransientInfo() protected;

/*
	command line syntax:
	
	jadclient path=<system path> ini=<ini file> schema=CardSchema app=KCBatch server=multiUser endJade
		action=transientinfo process=<process oid> 
		
	exitcode values:
	0	- successful, process transients analyzed and placed in file <log dir>\logs
	1  	- unable to locate process defined
*/
vars
	cc				: CnCntrl;
	
	file			: File;
	
	proc,
	procFound		: Process;
	
	invalid			: Boolean;
	
	pos				: Integer;
	
	action,
	oidStr,
	processOid,
	transientUsage,
	str,
	str2			: String;
	
	ts				: TimeStamp;
begin
	cc				:= app.myCnCntrl;
	if self.initParams.size() <> 2 then
		self.zReportError("Expected 2 command line parameters");
		app.cnTerminate();
	endif;
	
	foreach str2 in self.initParams do
		str 		:= str2.toLower();
		pos 		:= 1;
		action 		:= str.scanUntil(CN_EQUAL, pos);
		if action = "action" then
			// ignore action command
		
		elseif action = "process" then
			pos 	:= pos + 1;
			processOid := str2[pos:end];
		
		else
			self.zReportError("Unknown command line parameter : " & str2);
			app.cnTerminate();
		endif;
	endforeach;

	if not processOid.cnIsDecimalAndNotNegative(true) then
		self.zReportError("Invalid process oid : " & processOid);
		app.cnTerminate();
	endif;
	
	pos := 1;
	if processOid.scanUntil(CN_PERIOD, pos).Integer <> 187 then
		self.zReportError("Invalid process oid, class should be 187 : " & processOid);
		app.cnTerminate();
	endif;
	
	on SystemException do app.cnGenericExceptionHandler(exception, 1090, null, invalid);
	on SystemException do app.cnGenericExceptionHandler(exception, 4, null, invalid);
	foreach proc in Process.instances do
		invalid 	:= false;
		oidStr		:= self.getOidStringForObject(proc);
		if invalid then
			continue;
		endif;
		
		if processOid = oidStr then
			procFound := proc;
			break;
		endif;
	endforeach;

	if procFound = null then
		self.zReportError("Process oid " & processOid & " is not running");
		app.cnTerminate();
	endif;

	beginNotification(process, Process_TDB_Info_Event, Response_Continuous, null);
	procFound.sendTransientFileInfo();
	self.log("Sent 'transientFileInfo' request to " & processOid);
epilog
	delete file;
end;
}
zValidateUser
{
zValidateUser() protected;

vars
	cem				: CnExternalMethods;
	
	maxLength,
	result			: Integer;
	
	account,
	accountGroup,
	adminGroup,
	userCode		: String;
begin
	create cem transient;
	maxLength := 50;
	// can't use process userCode or signOnUserCode as process in Non_GUI
	result := cem.emGetUserName(userCode, maxLength);
	if result <> null then
		self.zReportError("Unexpected result from emGetUserName : " & result.String);
		return;
	endif;
		
	self.log("Running with usercode " & userCode);
	if userCode.toLower() = "system" then
		self.log("Signed on with SYSTEM account");
		return;
	endif;
	
	account 		:= app.cnGetEnvironmentId();
	if userCode = account then
		self.log("Signed on with correct account");
		return;
	endif;
	
	accountGroup	:= account & "_m";
	if cem.cnGroupCheck(userCode, accountGroup, result) then
		self.log("Signed on as user " & userCode & " which is valid in group " & accountGroup);
		return;
	endif;
	
	accountGroup := cem.emGetAdministratorsGroup();
	if cem.cnGroupCheck(userCode, accountGroup, result) then
		self.log("Signed on as user " & userCode & " which is valid in group " & accountGroup);
		return;
	endif;
	
	self.zReportError("Invalid usercode for this function : " & userCode);
epilog
	delete cem;
end;
}
zVerifyCardSchemaVersion
{
zVerifyCardSchemaVersion() protected;

vars
	cc				: CnCntrl;
	
	file			: File;

	len,
	lineCount,
	pos				: Integer;

	action,
	fileName,
	line,
	str,
	str2,
	versionFromFile,
	versionRequired	: String;
begin
	cc				:= app.myCnCntrl;
	if self.initParams.size() <> 3 then
		self.zReportError("Expected 3 command line parameters");
		app.cnTerminate();
	endif;
	
	foreach str2 in self.initParams do
		str 		:= str2.toLower();
		pos 		:= 1;
		action 		:= str.scanUntil(CN_EQUAL, pos);
		if action = "action" then
			// ignore action command
		
		elseif action = "version" then
			pos 	:= pos + 1;
			versionRequired := str2[pos:end];
		
		elseif action = "file" then
			pos 	:= pos + 1;
			fileName := str2[pos:end];
			
		else
			self.zReportError("Unknown command line parameter : " & str2);
			app.cnTerminate();
		endif;
	endforeach;

	if versionRequired = null then
		self.zReportError("Version is expected");
		terminate;
	endif;
	
	if versionRequired.cnCountCharOccurences(CN_PERIOD) <> 3 then 
		self.zReportError("Version format required <mm.r.cc.ppp>");
		terminate;
	endif;
	
	versionRequired := versionRequired.cnMarkReleaseCutPatchString();
	
	if fileName = null then
		self.zReportError("File is expected");
		terminate;
	endif;
	
	create file transient;
	file.fileName := fileName;
	file.mode := file.Mode_Input;
	if not file.isAvailable() then
		self.zReportError("File is not resident");
		terminate;
	endif;
	
	while not file.endOfFile do
		line := file.readLine();
		lineCount := lineCount + 1;
		pos := line.pos("CardSchema_Version:", 1);
		if pos = null then
			continue;
		endif;
		
//		self.log("Found 'CardSchema_Version:' in line #" & lineCount.String);
		line.scanUntil(CN_DOUBLE_QUOTE, pos);
		if pos = null then
			self.zReportError("Expected to locate version literal in line #" & lineCount.String);
			terminate;
		endif;
		
//		self.log("Found start of literal at offset " & pos.String);
		pos := pos + 1;
		len := line.length();
		if pos <= len then 
			versionFromFile := line.scanUntil(CN_DOUBLE_QUOTE, pos);
			self.log("CardSchema version from file '" & versionFromFile & "'");
			break;
		endif;
			
		self.zReportError("Unexpected CardSchema version at line #" & lineCount.String & ", unexpected end of line.");
		terminate;
	endwhile;
	
	versionFromFile := versionFromFile.cnMarkReleaseCutPatchString();
	if versionFromFile.cnCountCharOccurences(CN_PERIOD) <> 3 then
		self.zReportError("Version '" & versionFromFile & "' in file not expected format <mm.r.cc.ppp>");
		terminate;
	endif;
	
	if versionFromFile <> versionRequired then
		self.zReportError("File version '" & versionFromFile & "' does not match required version '" & versionRequired & "'");
		terminate;
	endif;
	
	self.log("File version '" & versionFromFile & "' matches required version");
epilog
	delete file;
end;
}
	)
	CnJadeCareExecutor (
	jadeMethodSources
executeCardSchemaValidateMethods
{
executeCardSchemaValidateMethods(pExecuteFunction 	: String;
								 pItemIndex			: Integer;
								 pItemName			: String;
								 pParameters 		: HugeStringArray) updating;

vars
	cc						: CnCntrl;
	
	proc					: Process;
	
	sz						: Integer;
begin
	cc := app.myCnCntrl;
	self.zLoadSelf(pExecuteFunction,
					pItemIndex,
					pItemName);
	sz := pParameters.size();
	if sz > null then
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName & " ERROR : " & sz.String & " parameters passed, none expected", null);
		self.causeEvent(Cn_JadeCareInstaller_Response, true, "ERROR" & CN_PIPE & sz.String & " parameters passed, none expected");
		return;
	endif;
	
	
	// while there are no incoming parameters, the shared transient is
	// still required to receive the response parameters
	beginTransientTransaction;
	create self.parameters sharedTransient;
	pParameters.copy(self.parameters);
	commitTransientTransaction;
	
	proc := app.startApplicationWithParameter(CN_CARDSCHEMA, CN_KCVALIDATEMETHODS, self.parameters);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " started process " & proc.String, null);
	self.beginNotification(proc, Object_Delete_Event, Response_Cancel, Cn_JadeCareInstaller_Terminate);
end;
}
executeJadeRecompileAllMethods
{
executeJadeRecompileAllMethods(pExecuteFunction 	: String;
								 pItemIndex			: Integer;
								 pItemName			: String;
								 pParameters 		: HugeStringArray) updating;

vars
	cc						: CnCntrl;
	
	proc					: Process;
	sz						: Integer;
begin
	cc := app.myCnCntrl;
	self.zLoadSelf(pExecuteFunction,
					pItemIndex,
					pItemName);
	sz := pParameters.size();
	if sz > null then
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName & " ERROR : " & sz.String & " parameters passed, none expected", null);
		self.causeEvent(Cn_JadeCareInstaller_Response, true, "ERROR" & CN_PIPE & sz.String & " parameters passed, none expected");
		return;
	endif;
	
	beginTransientTransaction;
	create self.parameters sharedTransient;
	pParameters.copy(self.parameters);
	commitTransientTransaction;
	
	proc := app.startApplicationWithParameter(CN_ROOTSCHEMA, CN_JADERECOMPILEALLMETHODS, self.parameters);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " started process " & proc.String, null);
	self.beginNotification(proc, Object_Delete_Event, Response_Cancel, Cn_JadeCareInstaller_Terminate);
end;
}
executeJadeReorgApp
{
executeJadeReorgApp(pExecuteFunction 	: String;
					 pItemIndex			: Integer;
					 pItemName			: String;
					 pParameters : HugeStringArray) updating;

vars
	cc						: CnCntrl;
	
	proc					: Process;
begin
	cc := app.myCnCntrl;
	self.zLoadSelf(pExecuteFunction,
					pItemIndex,
					pItemName);
	
	if pParameters.isEmpty() then
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName & " ERROR : no parameters passed", null);
		self.causeEvent(Cn_JadeCareInstaller_Response, true, "ERROR" & CN_PIPE & "no parameters passed");
		return;
	endif;
	
	beginTransientTransaction;
	create self.parameters sharedTransient;
	pParameters.copy(self.parameters);
	commitTransientTransaction;
	
	proc := app.startApplicationWithParameter(CN_ROOTSCHEMA, CN_JADEREORGAPP, self.parameters);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " started process " & proc.String, null);
	self.beginNotification(proc, Object_Delete_Event, Response_Cancel, Cn_JadeCareInstaller_Terminate);
end;
}
executeJadeSchemaLoader
{
executeJadeSchemaLoader(pExecuteFunction 	: String;
								 pItemIndex			: Integer;
								 pItemName			: String;
								 pParameters 		: HugeStringArray) updating;

vars
	cc						: CnCntrl;
	
	proc					: Process;
begin
	cc := app.myCnCntrl;
	self.zLoadSelf(pExecuteFunction,
					pItemIndex,
					pItemName);
	if pParameters.isEmpty() then
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName & " ERROR : no parameters passed", null);
		self.causeEvent(Cn_JadeCareInstaller_Response, true, "ERROR" & CN_PIPE & "no parameters passed");
		return;
	endif;
	
	beginTransientTransaction;
	create self.parameters sharedTransient;
	pParameters.copy(self.parameters);
	commitTransientTransaction;
	
	proc := app.startApplicationWithParameter(CN_ROOTSCHEMA, CN_JADESCHEMALOADER, self.parameters);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " started process " & proc.String, null);
	self.beginNotification(proc, Object_Delete_Event, Response_Cancel, Cn_JadeCareInstaller_Terminate);
end;
}
sysNotification
{
sysNotification(eventType: Integer; theObject: Object; eventTag: Integer) updating;

vars
	cc			: CnCntrl;
	
	len,
	result		: Integer;
	
	response,
	str			: String;
begin
	cc			:= app.myCnCntrl;
	if eventType = Object_Delete_Event			 and
	   eventTag = Cn_JadeCareInstaller_Terminate then
		str := self.parameters.last();
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " " & self.executeFunction & " response : '" & str & "'", null);
		len		:= str.length();
		if len > 7 				and
		   str[1:7] = "result=" then
			response := str[8:end];
		
		elseif len > 7 then
			response := "ERROR" & CN_PIPE & "Expected 'result=' header in response";
		
		else
			response := "ERROR" & CN_PIPE & "Expected response expected to be 8 bytes or more";
		endif;
		
		self.causeEvent(Cn_JadeCareInstaller_Response, true, response);
		beginTransientTransaction;
		delete self.parameters;
		commitTransientTransaction;
		return;
	endif;
end;
}
userNotification
{
userNotification(eventType: Integer; theObject: Object; eventTag: Integer; userInfo: Any) updating;

vars
	cc			: CnCntrl;
	
	execAdv		: CnExecuteAdvice;
	
	kc			: CnKarmaCntrl;
	
	msg,
	newmsg		: CnMessage;

	exitCode,
	pos			: Integer;
	
	errorMsg,
	info		: String;
begin
	kc			:= app.myCnKarmaCntrl;
	cc			:= app.myCnCntrl;
	info 		:= userInfo.String;
	pos 		:= info.reversePos(CN_PIPE);
	if pos = null then
		exitCode := info.Integer;
	
	else
		errorMsg :=	info[pos+1:end];
		exitCode := -1;
	endif;
	
	create msg transient;
	msg.createNewMsg(msg.Advice, msg.Execute_Advice, kc.localFQDN, kc.localIpAddress, cc.Application_Process, cc.KarmaCommsMgr_Process, newmsg);
	execAdv		:= newmsg.CnExecuteAdvice;
	execAdv.setManagedEnvironmentName(kc.managedEnvironmentName);
	execAdv.setExecuteFunction(self.executeFunction);
	execAdv.setItemIndex(self.fileIndex);
	execAdv.setItemName(self.fileName);
	execAdv.setExitCode(exitCode);
	execAdv.setErrorMessage(errorMsg);
	execAdv.sendMessage(kc.myParentTcp);
epilog
	delete msg;
	delete newmsg;
	delete self;
end;
}
zLoadSelf
{
zLoadSelf(pExecuteFunction 	: String;
		 pFileIndex			: Integer;
		 pFileName			: String) updating, protected;

vars

begin
	self.executeFunction 	:= pExecuteFunction;
	self.fileIndex			:= pFileIndex;
	self.fileName			:= pFileName;
	self.beginNotification(self, Cn_JadeCareInstaller_Response, Response_Cancel, null);
end;
}
	)
	CnSecurityManager (
	jadeMethodSources
getCertificateDetails
{
getCertificateDetails(pFileName 	: String; 
						pSubject 	: String output;
						pExpiryDate	: Date output) : Boolean;
						
/*
	Accesses the SSL certificate and derives the expiry date and subject.

	This executes the openssl utility which is located:
	- Windows - in the binaries of the JADE environment (c_bin)
	- Linux   - in /usr/bin which should be defined in the system path
	
	Input	: FileName		- the fully qualified file name of the certificate to be accessed
	
	Output	: Subject		- the internal subject name in the certificate
	
			  ExpiryDate	- the expiry date assigned to the certificate
			  
	Result	: true			- found file and got certificate details
	
			  false			- unable to locate certificate file or get details
*/
vars
	file		: File;
	
	cem			: CnExternalMethods;
	
	expiryDate	: Date;
	
	bin			: Binary;
	
	command,
	dateStr,
	day,
	endOfLine,
	month,
	notAfterDate,
	stdout,
	subject,
	year		: String;

	binLength,
	exitCode,
	pos,
	pos2,
	resultNo	: Integer;
	
	cc			: CnCntrl;
begin
	cc := app.myCnCntrl;
	pExpiryDate := null;
	create file transient;
	file.fileName := pFileName;
	file.usePresentationFileSystem := false;
	file.mode := file.Mode_Input;
	if not file.isAvailable() then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " unable to find certificate '" & pFileName & "'", null);
		return false;
	endif;
	
	if app.cnOSPlatformIsWindows() then
		command := app.getJadeInstallDirAppServer() & "/openssl ";
		endOfLine := file.endOfLine;
	
	else
		command := "openssl ";
		endOfLine := file.endOfLine;
	endif;
	
	command := command & " x509 -in " & pFileName & " -noout -enddate -subject";
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " execute command '" & command & "'", null);
	create cem transient;
	resultNo 	:= cem.emCreateProcessReturnResults(command, null, exitCode, binLength, bin);
	if resultNo <> null or 
	   exitCode <> null then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " openssl failed : result=" & resultNo.String & ", exitCode=" & exitCode.String, null);
		return false;
	endif;

	stdout	:= bin[1:binLength].String;
	pos := stdout.toLower().pos("notafter=", 1);
	if pos = null then
		return false;
	endif;
	
	pos := pos + "notafter=".length();
	pos2 := stdout.pos("GMT", pos);																								// PAR 694
	notAfterDate := stdout[pos:pos2-pos-1];																						// PAR 694
	// now derive date form
	pos := 1;
	month := notAfterDate.scanUntil(" ", pos);
	notAfterDate.scanWhile(" ", pos);
	day := notAfterDate.scanUntil(" ", pos);
	notAfterDate.scanWhile(" ", pos);
	notAfterDate.scanUntil(" ", pos);				// bypass time format
	notAfterDate.scanWhile(" ", pos);
	year := notAfterDate.scanUntil(" ", pos);
	
	dateStr := day & month & year;
	pExpiryDate := dateStr.Date;
	
	pos := stdout.toLower().reversePos("/cn=");
	if pos = null then
		return false;
	endif;
	
	pos := pos + "/cn=".length();
	pSubject := stdout.scanUntil(endOfLine, pos);
	
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " expiryDate=" & pExpiryDate.String &
													", subject=" & pSubject, null);
epilog
	delete file;
	delete cem;
end;
}
	)
	CnStartManager (
	jadeMethodSources
startMonitorBackgroundOnServer
{
startMonitorBackgroundOnServer() : Integer serverExecution;

vars
	file			: File;

	directivesFile,
	iniFile,
	osVersion,
	path			: String;
	
	osArchitecture,
	osPlatform,
	pos				: Integer;
	
	updateIni		: Boolean;
	
	cc				: CnCntrl;
begin
	cc := app.myCnCntrl;
	iniFile := app.getIniFileName();
	directivesFile := app.getProfileString(iniFile, "JadeMonitorBackground", "DirectivesFile", null);
	
	// if ini file setting not found then default to <env>/server/c_bin/directives.txt
	if directivesFile = null then
		updateIni := true;
		osPlatform	:= node.getOSPlatform(osVersion, osArchitecture);
		path := app.dbPath;
		path.replaceChar("\", "/");
		if path[path.length:1] = "/" then
			path := path[1:path.length-1];
		endif;
		
		pos := path.reversePos("/");
		if osPlatform = Node.OSWindows 				or
		   osPlatform = Node.OSWindowsEnterprise 	or
		   osPlatform = Node.OSWindowsHome			then
			path := path[1:pos] & "c_bin";
			
		else
			path := path[1:pos] & "bin";
		endif;
		
		directivesFile := path & "/directives.txt";
		cc.cnWriteLog(cc.CnLogComment, "Defaulting to directives file '" & directivesFile & "'.", null);
	
	else
		cc.cnWriteLog(cc.CnLogComment, "Ini file specifies directives file '" & directivesFile & "'.", null);
	endif;
	
	create file transient;
	file.fileName := directivesFile;
	file.mode := file.Mode_Input;
	if not file.isAvailable() then
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " no directives file found '" & directivesFile & "'.", null);
		return 2;
	endif;
	
	if updateIni then
		app.setProfileString(iniFile, "JadeMonitorBackground", "DirectivesFile", directivesFile);
		cc.cnWriteLog(cc.CnLogComment, "Updated ini file [JadeMonitorBackground] DirectivesFile=" & directivesFile, null);
	endif;
	
	app.startApplication(CN_JADEMONITORSCHEMA, CN_JADEMONITORBACKGROUND);
	cc.cnWriteLog(cc.CnLogComment, "Started JadeMonitorBackground.", null);
	return 1;
epilog
	delete file;
end;
}
	)
	CnNameSizeInfo (
	jadeMethodSources
loadSelf
{
loadSelf(pName : String; pDec : Decimal) updating;

vars

begin
	self.name := pName;
	self.size := pDec;
end;
}
setMapFileItems
{
setMapFileItems(pPath : String; pRestoreSize, pInitialSize, pExtentSize : Decimal) updating;

vars

begin
	self.path := pPath;
	self.restoredSize := pRestoreSize;
	self.initialSize := pInitialSize;
	self.extentSize := pExtentSize;
end;
}
setSize
{
setSize(pDec : Decimal) updating;

vars

begin
	self.size := pDec;
end;
}
	)
	CnSchemaElement (
	jadeMethodSources
getName
{
getName(): String;

vars

begin
	return self.appName & " of " & self.appSchemaName & 
				" (" & self.lastModified.date.cnUserFormat($CnDDMMYY) & " " & self.lastModified.time.cnUserFormat($CnHHMMSS) & ")";
end;
}
loadSelf
{
loadSelf(pSchema, 
		 pName, 
		 pVersionTag 	: String; 
		 pFileType 		: Character; 
		 pLastModified 	: TimeStamp) updating;

vars
	ts		: TimeStamp;
	
	xName	: String;
	
	cc		: CnCntrl;
begin
	cc := app.myCnCntrl;
	ts	  := pLastModified;
	xName := pName;
	if pVersionTag <> null then
		xName := xName & "_" & pVersionTag;		// patchset
	endif;
	
	if pFileType = "D" then						// ddbfile, always set milliseconds to 999 to make unique
		ts := ts + 999.Time;
	endif;

	self.appName 		:= xName;
	self.appSchemaName 	:= pSchema;
	self.schemaFileType := pFileType;
	self.lastModified 	:= ts;
/*	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " schema=" & pSchema & 
														", name=" & xName & 
														", schemaFileType=" & pFileType & 
														", lastModified=" & ts.date().cnUserFormat($CnCCYYMMDD) & " " & ts.time().cnUserFormat($CnHHMMSS), null);
*/
end;
}
	)
	CnVariant (
	jadeMethodSources
getValue
{
getValue() : Any;

vars
	cc	: CnCntrl;
begin
	if myType	= Object then
		return self.oidString.asObject();
	else
		return value.cnAsType(myType);
	endif;
end;
}
setValue
{
setValue(val : Any) updating;

vars

begin
	if val.isKindOf(Object) then
		oidString		:= self.getObjectStringForObject(val.Object);
	else
		self.value 		:= val.Binary;
	endif;
	
	self.myType	:= val.cnGetType;
end;
}
	)
	CnNamedPipe (
	jadeMethodSources
cnArmNamedPipeExceptionHandler
{
cnArmNamedPipeExceptionHandler();

vars

begin
	// Currently requires re-implementation in subschema : arm globally	
end;
}
cnClose
{
cnClose(receiver : Object) updating;

vars
 	cc : CnCntrl;
begin
	cc:= app.myCnCntrl;
	self.cnSetMyReceiver(receiver);

	if self.state <> 0 then
	 	cc.cnWriteLog(cc.CnLogConnect, "Closing connection #" & self.connectionNo.String & 
	 					   ", state=" & self.state.String & ", computer=" & self.serverName, null);
	 	self.closeAsynch(receiver, "cnCloseNotify");
	else
	 	cc.cnWriteLog(cc.CnLogConnect, "Connection #" & self.connectionNo.String & " now closed.", null);
	endif;
end;
}
cnCloseNotify
{
cnCloseNotify(tcp : CnNamedPipe input) updating;

vars
 	s : String;
 	cc : CnCntrl;
begin
	cc := app.myCnCntrl;
	s := cc.appName & " named pipe connection #" & tcp.connectionNo.String;
    
	s := s & " successfully closed";
	tcp.retryNo := 0;
	cc.cnWriteLog(cc.CnLogConnect, s, null);

	///  The user may want to reimplement this method (use inheritMethod), because
	///  typically you'd want to perform another cnListen or CnOpen at this point, 
	///  or delete the tcp object.
end;
}
cnGetBodyLength
{
cnGetBodyLength(buf : Binary; preambleLength : Integer) : Integer protected;

vars
	
begin
	if app.isUnicode then
		return buf[preambleLength + 1 : self.headerLength - preambleLength].ansiToUnicode.Integer;
		
	else
		return buf[preambleLength + 1 : self.headerLength - preambleLength].String.Integer;
	endif;
end;
}
cnHaltConnection
{
cnHaltConnection() updating;

vars
 	cc : CnCntrl;
 	action : String;
begin
	///  Used when retry limit exceeded - halt the connection and leave it in a closed state ///

	cc := app.myCnCntrl;

	cc.cnWriteLog(cc.CnLogErrors, "Named pipe operation failed : retry limit exceeded : halting connection #" &
						 self.connectionNo.String & " from/to " & self.serverName, null);
	if self.state <> 0 then
		self.cnClose(self.myReceiver);
	endif;

	self.retryNo := 0;
end;
}
cnListen
{
cnListen(portNo : Integer; receiver : Object) updating;

vars
   	cc			: CnCntrl;
begin
	////  portNo is included in the signature only to provide compatibility with
	////  CnTcpConnection classes.  Not actually used.

	cc := app.myCnCntrl;
    self.cnArmNamedPipeExceptionHandler;
 	if portNo = 0 then
 		app.msgBox("TCP port not specified in CnTcpConnection::cnListen", "Error",0);
 		return;
 	endif;
 	if self.state <> 0 then
 		app.msgBox("Wrong TCP state (=" & self.state.String & ") in TcpCnConnection::cnListen", "Error",0);
 		return;
 	endif;

	if self.connectionNo = 0 then
		cc.bumpConnectionNo;
		self.connectionNo := cc.connectionNo;
	endif;

    if self.headerLength = 0 then					// use default from CnCntrl
    	self.headerLength 		:= cc.headerLength;
	    if cc.headerLength < 1 then
			app.msgBox("Message header length not specified, in CnNamedPipe::cnListen", "Fatal Error", 0);
			//
			//  The above should have been set up in CnCntrl by user code, typically during initialisation  ////
			// 
			return;
		endif;
	endif;

    self.cnSetMyReceiver(receiver);

    if self.retryNo <= cc.connectionRetryLimit then
    	self.listenAsynch(receiver, "cnListenNotify");
    	cc.cnWriteLog(cc.CnLogConnect, cc.appName & " : named pipe connection=" & self.connectionNo.String &
    					   " now listening, retry=" & self.retryNo.String, null);
   	else 
   		self.cnHaltConnection();
	endif;
end;
}
cnListenNotify
{
cnListenNotify(tcp : CnNamedPipe input) updating;

vars
 	cc : CnCntrl;
begin
 	///   This is a default handler for listen notifications.  This is invoked
 	///   when another computer attempts to connect to the listening named pipe object.
 	///   You will normally need to reimplement this method and use inheritMethod, and
 	///	  code your own additional requirements.

 	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogConnect, "Connection established from host " & 
					   tcp.serverName & " on connection #" & tcp.connectionNo.String &
					   " : pipe name = " & tcp.name, null);

	tcp.msgHeader 		:= null;
	tcp.retryNo 		:= 0;

	cc.bumpConnectionCount;

	/// At this juncture, someone needs to start the dialog by performing a cnRead
	/// or a cnWrite.  You need to code this when re-implementing this method (use
	/// inheritMethod).  
end;
}
cnOpen
{
cnOpen(computer : String; pipeName : String; receiver : Object) updating;

vars
	cc : CnCntrl;
begin
	cc := app.myCnCntrl;
	cnArmNamedPipeExceptionHandler();					// typically you should arm this 'global'
	self.serverName		:= computer;
	if self.headerLength = 0 then
		self.headerLength 	:= cc.headerLength;
	endif;
	self.cnSetMyReceiver(receiver);
	self.name			:= pipeName;
	self.fillReadBuffer	:= true;
	
	if self.connectionNo = 0 then
		cc.bumpConnectionNo;
		self.connectionNo := cc.connectionNo;
	endif;

	if self.retryNo <= cc.connectionRetryLimit then
		cc.cnWriteLog(cc.CnLogConnect, cc.appName &
				    " opening named pipe '" & pipeName & "' connection to " & self.name & ", retry=" &
				    self.retryNo.String & " connection #" & self.connectionNo.String & " (" & self.String & ")", null);
		if self.state <> 0 then
			cc.cnWriteLog(cc.CnLogErrors, "Wrong connection state for cnOpen : state=" & self.state.String, null);
			return;
		else
			self.openAsynch(receiver, "cnOpenNotify");
		endif;
	else
		self.cnHaltConnection();						// error halt
	endif;
end;
}
cnOpenNotify
{
cnOpenNotify(tcp : CnNamedPipe input) updating;

vars
 	cc : CnCntrl;
begin
 	cc := app.myCnCntrl;
 	tcp.endTimer(1);

	cc.cnWriteLog(cc.CnLogConnect, "CnNamedPipe::cnOpenNotify : successful outbound connection : " & 
							       " connectionNo=" & tcp.connectionNo.String &
							   	   ", computer=" & tcp.serverName &
							   	   ", pipeName=" & tcp.name, null);

	cc.bumpConnectionCount;
	tcp.retryNo := 0;

	///////  Typically the developer will reimplement this (use inheritMethod) and    //////
	///////  add code to take appropriate action after the open, e.g. a read		  //////
end;
}
cnProcessHeader
{
cnProcessHeader(buf : Binary) : Integer updating;

vars
 	cc 				: CnCntrl;
 	preamble		: Binary;
 	preambleLength	: Integer;
begin
	/////	 This method returns the length of the message body    	/////

	cc 				:= app.myCnCntrl;
	preamble		:= user_cnGetPreambleDefinition;
	preambleLength	:= preamble.length; 

	if preamble <> null and buf[1:preambleLength] = preamble then		// valid header
		return cnGetBodyLength(buf, preambleLength);			
	else
		return -1;
	endif;
end;
}
cnRaiseConnectionException
{
cnRaiseConnectionException(errorCode : Integer; errorText : String) updating, protected;

vars
	exObj : ConnectionException;
begin
	create exObj;
	exObj.errorCode 		:= errorCode;
	exObj.extendedErrorText	:= errorText;
	exObj.continuable		:= true;
	exObj.cnSetConnection(self);
	raise exObj;
end;
}
cnRead
{
cnRead(receiver : Object) updating;

vars
  	cc : CnCntrl;
begin
	cc := app.myCnCntrl;
    self.cnArmNamedPipeExceptionHandler();
	cc.cnWriteLog(cc.CnLogDiag, "Named pipe '" & self.name & "', connection #" & self.connectionNo.String &
							   " about to readAsync....", null);
	self.cnSetMyReceiver(receiver);
	self.msgHeader := null;
	self.readBinaryAsynch(self.headerLength, receiver, "cnReadNotifyHeader");
end;
}
cnReadNotify
{
cnReadNotify(tcp : CnNamedPipe input; buf : Binary) updating;

vars
	err : String;
	cc 	: CnCntrl;
	len	: Integer;
begin
	//   This method is invoked when the message BODY is received.  The body is   /////
	//   returned in Binary buf.												  /////

	cc 	:= app.myCnCntrl;
	len	:= buf.length;
	cc.cnWriteLog(cc.CnLogDiag, "CnNamedPipe::cnReadNotify : new msg from " & tcp.serverName &  
								", bodylength=" & len.String & ", data=" & 
								tcp.msgHeader.cnAnsiToString(tcp.msgHeaderLength) & buf.cnAnsiToString(len), null);
	tcp.retryNo := 0;
	tcp.msgHeader := null;

	//  The user should normally re-implement this method and use inheritMethod.  At
	//  this point the user should complete any other validity checks (on the 
	//  data received in buf) and then process the received data.  Usually, the last thing
	//  you'd do in this method would be to perform another cnRead.
end;
}
cnReadNotifyHeader
{
cnReadNotifyHeader(tcp : CnNamedPipe input; buf : Binary) updating;

vars
 	length, len, pos 	: Integer;
 	s, str2				: String;
 	cc 					: CnCntrl;
 	foundHeaderStart 	: Boolean;
 
begin
	//  We come here when we've read the number of bytes that should be in the 
	//  message header.  We now check to see if this is a valid header (user code
	//  required) and then fire off another read to get the body.

	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, "Received header or part header from " & 
					   tcp.serverName & ", pipe name=" & tcp.name & ", on connection #" & tcp.connectionNo.String &
					   " (" & tcp.String & "), buf=" & buf.ansiToString, null);

	length := cnProcessHeader(buf);							// this should return the length of the 
															// message body, or -1 if invalid header
	if length > 0 and buf.length = tcp.headerLength then	// This is the expected, normal result so
		tcp.msgHeader := buf;								// we initiate the read of the message body
		tcp.msgHeaderLength	:= buf.length;
		tcp.readBinaryAsynch(length, tcp.myReceiver, "cnReadNotify"); 
		return;
	endif;	

    /////  If we get to here then we have probably got a corrupted data stream.   As of 2.6.100     	////
    /////  we give up immediately i.e. break the connection and raise a connection exception.		////	 	
	
	cc.cnWriteLog(cc.CnLogErrors, "Connection " & tcp.String & "(#" & tcp.connectionNo.String & 
				  ") appears to have bad header (value=" & buf.ansiToString & buf.display & ") - will close connection.", null);
	tcp.close();
	cnRaiseConnectionException(Cn_Tcp_Header_Error, "Named pipe message had unrecognised message header.");
end;
}
cnSetMyReceiver
{
cnSetMyReceiver(receiver : Object) updating;

vars

begin
 	self.myReceiver := receiver;
end;
}
cnWrite
{
cnWrite(body : Binary; receiver : Object) updating;

vars
 	buffer 	: String;
 	cc 		: CnCntrl;
 	bin		: Binary;
 	str		: String;
begin
	cc := app.myCnCntrl;
	self.cnArmNamedPipeExceptionHandler();

	bin := self.user_cnBuildHeader(body) & body;
	
 	self.cnSetMyReceiver(receiver);

    if self.retryNo <= cc.connectionRetryLimit then
    	str := "Named pipe connection #" & connectionNo.String & " (" & self.String & ") sending to " &
    		   self.serverName & 	", bodylength=" & body.length.String;

    	if bin.length < 300 then
    		str := str & ", data=" & bin.cnAnsiToString(bin.length);
    	else
    		str := str & ", data=" & bin[1:300].cnAnsiToString(300) & ".... [truncated]";
    	endif;
    	
 		cc.cnWriteLog(cc.CnLogTransmit, str, null);
 		self.writeBinaryAsynch(bin, receiver, "cnWriteNotify");
 	else
 		self.cnHaltConnection();							// error
 	endif;	
end;
}
cnWriteNotify
{
cnWriteNotify(tcp : CnNamedPipe input) updating;

vars
	cc	: CnCntrl;
begin
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, "::cnWriteNotify for named pipe (" & tcp.name & ") connection #" &
				  tcp.connectionNo.String, null);
 	tcp.retryNo := 0;
end;
}
user_cnBuildHeader
{
user_cnBuildHeader(body : Binary) : Binary updating;

vars
 	msgnolength : Integer;
 	length 		: Integer;
 	cc			: CnCntrl;
 	preamble 	: Binary;
 	msgLenStr	: String;
	msgLenBin	: Binary;
	
begin
	/// This method returns a header binary string that defines the length of the message body, prefixed
	/// by default with an SOH & "CNW".  Currently, headers are always ANSI format, even in unicode systems. 

	cc 			:= app.myCnCntrl;
	length 		:= body.length;
	preamble 	:= user_cnGetPreambleDefinition;
	msgnolength := self.headerLength - preamble.length;		// set the length of the output string  
															// allow 4 octets for the SOH-CNW preamble
	msgLenStr	:= length.String.padLeadingZeros(msgnolength);														
	
	if app.isUnicode then														
		msgLenBin	:= msgLenStr.cnUnicodeToAnsi;
	else
		msgLenBin	:= msgLenStr.Binary;
	endif;
	
    return preamble & msgLenBin;
end;
}
user_cnGetPreambleDefinition
{
user_cnGetPreambleDefinition() : Binary;

vars
	cc 	: CnCntrl;
	str	: String;
begin
	////   This method defines the header preamble.  You can reimplement this   //////
	////   method if you want to change the preamble.	Also see method			////// 
	////   user_cnBuildHeader													//////

	cc 	:= app.myCnCntrl;
	str	:= cc.Cn_SOH & "CNW";
	
	if app.isUnicode then
 		return str.cnUnicodeToAnsi;
 	else
 		return str.Binary;
 	endif;
end;
}
	)
	CnDeployMgrTcpConnection (
	jadeMethodSources
buildHeader
{
buildHeader(body : Binary) : Binary;

vars
 	msgnolength : Integer;
 	length 		: Integer;
 	preamble 	: Binary;
	msgLenBin	: Binary;
	
begin
	/// This method returns a header binary string that defines the length of the message body, prefixed
	/// by default with an SOH & "CNW".  

	length 		:= body.length;
	preamble 	:= getPreambleDefinition;
	msgnolength := HEADER_LENGTH - preamble.length;		// set the length of the output string  
														// allow 4 octets for the SOH-CNW preamble
	if app.isUnicode then														
		msgLenBin	:= self.integerToString(msgnolength, length).cnUnicodeToAnsi;
	else
		msgLenBin	:= self.integerToString(msgnolength, length).Binary;
	endif;
	
    return preamble & msgLenBin;
end;
}
cnGetBodyLength
{
cnGetBodyLength(buf : Binary; preambleLength : Integer) : Integer protected;

vars
	
begin
	if app.isUnicode then
		return buf[preambleLength + 1 : HEADER_LENGTH - preambleLength].ansiToUnicode.Integer;
		
	else
		return buf[preambleLength + 1 : HEADER_LENGTH - preambleLength].String.Integer;
	endif;
end;
}
cnOpen
{
cnOpen(computer : String; portNo : Integer; receiver : Object) updating;

vars
begin
	self.name 			:= computer;
	self.port			:= portNo;
	self.openAsynch(receiver, "cnOpenNotify");
end;
}
cnOpenNotify
{
cnOpenNotify(tcp : CnDeployMgrTcpConnection input) updating;

vars
	bm		: CnBatchMgr;
begin
	bm		:= self.myCnBatchMgr;
	bm.log(method.cnGetMethodName() & " successful outbound connection to JSA using " & self.String); 
	tcp.cnWrite(message, tcp);
	tcp.cnRead();						// wait for OK response then close connection
end;
}
cnProcessHeader
{
cnProcessHeader(buf : Binary) : Integer updating;

vars
 	preamble		: Binary;
 	preambleLength	: Integer;
begin
	/////	 This method returns the length of the message body    	/////

	preamble		:= getPreambleDefinition;
	preambleLength	:= preamble.length; 

	if preamble <> null and buf[1:preambleLength] = preamble then		// valid header
		return cnGetBodyLength(buf, preambleLength);
		
	elseif preambleLength = 0 then
		if app.isUnicode then
			return buf[1 : HEADER_LENGTH].ansiToUnicode.Integer;
		else
			return buf[1 : HEADER_LENGTH].String.Integer;
		endif;
					
	else
		return -1;
	endif;
end;
}
cnRead
{
cnRead();

vars

begin
	self.myCnBatchMgr.log("Now performing readBinaryAsynch ....");
	self.readBinaryAsynch(HEADER_LENGTH, self, "cnReadNotifyHeader");
end;
}
cnReadNotify
{
cnReadNotify(tcp : CnDeployMgrTcpConnection io; buf : Binary) updating;

vars
	err : String;
	len	: Integer;
begin
	//   This method is invoked when the message BODY is received.  The body is   /////
	//   returned in Binary buf.												  /////

	len				:= buf.length;
	self.myCnBatchMgr.log(method.cnGetMethodName() & " : bufferLength=" & len.String & ", buffer=" & buf.String);
	tcp.msgHeader 	:= null;
	self.myCnBatchMgr.log(method.cnGetMethodName() & " : closing connection before termination.");
	tcp.close();
	
epilog
	delete tcp;
	terminate;
end;
}
cnReadNotifyHeader
{
cnReadNotifyHeader(tcp : CnDeployMgrTcpConnection input; buf : Binary) updating;

vars
 	length, len, pos 	: Integer;
 	s, str2				: String;
 	foundHeaderStart 	: Boolean;
 
begin
	//  We come here when we've read the number of bytes that should be in the 
	//  message header.  We now check to see if this is a valid header (user code
	//  required) and then fire off another read to get the body.

	length := cnProcessHeader(buf);							// this should return the length of the 
															// message body, or -1 if invalid header
	self.myCnBatchMgr.log(method.cnGetMethodName() & " : received from JSA : buffer=" & buf.String);
	
	if length > 0 and buf.length = HEADER_LENGTH then		// This is the expected, normal result so
		tcp.msgHeader := buf;								// we initiate the read of the message body
		tcp.readBinaryAsynch(length, self, "cnReadNotify"); 
		return;
	endif;	
end;
}
cnWrite
{
cnWrite(body : Binary; receiver : Object) updating;

vars
 	buffer 	: String;
 	cc 		: CnCntrl;
 	bin		: Binary;
 	str		: String;
begin
	bin := buildHeader(body) & body;
	self.myCnBatchMgr.log("Now sending message to JSA : buf=" & bin.String);
 	self.writeBinaryAsynch(bin, receiver, "cnWriteNotify");
end;
}
cnWriteNotify
{
cnWriteNotify(tcp : CnDeployMgrTcpConnection input) updating;

vars

begin
	message	:= null;
end;
}
getPreambleDefinition
{
getPreambleDefinition() : Binary;

vars
	str	: String;
begin
	////   This method defines the header preamble.  You can reimplement this   //////
	////   method if you want to change the preamble.	Also see method			////// 
	////   buildHeader															//////

	str	:= #'01' & "CNW";
	
	if app.isUnicode then
 		return str.cnUnicodeToAnsi;
 	else
 		return str.Binary;
 	endif;
end;
}
integerToString
{
integerToString(stringlength :Integer; int : Integer) : String;    	

constants
	Asterisks : String="***************************";
	AllZeros  : String="000000000000000000000000000";
vars
	s : String;
	ilen : Integer;
begin											// method converts integer to right-aligned
	s := int.String;			           	 	// string with preceding zeros i.e. COBOL PIC 9 DISPLAY
	ilen := s.length;

   	if ilen > stringlength then					
		return Asterisks[1:stringlength];		// integer won't fit in string length
	elseif ilen = stringlength then
		return s;
	else
		return AllZeros[1:stringlength - ilen] & s;
	endif;
end;
}
	)
	CnTcpConnection (
	jadeMethodSources
cnArmConnectionResponseTimer
{
cnArmConnectionResponseTimer() updating;

vars
	cc : CnCntrl;
	millis : Integer;
begin
 	cc := app.myCnCntrl;
 	millis := cc.connectionResponseTime * 1000;
 	self.beginTimer(millis, Timer_OneShot, 20);
end;
}
cnArmTcpExceptionHandler
{
cnArmTcpExceptionHandler() updating;

vars
	cc : CnCntrl;
begin
	cc := app.myCnCntrl;
	if not cc.tcpExceptionHandlerArmed then
		on ConnectionException do app.cnTcpExceptionHandler(exception) global;
		cc.setTcpExceptionHandlerArmed(true);
	endif;
end;
}
cnBumpRetryNo
{
cnBumpRetryNo() updating;

vars

begin
 	self.retryNo := self.retryNo + 1;
end;
}
cnClose
{
cnClose(receiver : Object) updating;

vars
 	cc : CnCntrl;
begin
	cc:= app.myCnCntrl;
	self.cnSetLastAction(Close);
	self.cnSetMyReceiver(receiver);

	if self.state <> 0 then
	 	cc.cnWriteLog(cc.CnLogConnect, "Closing connection #" & self.connectionNo.String & 
	 					   ", state=" & self.state.String & ", computer=" & self.computerName, self);
	 	self.closeAsynch(receiver, "cnCloseNotify");
	else
	 	cc.cnWriteLog(cc.CnLogConnect, "Connection #" & self.connectionNo.String & " now closed.",self);
	endif;
end;
}
cnCloseNotify
{
cnCloseNotify(tcp : CnTcpConnection input) updating;

vars
 	s : String;
 	cc : CnCntrl;
begin
    cc := app.myCnCntrl;
	s := cc.appName & " connection #" & tcp.connectionNo.String & " successfully closed";
	tcp.cnSetLastAction(null);
	tcp.cnSetConnectionType(null);
	tcp.retryNo := 0;
	cc.decrementConnectionCount();
	cc.cnWriteLog(cc.CnLogConnect, s, tcp);

	///  The user may want to reimplement this method (use inheritMethod), because
	///  typically you'd want to perform another cnListen or CnOpen at this point, 
	///  or delete the tcp object.
end;
}
cnGetBodyLength
{
cnGetBodyLength(buf : Binary; preambleLength : Integer) : Integer protected;

vars
	
begin
	if app.isUnicode then
		return buf[preambleLength + 1 : self.headerLength - preambleLength].ansiToUnicode.Integer;
		
	else
		return buf[preambleLength + 1 : self.headerLength - preambleLength].String.Integer;
	endif;
end;
}
cnGetLastActionString
{
cnGetLastActionString() : String;

vars
 	action : String;
begin
	if self.lastAction = Listen then
		action := "Listen";
	elseif self.lastAction = Open then
		action := "Open";
	elseif self.lastAction = Close then
		action := "Close";
	elseif self.lastAction = Read then
		action := "Read";
	elseif self.lastAction = Write then
		action := "Write";
	elseif self.lastAction = null then
		action := "<null>";
	else
		action := "<unknown '" & self.lastAction & "'>";
	endif;

	return action;
end;
}
cnGetNextJossIpAddress
{
cnGetNextJossIpAddress() : Integer updating;
/*
	Subclassed in JOSS schema.
*/
vars

begin
	return 30 * 1000;
end;
}
cnGetStateString
{
cnGetStateString() : String;

vars
	
begin
	if self.state = self.Disconnected then
		return "Disconnected";
	endif;

	if self.state = self.Connecting then
		return "Listening";
	endif;

	if self.state = self.Connected then
		return "Connected";
	endif;
	
	if self.state = self.Disconnecting then
		return "Disconnecting";
	endif;
	
	return "Unknown state : " & self.state.String;
end;
}
cnHaltConnection
{
cnHaltConnection() updating;

vars
 	cc : CnCntrl;
 	action : String;
begin
	///  Used when retry limit exceeded - halt the connection and leave it in a closed state ///

	cc := app.myCnCntrl;
	action := self.cnGetLastActionString;

	cc.cnWriteLog(cc.CnLogErrors, action & " operation failed : retry limit exceeded : halting connection #" &
						 self.connectionNo.String & " from/to " & self.computerName,  self);
	if self.state <> 0 then
		self.cnClose(self.myReceiver);
	endif;

	self.retryNo := 0;
end;
}
cnIntegerToString
{
cnIntegerToString(stringlength :Integer; int : Integer) : String;    	

constants
	Asterisks : String="***************************";
	AllZeros  : String="000000000000000000000000000";
vars
	s : String;
	ilen : Integer;
begin											// method converts integer to right-aligned
	s := int.String;			           	 	// string with preceding zeros i.e. COBOL PIC 9 DISPLAY
	ilen := s.length;

   	if ilen > stringlength then
		app.cnRaiseAlert("Maximum message length exceeded", 
						 "CardSchema message length requires " & ilen.String & " bytes but only " & stringlength.String & " allowed." & CrLf &
						 "Application " & app.myCnCntrl.appName & " will incur forced unhandled exception (" & Cn_Edit_Error.String & ")." & CrLf & CrLf &
						 "JADE environment : " & app.myCnKarmaCntrl.environmentId & " on " & app.myCnKarmaCntrl.localFQDN,
						 "N",
						 app.actualTime(),
						 app.myCnCntrl.appName,
						 app.myCnKarmaCntrl.localFQDN,
						 app.myCnKarmaCntrl.localIpAddress);
		app.cnRaiseNormalException(Cn_Edit_Error, 
									"Max message length exceeded", 
									"Message length requires " & ilen.String & " but only " & stringlength.String & " allowed", 
									false);
	endif;
	
	if ilen = stringlength then
		return s;
	else
		return AllZeros[1:stringlength - ilen] & s;
	endif;
end;
}
cnJossTcpRestart
{
cnJossTcpRestart(): Boolean updating;

vars
	cc 				: CnCntrl;

	tcp2 			: CnTcpConnection;
	
	timeInterval	: Integer;
begin
	cc := app.myCnCntrl;	

	if cc.appName <> CN_KARMACOMMSMGR and
	   cc.appName <> CN_KCCMGR then
	   	return false;
	endif;

	tcp2 := self;
    if self.connectionType <> self.Opener then
		return false;
	endif;
	
	// mainly here for KCCMgr to Karma, but this will also be
	// invoked for Karma to Joss connections.  See 
	// Joss::user_cnTcpExceptionHandler for other Joss/Karma handling
	if tcp2.state <> null then
		tcp2.cnClose(tcp2);
	endif;
			
	if tcp2.cnRetryTimerRunning then
		cc.cnWriteLog(cc.CnLogConnect, method.cnGetMethodName() & " connection #" & tcp2.connectionNo.String & " retry timer already running, waiting for timer event.", self);
	
	else
		if tcp2.port = JSA_TO_JSM_PORT then
			timeInterval := self.cnGetNextJossIpAddress();	// we've got here because we were unable to open a connection to JSM, get the next ip address and try again
			
		else
			timeInterval := 30 * 1000;
		endif;
		
		cc.cnWriteLog(cc.CnLogConnect, "Starting reopen timer in cnJossTcpRestart on connection #" & tcp2.connectionNo.String & " (" & self.getObjectStringForObject(tcp2) & ")... " & timeInterval.String & " ms", self);
		tcp2.beginTimer(timeInterval, Timer_OneShot, 21);
		tcp2.cnSetCnRetryTimerRunning(true);
	endif;

	return true;
end;
}
cnKillConnection
{
cnKillConnection() updating;

vars
 	cc : CnCntrl;
begin
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogErrors, "Retry limit exceeded : killing connection #" & self.connectionNo.String &
 						" on port " & self.port.String & " from/to " & self.computerName,  self);
 	cc.decrementConnectionCount;
 	delete self;
 	cc.cnWriteLog(cc.CnLogErrors, "CnTcpConnection object deleted", null);
end;
}
cnListen
{
cnListen(portNo : Integer; receiver : Object) updating;

vars
   	cc			: CnCntrl;
begin
	////  If you are going do perform more than one listen on a given port, then
	////  you MUST use cnListenContinuous.  

	cc := app.myCnCntrl;
    self.cnArmTcpExceptionHandler;
 	if portNo = 0 then
 		app.msgBox("TCP port not specified in CnTcpConnection::cnListen", "Error",0);
 		return;
 	endif;
 	if self.state <> 0 then
 		app.msgBox("Wrong TCP state (=" & self.state.String & ") in TcpCnConnection::cnListen", "Error",0);
 		return;
 	endif;

	if self.connectionNo = 0 then
		cc.bumpConnectionNo;
		self.connectionNo := cc.connectionNo;
	endif;

    self.port 				:= portNo;
    self.cnPort				:= portNo;
    self.resolveRemoteName 	:= cc.resolveRemoteName;
    self.lastPort			:= portNo;

    if self.headerLength = 0 then					// use default from CnCntrl
    	self.headerLength 		:= cc.headerLength;
	    if cc.headerLength < 1 then
			app.msgBox("Message header length not specified, in CnTcpConnection::cnListen", "Fatal Error", 0);
			//
			//  The above should have been set up in CnCntrl by user code, typically during initialisation  ////
			// 
			return;
		endif;
	endif;

    self.cnSetLastAction(Listen);
    self.cnSetMyReceiver(receiver);
    self.computerName 	:= null;
    self.lastIpAddress 	:= null;
    self.cnSetMyCnCntrl(cc);

    if self.retryNo <= cc.connectionRetryLimit then
    	self.listenAsynch(receiver, "cnListenNotify");
    	cc.cnWriteLog(cc.CnLogConnect, cc.appName & " : TCP Connection=" & self.connectionNo.String &
    					   " now listening on port=" &	self.port.String & ", retry=" & self.retryNo.String, null);
   	else 
   		self.cnHaltConnection();
	endif;
end;
}
cnListenContinuous
{
cnListenContinuous(portNo : Integer; receiver : Object) updating;

vars
	cc 	: CnCntrl;
	tcp	: CnTcpConnection;
begin
	cc := app.myCnCntrl;
    self.cnArmTcpExceptionHandler();
 	if portNo = 0 then
 		app.msgBox("TCP port not specified in " & method.cnGetMethodName(), "Error",0);
 		return;
 	endif;
	
 	if self.state <> 0 then
 		app.msgBox(method.cnGetMethodName() & " Wrong TCP state (=" & self.state.String & ")", "Error",0);
 		return;
 	endif;

	if self.connectionNo = 0 then
		cc.bumpConnectionNo;
		self.connectionNo := cc.connectionNo;
	endif;

	///  Check that we aren't already listening on this port   /////

	tcp := cc.allCnTcpConnections.getAtKeyGeq(portNo, 0);
	if tcp <> null then
		if tcp.port = portNo and tcp.state = 1 then
			cc.cnWriteLog(cc.CnLogErrors, "Application tried to perform listenContinuous on port " &
							   portNo.String & " but a listen is already in place using connection #" &
							   tcp.connectionNo.String & " - listenContinuous aborted", null);
			delete self;
			return;
		endif;
	endif;

    self.port 				:= portNo;
    self.cnPort				:= portNo;
    self.resolveRemoteName 	:= cc.resolveRemoteName;
    self.lastPort			:= portNo;

    if self.headerLength = 0 then			// not set up by user for connection, so use default
    	if cc.headerLength < 1 then
			app.msgBox(method.cnGetMethodName() & " Message header length not specified", "Fatal Error", 0);
			//
			//  The above should have been set up in CnCntrl by user code, typically during initialisation  ////
			// 
			return;
		endif;
    	self.headerLength 		:= cc.headerLength;
    endif;

    self.cnSetLastAction(Listen);
    self.cnSetMyReceiver(receiver);
    self.computerName 		:= null;
    self.lastIpAddress 		:= null;
    self.cnSetMyCnCntrl(cc);
    self.cnSetConnectionType(self.ContinuousListenerMaster);

    if self.connectionNo = 0 then
		cc.bumpConnectionNo;
		self.connectionNo := cc.connectionNo;
	endif;

    cc.cnWriteLog(cc.CnLogConnect, "Performing listenContinuousAsynch using connection #" & self.connectionNo.String & 			// PAR 6782
									" on port " & portNo.String & ", localInterface=" & self.localInterface & 					// PAR 6782
									", receiver=" & receiver.String, null);														// PAR 6782
    self.listenContinuousAsynch(receiver, "cnListenContinuousNotify");
end;
}
cnListenContinuousNotify
{
cnListenContinuousNotify(tcplisten : CnTcpConnection; tcp : CnTcpConnection input) updating;

vars
 	cc : CnCntrl;
begin
 	///   This is a default handler for listenContinuous notifications.  This is invoked
 	///   when another computer attempts to connect to the listening TCP object.
 	///   You will normally need to reimplement this method and use inheritMethod, and
 	///	  code your own additional requirements.

 	cc := app.myCnCntrl;
	if cc.appName = CN_JOSSCOMMSMGR then
		cnStartTransaction(method.cnGetMethodName());
	endif;
	
 	cc.bumpConnectionNo;
	cc.cnWriteLog(cc.CnLogConnect, "Connection established from host " & 
					   tcp.remoteName & " (" & tcp.remoteIpAddress & ") on port " & 
					   tcp.port.String  & " : connection #" & cc.connectionNo.String, null);

	tcp.cnSetConnectionNo(cc.connectionNo);

	if tcp.headerLength = 0 then
 		tcp.headerLength := cc.headerLength;
 	endif;

	tcp.msgHeader 	:= null;
	tcp.retryNo 	:= 0;
	tcp.computerName  := tcp.remoteName;

	if tcp.remoteName <> null then
		tcp.cnSetRemoteId(tcp.remoteName);
	else
		tcp.cnSetRemoteId(tcp.remoteIpAddress);			// DNS resolution failed so use IP address as key for CnTcpClientDict
	endif;

	tcp.lastPort	  := tcp.port;
	tcp.cnPort		  := tcp.port;
	tcp.lastIpAddress := tcp.remoteIpAddress;
	tcp.cnSetConnectionType(tcp.ContinuousListener);			// so we can take appropriate action if connection breaks
	tcp.cnSetLastAction(null);
    tcp.cnSetMyReceiver(self);
    tcp.cnSetMyCnCntrl(cc);

	/// At this juncture, someone needs to start the dialog by performing a cnRead
	/// or a cnWrite.  You need to code this when re-implementing this method (use
	/// inheritMethod).  
epilog
	if cc.appName = CN_JOSSCOMMSMGR then
		cnEndTransaction();
	endif;
end;
}
cnListenNotify
{
cnListenNotify(tcp : CnTcpConnection input) updating;

vars
 	cc : CnCntrl;
begin
 	///   This is a default handler for listen notifications.  This is invoked
 	///   when another computer attempts to connect to the listening TCP object.
 	///   You will normally need to reimplement this method and use inheritMethod, and
 	///	  code your own additional requirements.

 	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogConnect, "Connection established from host " & 
					   tcp.remoteName & " on connection #" & tcp.connectionNo.String &
					   " : ip addr=" & tcp.remoteIpAddress, tcp);

	tcp.msgHeader 		:= null;
	tcp.retryNo 		:= 0;
	tcp.computerName 	:= tcp.remoteName;
	tcp.lastIpAddress 	:= tcp.remoteIpAddress;

	if tcp.remoteName <> null then
		tcp.cnSetRemoteId(tcp.remoteName);
	else
		tcp.cnSetRemoteId(tcp.remoteIpAddress);			// DNS resolution failed so use IP address as key for CnTcpClientDict
	endif;

	tcp.cnSetConnectionType(Listener);
	cc.bumpConnectionCount;

	/// At this juncture, someone needs to start the dialog by performing a cnRead
	/// or a cnWrite.  You need to code this when re-implementing this method (use
	/// inheritMethod).  
end;
}
cnOpen
{
cnOpen(computer : String; portNo : Integer; receiver : Object) updating;

vars
	cc 	: CnCntrl;

	cem	: CnExternalMethods;
begin
	cc 	:= app.myCnCntrl;

	if computer = null or portNo < 1 then
		abortTransaction;
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " failed : connection #" & self.connectionNo.String &
					  ", computer=" & computer & ", portNo=" & portNo.String, null);
		create cem transient;
		if app.cnApplicationType = app.ApplicationType_GUI and not cem.emIsService then
			app.msgBox("Computer or port not specified in CnTcpConnection::cnOpen", "Open Error",16);
		endif;
		return;
	endif;

    self.cnArmTcpExceptionHandler;
	self.name 			:= computer;
	self.computerName 	:= computer;
	if self.headerLength = 0 then
		self.headerLength 	:= cc.headerLength;
	endif;
	self.port			:= portNo;
	self.cnPort			:= portNo;
	self.lastPort		:= portNo;
	self.lastIpAddress	:= null;
	self.cnSetMyCnCntrl(cc);
	self.cnSetConnectionType(Opener);
	self.cnSetMyReceiver(receiver);
	if self.connectionNo = 0 then
		cc.bumpConnectionNo;
		self.connectionNo := cc.connectionNo;
	endif;
	if self.isKindOf(CnKarmaTcpConnection) then
		self.causeEvent(self.CnKarmaTcpConnection.TCP_Open, true, 0);
	endif;

	if self.retryNo <= cc.connectionRetryLimit then
		cc.cnWriteLog(cc.CnLogConnect, cc.appName &
				    " opening connection to " & self.name & " on port " & 
				    self.port.String & ", retry=" & self.retryNo.String &
				    " connection #" & self.connectionNo.String, self);
		self.cnSetLastAction(Open);
		if self.state <> 0 then
			cc.cnWriteLog(cc.CnLogErrors, "Wrong connection state for cnOpen : state=" & self.state.String, self);
			return;
		else
			self.openAsynch(receiver, "cnOpenNotify");
		endif;
	else
		self.cnHaltConnection();						// error halt
	endif;
epilog
	delete cem;
end;
}
cnOpenNotify
{
cnOpenNotify(tcp : CnTcpConnection input) updating;

vars
 	cc : CnCntrl;
begin
 	cc := app.myCnCntrl;
 	tcp.endTimer(1);

	cc.cnWriteLog(cc.CnLogConnect, method.cnGetMethodName() & " : successful outbound connection : " & 
							   " connectionNo=" & tcp.connectionNo.String &
							   ", computer=" & tcp.remoteName &
							   ", ipAddr=" & tcp.remoteIpAddress, tcp);

	cc.bumpConnectionCount;
	tcp.retryNo := 0;
	tcp.cnSetConnectionType(Opener);
	tcp.lastIpAddress := tcp.remoteIpAddress;

	if tcp.remoteName <> null then
		tcp.cnSetRemoteId(tcp.remoteName);
	else
		tcp.cnSetRemoteId(tcp.remoteIpAddress);
	endif;

	///////  Typically the developer will reimplement this (use inheritMethod) and    //////
	///////  add code to take appropriate action after the open, e.g. a read		  //////
end;
}
cnProcessHeader
{
cnProcessHeader(buf : Binary) : Integer updating;

vars
 	cc 				: CnCntrl;
 	preamble		: Binary;
 	preambleLength	: Integer;
begin
	/////	 This method returns the length of the message body    	/////

	cc 				:= app.myCnCntrl;
	preamble		:= user_cnGetPreambleDefinition;
	preambleLength	:= preamble.length; 

	if preamble <> null and buf[1:preambleLength] = preamble then		// valid header
		return cnGetBodyLength(buf, preambleLength);
		
	elseif preambleLength = 0 and headerLength > 0 then
		if app.isUnicode then
			return buf[1 : self.headerLength].ansiToUnicode.Integer;
		else
			return buf[1 : self.headerLength].String.Integer;
		endif;
					
	else
		return -1;
	endif;
end;
}
cnRaiseConnectionException
{
cnRaiseConnectionException(errorCode : Integer; errorText : String) updating, protected;

vars
	exObj : ConnectionException;
begin
	create exObj;
	exObj.errorCode 		:= errorCode;
	exObj.extendedErrorText	:= errorText;
	exObj.continuable		:= true;
	exObj.cnSetConnection(self);
	raise exObj;
end;
}
cnRead
{
cnRead(receiver : Object) updating;
//______________________________________________________________________________________
//                +-------------------------------------+
//                |   CardSchema (JADE) Class Library   |
//                +-------------------------------------+

//		This material is proprietary to Jade Software Corporation Limited New Zealand and is  
//		not to be reproduced, used or disclosed except upon written permission of Jade
//	    Software Corporation Limited.                                                                     
//
//      COPYRIGHT (C) JADE SOFTWARE CORPORATION LIMITED 1998 - 2002 - ALL RIGHTS RESERVED
//_____________________________________________________________________________________
vars
  	cc : CnCntrl;
begin
	cc := app.myCnCntrl;
    self.cnArmTcpExceptionHandler;
	self.fillReadBuffer := true;
	cc.cnWriteLog(cc.CnLogReceive, "Connection #" & self.connectionNo.String &													// PAR 6782
							   " about to readAsync on port " & self.port.String &
							   " .....", self);
	self.cnSetLastAction(Read);
	self.cnSetMyReceiver(receiver);
	self.msgHeader := null;
	self.readBinaryAsynch(self.headerLength, receiver, "cnReadNotifyHeader");
end;
}
cnReadNotify
{
cnReadNotify(tcp : CnTcpConnection input; buf : Binary) updating;

vars
	err : String;
	cc 	: CnCntrl;
	len	: Integer;
begin
	//   This method is invoked when the message BODY is received.  The body is   /////
	//   returned in Binary buf.												  /////

	cc 	:= app.myCnCntrl;
	len	:= buf.length;
	cc.cnWriteLog(cc.CnLogReceive, method.cnGetMethodName() & " : new msg from " & tcp.remoteName &								// PAR 6782
								self.cnReadNotifyUserInfo(buf) & 
								", bodylength=" & len.String & ", data=" & 
								tcp.msgHeader.cnAnsiToString(tcp.msgHeaderLength) & buf.cnAnsiToString(len), tcp);
	tcp.retryNo := 0;
	tcp.msgHeader := null;

	//  The user should normally re-implement this method and use inheritMethod.  At
	//  this point the user should complete any other validity checks (on the 
	//  data received in buf) and then process the received data.  Usually, the last thing
	//  you'd do in this method would be to perform another cnRead.  This final cnRead should be done in the epilog
	//  to cater for the situation where an exception occurs during the handling of the message, otherwise the
	//  connection will appear to go to sleep after an exception.
end;
}
cnReadNotifyHeader
{
cnReadNotifyHeader(tcp : CnTcpConnection input; buf : Binary) updating;

vars
 	length, len, pos 	: Integer;
 	s, str2				: String;
 	cc 					: CnCntrl;
 	foundHeaderStart 	: Boolean;
 
begin
	//  We come here when we've read the number of bytes that should be in the 
	//  message header.  We now check to see if this is a valid header (user code
	//  required) and then fire off another read to get the body.

	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogReceive, "Received header or part header from " & 													// PAR 6782
					   tcp.remoteName & " on connection #" & tcp.connectionNo.String & " (" &
					   tcp.String & "), buf=" & buf.ansiToString, tcp);

	length := cnProcessHeader(buf);							// this should return the length of the 
															// message body, or -1 if invalid header
	if length > 0 and buf.length = tcp.headerLength then	// This is the expected, normal result so
		tcp.msgHeader := buf;								// we initiate the read of the message body
		tcp.msgHeaderLength	:= buf.length;
		tcp.readBinaryAsynch(length, tcp.myReceiver, "cnReadNotify"); 
		return;
	endif;	

    /////  If we get to here then we have probably got a corrupted data stream.   As of 2.6.100     	////
    /////  we give up immediately i.e. break the connection and raise a connection exception.		////	 	
	
	cc.cnWriteLog(cc.CnLogErrors, "Connection " & tcp.String & "(#" & tcp.connectionNo.String & 
				  ") appears to have bad header (value=" & buf.ansiToString & buf.display & ") - will close connection.", null);
	tcp.close();
	cnRaiseConnectionException(Cn_Tcp_Header_Error, "TCP message had unrecognised message header.");
end;
}
cnReadNotifyUserInfo
{
cnReadNotifyUserInfo(pBuffer : Binary) : String;
/*
	Allows for sub-classes to return some unique info about the incoming message
*/
vars

begin
	return null;
end;
}
cnSetCnRetryTimerRunning
{
cnSetCnRetryTimerRunning(set : Boolean) updating;

vars

begin
 	self.cnRetryTimerRunning := set;
end;
}
cnSetConnectionNo
{
cnSetConnectionNo(connection : Integer) updating;

vars

begin
 	self.connectionNo := connection;
end;
}
cnSetConnectionType
{
cnSetConnectionType(type : String) updating;

vars

begin
 	if type <> Opener 			 	 	and
 	   type <> Listener 		  		and
 	   type <> ContinuousListener 		and
 	   type <> ContinuousListenerMaster	and
 	   type <> null			      		then
 	   	write ">> PROGRAM ERROR : Invalid type specified for CnTcpConnection::setConnectionType";	// program error
 	    return;
 	endif;

 	self.connectionType := type;
end;
}
cnSetHeaderLength
{
cnSetHeaderLength(length : Integer) updating;

vars

begin
	self.headerLength := length;
end;
}
cnSetLastAction
{
cnSetLastAction(action : String) updating;

vars

begin
	if action <> Read	and			
	   action <> Write	and			
	   action <> Close	and			
	   action <> Open	and			
	   action <> Listen and
	   action <> null	then			
	   	write "Invalid value specified in CnTcpConnection::cnSetLastAction";		// program error
	   	return;
	endif;

	self.lastAction := action;
end;
}
cnSetMyCnCntrl
{
cnSetMyCnCntrl(cnCntrl : CnCntrl) updating;

vars

begin
	self.myCnCntrl := cnCntrl;
end;
}
cnSetMyReceiver
{
cnSetMyReceiver(receiver : Object) updating;

vars

begin
 	self.myReceiver := receiver;
end;
}
cnSetRemoteId
{
cnSetRemoteId(id : String) updating;

vars

begin
 	self.remoteId := id;
end;
}
cnWrite
{
cnWrite(body : Binary; receiver : Object) updating;

vars
 	buffer 	: String;
 	cc 		: CnCntrl;
 	bin		: Binary;
 	str		: String;
begin
	cc := app.myCnCntrl;
	self.cnArmTcpExceptionHandler;

	bin := self.user_cnBuildHeader(body) & body;
	
 	self.cnSetMyReceiver(receiver);

    if self.retryNo <= cc.connectionRetryLimit then
    	str := "Connection #" & connectionNo.String & " (" & self.String & ") sending to " &
    		   self.computerName & "(" & self.remoteIpAddress & ")" &
			   self.cnWriteUserInfo(body) & ", bodylength=" & body.length.String;

    	if bin.length < 500 then
    		str := str & ", data=" & bin.cnAnsiToString(bin.length);
    	else
    		str := str & ", data=" & bin[1:500].cnAnsiToString(500) & ".... [truncated after 500 octets]";
    	endif;
    	
 		cc.cnWriteLog(cc.CnLogTransmit, str, self);
 		self.cnSetLastAction(Write);
 		self.writeBinaryAsynch(bin, receiver, "cnWriteNotify");
 	else
 		self.cnHaltConnection();							// error
 	endif;	
end;
}
cnWriteNotify
{
cnWriteNotify(tcp : CnTcpConnection input) updating;

vars
	cc	: CnCntrl;
begin
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogTransmit, method.cnGetMethodName() & " for connection #" & tcp.connectionNo.String &					// PAR 6782
				       " on port " & tcp.port.String, tcp);
 	tcp.retryNo := 0;
end;
}
cnWriteSync
{
cnWriteSync(buf : Binary) updating;

vars
	buffer	: String;
	bin		: Binary;
 	cc 		: CnCntrl;
	str		: String;
begin
	cc 		:= app.myCnCntrl;
	bin 	:= self.user_cnBuildHeader(buf) & buf;				// user can reimplement this, to build the header.
	self.cnArmTcpExceptionHandler;
	str := "Connection #" & connectionNo.String & " (" & self.String & ") sending to " &
    		   self.computerName & " (" & self.remoteIpAddress & ") via writeSync, bodylength=" & buf.length.String;

	if bin.length < 500 then
		str := str & ", data=" & bin.cnAnsiToString(bin.length);
	else
		str := str & ", data=" & bin[1:500].cnAnsiToString(500) & ".... [truncated after 500 octets]";
	endif;
    	
 	cc.cnWriteLog(cc.CnLogTransmit, str, self);
 	self.writeBinary(bin);
end;
}
cnWriteUserInfo
{
cnWriteUserInfo(pBuffer : Binary) : String;
/*
	Allows for sub-classes to return some unique info about the outgoing message
*/
vars

begin
	return null;
end;
}
getNextJossIpAddress
{
getNextJossIpAddress() : Integer updating;
/*
	Subclassed in JOSS schema.
*/
vars

begin
	return 30 * 1000;
end;
}
setCnPort
{
setCnPort(prt : Integer) updating;

vars

begin
	self.cnPort := prt;
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;

vars
 	str, str2 : String;
 	cc : CnCntrl;
begin
	/////////////////////////////////////////////////////////////////////////////
	/////////   Note that timers 20 - 25 are reserved for CardSchema use.  //////
	/////////   If you reimplement this event, you MUST inheritMethod for  //////
	/////////   CnTcpConnection class to work.				               //////
    /////////////////////////////////////////////////////////////////////////////

	cc := app.myCnCntrl;

 	if eventTag = 20 then							/// tcp general timeout  ///
 		self.endTimer(20);
 		str := self.cnGetLastActionString & " to client " & self.computerName & " on port " &
 			   self.lastPort.String & " timed out  -" & CrLf;

 		str := "OK to close connection and ";		   

 		if self.connectionType = Listener then
 			str2 := str2 & " listen for client reconnect ?";
 		else
 			str2 := str2 & " re-open connection to client ?";
 		endif;

 		if app.msgBox(str & str2 & CrLf & "Or Cancel to wait again for response timer period",
 					  "Connection Timeout", MsgBox_OK_Cancel + MsgBox_Exclamation_Mark_Icon) = MsgBox_Return_OK then
 			self.cnHaltConnection;
 		else
 			self.cnArmConnectionResponseTimer; 
 		endif;
 	endif;

 	//////////////////////////  Karma / Joss Stuff ////////////////////////////////////////

 	if eventTag = 21 or eventTag = Connection_Retry_Timer then				// Karma Client-to-parent timeout
 		self.cnSetCnRetryTimerRunning(false);
 		if self.state = 0 then
    		self.cnOpen(self.computerName, self.lastPort, self.myReceiver);
    	endif;
 	endif;
end;
}
user_cnBuildHeader
{
user_cnBuildHeader(body : Binary) : Binary updating;

vars
 	msgnolength : Integer;
 	length 		: Integer;
 	cc			: CnCntrl;
 	preamble 	: Binary;
	msgLenBin	: Binary;
	
begin
	/// This method returns a header binary string that defines the length of the message body, prefixed
	/// by default with an SOH & "CNW".  Currently, headers are always ANSI format, even in unicode systems. 

	cc 			:= app.myCnCntrl;
	length 		:= body.length;
	preamble 	:= user_cnGetPreambleDefinition;
	msgnolength := self.headerLength - preamble.length;		// set the length of the output string  
															// allow 4 octets for the SOH-CNW preamble
	if app.isUnicode then														
		msgLenBin	:= self.cnIntegerToString(msgnolength, length).cnUnicodeToAnsi;
	else
		msgLenBin	:= self.cnIntegerToString(msgnolength, length).Binary;
	endif;
	
    return preamble & msgLenBin;
end;
}
user_cnGetPreambleDefinition
{
user_cnGetPreambleDefinition() : Binary;

vars
	cc 	: CnCntrl;
	str	: String;
begin
	////   This method defines the header preamble.  You can reimplement this   //////
	////   method if you want to change the preamble.	Also see method			////// 
	////   user_cnBuildHeader													//////

	cc 	:= app.myCnCntrl;
	str	:= cc.Cn_SOH & "CNW";
	
	if app.isUnicode then
 		return str.cnUnicodeToAnsi;
 	else
 		return str.Binary;
 	endif;
end;
}
user_cnIssueErrorMsg
{
user_cnIssueErrorMsg(exObj : Exception) updating;

vars
	str 	: String;
	kc		: CnKarmaCntrl;
	cc		: CnCntrl;
begin
	///  This is the default error message if connections fail and auto-restart isn't   ///
	///  in effect.  You can re-implement this in your subclass of CnTcpConnection.     ///
	///  You may want to log the error rather than have the app halt on a msgBox.       ///
	//   This is also a good place to do any other error handling, such as deleting the /// 
	///  disconnected TCP object etc.													///


    kc 	:= app.myCnKarmaCntrl;
    cc	:= app.myCnCntrl;
    str :=  "Application " & cc.appName;

    if kc <> null then
    	str := str & " in environment " & kc.environmentId;
    endif;

    str := str & " had connection failure - " & self.cnGetLastActionString & " operation to " & CrLf &
        		 " computer " & self.computerName & " on port " & self.lastPort.String & " failed";  

   	if app.cnApplicationType = app.ApplicationType_GUI then
     	app.msgBox(str, "Connection Failure", 48);
	else
		cc.cnWriteLog(cc.CnLogErrors, str, null);
	endif;
end;
}
user_cnTcpExceptionHandler
{
user_cnTcpExceptionHandler(exObj : Exception) : Integer updating;

vars

begin
	///  Placeholder for user-defined exception handling called from 			///
	///  cnTcpExceptionHandler.  You should reimplement this method in your		///
	///  subschema if you want to change the way your application handles		///
	///  connection exceptions.

	///  Return Ex_Continue to allow CnTcpConnection class to continue or 		///
	///  Ex_Abort_Action or Ex_Pass_Back.                 						///

	return Ex_Continue;
end;
}
user_cnTcpRestart
{
user_cnTcpRestart() : Integer updating;

vars

begin
 	// Developer can reimplement this method to handle failed connection differently
 	// e.g. log it and restart.  Return a valid exception return code, i.e. Ex_Continue,
 	// Ex_Abort_Action etc, if you want your method to override the 
 	// default handling in app.cnTcpExceptionHandler.

 	return -1;
end;
}
	)
	CnKarmaTcpConnection (
	jadeMethodSources
cnOpenNotify
{
cnOpenNotify(tcp : CnKarmaTcpConnection input) updating;

vars
	cnapp					: CnApp;

	cc 						: CnCntrl;
	
	cem						: CnExternalMethods;
	
	kc 						: CnKarmaCntrl;
	
	machine 				: CnMachine;
	
	cnproc					: CnProcess;
	
	file					: File;
	
	jdba					: JadeDatabaseAdmin;
	
	proc					: Process;
	
	objArray				: ObjectArray;
	
	badObject,
	defaultCloseAction,																											// PAR 805
	persistentVerifyJournal	: Boolean;

	pid,
	posn,
	rslt					: Integer;
	
	closeAction,
	fqdn,
	iniFileName,
	ipaddress,
	procid					: String;
	
	now		 				: TimeStamp;
begin
	inheritMethod(tcp);

	cc 		:= tcp.myCnCntrl;
	kc 		:= app.myCnKarmaCntrl;
	create cem transient;
	if kc.networkAddressNode = CN_LOCALHOST_IPADDRESS then
		kc.setNetworkAddressNode(app.cnGetNetworkAddressNode());
		if kc.networkAddressNode <> CN_LOCALHOST_IPADDRESS then
			cc.cnWriteLog(cc.CnLogConnect, method.cnGetMethodName() & " networkAddressNode was " & CN_LOCALHOST_IPADDRESS & ", now " & kc.networkAddressNode, null);	// PAR 6782
		endif;
	endif;
	
	if kc.networkAddressProcess = CN_LOCALHOST_IPADDRESS then
		kc.setNetworkAddressProcess(app.cnGetNetworkAddressProcess());
		if kc.networkAddressProcess <> CN_LOCALHOST_IPADDRESS then
			cc.cnWriteLog(cc.CnLogConnect, method.cnGetMethodName() & " networkAddressProcess was " & CN_LOCALHOST_IPADDRESS & ", now " & kc.networkAddressProcess, null);	// PAR 6782
		endif;
	endif;

	kc.setMyParentTcp(tcp);
	ipaddress := tcp.localIpAddress;

	tcp.causeEvent(tcp.TCP_Open_Complete, true, tcp.lastPort);

    if cc.appName <> CN_KCCMGR then
		rslt := kc.getAddressInfo(ipaddress, fqdn);				// based on process.networkAddress

	else
		rslt := cem.emGetHostByAddress(ipaddress, fqdn);			// based on tcp localIpAddress
    endif;

	kc.setLocalFQDN(fqdn);
	kc.setLocalIpAddress(tcp.localIpAddress);

	if cc.appName = CN_KCCMGR then						
		cc.cnWriteLog(cc.CnLogConnect, "KCCMgr background client successfully connected to JSA", tcp);
		//////////  First, clear the slate   /////
		
		kc.allCnProcesses.purge();									// this was added back in for 2.7

		create objArray transient;
		CnApp.allProcessTransientInstances(objArray, 0, false);
		objArray.purge;

		CnMachine.allProcessTransientInstances(objArray, 0, false);
        objArray.purge();
       
        //////////////////////////////////////////
        
		machine := kc.allMachines[kc.localFQDN];
		if machine = null then
			create machine;
			machine.setClientFQDN(kc.localFQDN);
		endif;
		
		machine.setIpAddress(kc.localIpAddress);				
		machine.setIsActive(true);
		machine.setMyKarmaCntrl(kc);

		posn := 1;
 		procid := app.cnGetInstanceId(process).String;			// we use part of the OID as process id
 		kc.getProcessId(pid);									// OS pid

		cnproc	:= null;
		cnproc 	:= machine.allProcesses[procid.Integer];
        if cnproc = null then
        	cnproc	:= kc.allCnProcesses[procid.Integer];
        	if cnproc = null then
        		create cnproc;
        		cnproc.setProcessId(procid.Integer);			// this also sets myCnKarmaCntrl
        		cnproc.setStartTime(now.cnGMT);
        	endif;
        endif;
		
        cnproc.setMyMachine(machine);
        cnproc.setMyProcess(process);
        cnproc.setComputerName(app.cnComputerName);
        cnproc.setOsPID(pid);
        kc.setMyCnProcess(cnproc);

	    cnapp := machine.allApps[cc.appSchemaName, cc.appName];
		if cnapp = null then
			create cnapp transient;
			cnapp.setAppSchemaName(cc.appSchemaName);
			cnapp.setAppName(cc.appName);
		endif;

	 	cnapp.setMyMachine(machine);
	 	cnapp.setMyKarmaCntrl(kc);
	 	cnapp.setMyCnCntrl(cc);
	 	cnapp.setLogonTime(now.cnGMT);
	 	cnproc.setMyCnApp(cnapp);
		
   		tcp.setManagedEnvironmentName(kc.managedEnvironmentName);																// PAR 833 - must be located before the 'issueKCCMgrSessionOpenAdvice'

	 	//////////////////////    Now send SessionOpenAdvice for myself (KCCMgr)  ///////////////////////
	 	kc.issueKCCMgrSessionOpenAdvice(tcp, machine, cnproc);
		kc.endTimer(Cn_SendDbDetails_Timer);														// stop timer if running
		kc.beginTimer(Cn_SendDbDetails_TimeReorg, Timer_OneShot, Cn_SendDbDetails_Timer); 	// send database details in two min time

		
	 	/////////////////////////////////////////////////////////////////////////////////////////////////
	 	
   		//   Now delete any existing deploy.htm file  //

   		create file;
		file.mode		:= file.Mode_IO;
		file.kind		:= file.Kind_ANSI;
		file.fileName	:= (kc.driveLetter & ":/" & kc.environmentId).toLower & "/server/c_misc/deploy.htm";
		if file.isAvailable then
			if app.isMultiUser then
				file.purge;
				cc.cnWriteLog(cc.CnLogComment, "File " & file.fileName & " has been removed.", null);
			else
				cc.cnWriteLog(cc.CnLogComment, "File " & file.fileName & " has NOT been removed : app is in single user mode.", null);
			endif;
		else
			cc.cnWriteLog(cc.CnLogComment, ">>>> Deploy.htm file '" & file.fileName & "' not removed : file not available.", null);
		endif;
		
		if cc.logPathError then
			app.cnRaiseJossAlert(Cn_Karma_Alert,
							 	"Incomplete initialization file setup for environment " & kc.environmentId.toUpper & " on " & node.cnGetComputerName,
					     	 	"Initialization file '" & app.getIniFileNameAppServer & "' has [CardLog] LogPath=" &
					     	 	 cc.logPath & ", or LogPath is not defined.",
					     	 	"N",
					     	 	app.actualTime,
					     	 	cc.appName,
					     	 	kc.managedEnvironmentName,																		// JSM PAR 8367
					     	 	node.cnGetComputerName,
					     	 	kc.networkAddressNode, 		// PAR 441 - node.networkAddress,
					     	 	kc.myParentTcp);
		endif;
		
		create jdba transient;
		if jdba.isArchival then										// [PersistentDb] EnableArchivalRecovery=true
			iniFileName := app.getIniFileName();																				// PAR 805
			closeAction	:= app.getProfileString(iniFileName, CN_PERSISTENTDB, CN_JOURNALCLOSEACTION, null).toLower();			// PAR 805
			if closeAction = null then																							// PAR 805
				closeAction := "move";																							// PAR 805
				defaultCloseAction := true;																						// PAR 805
			endif;																												// PAR 805
			
			if cc.karmaControl		and																							// PAR 805
			   defaultCloseAction	then																						// PAR 805
				app.setProfileString(iniFileName, CN_PERSISTENTDB, CN_JOURNALCLOSEACTION, "None");								// PAR 805
				app.cnRaiseJossAlert(Cn_Karma_Alert,																			// PAR 805
								 	"Disallowed JournalCloseAction ini file setting for environment " & kc.environmentId.toUpper & " on " & node.cnGetComputerName,			// PAR 805
						     	 	"Initialization file '" & iniFileName & "' did not explicitly define [PersistentDb] JournalCloseAction. " &								// PAR 805
						     	 	 "The default close action is Move and this is not allowed for JADECare Managed Environments." & CrLf & CrLf &							// PAR 805
									 "The ini file has been update to explicitly set [PersistentDb] JournalCloseAction=None and requires the database to be cycled ASAP" &	// PAR 805
									 "for this option to implemented by the JADE Database.",									// PAR 805
						     	 	"N",																						// PAR 805
						     	 	app.actualTime,																				// PAR 805
						     	 	cc.appName,																					// PAR 805
						     	 	kc.managedEnvironmentName,																	// PAR 805, JSM PAR 8367
						     	 	node.cnGetComputerName,																		// PAR 805
						     	 	kc.networkAddressNode, 																		// PAR 441, PAR 805
						     	 	kc.myParentTcp);																			// PAR 805
				

			elseif cc.verifyDatabaseJournals	then					// [AppEnvironment] VerifyDatabaseJournals=true			// PAR 805
/*				// NFS 5970 - move and moveAndCompress journals
				//			- permit use of Move and MoveAndCompress as part of NFS 5970 implementation.
				if closeAction <> "none" 			and									
				   closeAction <> "copy" 			and
				   closeAction <> "copyandcompress" then
					if defaultCloseAction then																						// PAR 805
						closeAction := closeAction & " (default)";																	// PAR 805
					endif;																											// PAR 805
					
					app.cnRaiseJossAlert(Cn_Karma_Alert,
										"Disallowed JournalCloseAction ini file setting for environment " & kc.environmentId.toUpper & " on " & node.cnGetComputerName,
										"Initialization file '" & app.getIniFileName & "' has [PersistentDb] JournalCloseAction=" &
										 closeAction & " : not allowed for managed systems with [AppEnvironment] VerifyDatabaseJournals=true.",
										"N",
										app.actualTime,
										cc.appName,
										kc.managedEnvironmentName,																// JSM PAR 8367
										node.cnGetComputerName,
										kc.networkAddressNode, 		// PAR 441 node.networkAddress,
										kc.myParentTcp);
				endif;
*/				
				persistentVerifyJournal	:= app.getProfileString(iniFileName, CN_PERSISTENTDB, "VerifyJournal", false.String).Boolean;
				if persistentVerifyJournal then
					app.cnRaiseJossAlert(Cn_Karma_Alert,
										"Conflicting ini file settings for environment " & kc.environmentId.toUpper & " on " & node.cnGetComputerName,
										"Initialization file '" & iniFileName & "' has both following options set to true:" & CrLf &
										"[PersistentDb] VerifyJournal" & CrLf &
										"[AppEnvironment] VerifyDatabaseJournals" & CrLf & CrLf &
										 "Suggest that [AppEnvironment] VerifyDatabaseJournals=true and [PersistentDb] VerifyJournal be set to false." & CrLf &
										 "Changing either of these requires the JADE Environment to be cycled.",
										"N",
										app.actualTime,
										cc.appName,
										kc.managedEnvironmentName,																// JSM PAR 8367
										node.cnGetComputerName,
										kc.networkAddressNode, 		// PAR 441 node.networkAddress,
										kc.myParentTcp);
				
				endif;
			endif;
		endif;		   

		///  Now KCCMgr prods all processes running on the server to submit their Session_Open_Advices ///
		if not cem.emIsService and system.getDatabaseRole = SDS_RoleSecondary then

       		//  We don't send a KCCMgr SessionOpenAdvice (see above) when running SDS secondary on the desktop, 
       		//  because this could unravel all the cluster setup, if any, in JSA and JSM for
       		//  this JADE environment, with unpredictable results.  So we don't send any client advices either.
       		//
			cc.cnWriteLog(cc.CnLogDiag, "KCCMgr won't ask all processes to submit SessionOpenAdvices : SDS secondary not running as service.", null);
		
		else
			cc.cnWriteLog(cc.CnLogDiag, "KCCMgr now asking all processes to submit SessionOpenAdvices", null);
			on SystemException do app.cnHandleNullOrInvObjectRef(exception, proc, badObject);
		   	foreach proc in Process.instances do
				if proc.type = 2.Character				and					// SDS shadow process
				   proc <> process then										// ignore myself
					proc.causeEvent(Cn_Session_Open_Advice_Request, true, 0);
				endif;
		   	endforeach;
		endif;

		tcp.cnRead(self);	 
	endif;

epilog
	delete file;
	delete jdba;
	delete cem;
	delete objArray;
end;
}
cnProcessHeader
{
cnProcessHeader(buf : Binary) : Integer updating;

vars
	cc 				: CnCntrl;
	
 	preamble		: Binary;
 	
	bodyLength,
	preambleLength	: Integer;
begin
	/////	 This method returns the length of the message body, or for new extended headers 
	/////    initiates a second read to fetch the rest of the header. Remember that headers are
	/////    always in ANSI format.

	cc 				:= app.myCnCntrl;
	preamble		:= user_cnGetPreambleDefinition;
	preambleLength	:= preamble.length;
/*	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " preamble='" & preamble.display() & "'", null);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " preamble.length=" & preambleLength.String, null);
	if preamble <> null then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " buf header matches preamble=" & (buf[1:preambleLength] = preamble).String, null);
	endif;
*/
	if preamble <> null and buf[1:preambleLength] = preamble then		// We have a valid header
		if buf[preambleLength + 1].Integer = 69 then					// "E" - 'new' extended header format	
			return -2;													// have to get the rest of the header

		else															// else it's an 'old' format header - return length
			bodyLength := self.cnGetBodyLength(buf, preambleLength);
//			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " bodylength=" & bodyLength.String, null);
			return bodyLength;
		endif;

	else
//		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " failed, returning -1", null);
		return -1;														// corrupt header or not a header
	endif;
end;
}
cnReadNotify
{
cnReadNotify(tcp : CnKarmaTcpConnection input; buf: Binary) updating;

vars
	cc	: CnCntrl;

	msg	: CnMessage;
	
	str : String;
begin
 	inheritMethod(tcp, buf);
	cc := app.myCnCntrl;
 	if cc.appName <> CN_KARMACOMMSMGR and 
	   cc.appName <> CN_JOSSCOMMSMGR then
		create msg;
		msg.setMyTcp(tcp);
		msg.receiveMsg(buf, null, 0);
	endif;

epilog
	delete msg;
	if cc.appName <> CN_KARMACOMMSMGR and 
	   cc.appName <> CN_JOSSCOMMSMGR then
		if tcp.state = 2 then
			tcp.cnRead(self);		// we do this in the epilog so that it happens even after an exception (other than ConnectionException)
			
		else
			cc.cnWriteLog(cc.CnLogReceive, "Connection #" & self.connectionNo.String & " can't perform read operation in cnReadNotify : " &	// PAR 6782
					      "connection state now=" & tcp.state.String, null);
		endif;
	endif;
end;
}
cnReadNotifyHeader
{
cnReadNotifyHeader(tcp : CnKarmaTcpConnection input; buf : Binary) updating;

vars
 	length, len, pos : Integer;
 	s, str2		 	 : String;
 	cc  			 : CnCntrl;
begin
	//  We come here when we've read the number of bytes that should be in the 
	//  message header.  We now check to see if this is a valid header (user code
	//  required) and then fire off another read to get the body.

	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogReceive, "Received header or part header from " & tcp.remoteName &									// PAR 6782
					   " (" & tcp.remoteIpAddress & ") on connection #" & tcp.connectionNo.String & " (" &
					   tcp.String & "), buf=" & buf.ansiToString, tcp);

	length := cnProcessHeader(buf);							// this should return the length of the 
	//														// message body, or -1 if invalid header
	//														
	if length > 0 and buf.length = tcp.headerLength then	// This is the expected, normal (old) result so
		tcp.msgHeader := buf;								// we initiate the read of the message body
		tcp.msgHeaderLength	:= buf.length;
		tcp.readBinaryAsynch(length, tcp.myReceiver, "cnReadNotify"); 
		return;

	elseif length = -2 then									// new format extended header adds eight bytes - 
		tcp.msgHeader := buf;								// four more digits for length, 4 for flags
		tcp.msgHeaderLength := buf.length;
		tcp.readBinaryAsynch(8, tcp.myReceiver, "cnReadNotifyHeaderExt");	
		return;
	endif;	

    /////  If we get to here then we have probably got a corrupted data stream.   As of 2.6.100     ////
    /////  we give up immediately i.e. break the connection and raise a connection exception.		////	 	
	
	cc.cnWriteLog(cc.CnLogErrors, "Connection " & tcp.String & "(#" & tcp.connectionNo.String & 
				  ") appears to have bad header (value=" & buf.ansiToString & buf.display & ") - will close connection.", null);
	tcp.close();
	cnRaiseConnectionException(Cn_Tcp_Header_Error, "TCP message from " & tcp.remoteName & " (" & tcp.remoteIpAddress & ") had unrecognised message header.");	// PAR 1031
end;
}
cnReadNotifyHeaderExt
{
cnReadNotifyHeaderExt(tcp : CnKarmaTcpConnection input; buf : Binary) updating;

vars
	length	: Integer;
begin
	//   This is the second part of the header, required for extended headers
	//   Format of header is <SOH>CNWerrrnnnnnnnnnn where
	//   	<SOH>CNW is the preamble
	//		e is the extended flag, value is currently "E"
	//      r is a reserved for future use flag(s)
	//      nnnnnn is the message body length in PIC(9) display format
	//
	//		This is all hard coded, allows for 10 GB max message size.   RWM 14 Jul 99 v2.4.00.
	//
	msgHeader 	:= msgHeader[1 : msgHeaderLength] & buf;
	length		:= msgHeader[9:10].ansiToString.Integer;
	tcp.readBinaryAsynch(length, tcp.myReceiver, "cnReadNotify"); 
end;
}
setManagedEnvironmentName
{
setManagedEnvironmentName(pValue : String) updating;

vars

begin
 	self.managedEnvironmentName := pValue;
end;
}
setProtocolVersion
{
setProtocolVersion(version : Integer) updating;

vars

begin
  	self.protocolVersion := version;
end;
}
user_cnBuildHeader
{
user_cnBuildHeader(pBody : Binary) : Binary updating;

vars
 	msgnolength : Integer;
 	length 		: Integer;
 	cc			: CnCntrl;
 	preamble 	: Binary;
 	nulls		: Binary;
 	msgLenBin	: Binary;
begin
	/// This method returns a header string that defines the length of the message body, prefixed
	/// by default with an SOH & "CNW". 

	cc 			:= app.myCnCntrl;
	length 		:= pBody.length;
	preamble 	:= self.user_cnGetPreambleDefinition;

	if self.protocolVersion < 7 then
		msgnolength := self.headerLength - preamble.length;					// set the length of the output string 

	else
		preamble := preamble & 69.Binary[1:1];								// ANSI "E" - extended message format : length is hardcoded
		if not app.isUnicode then
			preamble := preamble & "   ".Binary;							// three reserved bytes, not currently used	
			
		else
			nulls	 := #"00".Binary & #"00".Binary;						// 4 bytes of nulls
			preamble := preamble & nulls[1:3]; 
		endif;
		
		msgnolength := 10;
	endif;
		
	if app.isUnicode then														
		msgLenBin	:= self.cnIntegerToString(msgnolength, length).cnUnicodeToAnsi;
		
	else
		msgLenBin	:= self.cnIntegerToString(msgnolength, length).Binary;
	endif; 

	return preamble & msgLenBin;
end;
}
	)
	CnSmtpConnection (
	jadeMethodSources
adjustFileLocationBase
{
adjustFileLocationBase(pFileLocationBase	:	String)	:	String;

// V1 21.06.00

constants

	ForwardSlash	= "/";
	BackSlash		= "\";

vars

	slashPosition	:	Integer;

begin

	if pFileLocationBase = null then
		return null;
	endif;

	// Look for Windows-style directory ending in backslash
	slashPosition	:=	pFileLocationBase.reversePos(BackSlash);
	if slashPosition <> 0 then
		if slashPosition = pFileLocationBase.length then
       		// The directory name already ends in backslash
       		return pFileLocationBase;
    	endif;
    	// Append backslash and return
    	return pFileLocationBase & BackSlash;
    endif;	

	// Look for UNIX-style directory ending in forward slash
	slashPosition	:=	pFileLocationBase.reversePos(ForwardSlash);
	if slashPosition <> 0 then
		if slashPosition = pFileLocationBase.length then
       		// The directory name already ends in forward slash
       		return pFileLocationBase;
       	endif;
       	// Append forward slash and return
       	return pFileLocationBase & ForwardSlash;	
    endif;

	// If directory contains no slashes, it should be a Windows-style directory
	return pFileLocationBase & BackSlash;

end;
}
base64Decode
{
base64Decode(pMessage: String input; pDecodedMessage: Binary output) : Integer updating;

// This method takes a Base64-encoded string (pMessage), and decodes it into a binary buffer (pDecodedMessage).

// A Base64-encoded message contains characters from the following alphabet:
// ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
// The message may also contain line breaks (CrLf) inserted by the Base64 encoding algorithm; these are ignored by the decoder, as are
// any characters that are not in the Base64 alphabet.

// Each character in the message has a corresponding 6-bit value from 0 thru 63:
//	-	A thru Z = 0 thru 25
//	-	a thru z = 26 thru 51
//	-	0 thru 9 = 52 thru 61
//	-	+        = 62
// 	-	/		 = 63

// The decoding is as follows:

//  - Take each group of four ASCII characters from the input stream
//  - For each character, find its corresponding 6-bit code
// 	- Make a 24-bit word out of the four 6-bit codes
// 	- Split each 24-bit word into three octets, and write the octets sequentially into the binary buffer.

// If the message ends with one equals sign (=), then the last word has only 16 bits.
// If the message ends with two equals signs, then the last word has only 8 bits.

// Return an integer of 0 if no errors are found, or 1 if the format of the buffer is invalid.

// Refer to RFC 2045 (www.oac.uci.edu/indiv/ehood/MIME/2045/rfc2045.html [pages 17 thru 19]) for a description of Base64 encoding.

// Author: Robin Arzoni, JADE Systems Group

constants

	Zero_Errors 	= 	0;
	Invalid_Format 	= 	1;
	MaskThird8Bits 	=	#000000FF;
    MaskSecond8Bits = 	#0000FF00;
    MaskFirst8Bits 	= 	#00FF0000;

vars

	validCharacter:Boolean;
	char:Character;
	nextInByte, nextOutByte, characterCount, groupOf24Bits, first, second, third, code:Integer;

begin

     nextInByte := 0;
     nextOutByte := 1;

     while nextInByte <= pMessage.length do
	     groupOf24Bits := 0;
	     characterCount := 0;
	     while characterCount < 4 and nextInByte < pMessage.length do

	        	nextInByte := nextInByte + 1;
	        	char := pMessage[nextInByte].Character;
				if char = "=" then
					 break;              					//Found a pad character: end of message
				endif;

				code := char.Integer;
				validCharacter := true;						//Assume character is in the Base64 alphabet

				if char >= "A" and char <= "Z" then
					code := code - 65;						//Calculate decode value (A thru Z yields 0 thru 25)
				elseif char >= "a" and char <= "z" then
					code := code - 71;						//Calculate decode value (a thru z yields 26 thru 51)
				elseif char >= "0" and char <= "9" then
					code := code + 4;						//Calculate decode value (0 thru 9 yields 52 thru 61)
				elseif char = "+" then
					code := 62;								//Decode value of + is 62
				elseif char = "/" then
					code := 63;								//Decode value of / is 63
				else	
                   	validCharacter := false;
				endif;

	 	    	if validCharacter then
	 	    		groupOf24Bits := groupOf24Bits * 64;
	 	    		groupOf24Bits := groupOf24Bits.bitOr(code);
	 	    		characterCount := characterCount + 1;
	 	    	endif;	
		endwhile;

		if characterCount = 0 then
		//End of message, and there were no pad characters (=)
			break;

		elseif char = "=" and nextInByte < pMessage.length then
			nextInByte := nextInByte + 1;
			char := pMessage[nextInByte];
			if char = "=" and nextInByte = pMessage.length then

			//Found two pad characters at end of message.
			//This means that the final octet of the message is in groupOf24Bits, but has to be shifted left to the correct position.

				groupOf24Bits := groupOf24Bits * 64;		
				groupOf24Bits := groupOf24Bits * 64;

				first := groupOf24Bits.bitAnd(MaskFirst8Bits);
				first := first div 2 ^ 16;

		        pDecodedMessage[nextOutByte] := first;

     		else
     			return Invalid_Format;
     		endif;	
		    break;

		elseif pMessage[nextInByte] = "=" and nextInByte = pMessage.length then

		//Found one pad character at end of message.
		//This means that the two final octets of the message are in groupOf24Bits, but they have to be shifted left to the correct position.

			groupOf24Bits := groupOf24Bits * 64;

			first := groupOf24Bits.bitAnd(MaskFirst8Bits);
			first := first div 2 ^ 16;

	        pDecodedMessage[nextOutByte] := first;
	        nextOutByte := nextOutByte + 1;

			second := groupOf24Bits.bitAnd(MaskSecond8Bits);
			second := second div 2 ^ 8;

			pDecodedMessage[nextOutByte] := second;
	        break;
		else

			//We haven't reached the end of the message yet: divide the 24 bits into three octets, and send them to the output stream.

			first := groupOf24Bits.bitAnd(MaskFirst8Bits);
			first := first div 2 ^ 16;

			second := groupOf24Bits.bitAnd(MaskSecond8Bits);
			second := second div 2 ^ 8;

			third := groupOf24Bits.bitAnd(MaskThird8Bits);

	        pDecodedMessage[nextOutByte] := first;
	        nextOutByte := nextOutByte + 1;
	        pDecodedMessage[nextOutByte] := second;
			nextOutByte := nextOutByte + 1;
			pDecodedMessage[nextOutByte] := third;
			nextOutByte := nextOutByte + 1;	        

        endif;
    endwhile;

    return Zero_Errors;
end;
}
base64Encode
{
base64Encode(pMessage: Binary input) : String updating;

// This method takes a binary buffer, and encodes it into an ASCII string, using the Base64 encoding technique defined in RFC 1521.

// Base64 encoding allows 8-bit data to be converted, so that it can be transmitted over a protocol that allows only 7-bit characters.
// Base64 also gives enhanced privacy, if the source data is standard ASCII text, as the message is no longer in clear text when it is sent over the wire.
// Base64 is almost identical to Privacy Enhanced Mail encoding (RFC 1421).

// The encoding is as follows:
// Take each group of three octets, so that we have 24 bits; divide each 24-bit group into four 6-bit groups; use the integer represented by each 6-bit group as an
// index into a table, and extract the corresponding ASCII character from that table; insert the ASCII character into the output stream.

// Some sections of this code could be broken into further methods, but calling them would probably be more inefficient than executing the code in-line. 

constants

	MaskFirst6Bits = 	#00FC0000;
    MaskSecond6Bits = 	#0003F000;
    MaskThird6Bits = 	#00000FC0;
    MaskFourth6Bits = 	#0000003F;
    Base64Table = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

vars
	firstChar, secondChar, thirdChar, fourthChar:Character;
	nextInByte, nextOutByte, characterCount, groupOf24Bits, first, second, third, fourth, thisLineLength:Integer;
	//startTime, endTime, loopTimeStart, loopTimeEnd:Integer;
    encodedMessage:String;
begin

    //startTime := currentTimeInMilliseconds;

     nextInByte := 0;
     nextOutByte := 1;

     while nextInByte <= pMessage.length do
	     characterCount := 0;
	     groupOf24Bits := 0;
	     while characterCount < 3 and nextInByte < pMessage.length do
	        	nextInByte := nextInByte + 1;
	        	groupOf24Bits := groupOf24Bits * 256;
	 	    	groupOf24Bits := groupOf24Bits.bitOr(pMessage[nextInByte].Integer);
	 	    	characterCount := characterCount + 1;
		endwhile;

		if characterCount = 3 then

			//Not the end of the message yet

			fourth := groupOf24Bits.bitAnd(MaskFourth6Bits);

			third := groupOf24Bits.bitAnd(MaskThird6Bits);
			third := third div 64;

			second := groupOf24Bits.bitAnd(MaskSecond6Bits);
			second := second div 64 ^ 2;

			first := groupOf24Bits.bitAnd(MaskFirst6Bits);
			first := first div 64 ^ 3;
			first := first.bitAnd(MaskFourth6Bits);	

	  		firstChar := Base64Table[first + 1];
	       	secondChar := Base64Table[second + 1];
	       	thirdChar := Base64Table[third + 1];
	       	fourthChar := Base64Table[fourth + 1];

	  		//Lines are not allowed to be more than 76 characters in length, (RFC 2045) so 73 is the last valid position for inserting a four-character group
	  		if thisLineLength > 73 then
				encodedMessage[nextOutByte] := Cr.Character;
				nextOutByte := nextOutByte + 1;
				encodedMessage[nextOutByte] := Lf.Character;
				nextOutByte := nextOutByte + 1;
				thisLineLength := 0;
			endif;	

			encodedMessage[nextOutByte] := firstChar;
			encodedMessage[nextOutByte + 1] := secondChar;
			encodedMessage[nextOutByte + 2] := thirdChar;
			encodedMessage[nextOutByte + 3] := fourthChar;
			nextOutByte := nextOutByte + 4;
			thisLineLength := thisLineLength + 4;

		elseif characterCount = 0 then
			//End of message, and the number of octets was exactly divisible by three
			break;

		elseif characterCount = 1 then
			//End of message, and we need to insert two pad characters

			groupOf24Bits := groupOf24Bits * 256;
			groupOf24Bits := groupOf24Bits * 256;

			second := groupOf24Bits.bitAnd(MaskSecond6Bits);
			second := second div 64 ^ 2;

			first := groupOf24Bits.bitAnd(MaskFirst6Bits);
			first := first div 64 ^ 3;
			first := first.bitAnd(MaskFourth6Bits);	

	  		firstChar := Base64Table[first + 1];
	       	secondChar := Base64Table[second + 1];
	       	thirdChar := "=".Character;
	       	fourthChar := "=".Character;

	  		//Lines are not allowed to be more than 76 characters in length, so 73 is the last valid position for inserting a four-character group
	  		if thisLineLength > 73 then
				encodedMessage[nextOutByte] := Cr.Character;
				nextOutByte := nextOutByte + 1;
				encodedMessage[nextOutByte] := Lf.Character;
				nextOutByte := nextOutByte + 1;
			endif;	

			encodedMessage[nextOutByte] := firstChar;
			encodedMessage[nextOutByte + 1] := secondChar;
			encodedMessage[nextOutByte + 2] := thirdChar;
			encodedMessage[nextOutByte + 3] := fourthChar;
	        break;

		else
		//End of message, and we need to insert one pad character

			groupOf24Bits := groupOf24Bits * 256;

			third := groupOf24Bits.bitAnd(MaskThird6Bits);
			third := third div 64;

			second := groupOf24Bits.bitAnd(MaskSecond6Bits);
			second := second div 64 ^ 2;

			first := groupOf24Bits.bitAnd(MaskFirst6Bits);
			first := first div 64 ^ 3;
			first := first.bitAnd(MaskFourth6Bits);	

	  		firstChar := Base64Table[first + 1];
	       	secondChar := Base64Table[second + 1];
	       	thirdChar := Base64Table[third + 1];
	       	fourthChar := "=".Character;

	  		//Lines are not allowed to be more than 76 characters in length, so 73 is the last valid position for inserting a four-character group
	  		if thisLineLength > 73 then
				encodedMessage[nextOutByte] := Cr.Character;
				nextOutByte := nextOutByte + 1;
				encodedMessage[nextOutByte] := Lf.Character;
				nextOutByte := nextOutByte + 1;
			endif;	

			encodedMessage[nextOutByte] := firstChar;
			encodedMessage[nextOutByte + 1] := secondChar;
			encodedMessage[nextOutByte + 2] := thirdChar;
			encodedMessage[nextOutByte + 3] := fourthChar;
	        break;

        endif;
    endwhile;

	//endTime := currentTimeInMilliseconds;
	//write "Total encoding time = " & (endTime - startTime).String;
    return encodedMessage;
end;
}
buildMessageHeader
{
buildMessageHeader() updating;

//V2 29.04.99 Handle name + e-mail address in sendFrom
//V3 20.06.00 Support for inline (embedded) objects; replace literals by constants
//V4 21.09.00 Remove second MIME-Version from header
//V5 05.02.03 Move MIME Version 1.0 line to main message header (GroupWise complains otherwise)
//V6 16.02.04 Remove leading space from subject
//V7 17.03.04 Stop insertion of CrLf after To: and cc:


constants

	LeftAngle		=	"<";	//V3
	RightAngle		=	">";	//V3
	BoundaryDash	=	"--";	//V3

vars
	cem							: CnExternalMethods;
	
	subjectEncoding				: Character;
	
    index,										//V3
    lineBreak					: Integer;	//V3

    content,
    contentTransferEncoding,
    header,
    lowerEncodingType,
	result,
	subjectCharset,
	subjectEncoded				: String;		//V3
begin

	//This method builds the RFC 822 header that precedes the e-mail message and attachment.

	content		:= contentType.toLower;	//contentType is the message content type supplied by the user
	if content = Html then 													//V3
		content := Text_Html;												//V3
	elseif content = Plain then												//V3
		content := Text_Plain;  											//V3
	endif;

	//Insert Date, From, and author of message
	header 		:=	HDate			&	CN_SPACE	&  									//V3
					self.genDate() 	&	CrLf	&									//V3
					HFrom			&	CN_SPACE	&									//V3
					self.sendFromName			& CN_SPACE & LeftAngle &				//V3
					self.sendFromAddress		& RightAngle & CrLf;				//V2 V3

	//Insert Sender
	if self.sender <> "" then
		header	:=	header &  HSender	& CN_SPACE & CN_SPACE & self.senderName & CN_SPACE & LeftAngle & self.senderAddress & RightAngle & CrLf;	//V3
	endif;

	//Insert Subject
//	header		:=	header &  HSubject	& Space & subject & CrLf;			//V3
	if self.charset = self.Charset_ISO_8859_1 or																				// NFS 932
	   self.charset = self.Charset_UTF_8	  then																				// NFS 932
		// if the message is user-encoded then the subject is also expected to be user-encoded									// NFS 932
		// if not user-encoded and either base64 or quoted-printable encoding is defined then									// NFS 932
		// we also need to encode the subject in form																			// NFS 932
		//	"=?char set>?<B|Q>?<encoded subject>?="																				// NFS 932
		// where 																												// NFS 932
		//		- <char-set> is UTF-8 or ISO-8859-1																				// NFS 932
		//		- B is Base64 encoded or Q is Quoted-Printable																	// NFS 932
		if not self.isUserEncoded then																							// NFS 932
			if self.charset = self.Charset_ISO_8859_1 then																		// NFS 932
				subjectCharset	:= self.Charset_ISO_8859_1_only;																// NFS 932
			
			else																												// NFS 932
				subjectCharset	:= self.Charset_UTF_8_only;																		// NFS 932
			endif;																												// NFS 932
			
			if self.encodingType = self.Base64 then																				// NFS 932
				subjectEncoded	:= self.emBase64Encode(self.subject.Binary);													// NFS 932
				subjectEncoding := self.Subject_Encoded_Base64;																	// NFS 932
			
			elseif self.encodingType = self.Quoted_Printable then																// NFS 932
				subjectEncoding := self.Subject_Encoded_Quoted_Printab;																	// NFS 932
				create cem transient;																							// NFS 932
				result	:= cem.emQPEncode(self.subject.Binary, subjectEncoded);													// NFS 932
				if result <> OK then																							// NFS 932	
					self.raiseValidationException(self.Err_Encoding_Error, method.cnGetMethodName & " '" & 						// NFS 932
														self.Quoted_Printable & "' subject encoding error : " & result);		// NFS 932
				endif;																											// NFS 932
			endif;																												// NFS 932
		endif;																													// NFS 932
	endif;																														// NFS 932
	
	if subjectEncoded = null then																								// NFS 932
		header		:=	header &  HSubject  & self.subject & CrLf;					// removed space for V6
	
	else																														// NFS 932
		// need to encapsulate encoded subject with char set and encoding type													// NFS 932
		subjectEncoded	:= subjectEncoded.cnRemoveChars(CrLf);																	// NFS 932
		header		:= header & self.HSubject & 																				// NFS 932
						CN_EQUAL & CN_QUESTIONMARK & subjectCharset & CN_QUESTIONMARK & 										// NFS 932
						subjectEncoding & CN_QUESTIONMARK & subjectEncoded & CN_QUESTIONMARK & CN_EQUAL & CrLf;					// NFS 932
	endif;																														// NFS 932
	
	//Insert To

	//The message may have multiple 'To' recipients, whose addresses are stored in the sendToAddresses array.
	//Each address may or may not have an attached name in the sendToNames array.

	header		:=	header & self.HTo & CN_SPACE & CN_SPACE;				//V3
	index		:=	1;                                       				//V3
	lineBreak	:= 	2;														//V7
	while index <= self.sendToAddresses.size() do
		header		:=	header	& self.sendToNames[index] & CN_SPACE & LeftAngle & self.sendToAddresses[index] & RightAngle;	//V3
		index		:=	index + 1;											//V3

		//No comma after last address
		if index <= self.sendToAddresses.size() then						//V3
			header	:=	header	&	CN_COMMA;                       			//V3
			if lineBreak = 0 then                                           //V3 RFC 822 says that CrLf must be followed by at least 1 space, moved here for V7
				header	:=	header	& CrLf & CN_SPACE;							//V3 when 'folding' lines.
				lineBreak	:= 1;											//V7 Insert line break after every two addresses.
			else															//V7
				lineBreak	:= 0;											//V7
			endif;															//V3																														//V3
		endif;	                                                 			//V3
	endwhile;	                 											//V3
	
    header		:=	header	&	CrLf;              							//V3

	//Insert Reply-To
	if self.replyTo <> null then
		header	:=	header & self.HReplyTo & CN_SPACE & CN_SPACE & self.replyToName & CN_SPACE & LeftAngle & self.replyToAddress & RightAngle & CrLf;		//V3 Reply-To is optional
	endif;

	//Insert Cc

	//The message may have multiple 'cc' recipients, whose addresses are stored in the ccAddresses array.
	//Each address may or may not have an attached name in the ccNames array.

	if self.cc <> null then
		header		:=	header & self.Hcc & CN_SPACE & CN_SPACE;							//V3
		index		:=	1;                                       				//V3
		lineBreak	:=	2;														//V7
		while index <= self.ccAddresses.size() do
			header		:=	header	& self.ccNames[index] & CN_SPACE & LeftAngle & self.ccAddresses[index] & RightAngle;	//V3
			index		:=	index + 1;

			//No comma after last address
			if index <= self.ccAddresses.size() then							//V3
				header	:=	header	&	CN_COMMA;                       			//V3
				if lineBreak = 0 then                                           //V3 RFC 822 says that CrLf must be followed by at least 1 space, moved here for V7
					header	:=	header	& CrLf & CN_SPACE;							//V3 when 'folding' lines.
					lineBreak	:= 1;											//V7 Insert line break after every two addresses.
				else															//V7
					lineBreak	:= 0;											//V7
				endif;															//V3																														//V3
			endif;	                                                 			//V3
		endwhile;	
    	header		:=	header	&	CrLf;

    endif;

    //RFC 822 provides a 'bcc' statement, but if we use it, our mail server still informs non-bcc recipients
    //that a bcc recipient has received the message. This defeats the point of using blind copies. 
    //We therefore create bccs by registering a bcc recipient through the RCPT command, and omitting the 'bcc' statement
    //in the RFC 822 header.

    //The code below is commented out for the time being:
    /* if bcc <> "" then
		header := header & "Bcc: " & " <" & bcc & ">" & CrLf;				//Blind carbon copies
       endif;*/

    //Insert Comments
    if self.comments <> null then
      	header := header & self.HComments & CN_SPACE & self.comments & CrLf;				//V3 Comments
    endif;	
    
	header			:=	header	&	self.MIME_Version	&	CrLf;				//V5

	if self.contentLocationBase <> null then										//V3
		header		:=	header	&	self.Content_Location	&	self.adjustFileLocationBase(self.contentLocationBase) & CrLf;	//V3
	endif;
	
	// Insert precedence
	if self.precedence <> null then
		header		:= header & self.HPrecedence & CN_SPACE & self.precedence & CrLf;
	endif;

	// Look for attachments
	if self.myAttachments.size() > null then										//Gen attachment file header (if any)
		boundary	:=	self.generateBoundary;
		header		:=	header			&
						self.Content_Type_Multipart_Mixed	&					//V3
						CN_SPACE			&
						self.Boundary_Equals & CN_DOUBLE_QUOTE			&					//V3
						boundary			 & CN_DOUBLE_QUOTE			& CrLf & CrLf;

		header		:=	header & BoundaryDash & boundary & CrLf;			//V3
	endif;	

	// Look for inline images
	if self.allInlines.size() > null then										//V3
		inlineBoundary	:=	self.generateInlineBoundary;							//V3

		header			:=	header			&								//V3
							self.Content_Type_Multipart_Related	&				//V3
							CN_SPACE			&								//V3
							Boundary_Equals	&	CN_DOUBLE_QUOTE			&				//V3
							inlineBoundary	&	CN_DOUBLE_QUOTE			&				//V3
							CN_SEMICOLON	&	CN_SPACE		&				//V3
							Type_Equals		&	CN_DOUBLE_QUOTE			&				//V3
							content	&	CN_DOUBLE_QUOTE	&	 CrLf	&	CrLf;	//V3



		header			:=	header & BoundaryDash & inlineBoundary & CrLf;	//V3
	endif;			

	// The next line defines the content transfer encoding of the actual message (as opposed to the content transfer encoding
	// of a file attachment). All we do here is pass the user-defined encodingType straight through to the Content-Transfer-Encoding
	// MIME parameter (although 'none' is replaced by '7Bit'). This allows encoding types such as Quoted-Printable, or experimental
	// encoding types beginning with X, to be specified by the user. At present this class doesn't offer conversion to Quoted-Printable.

	// Note: RFC 2045 refers to 'no encoding' as 'the identity coding transformation' (!). Clearly, to use the phrase 'no encoding' would
	// be far too simple.    

	lowerEncodingType			:=	encodingType.toLower;							//V3
	if lowerEncodingType = None then		                     					//V3
		contentTransferEncoding	:=	Seven_Bit;										//V3
	else                                                            				//V3
		contentTransferEncoding	:=	lowerEncodingType;                              //V3
	endif;                                                                  		//V3

	//header			:=	header	&	MIME_Version		&	CrLf			&	//V5 Removed this line 
	header			:=	header	&
	 					self.Content_Type			&	CN_SPACE		&				//V3
						content						& 	CN_SEMICOLON	&	CN_SPACE	& 	//V3
						self.charset				&	CrLf;               		//V3										// NFS 932

	header			:=	header	&
						self.Content_Transfer_Encoding	&								//V3
						CN_SPACE	&
						contentTransferEncoding & CrLf & CrLf;
    
	messageHeader	:=	header;
epilog
	delete cem;
end;
}
changeState
{
changeState(pStateClass:Class input) updating;

vars
    obj			:	Object;
    className	:	String;
begin

    obj			:= pStateClass.firstProcessTransientInstance;
    if obj = null then
    	className := self.getName & "::" & method.name;
    	raiseValidationException(Err_Missing_State_Object, className & " Cannot find SMTP state object " & pStateClass.name);
    endif;	
    myMailState := obj.CnSmtpState;

end;
}
checkNameLength
{
checkNameLength(pName:String):Boolean;

//V3 22.06.01	Allow unqualified names (without an @ sign): see new boolean allowUnqualifiedNames.
//V2 27.06.00	Return error if no @ sign found
vars
      i			:	Integer;
      mailName	:	String;
      user		:	String;
      domain	:	String;
begin

	//Check that mail address is valid

	mailName	:=	pName;
	i			:=	mailName.pos("@", 1);

    if i <> null then       //Found an @ sign: now separate the user name and domain
 		user	:=	mailName[1 : i -1];
   		if user.length > 64 then
   			return true; 	//User name too long
    	endif;

    	if i = mailName.length then
    		 return true;
    	endif;		//The @ is the last character - no domain specified

    	domain	:=	mailName[i +1 : end];
      	if  domain.length > 64 then
    		return true; 	//Domain name too long
    	endif;

		return false;		//E-mail address format is OK 		//V2
    else
    	
    	if allowUnqualifiedNames then							//V3
    		if mailName.length > 64 then						//V3
    			return true;	// User name too long			//V3
    		else												//V3
    			return false;									//V3 Unqualified name is OK
    		endif;												//V3
    	else													//V3
    		return true;     //Couldn't find an @				//V2
    	endif;	
    endif;	
end;
}
clearServerMessageAndRead
{
clearServerMessageAndRead(receiver	:	Object) updating;

vars

begin

	self.serverMessage	:=	null;
	cnRead(receiver);

end;
}
cnClose
{
cnClose(receiver: Object) updating;

//V1 30.06.00

vars

begin
	inheritMethod(receiver);
	connectionIsOpen	:=	false;

end;
}
cnCloseNotify
{
cnCloseNotify(tcp: CnTcpConnection input) updating;

//New method V1 06.08.2002	Delay sending completion notification until callback from cnClose is received.

vars

begin
	inheritMethod(tcp);
	myMailState.setCompleted(self);
end;
}
cnOpenNotify
{
cnOpenNotify(tcp : CnSmtpConnection input) updating;

//V4 25.06.04	Add open time to logging diagnostics
//V3 			Clear serverMessage before reading
//V2 			set connectionIsOpen

vars
	cc : CnCntrl;
begin
	if self.loggingRequired then						// V4
		self.d2Open := app.relativeMachineTime();		// V4
		cc := app.myCnCntrl;							// V4
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " open elapsed time = " & (self.d2Open - self.d1Open).String & "ms", null);	// V4
	endif;												// V4

	inheritMethod(tcp);

    //TCP connection has been established. Now issue a read, and wait for service ready reply (220).

    connectionIsOpen	:=	true;

    //If no client name has been supplied, default it to the local IP address enclosed in square brackets. This is allowed by SMTP. 
    if tcp.clientName = null then
    	tcp.clientName	:=	"[" & tcp.localIpAddress & "]";
    endif;

    changeState(CnSmtpStateTCPConnected);
    clearServerMessageAndRead(tcp);		//V3
end;
}
cnRead
{
cnRead(receiver : Object) updating;

//V3 	20.06.01 Don't clear serverMessage here: allow multi-buffer concatenation.
//V2 	21.07.99 Check if logging required
//Reimplemented: note that we do not inheritMethod.

vars
  	cnCntrl : CnCntrl;		// CnSmtpConnection: Changed from 'cc' as we need that name for the 'carbon copies' class attribute
begin

	cnCntrl := app.myCnCntrl;
    self.cnArmTcpExceptionHandler;
	self.fillReadBuffer := false; 	//CnSmtpConnection: On each notify, we'll check if CRLF has been received

	if self.loggingRequired then
		cnCntrl.cnWriteLog(cnCntrl.CnLogDiag, "Connection #" & self.connectionNo.String &
							   " about to readAsync on port " & self.port.String &
							   " .....", self);
	endif;

	self.cnSetLastAction(Read);
	self.cnSetMyReceiver(receiver);
	self.msgHeader := null;
	self.headerLength := 1001;		//CnSmtpConnection: 
	self.readBinaryAsynch(self.headerLength, receiver, "cnReadNotify");	//CnSmtpConnection: 
end;
}
cnReadNotify
{
cnReadNotify(tcp : CnSmtpConnection input; buf : Binary) updating;

//V3 21.09.00 Changes for UNICODE
//V2 21.07.99 Reimplemented method from CnTcpConnection superclass to check if logging required

vars
    i		:	Integer;
    smtp	:	CnSmtpConnection;
    buffer	:	String;
	cnCntrl :	CnCntrl;	// CnSmtpConnection: Changed from 'cc' as we need that name for the 'carbon copies' class attribute
	str		:	String;
begin
	//   This method is invoked when the message BODY is received.  The body is   /////
	//   returned in Binary buf.												  /////

	cnCntrl	:=	app.myCnCntrl;	
	
	if app.isUnicode then					//V3
		str		:=	buf.ansiToUnicode;		//V3
	else									//V3
		str		:=	buf.String;
	endif;									//V3
	
	if self.loggingRequired	or																									// PAR 1044
	   self.loggingResponse then																								// PAR 1044
		cnCntrl.cnWriteLog(cnCntrl.CnLogComment, "Msg from " & tcp.remoteName & 												// PAR 1044 
													", bodylength=" & str.length.String &										// PAR 1044
													", data='" & str & "'", tcp);	//V3										// PAR 1044
	endif;

	tcp.retryNo		:=	0;
	tcp.msgHeader	:=	null;

    smtp			:=	tcp;
    buffer			:=	str;
    
    //Look for CrLf in the received buffer
    i				:=	buffer.pos(CrLf, 1);

    //Whether we found CrLf or not, concatenate this received buffer with any previously-received data
    smtp.serverMessage := smtp.serverMessage & buffer;

    if i = null then
 	  	 cnRead(smtp);										// Didn't receive CrLf, so keep reading
    	 return;
    else													// We have a line terminated by CrLf. 
    	 myMailState.handleEvent(smtp);						// Call the state machine to handle the server message
    endif;

end;
}
cnWrite
{
cnWrite(body : Binary; receiver : Object) updating;

//V3 21.09.00 Changes for UNICODE
//V2 21.07.99 Reimplemented method from CnTcpConnection superclass to check if logging required

vars

 	buffer	:	Binary;
 	cnCntrl	:	CnCntrl;		// CnSmtpConnection: Changed from 'cc' as we need that name for the 'carbon copies' class attribute

begin
	cnCntrl	:=	app.myCnCntrl;
	self.cnArmTcpExceptionHandler;
 	buffer	:=	self.user_cnBuildHeader(body);				// user can reimplement this, to build the header.
 	buffer	:=	buffer & body;		 						
 	self.cnSetMyReceiver(receiver);

    if self.retryNo <= cnCntrl.connectionRetryLimit then
 		if self.loggingRequired then
 			cnCntrl.cnWriteLog(cnCntrl.CnLogTransmit, "To=" & self.computerName & ", length=" &
 						   body.length.String & ", data=" & buffer.ansiToString, self);		//V3
 		endif;

 		self.cnSetLastAction(Write);
 		self.writeBinaryAsynch(buffer, receiver, "cnWriteNotify");
 	else
 		self.cnHaltConnection();							// error
 	endif;	
end;
}
cnWriteNotify
{
cnWriteNotify(tcp : CnTcpConnection input) updating;

//V2 21.07.99 Reimplemented method from CnTcpConnection superclass to check if logging required

vars

	cnCntrl : CnCntrl;		// CnSmtpConnection: Changed from 'cc' as we need that name for the 'carbon copies' class attribute

begin
	cnCntrl		:=	app.myCnCntrl;

	if self.loggingRequired then
		cnCntrl.cnWriteLog(cnCntrl.CnLogDiag, "::cnWriteNotify for connection #" & tcp.connectionNo.String &
				       " on port " & tcp.port.String, tcp);
	endif;

 	tcp.retryNo	:=	0;
end;
}
create
{
create() updating;

//V8 13.05.14 Provide SMTP authentication and TLS (Transport Layer Security)
//V4 23.06.00 Replace literals by constants; remove creation of arrays (which are now exclusive collections) 
//V3 21.07.99 Set logging true or false
//V2 29.04.99 Handle name + e-mail address

vars
	class				:	Class;
	
	cnc					: 	CnCntrl;					

	smtpState			:	CnSmtpState;

	classCollection		:	ClassColl;
	
	obj					:	Object;
	
	sslContext			: 	JadeSSLContext;
	
	useTls				: 	Boolean;																				// V8
	
	iniFile,
	iniLoggingDefault,																											// PAR 1044
	iniLoggingResponse,																											// PAR 1044
	useTlsString		:	String;																					// V8
begin
	cnc := app.myCnCntrl;
	//If the application hasn't already created the State subclass instances, create them now. 
	iniFile			:=	app.getIniFileName;
	iniLoggingDefault := app.getProfileString(iniFile, CN_SMTPCLIENT, CN_SMTPCLIENT_LOGGING, null);								// PAR 1044
	if iniLoggingDefault = null then																							// PAR 1044
		iniLoggingDefault := false.String;																						// PAR 1044
		app.setProfileString(iniFile, CN_SMTPCLIENT, CN_SMTPCLIENT_LOGGING, iniLoggingDefault);									// PAR 1044
	endif;
	
	iniLoggingResponse := app.getProfileString(iniFile, CN_SMTPCLIENT, CN_SMTPCLIENT_LOGGINGRESPONSE, null);					// PAR 1044
	if iniLoggingResponse = null then																							// PAR 1044
		iniLoggingResponse := true.String;			// default is true															// PAR 1044
		app.setProfileString(iniFile, CN_SMTPCLIENT, CN_SMTPCLIENT_LOGGINGRESPONSE, iniLoggingResponse);						// PAR 1044
	endif;

    //write currentTimeInMilliseconds.String;

    create classCollection transient;
    CnSmtpState.getSubclasses(classCollection);

    foreach class in classCollection do
    	obj := class.firstProcessTransientInstance;
    	if obj = null then
        	create smtpState as class;
        endif;
    endforeach;

    delete classCollection;

    myMailState			:=	CnSmtpStateTCPDisconnected.firstProcessTransientInstance;	//Start off in CnSmtpTCPDisconnected state

    //Defaults
    self.contentType		:= self.Plain;					//V4 Content type: actual message
    self.encodingType		:= self.None;					//V4 Encoding type:  actual message
	self.charset			:= self.Charset_US_ASCII;		// NFS 832 - default to US-ASCII charset

    resolveRemoteName	:=	true;

    /*Set up logging parameter. Default logging is false. If ini file specifies true, then logging will proceed as per the logging
	 parameters in the ini file's CardLog section. */
	executeWhen not Cn_Debug_SMTP;
	iniFile			:=	app.getIniFileName;
	self.setLoggingIniDefault(iniLoggingDefault.Boolean);																		// PAR 1044
	self.setLoggingRequired(self.loggingIniDefault);
	self.setLoggingReponse(iniLoggingResponse.Boolean);																			// PAR 1044
	endExecuteWhen;

	executeWhen Cn_Debug_SMTP;
	self.setLoggingIniDefault(true);
	self.setLoggingRequired(true);
	self.setLoggingReponse(true);																								// PAR 1044
	endExecuteWhen;

	self.port := app.getProfileString(iniFile, "SMTPServer", "MailPort", "0").Integer;								// V8
	if self.port = null then																						// V8
		self.port := 25;						// default SMTP port
		app.setProfileString(iniFile, "SMTPServer", "MailPort", self.port.String);									// V8
		if self.loggingRequired then																				// V8
			cnc.cnWriteLog(cnc.CnLogDiag, "[SMTPServer] MailPort not defined, defaulting to 25", null);				// V8
		endif;																										// V8
		
	elseif self.loggingRequired then																				// V8
		cnc.cnWriteLog(cnc.CnLogDiag, "[SMTPServer] MailPort defined as " & self.port.String, null);				// V8
	endif;																											// V8
	
	useTlsString := app.getProfileString(iniFile, "SMTPServer", "MailUsesTLS", null);								// V8
	if useTlsString = null then 																					// V8
		app.setProfileString(iniFile, "SMTPServer", "MailUsesTLS", useTls.String);									// V8
	
	else																											// V8
		useTls := useTlsString.Boolean;																				// V8
	endif;																											// V8

	if self.loggingRequired then																					// V8
		cnc.cnWriteLog(cnc.CnLogDiag, "SMTP Mail Server using TLS (Transport Layer Security) = " & useTls.String, null);	// V8
	endif;																											// V8
	
	if useTls then																									// V8
		beginTransientTransaction;																					// V8
		create sslContext sharedTransient;																			// V8
		sslContext.methodType := sslContext.MethodTLSv1;															// V8
		self.sslContext := sslContext;																				// V8
		commitTransientTransaction;																					// V8
	endif;																											// V8
end;
}
currentTimeInMilliseconds
{
currentTimeInMilliseconds():Integer;

vars

	now		:	Time;
	nowTs	:	TimeStamp;

begin

	now		:=	 nowTs.time;
	return (now.hour * 3600000) + (now.minute * 60000) + (now.second * 1000) + now.milliSecond;
end;
}
delete
{
delete() updating;

//V8 13.05.14 Provide SMTP authentication and TLS (Transport Layer Security)
//V6 25.06.04 Tidy up after keep Connection Open was set
//V5 07.08.02 Optionally delete state objects, providing that this is the last CnSmtpConnection, or subclass thereof. 
//V4 23.06.00 Support for embedded inline images; remove deletion of arrays (which are now exclusive collections).
//V3 29.04.99 Handle name + e-mail address.
//V2 26.04.99 Call 'deleteFileObjects' method to reduce code.

vars
	cc						:	CnCntrl;

	sd						: 	CnStackDump;
	
	attToDelete				:	CnAttachment;

	inlineToDelete			:	CnSmtpInline;	//V4
	
	objArray				:	ObjectArray;
begin
	executeWhen Cn_Debug_SMTP;
	if self.loggingRequired then
		cc := app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & "....", null);
		create sd transient;
		sd.dumpCallStack(true, true);
	endif;
	endExecuteWhen;

	if self.myMailState.isKindOf(CnSmtpStateTCPConnected) then	//V6
		self.cnClose(self);			// close the connection		//V6
		app.doWindowEvents(100);								//V6
	endif;														//V6

	// Delete file objects

	self.deleteFileObjects();

	// Delete attachments

	while not self.myAttachments.isEmpty() do
		attToDelete := self.myAttachments.first();
		delete attToDelete;
	endwhile;

	// Delete inlines

	while not self.allInlines.isEmpty() do				//V4
		inlineToDelete := self.allInlines.first();   	//V4
		delete inlineToDelete;                  		//V4
	endwhile;	                                		//V4

	// V5 ...
	if self.removeStatesOnDeletion = true then
		create objArray transient;
		CnSmtpConnection.allProcessTransientInstances(objArray, 0, true);
		if objArray.size = 1 then
			self.deleteStateObjects();
		endif;
		
		delete objArray;	 
	endif;
	// V5
	if self.sslContext <> null then											// V8
		beginTransientTransaction;											// V8
		delete self.sslContext;												// V8
		commitTransientTransaction;											// V8
	endif;																	// V8
epilog
	delete sd;
end;
}
deleteFileObjects
{
deleteFileObjects() updating;

//V29	12.10.07 Remove isValidObject and ref to CnCntrl
//V2 	23.06.00 Support for embedded inline objects
//V1 	26.04.99 New method to reduce duplicated code.

vars
	attachment	:	CnAttachment;
	inline		:	CnSmtpInline;
	badObject	:	Boolean;				// V29
begin
	// Delete file objects

	if messageFileObject <> null then																						// V29
		on SystemException do app.cnGenericExceptionHandler(exception, Cn_ObjectNotFound, messageFileObject, badObject);	// V29
		delete messageFileObject;		
	endif;

	foreach attachment in myAttachments do
		attachment.deleteFileObject;
	endforeach;

	foreach inline in allInlines where inline.fileObject <> null do		//V2
		inline.deleteFileObject;										//V2
	endforeach;															//V2

end;
}
deleteStateObjects
{
deleteStateObjects() protected;

// Delete all SMTP state objects.
// Normally, these objects remain alive from the instantiation of the first CnSmtpConnection object to the termination
// of the app, and serve every CnSmtpConnection that is created in that app.

// This method is called from the destructor method of CnSmtpConnection if the user sets
// CnSmtpConnection.removeStatesOnDeletion to true.
// New state objects will be created when the next CnSmtpConnection object is created.

vars

	coll	:	ObjectArray;
	obj		:	Object;

begin

	create coll transient;
	CnSmtpState.allProcessTransientInstances(coll, 0, true);
	foreach obj in coll do
		delete obj;
	endforeach;
	delete coll;

end;
}
findContentType
{
findContentType(pExtension:String):String;

// V2 Add bmp 21.06.00

/* This method takes a file extension as input, and returns the MIME content type that matches the extension.
	For example, an extension of 'gif' yields a content type of 'image/gif'.

	As several different extensions can map to the same content type, the constant MIMETable is arranged as follows:

	<extension1>$[<extension2>$ ...],<content type>; ...

	Each extension in the table is terminated by a dollar sign. The last extension for a particular content type
	is terminated by a dollar sign and a comma. The content type immediately follows the comma, and is terminated by a semi-colon.

	A null string is returned if the extension is not in the table.

*/

constants

	MIMETable = "txt$," & Text_Plain & ";" &
				"gif$," & Gif & ";" &
				"jpeg$jpe$jpg$," & Jpeg & ";" &
				"htm$html$," & Text_Html & ";" &
				"bmp$," & Bmp & ";" &
				"mpeg$mpg$mpe$," & Mpeg & ";" &
    			"wav$," & Wav & ";" &
    			"avi$," & Avi & ";" &
    			"zip$," & Zip & ";";

vars
	i			:	Integer;
	offset		:	Integer;
	semiColon	:	Integer;

begin

    //Point to start of table
    i		:=	1;

    //Look for the extension and $
    offset	:=	MIMETable.pos(pExtension & "$", i);
    if offset = null then
    	return null;		// Extension not in table
    endif;

    //Found the extension - now get the corresponding content type
    i			:=	offset;
    offset		:=	MIMETable.pos(",", i);
   	semiColon	:=	MIMETable.pos(";", i);
   	if offset = null or semiColon = null then
   		return null;		// Table format error - should never happen
	endif;

	return MIMETable[offset + 1: semiColon - offset - 1];
end;
}
genDate
{
genDate():String;

//Version 3 : 03 Jun 14 Avoid using date.format as this returns day name and month name according to locale language
//Version 2 : 16 Dec 99 Cater for Time differential from GMT (e.g. output "16 Dec 99 10:45:30 +1300")

vars
	date		: 	Date;
	
	bias		:	Integer;

	dayName,
	dayOfMonth,
	minutes,
	month,
	seconds,
	sign,
	year		: 	String;

	time		:	Time;
begin
	if process.isUsingThinClient then
		bias	:= app.currentUTCBias(PresentationClient);
	else
		bias	:= app.currentUTCBias(CurrentLocation);
	endif;
	
	if bias < 0 then				//Bias for places east of Greenwich (e.g. NZ) is negative: make it positive
		sign := "+";
		bias := 0 - bias;
		
	else
		sign := "-";				//Bias for places west of Greenwich (e.g. New York) is positive
	endif;

	minutes 	:= (bias div 60).String.padLeadingZeros(2);
	seconds 	:= (bias mod 60).String.padLeadingZeros(2);
	
	dayName 	:= date.dayName()[1:3];		// needs to be in English
	dayOfMonth	:= date.day().String;
	month		:= date.monthName[1:3];		// needs to be in English
	year		:= date.year().String;
	
	return dayName & CN_COMMA & CN_SPACE & dayOfMonth & CN_SPACE & month & CN_SPACE & year &	// format ddd, dd MMM ccyy
		   CN_SPACE & time.format("HH:mm:ss") & 
		   CN_SPACE & sign & minutes & seconds;

end;
}
genUniqueCID
{
genUniqueCID(pImageIndex	:	Integer)	:	String;

//V1 21.06.00

vars

	today	:	Date;
	time	:	Time;

begin

	return Image & pImageIndex.String & "-" & app.random(65536).String & today.format("dd-MM-yyyy") & time.String & sendFromAddress; 

end;
}
generateBoundary
{
generateBoundary() :String;

vars

	today	:	Date;
	time	:	Time;

begin

	//The boundary is a string that separates discrete message parts. 

	return "--" & "Next_Part_=_" & app.random(65536).String & today.format("dd-MM-yyyy") & time.String & app.random(65536).String;

end;
}
generateInlineBoundary
{
generateInlineBoundary()	:	String;

//V1 Added in version 13, 20.06.00

vars

	today	:	Date;
	time	:	Time;

begin

	//The boundary is a string that separates discrete inline message parts. 

	return "--" & "Next_Inline_Part_=_" & app.random(65536).String & today.format("dd-MM-yyyy") & time.String & app.random(65536).String;

end;
}
getAtLeastOneValidRecipient
{
getAtLeastOneValidRecipient():Boolean;

//23.06.00	Redundant

vars

begin

	return atLeastOneValidRecipient;

end;
}
getBoundary
{
getBoundary() :String;

//23.06.00	Redundant

vars

begin

	return  boundary ;

end;
}
getEditedMessage
{
getEditedMessage(): String;

//23.06.00	Redundant

vars

begin

	return editedMessage;

end;
}
getMessageFileName
{
getMessageFileName() : String;

//23.06.00	Redundant

vars

begin

	return messageFileName;

end;
}
getMessageFileObject
{
getMessageFileObject() :File;

//23.06.00	Redundant

vars

begin

	return messageFileObject;

end;
}
getMessageHeader
{
getMessageHeader() :String;

//23.06.00	Redundant

vars

begin

	return messageHeader;		

end;
}
getMyAttachments
{
getMyAttachments():CnAttachmentArray;

//23.06.00	Redundant

vars

begin

	return myAttachments;

end;
}
getRecipientArray
{
getRecipientArray() : HugeStringArray;

//23.06.00	Redundant

vars

begin

	return recipientArray;

end;
}
getRecipientArrayIndex
{
getRecipientArrayIndex():Integer;

//23.06.00	Redundant

vars

begin

	return recipientArrayIndex;

end;
}
getServerMessage
{
getServerMessage():String;

//23.06.00	Redundant

vars

begin

	return serverMessage;

end;
}
initializeMIMEEntity
{
initializeMIMEEntity(pMIMEEntity	:	CnMIME input) updating;

// V28 30.08.07 Allow entity filename to be suffixed with a period and avoid 4031 exception
// V4 05.09.03 Allow user to specify physical location of file (e.g. whether it's on presentation client or app server).
// V3 19.01.02 Allow user to specify shareMode property of CnMIME entity.
// V2 28.06.00 Search for extension from end of filename, not from beginning.
// V1 23.06.00

vars

	mimeEntityFile	:	File;
	className		:	String;
	extension		:	String;
	extensionPtr	:	Integer;	
	fileName		:	String;			//V28
	len				: 	Integer;		//V28
begin

	className := self.getName & "::" & method.name;
	fileName					:= pMIMEEntity.fileName;
	create mimeEntityFile;
   	mimeEntityFile.kind			:=	File.Kind_Binary;
   	mimeEntityFile.mode			:=	File.Mode_Input;
   	
   	//V4...
   	if pMIMEEntity.physicalFileLocation =		pMIMEEntity.File_Is_In_Default_Location then
   		mimeEntityFile.usePresentationFileSystem	:=	process.isUsingThinClient;
		
   	elseif pMIMEEntity.physicalFileLocation =	pMIMEEntity.File_Is_On_Presentation_Client then
   		mimeEntityFile.usePresentationFileSystem	:=	true;
		
   	elseif pMIMEEntity.physicalFileLocation =	pMIMEEntity.File_Is_On_App_Server then
   		mimeEntityFile.usePresentationFileSystem	:=	false;
		
   	else
   		// User specified an invalid physical file location integer
   		raiseValidationException(Err_Invalid_Phys_File_Location, className & " Invalid physicalFileLocation property in a subclass of CnMIME");	
   	endif;
   	//...V4			
   	
   	if pMIMEEntity.shareMode.bitAnd(self.MIMEShareModeFlag) <> null then	//V3
   		mimeEntityFile.shareMode:=	pMIMEEntity.shareMode.bitAnd(3);		//V3
		
   	else	 																//V3
   		mimeEntityFile.shareMode:=	File.Share_Read;						//V3
   	endif;																	//V3

   	if isRelative(pMIMEEntity.fileName) then
   		mimeEntityFile.fileName	:=	adjustFileLocationBase(fileBase) & fileName;
		
   	else	
   		mimeEntityFile.fileName	:=	fileName;
   	endif;	

   	if not mimeEntityFile.isAvailable then
   		delete mimeEntityFile;
   		raiseValidationException(Err_Cant_Find_Attachment, className & " Can't find the attachment or inline file");
   	endif;

   	mimeEntityFile.openInput(mimeEntityFile.fileName);
    pMIMEEntity.setFileObject(mimeEntityFile);

    //Work out which encoding type and content type is appropriate for this kind of file

    //The user can specify both the content type and the encoding type. The encoding type is checked for validity. The content type is not checked,
    //as the number of content types in MIME encoding is increasing all the time, and we're unlikely to be able to keep track of them.

    //If contentType is left blank, then work out the MIME content type from the file extension
    if pMIMEEntity.contentType = null then
		len := fileName.length();						// V28
		while fileName[len] = "." do					// V28
			fileName := fileName[1:len-1];				// V28
			len := len - 1;								// V28
		endwhile;										// V28
		
    	extensionPtr	:=	fileName.reversePos(".");	//V2
    	if extensionPtr <> null then
    		extension	:=	fileName[extensionPtr + 1: end];
    		pMIMEEntity.contentType	:=	findContentType(extension);
    	endif;

    	//If the content type is still unknown, default it to application/octet-stream
    	if pMIMEEntity.contentType = null then
    		pMIMEEntity.contentType := OctetStream;
    	endif;		
    endif;

    //If encodingType is left blank, then make it 'none', if the first part of the content type is 'text', or 'base64' otherwise
    if pMIMEEntity.encodingType = null then
    	if pMIMEEntity.contentType[1: (pMIMEEntity.contentType.pos("/", 1) - 1)] = Text then
    		pMIMEEntity.encodingType	:=	None;
    	else
    		pMIMEEntity.encodingType	:=	Base64;
    	endif;
    endif;

	//V2 Removed check that encodingType is None or Base64 

	if pMIMEEntity.contentLocation = null then
		pMIMEEntity.contentLocation		:=	pMIMEEntity.fileName;
	endif;

end;
}
isRelative
{
isRelative(pFileName	:	String)	:	Boolean;

// V1 21.06.00

// RFC 1630 says "A partial form can be distinguished from an absolute form in that the latter must have a colon
// and that colon must occur before any slash characters." 

constants

	Colon		= ":";
	Slash		= "/";
	BackSlash	= "\";

vars

	index			:	Integer;
	slashIndex		:	Integer;
	backSlashIndex	:	Integer;

begin

	index			:=	pFileName.pos(Colon, 1);
	slashIndex		:=	pFileName.pos(Slash, 1);
	backSlashIndex	:=	pFileName.pos(BackSlash, 1);

	if index = 0 then
		return true;		//No colon

	else
		if slashIndex <> 0 and slashIndex < index then
			return true;
		elseif backSlashIndex <> 0 and backSlashIndex < index then	
			return true;
		else
			return false;
		endif;			
	endif;	

end;
}
openMessageFile
{
openMessageFile(pMessageFileName	:	String) updating;

//V1	27.06.00

vars

	file		:	File;
	className	:	String;

begin

	className		:=	self.getName & "::" & method.name;

	create file;
   	file.kind		:=	File.Kind_Binary;
   	file.mode		:=	File.Mode_Input;
   	file.shareMode	:=	File.Share_Read;
   	file.fileName	:=	pMessageFileName;

   	if not file.isAvailable then
   		delete file;
   		raiseValidationException(Err_Cant_Find_Message_File, className & " Can't find the message file");
   	endif;

   	file.openInput(pMessageFileName);
    messageFileObject := file;

end;
}
parseRecipients
{
parseRecipients(pRecipientList	:	String;
				pNames			:	CnStringArray input;
				pAddresses		:	HugeStringArray input
				) updating;

//V4 06.01.09 Ignore tokens that are blank
//V3 07.08.02 Move array clear code to start of method. If pRecipientList is null, arrays will then be null.
//V2 14.01.02 Cater for case where pRecipientList ends with semicolon (actually invalid, as it implies that there is
//			  another address to follow); this was causing an index error.	
//V1 02.07.00

constants

	SemiColon = ";";

vars

	pos			:	Integer;
	start		:	Integer;
	index		:	Integer;
	token		:	String;
	eName		:	String;
	eAddress	:	String;

begin

	pNames.clear;
	pAddresses.clear;
	
	if pRecipientList = null then
		return;
	endif;	

	start		:=	1;
	index		:=	1;
	while pos <= pRecipientList.length do
		pos	:=	pRecipientList.pos(SemiColon, start);
		if pos <> null then
			token	:=	pRecipientList[start: pos - start];
			start	:=	pos + 1;
			if start > pRecipientList.length then	//V2	Ensure that parse won't continue if semicolon found at end of string
		 		pos	:=	null;						//V2	
		 	endif;									//V2
		else
		 	token	:=	pRecipientList[start: end];
		endif;
		 
		token := token.trimBlanks();				// V4
		if token <> null then						// V4
			separateNameAndAddress(token.trimBlanks, eName, eAddress);
			pAddresses.atPut(index, eAddress);
			pNames.atPut(index, eName);
		endif;										// V4
		
		if pos = null then
		 	break;									//		End of parse
		endif;

		index	:=	index	+ 1;
	endwhile;		 			
end;
}
raiseValidationException
{
raiseValidationException(pErrorCode:Integer; pErrorText:String) updating;

//V2 11.5.99 Set mySmtpConnection in exception object

vars
 	exObj	:	CnSmtpConnectionException;
begin

	//Raise an exception if an error occurred during the validation phase

	create exObj;
	exObj.setMySmtpConnection(self);
	exObj.errorCode			:= pErrorCode;
	exObj.extendedErrorText := pErrorText;
	exObj.errorItem			:= "Validation Error";
	raise exObj;	

end;
}
reset
{
reset() updating;

vars

begin

	self.myMailState.sendRSET(self);

end;
}
resetConnectionObject
{
resetConnectionObject() updating;

//	WARNING : If the connection is to be kept open then this method needs to be called (explicitly) when the completion notification is actioned

//V5 25.06.04	Keep connection open
//V4 12.09.03	Support for new attributes
//V3 07.08.02	Reset various properties
//V2 21.06.01	Set completed to false
//V1 27.06.00	Clear all properties

vars

begin
	if not self.keepConnectionOpen then				// V5
		clientName					:=	null;
		connectionIsOpen			:=	false;		// V3
		mailServer					:=	null;
		myMailState					:=	CnSmtpStateTCPDisconnected.firstProcessTransientInstance;	//Start off in CnSmtpTCPDisconnected state
	endif;											// V5

	self.keepConnectionOpen		:= false;			// V5
	self.authenticate			:= false;			// V8
	self.username				:= null;			// V8
	self.password				:= null;			// V8
	allInlines.clear;
	allowUnqualifiedNames		:=	false;			//V3
	atLeastOneValidRecipient	:=	false;
	bcc							:=	null;
	bccAddresses.clear;
	bccNames.clear;
	blockSize					:=	1512;		//Default
	boundary					:=	null;
	cc							:=	null;
	ccAddresses.clear;
	ccNames.clear;
	comments					:=	null;
	completed					:=	false;		//V2
	contentLocationBase			:=	null;
	contentType					:=	Plain;
	disconnectOnValidationError	:=	false;		//V4
	editedMessage				:=	null;
	encodingType				:=	None;
	errorCode					:=	0;
	errorItem					:=	null;
	extendedErrorText			:=	null;
	fileBase					:=	null;
	inlineBoundary				:=	null;
	isUserEncoded				:=	false;

	executeWhen not Cn_Debug_SMTP;
	self.setLoggingRequired(self.loggingIniDefault);
	self.setLoggingReponse(true);																								// PAR 1044
	endExecuteWhen;
	
	executeWhen Cn_Debug_SMTP;
	self.setLoggingReponse(true);																								// PAR 1044
	endExecuteWhen;

	message						:=	null;
	messageFileName				:=	null;
	messageFileObject			:=	null;
	messageHeader				:=	null;
	myAttachments.clear;
	recipientArray.clear;
	recipientArrayIndex			:=	null;
	removeStatesOnDeletion		:=	false;	//V3
	replyTo						:=	null;
	replyToAddress				:=	null;
	replyToName					:=	null;
	result						:=	0;
	sendFrom					:=	null;
	sendFromAddress				:=	null;
	sendFromName				:=	null;
	sendTo						:=	null;
	sendToAddresses.clear;
	sendToNames.clear;
	sender						:=	null;
	senderAddress				:=	null;
	senderName					:=	null;
	serverMessage				:=	null;
	subject						:=	null;
	undelivered.clear;

end;
}
send
{
send() updating;

//V4 25.06.04	Keep connection open, add timings to diagnostics (open and message)
//V3 21.09.2000 Changes for UNICODE
//V2 Changes for lines that straddle blocks

vars
	cnCntrl				: CnCntrl;
	
	isTruncated			:	Boolean;	//V2

begin
	self.d1Message := app.relativeMachineTime();	// V4
    //Basic parameter validation. The name of the mail server is inserted in the 'mailServer' property during the validation.
    self.validate();		

	if self.messageFileName = "" then

		//The message to be sent is just a string in 'message': it is not contained in a file.
		//Now validate message contents, and add periods to start of lines if necessary.
		//The original input message is untouched: the adjusted output message is in editedMessage.
		//Messages contained in files are not validated here, but as each block is sent.

		//If Base64 encoding has been specified, the message is returned in encoded form in editedMessage.
		if self.loggingRequired then
			cnCntrl := app.myCnCntrl;
			cnCntrl.cnWriteLog(cnCntrl.CnLogDiag, "user message : '" & self.message & "'", null);
		endif;
		
		if self.charset = self.Charset_ISO_8859_1 or																			// NFS 932
		   self.charset = self.Charset_UTF_8 then																				// NFS 932
			self.validateMessage(message.Binary, editedMessage, encodingType, isTruncated, isUserEncoded);//V3 V2				// NFS 932
		
		else																													// NFS 932
			validateMessage(cnAnsiBinary(message), editedMessage, encodingType, isTruncated, isUserEncoded);//V3 V2
		endif;																													// NFS 932

		if self.loggingRequired then
			cnCntrl := app.myCnCntrl;
			cnCntrl.cnWriteLog(cnCntrl.CnLogDiag, "editted message : '" & self.editedMessage & "'", null);
		endif;
	endif;	

	//At this point we've verified that our parameters and data are correct. Now we can send the mail.
	//We start off in myMailState of CnSmtpStateTCPDisconnected. 'myMailState' controls the SMTP state, not the TCP connection.

	if self.connectionIsOpen and self.myMailState.isKindOf(CnSmtpStateTCPConnected) then	// V4
		self.myMailState.do220(self);  // send HELO											// V4
	//The state machine takes over from now on. The CnSmtpStateTCPConnected::do220 method will issue a HELO and change state to cnSmtpStateHELO,
	//wait on a read. The server message that is received by that read will be processed by the appropriate routine in the cnSmtpStateHELO state.
		return;																				// V4
	endif;																					// V4

    //Open the TCP connection
    self.d1Open := app.relativeMachineTime();												// V4
	self.cnOpen(self.mailServer, self.port, self);

	//The state machine takes over from now on. The cnOpenNotify method will change state to cnSmtpStateTCPConnected, and issue a read.
	//The server message that is received by that read will be processed by the appropriate routine in the cnSmtpStateTCPConnected state.

end;
}
separateNameAndAddress
{
separateNameAndAddress(	pNameAndAddress	:	String;
						pName			:	String output;
						pAddress		:	String output) updating;

//V1 26.06.00

constants

	DoubleQuote = '"';
	SingleQuote = "'";

vars

	i				:	Integer;
	quotePosition	:	Integer;
	quoteChar		:	Character;
	className		:	String;

begin

	//Format for name + e-mail address is "Name" person@domain

	className				:=	self.getName & "::" & method.name;	

	//If first character not quote, then put whole string into pAddress
	if pNameAndAddress[1] <> DoubleQuote then
		pAddress	 		:=	pNameAndAddress;
		return;

	else

		quoteChar			:=	pNameAndAddress[1];

		//Look for closing quote
		i 					:=	2;
		quotePosition		:=	pNameAndAddress.pos(quoteChar, i);
		if quotePosition = null then
			raiseValidationException(Err_Invalid_Address_Format, className & " Invalid format in address field. Quote missing?");	//Error - no closing quote
		else

			//Separate string into name and e-mail address
			pName		:=	pNameAndAddress[1:quotePosition];
			pAddress	:=	pNameAndAddress[quotePosition + 1:end];
			pAddress	:=	stripBlanks(pAddress);						//Remove any white space from e-mail address
			return;
		endif;
	endif;				

end;
}
separateNameAndEmail
{
separateNameAndEmail(pString:String; pNameArray:CnStringArray input) updating;

//V2 26.06.00	Redundant
//V1 29.04.99

constants

	Quote = '"';
vars

	i, quotePosition:Integer;

begin

	//Format for name + e-mail address is "Name" person@domain

	//If first character not quote, then put whole string into e-mail address element of array
	if pString[1] <> Quote then
		pNameArray[1] := "";
		pNameArray[2] := pString;
		return;
	else

		//Look for closing quote
		i := 2;
		quotePosition := pString.pos(Quote, i);
		if quotePosition = null then
			pNameArray.clear;    		//No closing quote - error
			return;
		else

			//Separate string into name (first element of array) and e-mail address (second element)
			pNameArray[1] := pString[1:quotePosition];
			pNameArray[2] := pString[quotePosition + 1:end];
			return;
		endif;
	endif;				

end;
}
setAtLeastOneValidRecipient
{
setAtLeastOneValidRecipient(pValue:Boolean) updating;

vars

begin

	atLeastOneValidRecipient := pValue;

end;
}
setCompleted
{
setCompleted(pCompleted	:	Boolean) updating;

//V2 25.06.04	Add length and elapsed time to diagnostics
//V1 02.07.00
vars
	cc	: CnCntrl;
begin
	if  self.loggingRequired and not self.completed then	// V2
		self.d2Message := app.relativeMachineTime();		// V2
		cc := app.myCnCntrl;								// V2
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " message size " & self.message.length().String & ", elapsed time = " & (self.d2Message - self.d1Message).String & "ms", null); // V2
	endif;													// V2

	completed	:=	pCompleted;
end;
}
setEditedMessage
{
setEditedMessage(pMessage:String) updating;

vars

begin

	editedMessage := pMessage;

end;
}
setLoggingIniDefault
{
setLoggingIniDefault(pValue : Boolean) updating;

vars

begin
	self.loggingIniDefault := pValue;
end;
}
setLoggingReponse
{
setLoggingReponse(pValue : Boolean) updating;

vars

begin
	self.loggingResponse := pValue;
end;
}
setLoggingRequired
{
setLoggingRequired(pFlag:Boolean) updating;

vars

begin

	loggingRequired := pFlag;

end;
}
setMessageFileObject
{
setMessageFileObject(pFile:File) updating;

vars

begin

	messageFileObject := pFile;

end;
}
setRecipientArrayIndex
{
setRecipientArrayIndex(pIndex:Integer) updating;

vars

begin

	recipientArrayIndex := pIndex;

end;
}
setServerMessage
{
setServerMessage(pMessage:String) updating;

vars

begin

	serverMessage := pMessage;

end;
}
stripBlanks
{
stripBlanks(pString:String input):String  updating;

//V2	27.06.00	Update to remove all white space froma string (including horizontal tabs)

vars
     i, j		:	Integer;
     outString	:	String;
begin

	//Remove all blanks from a string

	i := 1;  j := 1;

	while i <= pString.length do
		if pString[i] <> " " and pString[i] <> Tab then			//V2
			outString[j] := pString[i];
			j := j + 1;
		endif;
		i := i + 1;
	endwhile;

	return outString;			
end;
}
userNotification
{
userNotification(eventType : Integer; theObject : Object; eventTag : Integer; userInfo : Any) updating;

vars
      /*f:Form;
      l:Letter;
      smtp:CnSmtpConnection;*/
begin

	/* The user should reimplement this method in a subclass of CnSmtpConnection to trap the notification that occurs when a message has been sent.

       The arrival of the notification will only activate this method if the user specified the subclassed CnSmtpConnection object as the receiver
       when subscribing to the notification.

       If the user specified a form as the receiver, then the notification will activate the userNotify event of that form.

	   The code below is specific to the CnSmtpConnection class demo program, and is not part of the standard CnSmtpConnection class; 
	   however, it can be used as an example of how to trap a completion notification, and update the status line on a form accordingly.*/ 
    /*
	smtp := theObject.CnSmtpConnection;

	f := app.getForm("Letter");

	if f <> null then		// If using a form ...
 		l := f.Letter;

	 	// The message was sent (and/or an error occurred)
      	l.staLine.caption := "Message Sent (Trapped in Object)";				

    	// Show a message box if an error occurred
    	if smtp.result <> null then                                       
    		l.staLine.caption := l.staLine.caption & ": Error - " & smtp.result;
    		app.msgBox(smtp.extendedErrorText, "Error", MsgBox_OK_Only);
    	endif;
    else
       	// Running from a JADE script
    		app.msgBox("The error code (if any) is " & smtp.errorCode & ".", "Message Sent", MsgBox_OK_Only);
   	endif;		

    delete self; */

end;
}
user_cnBuildHeader
{
user_cnBuildHeader(body : Binary) : Binary updating;

vars

begin
	return null;
end;
}
user_cnGetPreambleDefinition
{
user_cnGetPreambleDefinition() : Binary;

vars

begin
	return null;
end;
}
user_cnTcpExceptionHandler
{
user_cnTcpExceptionHandler(exObj : Exception) : Integer updating;

// V2 26.06.2002	Ensure extended error text contains full text from exception
vars

begin

    /* This is the default code for handling TCP exceptions within the CnSmtpConnection object.
       You can replace this code with your own TCP exception handling if you prefer.*/

	self.result				:=	self.result.bitOr(CnSmtpConnection.Error_Occurred);
 	self.extendedErrorText	:=	exObj.text & " " & exObj.extendedErrorText;			// V2

 	self.errorCode			:=	exObj.errorCode;
 	self.errorItem			:=	exObj.errorItem;

	// Cause a completion event so the user can see that an exception occurred

	self.causeEvent(CnSmtpConnection.Completion_Event_Type, true, null);	
    return Ex_Abort_Action;
end;
}
validate
{
validate() updating;

//V6 allow send of attachments to be synchronous rather than async (refer PAR #760)
//V5 Allow number of recipients to be specified as ini file setting so max can be set by 
//	 SMTP server (RFC 2821) (NFS 763).
//V4 Only issue error Err_No_SendTo when sendTo, cc and bcc attributes are all null
//V3 Support for embedded (inline) images; remove unnecessary 'get' method calls; replace literals by constants;
//	 remove checks that mail contains a message and a subject; allow name to be associated with recipient, sender and replyTo.
//V2 Handle name + e-mail address in sendFrom

vars
    attachment			: CnAttachment;

    inline				: CnSmtpInline;	//V3
    
	tooLong				: Boolean;
	
	maxRecipients		: Integer;		// V5

    characterSet,
	className,
	iniFile,
	str					: String;
begin

	//Validate the message parameters (but not the content of the message: that's done by validateMessage).

	on CnSmtpConnectionException do validationExceptionHandler(exception);

	className := self.getName & "::" & method.name;			//V3

	//CnCntrl object must exist
	if app.myCnCntrl = null then
    	raiseValidationException(Err_No_Control_Object, className & " The CnCntrl object has not been created");//V3
    endif;

	iniFile := app.getIniFileName;

	//Set up mail server parameter
	self.mailServer := app.getProfileString(iniFile, "SMTPServer", "MailServer", self.name);  //'name' is defined in the Connection class

    if self.mailServer = null then
    	raiseValidationException(Err_No_Mail_Server, className & " You must specify a mail server in the 'name' property or the .ini file");//V3
	endif;

	//Set up client node parameters
	self.clientName := app.getProfileString(iniFile, "SMTPClient", "ClientName", self.clientName); 

	/* If the client name is still null at this point, it is defaulted to [<IP address>] after the TCP connection is made. See the
	   openNotify method */

	//blockSize tells us how much to write in one cnWrite command. It controls (a) messages that have to be buffered on output, and (b) file attachments. 
	self.blockSize := app.getProfileString(iniFile, "SMTPClient", "BlockSize", "0").Integer;
	if self.blockSize = null then
		self.blockSize := 1512;
		app.setProfileString(iniFile, "SMTPServer", "BlockSize", self.blockSize.String);
	endif;

	//max recipients tells us how many recipients to allow. This was changed in RFC 2821 from orginal limit in RFC 821.			// V5
	maxRecipients := app.getProfileString(iniFile, "SMTPServer", "MaxRecipients", "0").Integer;									// V5
	if maxRecipients = null then																								// V5
		maxRecipients := 100;			// default to RFC 821 100 max															// V5
		app.setProfileString(iniFile, "SMTPServer", "MaxRecipients", maxRecipients.String);										// V5
	endif;																														// V5
	
	//send attachments synchronously or ansynchronously, default is asynchronously												// V6
	str := app.getProfileString(iniFile, "SMTPServer", "SendAttachmentsSync", null);											// V6
	if str = null then																											// V6
		str := false.String;																									// V6												
		app.setProfileString(iniFile, "SMTPServer", "SendAttachmentsSync", str);												// V6
	endif;																														// V6
	
	self.sendAttachmentsSync := str.Boolean;																					// V6

	//Can either send a message OR a file
	if message <> "" and messageFileName <> null then
		raiseValidationException(Err_Double_Message_Definition, className & " Specify a message OR a message file: not both");//V3
	endif;
    
    // If message file specified, check that it exists. Open the file.
    if messageFileName <> null then
    	openMessageFile(messageFileName);				//V3
    endif;

     // If attachments specified, check that they exist. Open the files.

	if not myAttachments.isEmpty() then		
		foreach attachment in myAttachments do			//V3
			initializeMIMEEntity(attachment);			//V3
		endforeach;	
    endif;

	// If embedded inline objects specified, initialize them.

	if not allInlines.isEmpty() then		
		foreach inline in allInlines do					//V3
			if inline.sourceIsFile then					//V3
				initializeMIMEEntity(inline);			//V3
			else										//V3
				validateInlineContentType(inline);		//V3	
			endif;										//V3
		endforeach;										//V3
    endif;												//V3

    if sendFrom = null then
		raiseValidationException(Err_No_SendFrom, className & " You have not provided a 'sendFrom' property");//V3
    endif;

    separateNameAndAddress(sendFrom, sendFromName, sendFromAddress);								//V3

    //User name or domain name in FROM field must not be more than 64 characters long (RFC 821) 

    tooLong := checkNameLength(sendFromAddress);		//V3
    if tooLong then
   		raiseValidationException(Err_Invalid_SendFrom, className & " Invalid e-mail address format in the 'sendFrom' field (" & sendFrom & ")");//V3
    endif; 

   //Sender may be specified (this is the person who actually sent the mail, not necessarily the one who wrote it)
    if sender <> "" then
   		separateNameAndAddress(sender, senderName, senderAddress);								//V3
   		tooLong := checkNameLength(senderAddress);
   		if tooLong then
   	      	raiseValidationException(Err_Invalid_Sender, className & " Invalid e-mail address format in the 'sender' field (" & sender & ")");//V3
		endif;
	endif;		 	 

    if self.sendTo = null 	and									//V4
	   self.cc = null 		and									//V4
	   self.bcc = null		then								//V4
		raiseValidationException(Err_No_SendTo, className & " You have not provided a 'sendTo', 'cc' or 'bcc' property");	//V4
    endif;

    //Handle (potentially) multiple recipients

    recipientArray.clear;										//V3
    parseRecipients(sendTo, sendToNames, sendToAddresses);		//V3
    sendToAddresses.copy(recipientArray);                       //V3

    parseRecipients(cc, ccNames, ccAddresses);					//V3
    ccAddresses.copy(recipientArray);                  			//V3

	parseRecipients(bcc, bccNames, bccAddresses);				//V3
    bccAddresses.copy(recipientArray);							//V3

   	//Check all recipients: max was 100 recipients as at RFC 821, changed by RFC 2821, 
	//and max 64 characters each for user name and domain (RFC 821)
   	if recipientArray.size64() > maxRecipients then				// V5
     	raiseValidationException(Err_Too_Many_Recipients, className & " You can't specify more than " & maxRecipients.String & " recipients");	//V5
   	endif;	

	foreach str in recipientArray do
   		tooLong := checkNameLength(str);
   		if tooLong then
      		raiseValidationException(Err_Invalid_Recipient, className & " Invalid e-mail address format in the 'sendTo', 'cc' or 'bcc' fields (" & str & ")");//V3
		endif;
	endforeach;
	
    //User name or domain name in REPLY-TO field (if any) must not be more than 64 characters long (RFC 821) 

    if replyTo <> "" then
   		separateNameAndAddress(replyTo, replyToName, replyToAddress);								//V3
   		tooLong := checkNameLength(replyToAddress);
   		if tooLong then
   	      	raiseValidationException(Err_Invalid_ReplyTo, className & " Invalid e-mail address format in the 'replyTo' field (" & replyTo & ")");//V3
		endif;
	endif;	

    //Check for content type
    contentType := contentType.toLower;
    if contentType <> Html and contentType <> Plain then			//V3
     	raiseValidationException(Err_Invalid_Content_Type, className & " You have not provided a valid content type");//V3
    endif;

    // Check for valid charset
	characterSet := self.charset;
    if characterSet <> self.Charset_US_ASCII 	and 																			// NFS 932
	   characterSet <> self.Charset_UTF_8 		and 																			// NFS 932
	   characterSet <> self.Charset_ISO_8859_1 	then																			// NFS 932
     	self.raiseValidationException(self.Err_Invalid_CharacterSet, className & " You have not provided a valid character set");		// NFS 932
    endif;																														// NFS 932
end;
}
validateASCIIMessage
{
validateASCIIMessage(pInMessage:String; pOutMessage:String output; pWasPreviousLineTruncated:Boolean io) updating;//V2

//V4 28.06.00 Replace literals by constants
//V3 19.06.00 Cater for truncated line followed by a line containing only LF
//V2 29.03.00 Cater for lines that flow across block boundaries

vars

	isCurrentLineTruncated	:	Boolean;	//V2
	startPtr				:	Integer;
	endPtr					:	Integer;
	msgLength				:	Integer;
	linePtr					:	Integer;
	tmpMessage				:	String;
	className				:	String;
	line					:	String;

begin

    //Validate the contents of the message (e.g. all characters must be within the ASCII set)

    on CnSmtpConnectionException do validationExceptionHandler(exception);

    tmpMessage	:=	pInMessage;
    
    // pOutMessage is the string that we're going to build
    pOutMessage	:=	null;
    className	:=	self.getName & "::" & method.name;	//V5

    startPtr	:=	1;
	msgLength	:=	tmpMessage.length;

    //Iterate through whole message doing various checks
    while startPtr <= msgLength do

    	// Look for CrLf so we can isolate the next line
    	endPtr	:=	tmpMessage.pos(CrLf, startPtr);

    	//If CrLf not found, this partial line is at the end of a block
    	if endPtr = null then
    		line					:=	tmpMessage[startPtr : end];
    		isCurrentLineTruncated	:=	true;	//V2
    	else

    		// We found CrLf.

    		//Cater for case where the line consists only of CrLf. The CrLf will be appended to pOutMessage further down.
    		if endPtr = startPtr then
    			line	:=	"";						//V2
    		else	

    			// Line contains at least one character followed by CrLf
    			line	:=	tmpMessage[startPtr : endPtr - startPtr];

            endif;

    		//Cater for case where CrLf are the last characters of the block
    		if endPtr = tmpMessage.length -1 and tmpMessage[endPtr:2] = CrLf then
    			line	:=	line & CrLf;	//Append the CrLf now	//V2
    			endPtr	:=	null;		//Indicates end of block reached
    		endif;
    	endif;

     	// We now have a line. This is either a line terminated by CrLf, a line that ends with Cr (which we regard as a
     	// truncated line) or a line that does not contain CrLf at all (also a truncated line).

    	//Check that the line is not greater than 1000 characters (RFC 821 limit)
    	if line.length > 1000 then
    		raiseValidationException(Err_Line_Exceeds_1000, className & " One of the message lines exceeds 1000 characters");//V4
    	endif;

        //Check that no character is outside the ASCII range (RFC 821 rule)
        linePtr			:=	1;

        while linePtr <= line.length do
        	if line[linePtr].Character.Integer > 127 or line[linePtr].Character.Integer = null then
	    		raiseValidationException(Err_Non_ASCII_Character, className & " The message contains a non-ASCII character in the following line (" & line & ")");//V4
        	endif;
        	linePtr		:=	linePtr + 1;
        endwhile;

        //If this line starts with a period, then 'stuff' another period into the beginning of the line. Allows for data transparency (See RFC 821 section 4.5.2).
        //If the previous line was truncated, because it straddled two blocks, we don't treat the current line as a new line, but as part
        //of the previous one. 
        if pWasPreviousLineTruncated = false then	//V2
         	if	line[1] = "." then					//V2
        	 	line	:=	"." & line;
        	endif;
        else

        	//If the previous line was truncated, the last character of the previous line could have been Cr.
			//Therefore when handling truncated lines, we look for a Lf as the first character of the current line, and if it exists, we
			//look at the SECOND character to see if it's a period.

        	if line.length > 1 and line[1] = Lf and line[2] = "." then	//V3
        		line	:=	Lf & "." & line[2:end];     //V2
        	endif;				                    //V2
        endif;                                      //V2
        pWasPreviousLineTruncated	:=	false;		//V2 We've now dealt with that line, so set the flag false

        //If this is the last (or only) line in the block, or a part-line that occurs on the block boundary, don't add a CrLf
        if endPtr = null then
        	pOutMessage := pOutMessage & line;
           break;	//Exit from the method
        else
       		pOutMessage := pOutMessage & line & CrLf;
        endif;		

    	startPtr := endPtr + 2;
    endwhile;

	// Indicate whether the last line of the block was truncated. This parameter is passed back to us next time we enter the method.
	pWasPreviousLineTruncated	:=	isCurrentLineTruncated;	//V2			

end;
}
validateInlineContentType
{
validateInlineContentType(pInline	:	CnSmtpInline input) updating;

// V1 20.06.00

vars

	className	:	String;
	extensionPtr:	Integer;
	extension	:	String;

begin

	className := self.getName & "::" & method.name;

	//If contentType is left blank, and a fileName has been specified, work out the content type from the file extension
    if pInline.contentType = "" then
    	extensionPtr	:=	pInline.fileName.reversePos(".");
    	if extensionPtr <> null then
    		extension	:=	pInline.fileName[extensionPtr + 1: end];
    		pInline.contentType	:=	findContentType(extension);
    	endif;

    	//If the content type is still unknown, default it to octetstream
    	if pInline.contentType = "" then
    		pInline.contentType := OctetStream;
    	endif;	
    endif;

    //If encodingType is left blank, then make it 'none' if the first part of the content type is 'text', or 'base64' otherwise
    if pInline.encodingType = "" then
    	if pInline.contentType[1: (pInline.contentType.pos("/", 1) - 1)] = Text then
    		pInline.encodingType	:=	None;
    	else
    		pInline.encodingType	:=	Base64;
    	endif;
    endif;

	if pInline.contentLocation = null then
		pInline.contentLocation		:=	pInline.fileName;
	endif;	

end;
}
validateMessage
{
validateMessage(	pInMessage		:	Binary input;
				 	pOutMessage		:	String output;
					pEncodingType	:	String ;
					pIsTruncatedLine:	Boolean io;
					pIsUserEncoded	:	Boolean) updating;//V2

//V4 21.09.2000	Changes for UNICODE
//V3 23.06.2000	Call base64 encoder in dll, instead ofthe JADE encoder; don't encode if isUserEncoded is true	
//V2 29.03.2000 Cater for lines that flow across block boundaries

vars
	cnCntrl					: CnCntrl;
	
	cem						: CnExternalMethods;
	
	asciiMessage,
	lEncodingType,
	result					:	String;	//V4
begin
	cnCntrl					:= app.myCnCntrl;
 	on CnSmtpConnectionException do validationExceptionHandler(exception);

    lEncodingType	:=	pEncodingType.toLower;	//V4
    pOutMessage 	:=	null;

    //Do Base64 encode, if required
    if lEncodingType = self.Base64 and pIsUserEncoded = false then	//V4 V3
   		
		if self.loggingRequired then
			cnCntrl.cnWriteLog(cnCntrl.CnLogDiag, "Base64 encoding : input message '" & pInMessage.String & "'", null);
		endif;
		
   		pOutMessage	:=	self.emBase64Encode(pInMessage);		//V3
		if self.loggingRequired then
			cnCntrl.cnWriteLog(cnCntrl.CnLogDiag, "Base64 encoding : output message '" & pOutMessage & "'", null);
		endif;
   		// Base64-encoded messages don't need to be validated, because:
   		// - they will never contain lines of more than 76 characters, so can't exceed RFC 821 limit (1000 chars)
   		// - they are guaranteed to contain only ASCII characters
   		// - they will never contain a period (.), so 'period-stuffing' at the start of a line is never needed

    //Do Quoted-Printable encode, if required
    elseif lEncodingType = self.Quoted_Printable and 
		   pIsUserEncoded = false 				 then 
		if app.isUnicode()					then
			if self.loggingRequired then
				cnCntrl.cnWriteLog(cnCntrl.CnLogDiag, "Quoted-Printable encoding : input message '" & pInMessage.String & "'", null);
			endif;

			create cem transient;
			result		:=	cem.emQPEncode(pInMessage, pOutMessage);
			if result <> CN_OK then
				self.raiseValidationException(self.Err_Encoding_Error, method.cnGetMethodName & " '" & self.Quoted_Printable & "' encoding error : " & result);
			endif;
		
			if self.loggingRequired then
				cnCntrl.cnWriteLog(cnCntrl.CnLogDiag, "Quoted-Printable encoding : output message '" & pOutMessage & "'", null);
			endif;
			
		else
			self.raiseValidationException(self.Err_Invalid_Encoding_For_ANSI, method.cnGetMethodName & " '" & self.Quoted_Printable & "' is invalid for ANSI system");
		endif;
		
   	elseif app.isUnicode then																//V4
		self.validateASCIIMessage(pInMessage.ansiToString(), pOutMessage, pIsTruncatedLine);	//V4

	else
		self.validateASCIIMessage(pInMessage.String, pOutMessage, pIsTruncatedLine);		//V2//V4
	endif;	
end;
}
validationExceptionHandler
{
validationExceptionHandler(exObj:Exception):Integer updating;

//V6	10.09.03	Disconnect TCP/IP on validation error, if user requested it. This ensures that the whole message gets aborted.
//V5	10.09.03	Send RSET after getting validation error in DATA state
//V4	04.09.03	Close file object (if any) containing message 
//V3	20.06.01	Clear serverMessage before reading
//V2	21.09.2000  Changes for UNICODE
vars

begin

	self.result				:=	self.result.bitOr(Error_Occurred);	//Show that an error occurred
	self.extendedErrorText	:=	exObj.extendedErrorText;			//Tell user what the error was
	self.errorCode			:=	exObj.errorCode;
	self.errorItem			:=	exObj.errorItem;
	
	if self.messageFileObject <> null and self.messageFileObject.isOpen then	//V4
		self.messageFileObject.close;								//V4
	endif;															//V4

    if myMailState.isKindOf(CnSmtpStateTCPDisconnected) then		//Found an error while editing a non-file message (TCP connection not yet open)
 		return Ex_Pass_Back;										
    elseif myMailState.isKindOf(CnSmtpStateDATA) then	 
   		
   		if self.disconnectOnValidationError = true then				//V6 This is the only way (it seems) whereby you can abort a message in DATA state.
   																	//V6 Strictly speaking, according to RFC821, you should not disconnect until you send
   																	//V6 a QUIT, but if QUIT (or RSET) is sent in DATA state, it's interpreted as data,
   																	//V6 not as a command.
   			cnClose(self);
      		changeState(CnSmtpStateTCPDisconnected);
      	else		
   			cnWrite(cnAnsiBinary(CrLf & "." & CrLf), self);			//V2 Found an error while sending a file message or attachment. 
   			self.myMailState.sendRSET(self);						//V5 Send RSET. Now we expect a 250 reply, to which we will do a QUIT.
   		endif;	
   																	
      	return Ex_Abort_Action;
    else
      	return Ex_Abort_Action;
    endif;		

end;
}
	externalMethodSources
emBase64Decode
{
emBase64Decode(
			pMessage: String input; 
			pDecodedMessage: Binary output): Integer is "emBase64Decode" in "karma" updating, number = 1059;
}
emBase64Encode
{
emBase64Encode(pMessage: Binary input): String is "emBase64Encode" in "karma" updating, number = 1060;
}
	)
	CnLdapException (
	jadeMethodSources
cnSetErrorCode
{
cnSetErrorCode(pValue : Integer) updating;

vars

begin
	self.errorCode := pValue;
end;
}
cnSetErrorItem
{
cnSetErrorItem(pValue : String) updating;

vars

begin
	self.errorItem := pValue;
end;
}
cnSetExtendedErrorText
{
cnSetExtendedErrorText(pValue : String) updating;

vars

begin
	self.extendedErrorText := pValue;
end;
}
	)
	CnSmtpConnectionException (
	jadeMethodSources
setMySmtpConnection
{
setMySmtpConnection(pSmtp:CnSmtpConnection) updating;

vars

begin

	mySmtpConnection := pSmtp;

end;
}
	)
	ConnectionException (
	jadeMethodSources
cnSetConnection
{
cnSetConnection(tcp : Connection) updating;

vars

begin
	self.connection := tcp;
end;
}
	)
	FileNode (
	jadeMethodSources
cnGetFileAttribute
{
cnGetFileAttribute(attr : Integer) : Boolean;

vars
	attribs		: Integer;
	result		: Integer;
	cc			: CnCntrl;
	int			: Integer;
	errortext	: String;
	cem			: CnExternalMethods;
begin
	//  Method determines whether the specified attribute for the file node (self) is set or not. 
	
	if app.cnOSPlatformIsUnix then
		return false;										// external method not currently implemented for Unix,
	endif;													// only used for 'compressed' attribute in Windows
		
	cc		:= app.myCnCntrl;
	result	:= emGetFileAttributes(self.fileName, attribs);
	
	if result <> null then
		create cem transient;
		int	:= cem.emGetErrorText(result, errortext, 127);
		if int <> 0 then
			cc.cnWriteLog(cc.CnLogErrors, "CnExternalMethods::emGetErrorText got error result=" & int.String, null);
			errortext := "Unknown error";
		endif;
	
		app.cnRaiseNormalException(Cn_General_Error, self.fileName, "Error in FileNode::cnGetFileAttribute, error=" & result.String, true);	
		
	else	
		return attribs.bitAnd(attr) > 0;
	endif;
epilog
	delete cem;
end;
}
cnGetSimpleFileName
{
cnGetSimpleFileName() : String;

vars
	pos,
 	pos1,
	pos2		: Integer;

	xFileName	: String;
begin
	xFileName	:= self.fileName;
	pos1		:= xFileName.reversePos(CN_BACK_SLASH);		// check for Windows form first
	pos2		:= xFileName.reversePos(CN_SLASH);			// then check for standardised form (caters for Linux platform)
	if pos1 = null and
	   pos2 = null then
		return xFileName;
	endif;

	if pos1 > null then
		if pos2 < pos1 then
			pos := pos1;
		
		else
			pos := pos2;
		endif;
		
	else	// pos1 must be null
		pos := pos2;
	endif;
	
	if pos >= xFileName.length then
		return null;
	endif;
	
	return xFileName[pos+1:end];
end;
}
cnSetFileAttribute
{
cnSetFileAttribute(attr : Integer; setting : Boolean);

vars
	result			: Integer;
	attribs			: Integer;
	word			: Integer;
	cc				: CnCntrl;
	int				: Integer;
	errortext		: String;
	cem			: CnExternalMethods;
begin
	//  Method determines whether the specified attribute for the file node (self) is set. 
	
	if app.cnOSPlatformIsUnix then
		return;									// only used for compressed flag in Windows, not applicable to Unix
	endif;
	
	cc		:= app.myCnCntrl;
	result	:= emGetFileAttributes(self.fileName, attribs);

	if result > 0 then
		create cem transient;
		int	:= cem.emGetErrorText(result, errortext, 127);
		if int <> 0 then
			cc.cnWriteLog(cc.CnLogErrors, "CnExternalMethods::emGetErrorText got error result=" & int.String, null);
			errortext := "Unknown error";
		endif;
	
		app.cnRaiseNormalException(Cn_General_Error, self.fileName, "Error in FileNode::cnSetFileAttribute getting existing attributes, error=" &
								   result.String & " (" & errortext & ")", true);
		
	else
		word	:= attribs.bitAnd(attr);
		
		if word > 0 and not setting then				// the bit is on, turn it off
			word	:= attribs - attr;
		elseif word = 0 and setting then
			word	:= attribs + attr;					// the bit is off, turn it on
		else
			return;																		
		endif;
		
		result	:= emSetFileAttributes(self.fileName, word);
		if result > 0 then
			create cem transient;
			int	:= cem.emGetErrorText(result, errortext, 127);
			if int <> 0 then
				cc.cnWriteLog(cc.CnLogErrors, "CnExternalMethods::emGetErrorText got error, result=" & int.String, null);
				errortext := "Unknown error";
			endif;
			app.cnRaiseNormalException(Cn_General_Error, self.fileName, "Error in FileNode::cnSetFileAttribute setting file attributes, error=" & 
									   result.String & " (" & errortext & ")", true);
		endif;	
	endif;
epilog
	delete cem;
end;
}
	externalMethodSources
emGetFileAttributes
{
emGetFileAttributes(
			fileName: String; 
			attributes: Integer output): Integer is "emGetFileAttributes" in "karma" number = 1006;
}
emSetFileAttributes
{
emSetFileAttributes(
			fileName: String; 
			attributes: Integer): Integer is "emSetFileAttributes" in "karma" number = 1007;
}
	)
	File (
	jadeMethodSources
cnCopyFile
{
cnCopyFile(pDestFile : String; pFailIfExists : Boolean; pErrText : String output) : Boolean;

vars
	cc			: CnCntrl;
	
	kc			: CnKarmaCntrl;
	
	cem			: CnExternalMethods;
	
	errResult,
	maxTries,
	result,
	timeInterval,
	tries		: Integer;
	
	errormessage,
	errortext,
	logmessage	: String;
begin
	cc			:= app.myCnCntrl;
	kc			:= app.myCnKarmaCntrl;
	if kc <> null then
		timeInterval := kc.fileRetryInterval;
		maxTries 	 := kc.fileMaxRetries + 1;
	endif;
	
	if timeInterval = null then
		timeInterval := 5*1000;
	endif;

	create cem transient;
	maxTries := maxTries.max(1);
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " maxTries=" & maxTries.String & ", timeInterval=" & timeInterval.String & "ms", null);
	while maxTries > tries do
		tries := tries + 1;
//		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " starting emCopyFile, try #" & tries.String & ".....", null);
		result 	:= self.emCopyFile(self.fileName, pDestFile, pFailIfExists);
		if result = null then
			pErrText := null;
			logmessage := "copied " & self.fileName & " as " & pDestFile;
//			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & logmessage, null);
			return true;
		endif;
		
		errResult	:= cem.emGetErrorText(result, errortext, 127);
		if errResult <> null then
			cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " emGetErrorText result=" & errResult.String, null);
		endif;
	
		if result = 32 		or 		// file in use by another process
		   result = 5  		or		// access is denied																			// PAR 8062
		   result = 1224	then	// requested operation cannot be performed on a file with a user-mapped section open		// PAR 8062
			errormessage := "Copy of " & self.fileName & " to " & pDestFile & " failed (try #" & tries.String & " of " & maxTries.String & "), result=" & result.String & ":" & errortext;
			if maxTries > tries then
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & errormessage & "; waiting " & (timeInterval div 1000).String & "secs to retry...", null);
				process.sleep(timeInterval);
			endif;
		
		else
			errormessage := "Copy of " & self.fileName & " to " & pDestFile & " failed, result=" & result.String & ":" & errortext;
			break;
		endif;
	endwhile;

	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & errormessage, null);
	if maxTries > 1 then
		errormessage := errormessage & "; exceeded " & (maxTries-1).String & " maximum retries";
	endif;
	
	pErrText := errormessage;
	return false;
epilog
	delete cem;
end;
}
cnCopyFilePlus
{
cnCopyFilePlus(pDestFile 			: String; 
			   pVerifyIntegrity, 
			   pFailIfFileExists 	: Boolean; 
			   pErrText 			: String output) : Boolean updating;

vars
	cc				: CnCntrl;
	
	cem				: CnExternalMethods;

	int,
	resultI			: Integer;
	
	errortext,
	hashValueDest,
	hashValueSource,
	resultS		 	: String;
begin
	cc		:= app.myCnCntrl;
	if pVerifyIntegrity then
		resultS := self.cnGetMD5Hash(hashValueSource);
		if resultS <> CN_OK then
			pErrText := resultS;
			return false;
		endif;
	endif;
	
	if self.cnCopyFile(pDestFile, pFailIfFileExists, pErrText) then
		if pVerifyIntegrity then
			resultS := self.emGetFileHash(pDestFile, hashValueDest);
			if resultS <> CN_OK then
				pErrText := "File '" & pDestFile & "' error getting hash value : " & resultS;
				return false;
			endif;
			
			if hashValueSource <> hashValueDest then
				pErrText := "File '" & self.fileName & "' copy failed : copied file hash value (" & hashValueDest & ") does not match original (" & hashValueSource & ")";
				return false;
			endif;
		endif;
		
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " copied " & self.fileName & " as " & pDestFile, null);
 		return true;
	endif;

	return false;
epilog
	delete cem;
end;
}
cnCopyLoadLog
{
cnCopyLoadLog(file : File input) updating, protected;

vars
	str : String;
	cc	: CnCntrl;
begin
	cc			:= app.myCnCntrl;			
	file.mode 	:= file.Mode_Input;
	file.open;
	
	while not file.endOfFile do
		str := file.readLine;
		if str <> null then
			cc.cnWriteLog(cc.CnLogComment, str, null);
		endif;
	endwhile;
	
	file.close;
end;
}
cnGetFileDescription
{
cnGetFileDescription() : String;

vars

begin
	return cnGetFileInfo("FileDescription");
end;
}
cnGetFileInfo
{
cnGetFileInfo(type : String) : String;

vars
	result 	: Integer;

	errText,
	info	: String;
begin
	if not (process.isUsingThinClient and usePresentationFileSystem) then	
		return cnGetFileInfoAppServer(type);		// use external method for non-thin client, RS6000 etc
	endif;
	//
	//  For NT, we use external function for thin thin clients.
	//  Remember - external methods execute on app server, not the thin client........RWM
	//
	if not self.isAvailable() then
		return null;
	endif;
	
	result := call cnFileVersionInfo(self.fileName, type, info, 200, errText);
	if result <> null then
		return null;
	endif;
	
	return info;
end;
}
cnGetFileInfoAppServer
{
cnGetFileInfoAppServer(type : String) : String;

vars
	result 	: String;
	info	: String;
	errText	: String;
	cc		: CnCntrl;
begin
	if self.isAvailable then
		result := emFileVersionInfo(self.fileName, type, info);
		if result = CN_OK then
			return info;
		else
			cc := app.myCnCntrl;
			cc.cnWriteLog(cc.CnLogErrors, "File " & self.fileName & " in File::cnGetFileVersionAppServer : " & result, null);
		endif;

	else
		return "<File '" & fileName & "' not found>";
	endif;
end;
}
cnGetFileLength
{
cnGetFileLength() : Integer updating;

vars
	mode,
	result	: Integer;
	
	cc		: CnCntrl;
begin
	cc	:= app.myCnCntrl;
	mode := self.kind;
	if self.isAvailable then
		self.kind := self.Kind_Binary;
		return self.fileLength();
	endif;
	
	cc.cnWriteLog(cc.CnLogErrors, "File " & self.fileName & " not available (in method File::cnGetFileLength).", null);
	return -1;
epilog
	self.kind := mode;
end;
}
cnGetFileLength64
{
cnGetFileLength64() : Integer64 updating;

vars
	mode,
	result	: Integer;
	
	cc		: CnCntrl;
begin
	cc	:= app.myCnCntrl;
	mode := self.kind;
	if self.isAvailable then
		self.kind := self.Kind_Binary;
		return self.fileLength64();
	endif;
	
	cc.cnWriteLog(cc.CnLogErrors, "File " & self.fileName & " not available (in method File::cnGetFileLength64).", null);
	return -1;
epilog
	self.kind := mode;		// restore to incoming value
end;
}
cnGetFileVersion
{
cnGetFileVersion() : String;

vars
	fname,
	suffix	: String;
begin
	suffix := self.cnGetSuffix().toLower();
	if suffix = null 	or			// Linux executable
	   suffix = "exe" 	or			// Windows executable
	   suffix = "dll"	or			// Windows library
	   suffix = "ocx"	or			// Windows OCX
	   suffix = "so"	or			// Linux library
	   suffix = "sh"	then		// Linux shell script
		return cnGetFileInfo("FileVersion");
	endif;

	fname := self.cnGetSimpleFileName().toLower();
	if fname.cnContains(".dll.ansi") 			or
	   fname.cnContains(".dll.unicode") 		or
	   fname.cnContains(".dll.x64.ansi") 		or
	   fname.cnContains(".dll.x64.unicode") 	or
	   fname.cnContains(".so.ansi") 			or
	   fname.cnContains(".so.x64.ansi") 		then
		return cnGetFileInfo("FileVersion");
	endif;
	
	return null;
end;
}
cnGetFileVersionAppServer
{
cnGetFileVersionAppServer() : String;

vars
	result 	: String;
	info	: String;
	errText	: String;
	cc		: CnCntrl;
begin
	if self.isAvailable then
		result := emFileVersionInfo(self.fileName, "FileVersion", info);
		if result = CN_OK then
			return info;
		else
			cc := app.myCnCntrl;
			cc.cnWriteLog(cc.CnLogErrors, "File " & self.fileName & " in File::cnGetFileVersionAppServer : " & result, null);
		endif;

	else
		return "<File '" & fileName & "' not found>";
	endif;
end;
}
cnGetMD5Hash
{
cnGetMD5Hash(pMD5Hash : String output) : String;
/*
	Note :	this method can NOT be used to derive the MD5 hash value for a file resident
			on a thin-client workstation.
			
*/
vars
	result,
	hashValue	: String;
begin
	result := self.emGetFileHash(self.fileName, hashValue);
	if result <> CN_OK then
		return "File '" & self.fileName & "' error getting hash value : " & result;
	endif;	

	pMD5Hash := hashValue;
	return CN_OK;
end;
}
cnGetSuffix
{
cnGetSuffix() : String;

/*
	Reworked to cater for PAR #871.
	Now handles :
	- filename with suffix          				- c:\test\aFileName.txt
	- filename with last character of period (.)	- c:\test\aFileName.
	- filename with no suffix						- c:\test\aFileName
*/
vars
	len,
 	pos : Integer;
	
	str	: String;
begin
	str := self.fileName;
	pos := str.reversePos(CN_PERIOD);
	if pos = null then
		return null;
	endif;
	
	len := str.length();
	pos := pos + 1;
	if pos > len then
		return null;
	endif;
	
	return str[pos : end];
end;
}
cnLastModifiedGMT
{
cnLastModifiedGMT() : TimeStamp;

vars
 	bias	: Integer;
 	result	: Integer;
 	myTime	: Time;
 	fileTS	: TimeStamp;
begin
	//  This method adjusts time to GMT and strips seconds off the time.
	//  This was required because the FAT file system rounds to 2 seconds

 	result := cnGetGMTBias(bias);
	fileTS	:= self.lastModified;

	if bias <0 then
		myTime.setTime(0, -bias, 0, 0);
		fileTS := fileTS - myTime;
	else
		myTime.setTime(0, bias, 0, 0);
		fileTS := fileTS + myTime;
	endif;

	myTime.setTime(fileTS.time.hour, fileTS.time.minute, 0, 0);
	fileTS.setTime(myTime);
	return fileTS;	
end;
}
cnRemoveFile
{
cnRemoveFile(pRetryLimit : Integer; pRetryWaitInterval : Integer) : String;
/*
	Purpose		: purges file from disk. 
				  Allows for up to retry limit attempts before failing.
				  If successful, OK is return otherwise failure reason is returned.
*/

vars
	kc 			: CnKarmaCntrl;
	
	cc			: CnCntrl;
	
	errStr,
	userDetails	: String;
	
	retries		: Integer;
begin
	kc := app.myCnKarmaCntrl;
	cc := app.myCnCntrl;

	on FileException do kc.fileExceptionHandler(exception);

	while true do
	    kc.setHadFileException(false);
	    kc.setFileRetryNo(0);
	
		self.purge();
		if not kc.hadFileException then
			return CN_OK;
		endif;

		errStr := kc.exceptionFileName & " exception=" & kc.exceptionErrorCode.String & " (" & kc.exceptionText & ")";
		if retries = pRetryLimit then
			return errStr & ", retry limit exceeded";
		endif;

		retries := retries + 1;
		errStr := errStr & ", retrying remove";
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & errStr, null);
		process.sleep(pRetryWaitInterval);
	endwhile;
end;
}
cnRenameFile
{
cnRenameFile(pFileName : String; pRetryLimit : Integer; pRetryWaitInterval : Integer) : String;
/*
	Purpose		: renames a file from disk. 
				  Allows for up to 4 attempts before failing.
				  If successful, OK is return otherwise failure reason is returned.
*/

vars
	kc 			: CnKarmaCntrl;
	
	file		: File;
	
	cc			: CnCntrl;
	
	errStr,
	userDetails	: String;
	
	retries		: Integer;
begin
	// assumes mode = input
	if not self.isAvailable() then
		return CN_OK;
	endif;
	
	create file transient;
	file.fileName := pFileName;
	file.mode := file.Mode_Input;
	if file.isAvailable() then
		errStr := file.cnRemoveFile(pRetryLimit, pRetryWaitInterval);		// remove existing script before rename to avoid 5015 exception
		if errStr <> CN_OK then
			return errStr;
		endif;
	endif;
	
	kc := app.myCnKarmaCntrl;
	cc := app.myCnCntrl;

	on FileException do kc.fileExceptionHandler(exception);

	while true do
	    kc.setHadFileException(false);
	    kc.setFileRetryNo(0);
	
		self.rename(pFileName);
		if not kc.hadFileException then
			return CN_OK;
		endif;

		errStr := kc.exceptionFileName & " exception=" & kc.exceptionErrorCode.String & " (" & kc.exceptionText & ")";
		if retries = pRetryLimit then
			return errStr & ", retry limit exceeded";
		endif;

		retries := retries + 1;
		errStr := errStr & ", retrying rename";
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & errStr, null);
		process.sleep(pRetryWaitInterval);
	endwhile;
epilog
	delete file;
end;
}
cnSetFileRetryDefaults
{
cnSetFileRetryDefaults();

vars
	kc	: CnKarmaCntrl;
begin
	kc := app.myCnKarmaCntrl;
	kc.setFileRetryNo(null);
	kc.setFileMaxRetries(9);
	kc.setFileRetryInterval(10*1000);
end;
}
cnSetLastModified
{
cnSetLastModified(ts : TimeStamp) : String updating;

vars
	date, time 	: Integer;
	int			: Integer;
	str			: String;
	d			: Date;
	t			: Time;
	result		: Integer;
	ne			: NormalException;
	
	cem			: CnExternalMethods;
begin
	if ts = null then
		return "Null timestamp submitted to File::cnSetLastModified";
	endif;

	if self.isOpen then
		create ne transient;
		ne.errorCode			:= Cn_File_Error;
		ne.extendedErrorText	:= "Can't modify timestamp on open file.";
		raise(ne);
		return null;
	endif; 

	d 		:= ts.date;
	date 	:= d.year * 10000 + d.month * 100 + d.day;
	t		:= ts.Time;
	time	:= t.hour * 10000 + t.minute * 100 + t.second;

	result := emSetModifyTime(self.fileName, date, time);
	if result <> 0 then
		create cem transient;
		int := cem.emGetErrorText(result, str, 127);
		return "File::cnSetLastModified error=" & result.String & " (" & str & ")";
	endif;

	return CN_OK;
epilog
	delete cem;
end;
}
	externalMethodSources
cnGetGMTBias
{
cnGetGMTBias(bias: Integer output): Integer is "emGetGMTBias" in "karma" number = 1006;
}
emCopyFile
{
emCopyFile(sourceFile: String; 
			destFile: String; 
			failIfExists: Boolean): Integer is emCopyFile in karma;
}
emCopyFileWithTimeStamps
{
emCopyFileWithTimeStamps (sourceFile : String;
						  targetFile : String;
						  failIfExists : Boolean) : Integer is emCopyFileWithTimeStamps in karma ;
}
emDeleteFile
{
emDeleteFile(fileName: String): Integer is emDeleteFile in karma;
}
emFileVersionInfo
{
emFileVersionInfo(
			fileName: String; 
			infoType: String; 
			infoValue: String output): String is "emFileVersionInfo" in "karma" number = 1007;
}
emGetFileHash
{
emGetFileHash(pFileName : String; pHashValue : String output) : String is emGetFileHash in karma;
}
emMoveFileEx
{
emMoveFileEx(sourceFile : String;
			 destFile   : String;
			 flags		: Integer) : Integer is emMoveFileEx in karma;
}
emSetAccessTime
{
emSetAccessTime(pFilename: String; 
				pDate: Integer; 
				pTime: Integer): Integer is emSetAccessTime in karma protected;
				
/*
This method was added in CardSchema 3.4 for use by JSM.

NOTE:
Be aware that the timestamp milliseconds is set to zero.
*/
}
emSetAccessTimeEx
{
emSetAccessTimeEx(pFilename: String; 
				  pDate: Integer; 
				  pTime: Integer): Integer is emSetAccessTimeEx in karma protected;
				
/*
This method was added in CardSchema 4.0.03 for use by JSM.

NOTE:
	fileName	Name and path of the file
	
	newDate		The new "last modified" date. The date is an integer in this format :
				ccyy * 10000 + mm * 100 + dd
				For example, 23rd January, 2000 is represented as 20000123.
	
	newTime		The new "last modified" time. The time is an integer in this format :
				hh * 10000000 + mm * 100000 + ss * 1000 + iii 
				where iii represents 3 decimal digits of milliseconds.
				For example, 5.123 seconds after 11 minutes past 3 p.m. is represented as 151105123.

*/
}
emSetCreateTime
{
emSetCreateTime(pFilename: String; 
				pDate: Integer; 
				pTime: Integer): Integer is emSetCreateTime in karma protected;
/*
This method was added in CardSchema 3.4 for use by JSM.

NOTE:
Be aware that the timestamp milliseconds is set to zero.
*/
}
emSetCreateTimeEx
{
emSetCreateTimeEx(pFilename: String; 
				  pDate: Integer;
				  pTime: Integer): Integer is emSetCreateTimeEx in karma protected;
/*
This method was added in CardSchema 4.0.03 for use by JSM.

NOTE:
	fileName	Name and path of the file
	
	newDate		The new "last modified" date. The date is an integer in this format :
				ccyy * 10000 + mm * 100 + dd
				For example, 23rd January, 2000 is represented as 20000123.
	
	newTime		The new "last modified" time. The time is an integer in this format :
				hh * 10000000 + mm * 100000 + ss * 1000 + iii 
				where iii represents 3 decimal digits of milliseconds.
				For example, 5.123 seconds after 11 minutes past 3 p.m. is represented as 151105123.

*/
}
emSetModifyTime
{
emSetModifyTime(pFilename: String; 
				pDate: Integer; 
				pTime: Integer): Integer is emSetModifyTime in karma;

/*
	NOTE:
	Be aware that the timestamp milliseconds is set to zero.
*/
}
emSetModifyTimeEx
{
emSetModifyTimeEx(pFilename: String;
				  pDate: Integer;
				  pTime: Integer): Integer is emSetModifyTimeEx in karma;

/*
This method was added in CardSchema 4.0.03 for use by JSM.

NOTE:
	fileName	Name and path of the file
	
	newDate		The new "last modified" date. The date is an integer in this format :
				ccyy * 10000 + mm * 100 + dd
				For example, 23rd January, 2000 is represented as 20000123.
	
	newTime		The new "last modified" time. The time is an integer in this format :
				hh * 10000000 + mm * 100000 + ss * 1000 + iii 
				where iii represents 3 decimal digits of milliseconds.
				For example, 5.123 seconds after 11 minutes past 3 p.m. is represented as 151105123.

*/
}
	)
	FileFolder (
	jadeMethodSources
cnCopyFilesFromDirectory
{
cnCopyFilesFromDirectory(pDestDir : String; pCreateDirectoryIfNotFound, pIncludeSubDirectories, pVerifyIntegrity : Boolean; pErrText : String output) : Boolean updating;
/*
	Purpose		:	Copy all files from a the directory specified by this file folder. 
					Optionally allow copy of all subdirectories.
					Optionally allow validation of each file written by doing an MD5 hash over the input file and checking it against
					that derived from the file just copied.
					
	Parameters	:	self.fileName				-	expected to be the name of the file folder that is the starting point for the copy
	
					pDestDir					-	the destination directory into which copy is to be done
					
					pCreateDirectoryIfNotFound	-	true	- if destination directory doesn't exist, create it
													false	- if destination directory doesn't exist, then error
													
					pIncludeSubDirectories		-	true	- execute same actions for all sub-directories
													false	- don't apply action to sub-directories

					pVerifyIntegrity			-	true	- any files copied are subjected to MD5 hash check to verify integrity of copy process
													false	- no checks done on output file
													
					pErrText					-	if result is false, this contains the error message that caused the failure

	Result			true	- copy was successful
					false	- copy failed, pErrText contains failure reason					
*/
vars
	kc			: CnKarmaCntrl;
	
	fileNode	: FileNode;
	
begin
	kc := app.myCnKarmaCntrl;

	on FileException do kc.fileExceptionHandler(exception);
    kc.setHadFileException(false);
    kc.setFileRetryNo(0);

	if not self.cnZCopyFilesFromDirectory(pDestDir, pCreateDirectoryIfNotFound, pIncludeSubDirectories, pVerifyIntegrity, pErrText) then
		return false;
	endif;
	
	if kc.hadFileException then
		pErrText := "Exception occurred during copy : " & kc.exceptionFileName & ", exception=" & kc.exceptionErrorCode.String & " (" & kc.exceptionText & ")";
		return false;
	endif;

	return true;
end;
}
cnGetMaskedFileLengths
{
cnGetMaskedFileLengths(	pLocations				: CnStringArray;
						pFolderMask,
						pFileMask				: String;
						pStructureNames 		: CnStringArray input;
						pStructureLengths,
						pUdrStructureLengths,
						pUdrNumberStructures	: Integer64Array input) updating;
/*
	searches each of the locations specified looking for a files with a specific mask
	
	example:
	pFolderMask  = "*_udr*.dat"
	pFileMask	 = "_udr"
	
	the above masks will identify the length of DbFileTest_part0000000004_udr.dat as well as 
	DbFileTest_part0000000004_udr[2133.19001.2101.2].dat with partitioned file
	DbFileTest_part0000000004.
*/
vars
	cc			: CnCntrl;
	
	file		: File;																											// PAR 699

	fn			: FileNode;

	pos			: Integer;
	
	count,
	fileLength,
	newLength,
	num,
	index		: Integer64;
	
	location,
	str			: String;
begin
	cc := app.myCnCntrl;
		// interim patch to obtain size of any udr files
		// the location given here is expected to exist and needs to be checked by the invoking method if any doubt otherwise will incur an exception
	foreach location in pLocations do
		self.fileName 	:= location;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " scanning location '" & location & "' with mask '" & pFolderMask & "' ....", null);
		self.mask		:= pFolderMask;
		
		foreach fn in self.files do
			count := count + 1;
			if not fn.isKindOf(File) then
				continue;
			endif;
			
			file := fn.File;																									// PAR 699
			file.kind := file.Kind_Binary;																						// PAR 699
			fileLength := file.fileLength64();																					// PAR 699
			pos := 1;
			pos := file.name.pos(pFileMask, pos);																				// PAR 699
			str := file.name[1:pos-1];																							// PAR 699
			index := pStructureNames.indexOf64(str);
			if index = null then
				pStructureNames.add(str);
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " adding structure '" & str & "' (1), length=" & fileLength.String, null);
				if pStructureLengths <> null then
					pStructureLengths.add(fileLength);
				endif;
				
				if pUdrStructureLengths <> null then
					pUdrStructureLengths.add(fileLength);
				endif;
				
				if pUdrNumberStructures <> null then
					pUdrNumberStructures.add(1);
				endif;
			
			else
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " update structure '" & str & "' (" & index.String & "), with length=" & fileLength.String, null);
				if pStructureLengths <> null then
					newLength := pStructureLengths.at(index) + fileLength;
					pStructureLengths.atPut(index, newLength);
				endif;
				
				if pUdrStructureLengths <> null then
					newLength := pUdrStructureLengths.at(index) + fileLength;
					pUdrStructureLengths.atPut(index, newLength);
				endif;
				
				if pUdrNumberStructures <> null then
					num := pUdrNumberStructures.at(index) + 1;
					pUdrNumberStructures.atPut(index, num);
				endif;
			endif;
		endforeach;
	endforeach;
	
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " located " & count.String & " items", null);
epilog
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " inExceptionState=" & process.isInExceptionState().String, null);
end;
}
cnRenameDirectory
{
cnRenameDirectory(newName : String) : String;

constants
	Err_Access_Is_Denied			: Integer	= 13;
	Err_File_Path_Cannot_Be_Found	: Integer	= 2;
	Err_Name_Contains_InvalidChars	: Integer	= 22;
	
vars
	result		: Integer;
	int			: Integer;
	cc			: CnCntrl;
	str			: String;
	errortext	: String;
	cem			: CnExternalMethods;
begin
	if not self.isAvailable then
		return "Directory '" & self.fileName & "' not found.";
	endif;
	
	result	:= emRenameDirectory(self.fileName, newName);

	if result > 0 then
		cc	:= app.myCnCntrl;
		
		// JWC advises that standard windows error codes don't apply here so we decode the following 3 ourselves
		
		if result = Err_Access_Is_Denied then
			errortext := "Access is denied.";
		
		elseif result = Err_File_Path_Cannot_Be_Found then
			errortext := "File or Path cannot be found.";
			
		elseif result = Err_Name_Contains_InvalidChars then
			errortext := "Name contains invalid characters.";
			
		else
			create cem transient;
			int	:= cem.emGetErrorText(result, errortext, 127);
			if int <> 0 then
				cc.cnWriteLog(cc.CnLogErrors, "CnExternalMethods::emGetErrorText got error result=" & int.String, null);
				errortext := "Unknown error.";
			endif;
		endif;
	
		return "Rename of directory '" & self.fileName & "' to '" & newName & "' failed : error=" & result.String & " (" & errortext & ")";
	endif;
	
	return CN_OK;
epilog
	delete cem;
end;
}
cnZCopyFilesFromDirectory
{
cnZCopyFilesFromDirectory(pDestDir : String; pCreateDirectoryIfNotFound, pIncludeSubDirectories, pVerifyIntegrity : Boolean; pErrText : String output) : Boolean updating, protected;
/*
	Purpose		:	Copy all files from a the directory specified by this file folder. 
					Optionally allow copy of all subdirectories.
					Optionally allow validation of each file written by doing an MD5 hash over the input file and checking it against
					that derived from the file just copied.
					
	Parameters	:	self.fileName				-	expected to be the name of the file folder that is the starting point for the copy
	
					pDestDir					-	the destination directory into which copy is to be done
					
					pCreateDirectoryIfNotFound	-	true	- if destination directory doesn't exist, create it
													false	- if destination directory doesn't exist, then error
													
					pIncludeSubDirectories		-	true	- execute same actions for all sub-directories
													false	- don't apply action to sub-directories

					pVerifyIntegrity			-	true	- any files copied are subjected to MD5 hash check to verify integrity of copy process
													false	- no checks done on output file
													
					
*/
constants
	Continue_If_File_Exists	: Boolean = false;
vars
	fileNode		: FileNode;

	thisFileName,
	newFileName		: String;
	
	ff				: FileFolder;

	kc				: CnKarmaCntrl;
begin
	if not self.isAvailable then
		pErrText := "Source directory '" & self.fileName & "' does not exist";
		return false;
	endif;

	create ff transient;
	ff.fileName := pDestDir;
	if not ff.isAvailable then
		if pCreateDirectoryIfNotFound then
			ff.make();
		
		else
			pErrText := "Directory '" & pDestDir & "' does not exist";
			return false;
		endif;
	endif;
	
	foreach fileNode in self.files do
		thisFileName := fileNode.cnGetSimpleFileName();
		newFileName := pDestDir & "/" & thisFileName;
		if fileNode.isKindOf(File) then
			if not fileNode.File.cnCopyFilePlus(newFileName, pVerifyIntegrity, Continue_If_File_Exists, pErrText) then
				return false;
			endif;
			
		elseif pIncludeSubDirectories then
			if not fileNode.FileFolder.cnZCopyFilesFromDirectory(newFileName, pCreateDirectoryIfNotFound, pIncludeSubDirectories, pVerifyIntegrity, pErrText) then
				return false;
			endif;
		endif;
	endforeach;

	return true;
	
epilog
	delete ff;
end;
}
	externalMethodSources
emRenameDirectory
{
emRenameDirectory(
			sourceDir: String; 
			destDir: String): Integer is "emRenameDirectory" in "karma" number = 1005;
}
	)
	GCardSchema (
	jadeMethodSources
cnGetProfileStringServer
{
cnGetProfileStringServer(section, keyName, default : String) : String serverExecution;

vars
	//  Get ini file data from server's ini file.
begin
	return app.cnGetProfileStringServer(section, keyName, default);
end;
}
cnGetServerComputerName
{
cnGetServerComputerName() : String serverExecution;

vars

begin
 	return app.cnComputerName;
end;
}
cnGetServerHostFQDN
{
cnGetServerHostFQDN() : String serverExecution;

vars
   	fqdn,
	ipAddress	: String;
   	cc			: CnCntrl;
   	result		: Integer; 
   	cem			: CnExternalMethods;
begin
	ipAddress := process.networkAddress;
	create cem transient;
	result		:= cem.emGetHostByAddress(ipAddress, fqdn);
	if result <> 0 then
		cc := app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " : kc.emGetHostByAddress failed for IP address=" & 
					  ipAddress, null);
		return ipAddress;
	endif;

	return fqdn;
epilog
	delete cem;
end;
}
cnGetServerInstallDir
{
cnGetServerInstallDir() : String serverExecution;

vars

begin
 	return app.cnStandardizePathName(app.getJadeInstallDir);
end;
}
cnGetServerLogArchiveDir
{
cnGetServerLogArchiveDir() : String serverExecution;

vars
	logroot	: String;
	logpath	: String;
	len		: Integer;
begin
	logroot := app.getProfileStringAppServer(app.getIniFileNameAppServer, "PersistentDb", "JournalArchiveDirectory", null);
	
	if logroot = null then
		logroot := self.cnGetServerLogRootDir() & "/archive";	// defaults to archive directory
	endif;
	
	logroot.replaceChar("\", "/");
	if app.cnOSPlatformIsWindows and logroot[2] = ":" then		// fully qualified path : Windows
		logpath := logroot;
		
	elseif app.cnOSPlatformIsUnix and logroot[1] = "/" then		// fully qualified path : Unix
		logpath	:= logroot;
		
	else	
		logpath := app.dbPath & "/" & logroot;					// partial path
	endif;

	len := logpath.length;

	if logpath[len] = "/" then
		logpath := logpath[1 : len - 1];
	endif;
	
	return logpath;
end;
}
cnGetServerLogFileName
{
cnGetServerLogFileName() : String serverExecution;

vars

begin
 	return app.getProfileStringAppServer(cnGetServerIniFileName, "CardLog", "LogFileName", "cn_comms.log");
end;
}
cnGetServerLogPath
{
cnGetServerLogPath() : String serverExecution;

vars

begin
	return app.getProfileStringAppServer(cnGetServerIniFileName, "CardLog", "LogPath", "c:/temp");	
end;
}
cnGetServerLogRootDir
{
cnGetServerLogRootDir() : String serverExecution;

vars
	logroot,
	logpath,
	iniFileTitle	: String;
	
	len				: Integer;
begin
	iniFileTitle := app.getIniFileNameAppServer();
	logroot := app.getProfileStringAppServer(iniFileTitle, CN_PERSISTENTDB, "JournalRootDirectory", null);
	
	if logroot = null or
	   logroot.toLower() = "<default>" then	
		logroot := "journals";
	endif;	
	
	if app.cnOSPlatformIsWindows and logroot[2] = ":" then		// fully qualified path : Windows
		logpath := logroot;
	elseif app.cnOSPlatformIsUnix and logroot[1] = "/" then		// fully qualified path : Unix
		logpath	:= logroot;
	else	
		logpath := app.dbPath & "/" & logroot;					// partial path
	endif;

	len := logpath.length;

	if logpath[len] = "/" or
	   logpath[len] = "\" then
		return logpath[1 : len - 1];
	else
		return logpath;
	endif;
end;
}
cnGetServerName
{
cnGetServerName() : String;

vars
	//  No longer used by CardSchema or JSM : only retained for 
	//  compatibility with existing user application schemas.....RWM 18 July 2003 	
begin
	return app.myCnKarmaCntrl.managedEnvironmentName;			// re-implemented for CardSchema 3.0
end;
}
cnGetServerNode
{
cnGetServerNode() : Node serverExecution;

vars

begin
 	return node;
end;
}
cnGetUserProcess
{
cnGetUserProcess(appName : String; excludeOwnProcess : Boolean) : Process serverExecution, updating;

vars
 	proc		: Process;
	badObject	: Boolean;
begin
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, proc, badObject);
	
	/////  Gets process for application specified in appName		   //////
	
	foreach proc in Process.instances do
		if proc.type = 5.Character then					// shadow process
			continue;
		endif;
		
		if not excludeOwnProcess or proc <> process then
			if proc.persistentApp.name = appName then
				return proc;
			endif;
		endif;
	endforeach;
end;
}
cnGetUserProcessForNode
{
cnGetUserProcessForNode(procid : String; excludeOwnProcess : Boolean; nod : Node) : Process serverExecution, updating;

vars
	obj			: Object;
 	proc		: Process;
	procSet		: ObjectSet;
	badObject	: Boolean;
begin
	create procSet transient;
	nod.processes.copy(procSet);		// use set to avoid locking each object as we're not worried about order
	/////  Gets first process for specified node based on app name
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, proc, badObject);
	foreach obj in procSet do
		proc := obj.Process;
		if not excludeOwnProcess or proc <> process then
			if proc.persistentApp.name = procid then
				return proc;
			endif;
		endif;
	endforeach;
epilog
	delete procSet;
end;
}
cnSetProfileStringServer
{
cnSetProfileStringServer(section, keyName, string : String) serverExecution;

vars

begin
	app.setProfileString(app.getIniFileName, section, keyName, string);
end;
}
cnStartBackgroundClient
{
cnStartBackgroundClient() : String serverExecution, updating;

vars
	binPath		: String;
	iniInfo		: String;
	str			: String;
	kc			: CnKarmaCntrl;
	cc			: CnCntrl;
	iResult		: Integer;
	schemaName	: String;
	appName		: String;
	proc		: Process;
begin
	if app.cnSystemType = CN_SYSTEMTYPE_JSM or
	   app.cnSystemType = CN_SYSTEMTYPE_JSA then
		schemaName	:= CN_JOSSCONTROL;
	endif;   
	   
	if app.cnSystemType = CN_SYSTEMTYPE_JSM then
		appName		:= CN_JOSSCOMMSMGR;
		
	elseif app.cnSystemType = CN_SYSTEMTYPE_JSA then
		appName		:= CN_KARMACOMMSMGR;
		
	else
		schemaName	:= CN_CARDSCHEMA;
		appName		:= CN_KCCMGR;
	endif;
	//
	cc	:= app.myCnCntrl;	
	cc.cnWriteLog(cc.CnLogDiag, "Server method is starting background client : schema=" & schemaName & ", app=" & appName, null);
	proc := app.startApplication(schemaName, appName);
	if proc = null then
		return "Background client : schema=" & schemaName & ", app=" & appName & " failed to start.";
	endif;

	return CN_OK;
end;
}
	externalMethodSources
cnGetServerIniFileName
{
cnGetServerIniFileName(): String is "getIniFileNameWithPath" in "jomsupp" serverExecution, number = 1013;
}
	)
	JadeDatabaseAdmin (
	jadeMethodSources
cn3004ExceptionHandler
{
cn3004ExceptionHandler(exObj : Exception; error : Boolean output) : Integer;

vars

begin
	if exObj.errorCode = 3004 then		
		error	:= true;
		return Ex_Resume_Next;
	else
		return Ex_Pass_Back;
	endif;
end;
}
cn3074ExceptionHandler
{
cn3074ExceptionHandler(exObj : Exception; error : Boolean output) : Integer;

vars

begin
	if exObj.errorCode = 3074 then		
		error	:= true;
		return Ex_Resume_Next;
		
	else
		return Ex_Pass_Back;
	endif;
end;
}
cn3116ExceptionHandler
{
cn3116ExceptionHandler(exObj : Exception; error : Boolean output) : Integer;

vars

begin
	if exObj.errorCode = 3116 then		
		error	:= true;
		return Ex_Resume_Next;
	endif;
	
	return Ex_Pass_Back;
end;
}
cnGetDatabaseSubrole
{
cnGetDatabaseSubrole() : Integer;

vars
	jdo	: JadeDynamicObject;
begin
	// only applicable to SDS secondaries and RPS nodes

	create jdo transient;
	sdsGetMyServerInfo(jdo);
	return jdo.getPropertyValue("subrole").Integer;
	
epilog
	delete jdo;
end;
}
cnGetMapFileInfo
{
cnGetMapFileInfo(pMapFileNames : CnSmallStringArray input; pMapFileSizes : CnDecimalArray input);

vars
	dbFileArray	: DbFileArray;
	dbFile		: DbFile;
	error3004	: Boolean;
	error3074	: Boolean;
	error3116	: Boolean;
	lngth		: Decimal[23,0];
	cc			: CnCntrl;
	status		: Integer;
	kc			: CnKarmaCntrl;
	str			: String;
	count		: Integer;
	mapStr		: String;
	pos			: Integer;
	lockError	: Boolean;
	lockTries	: Integer;
begin
	cc	:= app.myCnCntrl;
	kc := app.myCnKarmaCntrl;
	create dbFileArray transient;
	
	on LockException do app.cnGenericExceptionHandler(exception, Cn_ObjectLocked, null, lockError);
	while true do
		lockTries := lockTries + 1;
		self.getAllDbFiles(dbFileArray);
		if not lockError then
			break;
		endif;
		
		lockError := false;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & lockTries.String & " attempts, retrying", null);
		process.sleep(2000);
	endwhile;
	
	on Exception do cn3004ExceptionHandler(exception, error3004); 				// Internal error : RPS node not yet unmapped
	on Exception do cn3074ExceptionHandler(exception, error3074); 				// Error when explicit directory declared on mapfile and directory doesn't exist
	on Exception do cn3116ExceptionHandler(exception, error3116); 				// Database file locked for reorg
	
	foreach dbFile in dbFileArray do
		if dbFile.excludeFromBackup then
			continue;
		endif;
		
		status := dbFile.getFileStatus();
		if error3004 then
			cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " : UE 3004 (internal) : unmapped database : possible cause is that this is a " &
						  "new RPS node and the RPS datapump has not yet been run. Map files not captured for SessionOpenAdvice.", null);
			pMapFileNames.clear();
			pMapFileSizes.clear();
			return;
		endif;
		
		// identify which map files have explicit paths declared so that
		// an alert can be generated naming these to avoid issues in future
		// with this application.
		if dbFile.path <> null then
			count := count + 1;
			mapStr := mapStr & dbFile.name & " " & dbFile.database.name & CrLf;
		endif;
		
		if error3074 then
			str := "Mapfile " & dbFile.name & " for database " & dbFile.database.name & " has declared explicit path '" & dbFile.path & "' " &
					" which does not exist. Development staff need to be advised.";
			cc.cnWriteLog(cc.CnLogErrors, "Generating alert : " & str, null);
			pos := 1;
			app.cnRaiseJossAlert(Cn_Karma_Alert,
								 "Database file error occurred in " & kc.environmentId & " on " & node.cnGetComputerName.scanUntil(".", pos),
								 str,
								 "N",
								 app.actualTime,
								 cc.appName,
								 kc.managedEnvironmentName,																		// JSM PAR 8367
								 node.cnGetComputerName,
								 kc.networkAddressNode,			// PAR 441 node.networkAddress,
								 kc.myParentTcp);
			error3074 := false;
			continue;
		endif;
		
		if status <> dbFile.Status_Unmapped then			
			pMapFileNames.add(dbFile.getName);
			lngth := dbFile.getFileLength();
			if error3116 then
				error3116 := false;
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " database file " & dbFile.getName() & " is locked for reorganization, unable to determine length.", null);
				lngth := null;
			endif;

			pMapFileSizes.add(lngth);
		endif;
	endforeach;

	
	if count > null then
		if count = 1 then
			str := count.String & " mapfile has";
		
		else
			str := count.String & " mapfiles have";
		endif;
		
		str := str & " explicit path declarations. " &
				"This needs to be addressed to avoid issues should this system need to be relocated or refreshed. " &
				"Development staff need to be advised." & CrLf &
				mapStr;
		cc.cnWriteLog(cc.CnLogErrors, "Generating alert : " & str, null);
		pos := 1;
		app.cnRaiseJossAlert(Cn_Karma_Alert,
							 kc.environmentId & " on " & node.cnGetComputerName.scanUntil(".", pos) & " has mapfiles with explicit path names",
							str,
							"N",
							app.actualTime,
							cc.appName,
							kc.managedEnvironmentName,																			// JSM PAR 8367
							node.cnGetComputerName,
							kc.networkAddressNode,		// PAR 441 node.networkAddress,
							kc.myParentTcp);
	endif;
epilog
	delete dbFileArray;
end;
}
cnRpsStartDataPump
{
cnRpsStartDataPump();

vars
	dba : JadeDatabaseAdmin;
begin
	create dba transient;
	dba.sendMsgWithParams("rpsStartDataPump", null, null);
epilog
	delete dba;
end;
}
	)
	CnJadeDatabaseAdmin (
	jadeMethodSources
ehHandleAnyException
{
ehHandleAnyException(pExObj : Exception; pErrorCode : Integer output) : Integer;

vars

begin
	pErrorCode := pExObj.errorCode;
	return Ex_Resume_Next;
end;
}
getAllDatabaseStructureInfo
{
getAllDatabaseStructureInfo(pDbFileNames	 		: CnStringArray input;
							pPartitionNames			: CnStringArray input;
							pDbFiles				: DbFileArray input;
							pStatii 				: IntegerArray input;
							pPartitionIds			: Integer64Array input;						// this and remaining items are optional - zero for DbFile entity
							pKinds					: IntegerArray input;						// if dbfile then Kind else partition = 999	
							pLocations				: CnStringArray input;						// optional
							pExcludeFromBackup		: BooleanArray input;						// optional - applies to DbFile only
							pLengths				: Integer64Array input;						// optional
							pUDRFileLengths			: Integer64Array input;						// optional
							pUDRNumberStructures	: Integer64Array input;						// optional
							pEncryptionStatus		: IntegerArray input;						// optional						// PAR 1004
							pIsPartitioned			: BooleanArray input;						// optional - applies to DbFile only
							pPartitionCounts		: Integer64Array input;						// optional - applies to DbFile only
							pModifiedTimeStamps		: TimeStampArray input;						// optional
							pBackupTimeStamps		: TimeStampArray input;						// optional
							pFullBackupTimeStamps	: TimeStampArray input;						// optional
							pFrozenArray			: BooleanArray input;						// optional
							pOfflineArray			: BooleanArray input) : String;				// optional
/*
	Returns database file info.
	
	Note :
	- that modified, backup and full timestamps are only flushed to the control file(s) when beginBackup has been executed.
	- that the pLengths contains the sum of the Database Structure as well as any UDR (JadeBytes) components associated with it.
*/
constants
	Status_Offline					: Integer	= DbFile.Status_Offline;
	Partition_Kind					: Integer	= 999;
vars
	kc								: CnKarmaCntrl;
	
	dbFile							: DbFile;
	
	dbFileArray,
	dbFilePartitionedArray			: DbFileArray;
	
	ff								: FileFolder;

	frozenArray,
	offlineArray					: BooleanArray;

	partitionLocations,
	partitionNames,
	structureNames,
	uniqueLocations					: CnStringArray;

	partitionStatii					: IntegerArray;
	
	partitionIds,
	partitionLengths				: Integer64Array;
	
	partitionModifiedTimeStamps,
	partitionBackupTimeStamps,
	partitionFullBackupTimeStamps	: TimeStampArray;
	
	iterFrozen,
	iterOffline,
	iterPartBackupTimeStamp,
	iterPartFullBackupTimeStamp,
	iterPartId,
	iterPartLength,
	iterPartLocation,
	iterPartitionName,
	iterPartModifiedTimeStamp,
	iterPartStatus					: Iterator;
	
	dbFileModifiedTimeStamp,
	dbFileBackupTimeStamp,
	dbFileFullBackupTimeStamp		: TimeStamp;
	
	dbFileExclude,
	dbFileIsPartitioned,
	frozen,
	isRpsMappedExtent,																											// PAR 1098
	offline							: Boolean;
	
	dbFileEncryptionStatus,																										// PAR 1004
	dbFileKind,
	dbFileStatus,
	partitionStatus,
	errorCode,
	storageMode						: Integer;																					// PAR 1098

	dbFileLength,
	dbFilePartitionCount,
	partitionId,
	partitionLength					: Integer64;

	dbErrorStr,
	dbFileName,
	dbFileLocation,
	partitionLocation,
	partitionErrorStr,
	partitionName,
	resultStr,
	rpsMappingName,																												// PAR 1098
	schemaName,																													// PAR 1098
	str,
	structureName					: String;
	
	partitionModifiedTimeStamp,
	partitionBackupTimeStamp,
	partitionFullBackupTimeStamp	: TimeStamp;
	
	cc								: CnCntrl;
begin
	kc := app.myCnKarmaCntrl;
	cc := app.myCnCntrl;
	create dbFileArray transient;
	self.getAllDbFiles(dbFileArray);
	
	// RPS mapped extent structures may not be mapped but could be defined as partitioned which will cause UE 3004				// PAR 1098
	if self.sdsGetDatabaseSubrole() = SDS_SubroleRelational then																// PAR 1098
		self.rpsGetDatabaseParameters(schemaName, rpsMappingName, storageMode);													// PAR 1098
		isRpsMappedExtent := (storageMode = self.RpsStorageMode_MappedExtent);													// PAR 1098
	endif;
	
	on SystemException do self.ehHandleAnyException(exception, errorCode);
	create uniqueLocations transient;
	dbFileLocation		:= app.dbPath();
	dbFileLocation.replaceChar(CN_BACK_SLASH, CN_SLASH);

	uniqueLocations.add(dbFileLocation);							// the current system path required by default
	create ff transient;
	create dbFilePartitionedArray transient;
	create partitionNames 	transient;
	create partitionStatii	transient;
	iterPartStatus := partitionStatii.createIterator();
	if pPartitionIds <> null then
		create partitionIds transient;
		iterPartId := partitionIds.createIterator();
	endif;
	
	if pLocations <> null then
		create partitionLocations	transient;
		iterPartLocation := partitionLocations.createIterator();
	endif;
	
	if pLengths <> null then
		create partitionLengths	transient;
		iterPartLength := partitionLengths.createIterator();
	endif;
	
	if pModifiedTimeStamps <> null then
		create partitionModifiedTimeStamps transient;
		iterPartModifiedTimeStamp := partitionModifiedTimeStamps.createIterator();
	endif;
	
	if pBackupTimeStamps <> null then
		create partitionBackupTimeStamps transient;
		iterPartBackupTimeStamp := partitionBackupTimeStamps.createIterator();
	endif;
	
	if pFullBackupTimeStamps <> null then
		create partitionFullBackupTimeStamps transient;
		iterPartFullBackupTimeStamp := partitionFullBackupTimeStamps.createIterator();
	endif;
	
	if pFrozenArray <> null then
		create frozenArray transient;
		iterFrozen := frozenArray.createIterator();
	endif;
	
	if pOfflineArray <> null then
		create offlineArray transient;
		iterOffline := offlineArray.createIterator();
	endif;
	
	foreach dbFile in dbFileArray do
		dbErrorStr					:= null;
		partitionErrorStr			:= null;
		errorCode					:= null;
		dbFileName 					:= dbFile.getName();
		dbFileExclude 				:= false;
		dbFileIsPartitioned			:= false;
		dbFileEncryptionStatus		:= null;																					// PAR 1004
		dbFileLocation				:= null;
		dbFileKind					:= null;
		dbFileStatus				:= null;
		dbFileLength				:= null;
		dbFilePartitionCount		:= null;
		dbFileModifiedTimeStamp		:= null;
		dbFileBackupTimeStamp		:= null;
		dbFileFullBackupTimeStamp	:= null;
		partitionId					:= null;
		frozen						:= false;
		offline						:= false;

		dbFileExclude 				:= dbFile.excludeFromBackup;
		dbFileKind					:= dbFile.kind;
		if dbFileKind <> dbFile.Kind_Control 				and																	// PAR 700
		   (dbFileKind <> dbFile.Kind_Environmental or
		    (dbFileKind = dbFile.Kind_Environmental and 
			 not dbFileExclude))							then																// PAR 700
			if pEncryptionStatus <> null then																					// PAR 1004
				dbFileEncryptionStatus	:= dbFile.getCryptStatus();																// PAR 1004
			endif;																												// PAR 1004
			
			dbFileStatus			:= dbFile.getFileStatus();
			if errorCode <> null then
				dbErrorStr 			:= dbErrorStr & " getFileStatus UE " & errorCode.String;
				errorCode 			:= null;
			endif;
			
			dbFileLocation			:= dbFile.path.cnStripTrailingSlash();
			dbFileLocation.replaceChar(CN_BACK_SLASH, CN_SLASH);
			if errorCode = null then
				if dbFileLocation <> null and
				   not uniqueLocations.includes(dbFileLocation) then
					ff.fileName := dbFileLocation;
					if ff.isAvailable() then
						uniqueLocations.add(dbFileLocation);			// as we're going to access the File System for UDR files, don't want any duplicates
					
					else
						dbErrorStr := dbErrorStr & " path " & dbFileLocation & " not available " & dbFileName;
					endif;
				endif;
			
			else
				dbErrorStr := dbErrorStr & " path UE " & errorCode.String;
				errorCode := null;
			endif;

			if dbFileStatus = dbFile.Status_Offline then								// should only apply to _syspkgs
				offline := true;
			
			elseif dbFileStatus = dbFile.Status_Unmapped and							// should only apply to RPS structures in a mapped extent	// PAR 1098
			       isRpsMappedExtent 					 then																	// PAR 1098
				offline := true;																								// PAR 1098
				
			elseif pLengths <> null and
			    dbFileStatus = dbFile.Status_Resident then
//				dbFileLength		:= dbFile.getFileLength().Integer64;
				dbFileLength		:= dbFile.getTotalFileLength64(dbFile.GetTotLen_Base);
				if errorCode <> null then
					dbErrorStr := dbErrorStr & " getTotalFileLength64 UE " & errorCode.String;
					errorCode := null;
								
				// JADE issue if zero length but resident
				elseif dbFileLength = null then
					str := "Database structure " & dbFileName & " (oid=" & dbFile.getOidString() & 
							") has status of Resident (" & dbFileStatus.String & ") yet has zero length";
					cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " " & str, null);
					app.cnRaiseJossAlert(Cn_Karma_Alert,
										 "JADE metaschema issue",
										 str,
										 "N",
										 app.actualTime,
										 app.name,
										 kc.managedEnvironmentName,
										 kc.localFQDN,
										 kc.localIpAddress,
										 kc.myParentTcp);
				endif;
			endif;
	
			if dbFileStatus = dbFile.Status_Unmapped and																	// PAR 1098
			   isRpsMappedExtent 					 then																	// PAR 1098
				// do nothing 																								// PAR 1098
			
			else																											// PAR 1098
				dbFileIsPartitioned := dbFile.isPartitioned();
				if errorCode <> null then
					dbErrorStr := dbErrorStr & " isPartitioned UE " & errorCode.String;
					errorCode := null;
				endif;
				
				if dbFileIsPartitioned then
					dbFilePartitionedArray.add(dbFile);				// load these into array so we avoid scanning UDR details for partitions as we get partition info later
				endif;
				
				if pPartitionCounts <> null 		and
				   dbFileIsPartitioned				then
					dbFilePartitionCount := dbFile.getPartitionCount();
					if errorCode <> null then
						dbErrorStr := dbErrorStr & " partitionCount UE " & errorCode.String;
						errorCode := null;
					endif;
				endif;
			endif;																											// PAR 1098
			
			if pModifiedTimeStamps <> null then
				dbFileModifiedTimeStamp 	:= dbFile.getModifiedTimestamp();
				if errorCode <> null then
					dbErrorStr := dbErrorStr & " getModifiedTimestamp UE " & errorCode.String;
					errorCode := null;
				endif;
			endif;

			if pBackupTimeStamps <> null then
				dbFileBackupTimeStamp		:= dbFile.getBackupTimestamp();
				if errorCode <> null then
					dbErrorStr := dbErrorStr & " getBackupTimestamp UE " & errorCode.String;
					errorCode := null;
				endif;
			endif;
			
			if pFullBackupTimeStamps <> null then
				dbFileFullBackupTimeStamp	:= dbFile.getFullBackupTimestamp();
				if errorCode <> null then
					dbErrorStr := dbErrorStr & " getFullBackupTimestamp UE " & errorCode.String;
					errorCode := null;
				endif;
			endif;
			
			if pFrozenArray <> null then
				frozen := dbFile.isFrozen();
			endif;
		endif;

		pDbFiles.add(dbFile);
		pDbFileNames.add(dbFileName);
		pPartitionNames.add(null);
		pStatii.add(dbFileStatus);

		if pPartitionIds <> null then
			pPartitionIds.add(null);			// always zero for DbFile
		endif;
		
		if pKinds <> null then
			pKinds.add(dbFileKind);
		endif;

		if pLocations <> null then
			pLocations.add(dbFileLocation);
		endif;
		
		if pExcludeFromBackup <> null then
			pExcludeFromBackup.add(dbFileExclude);
		endif;
		
		if pLengths <> null then
			pLengths.add(dbFileLength);
		endif;
		
		if pUDRFileLengths <> null then
			pUDRFileLengths.add(null);
		endif;
		
		if pUDRNumberStructures <> null then
			pUDRNumberStructures.add(null);
		endif;
		
		if pIsPartitioned <> null then
			pIsPartitioned.add(dbFileIsPartitioned);
		endif;
		
		if pPartitionCounts <> null then
			pPartitionCounts.add(dbFilePartitionCount);
		endif;
		
		if pModifiedTimeStamps <> null then
			pModifiedTimeStamps.add(dbFileModifiedTimeStamp);
		endif;
		
		if pBackupTimeStamps <> null then
			pBackupTimeStamps.add(dbFileBackupTimeStamp);
		endif;
		
		if pFullBackupTimeStamps <> null then
			pFullBackupTimeStamps.add(dbFileFullBackupTimeStamp);
		endif;
		
		if pFrozenArray <> null then
			pFrozenArray.add(frozen);
		endif;
		
		if pOfflineArray <> null then
			pOfflineArray.add(offline);
		endif;

		if pEncryptionStatus <> null then																					// PAR 1075
			pEncryptionStatus.add(dbFileEncryptionStatus);																	// PAR 1075
		endif;																												// PAR 1075

		if dbFileIsPartitioned then
			// transient items have been created once at start of this method
			partitionNames.clear();
			partitionStatii.clear();
			iterPartStatus.reset();
			if pPartitionIds <> null then
				partitionIds.clear();
				iterPartId.reset();
			endif;
			
			if pLocations <> null then
				partitionLocations.clear();
				iterPartLocation.reset();
			endif;
			
			if pLengths <> null then
				partitionLengths.clear();
				iterPartLength.reset();
			endif;
			
			if pModifiedTimeStamps <> null then
				partitionModifiedTimeStamps.clear();
				iterPartModifiedTimeStamp.reset();
			endif;
			
			if pBackupTimeStamps <> null then
				partitionBackupTimeStamps.clear();
				iterPartBackupTimeStamp.reset();
			endif;
			
			if pFullBackupTimeStamps <> null then
				partitionFullBackupTimeStamps.clear();
				iterPartFullBackupTimeStamp.reset();
			endif;
			
			if pFrozenArray <> null then
				frozenArray.clear();
				iterFrozen.reset();
			endif;
			
			if pOfflineArray <> null then
				offlineArray.clear();
				iterOffline.reset();
			endif;
			
			if dbErrorStr <> null then		// we've had an exception
				resultStr := resultStr & CrLf & dbFileName & " : " & dbErrorStr;
			endif;
			
			partitionErrorStr := self.getAllPartitionInfoForDbFile(dbFile,
																	false,
																	false,
																	partitionNames,
																	partitionStatii,
																	partitionIds,
																	partitionLocations,
																	partitionLengths,
																	pUDRFileLengths, 						// partiton UDR file lengths
																	pUDRNumberStructures, 					// partiton UDR number of files
																	partitionModifiedTimeStamps,
																	partitionBackupTimeStamps,
																	partitionFullBackupTimeStamps,
																	frozenArray,
																	offlineArray);
			if partitionErrorStr <> CN_OK then
				resultStr := resultStr & partitionErrorStr & CrLf;
			endif;
		
			foreach partitionName in partitionNames do
				partitionId						:= null;
				partitionStatus					:= null;
				partitionLocation				:= null;
				partitionLength					:= null;
				partitionModifiedTimeStamp		:= null;
				partitionBackupTimeStamp		:= null;
				partitionFullBackupTimeStamp	:= null;
				iterPartStatus.next(partitionStatus);
				
				pDbFiles.add(dbFile);
				pDbFileNames.add(dbFileName);
				pPartitionNames.add(partitionName);
				pStatii.add(partitionStatus);
				if pKinds <> null then
					pKinds.add(Partition_Kind);
				endif;
				
				if pPartitionIds <> null then
					iterPartId.next(partitionId);
					pPartitionIds.add(partitionId);
				endif;
				
				if pLocations <> null then
					iterPartLocation.next(partitionLocation);
					partitionLocation.replaceChar(CN_BACK_SLASH, CN_SLASH);
					partitionLocation := partitionLocation.cnStripTrailingSlash();
					pLocations.add(partitionLocation);
				endif;
				
				if pLengths <> null then
					iterPartLength.next(partitionLength);
					pLengths.add(partitionLength);
				endif;
				
				if pModifiedTimeStamps <> null then
					iterPartModifiedTimeStamp.next(partitionModifiedTimeStamp);
					pModifiedTimeStamps.add(partitionModifiedTimeStamp);
				endif;
				
				if pBackupTimeStamps <> null then
					iterPartBackupTimeStamp.next(partitionBackupTimeStamp);
					pBackupTimeStamps.add(partitionBackupTimeStamp);
				endif;
				
				if pFullBackupTimeStamps <> null then
					iterPartFullBackupTimeStamp.next(partitionFullBackupTimeStamp);
					pFullBackupTimeStamps.add(partitionFullBackupTimeStamp);
				endif;
		
				if pFrozenArray <> null then
					iterFrozen.next(frozen);
					pFrozenArray.add(frozen);
				endif;
		
				if pOfflineArray <> null then
					iterOffline.next(offline);
					pOfflineArray.add(offline);
				endif;
		
				if pEncryptionStatus <> null then																				// PAR 1004
					// if the parent map file is defined as encrypted then this applies to all its partitions					// PAR 1004
					pEncryptionStatus.add(dbFileEncryptionStatus);																// PAR 1004
				endif;																											// PAR 1004
				
				if pExcludeFromBackup <> null then
					pExcludeFromBackup.add(false);
				endif;
		
				if pUDRFileLengths <> null then
					pUDRFileLengths.add(null);
				endif;
		
				if pIsPartitioned <> null then
					pIsPartitioned.add(false);
				endif;
		
				if pPartitionCounts <> null then
					pPartitionCounts.add(null);
				endif;
			endforeach;
		endif;
	endforeach;

	on SystemException do null;
		// interim patch to obtain size of any udr files
	if pLengths <> null or
	   pUDRFileLengths <> null then
		create structureNames transient;
		iterPartitionName := pPartitionNames.createIterator();
		// create interim list of structure names so that we can add UDR file sizes to length arrays
		foreach dbFileName in pDbFileNames do
			iterPartitionName.next(partitionName);
			structureName := dbFileName;
			if partitionName <> null then
				structureName := structureName & "_" & partitionName;
			endif;
			
			structureNames.add(structureName);
		endforeach;
		
		ff.cnGetMaskedFileLengths(uniqueLocations, "*_udr*.dat", "_udr", structureNames, pLengths, pUDRFileLengths, pUDRNumberStructures);
	endif;

	if resultStr = null then
		return CN_OK;
	endif;
	
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & resultStr, null);
	return resultStr;
epilog
	delete ff;
	delete iterPartBackupTimeStamp;
	delete iterPartFullBackupTimeStamp;
	delete iterPartId;
	delete iterPartLength;
	delete iterPartLocation;
	delete iterPartitionName;
	delete iterPartModifiedTimeStamp;
	delete iterPartStatus;
	delete iterFrozen;
	delete iterOffline;
	delete partitionNames;
	delete partitionIds;
	delete partitionStatii;
	delete partitionLocations;
	delete partitionLengths;
	delete partitionModifiedTimeStamps;
	delete partitionBackupTimeStamps;
	delete partitionFullBackupTimeStamps;
	delete frozenArray;
	delete offlineArray;
	delete dbFileArray;
	delete dbFilePartitionedArray;
	delete uniqueLocations;
	delete structureNames;
end;
}
getAllDbFileInfo
{
getAllDbFileInfo(pDbFileNames	 			: CnStringArray input;
				pDbFiles					: DbFileArray input;
				pDbFileStatus 				: IntegerArray input;
				pDbFileKind					: IntegerArray input;							// remaining items are optional
				pDbFileLocations			: CnStringArray input;							// optional
				pDbFileExcludeFromBackup	: BooleanArray input;							// optional
				pDbFileLengths				: Integer64Array input;							// optional
				pDbFileUDRFileLengths		: Integer64Array input;							// optional
				pDbFileIsPartitioned		: BooleanArray input;							// optional
				pDbFilePartitionCounts		: Integer64Array input;							// optional
				pDbFileModifiedTimeStamps	: TimeStampArray input;							// optional
				pDbFileBackupTimeStamps		: TimeStampArray input;							// optional
				pDbFileFullBackupTimeStamps	: TimeStampArray input) : String updating;		// optional
/*
	Returns database file info.
	
	Note :
	- that modified, backup and full timestamps are only flushed to the control file(s) when beginBackup has been executed.
	- that the pLengths contains the sum of the Database Structure as well as any UDR (JadeBytes) components associated with it.
*/
constants
	Status_Offline		: Integer	= DbFile.Status_Offline;

vars
	ff							: FileFolder;

	dbFileArray					: DbFileArray;
	
	dbFile						: DbFile;
	
	dbFileModifiedTimeStamp,
	dbFileBackupTimeStamp,
	dbFileFullBackupTimeStamp	: TimeStamp;
	
	structureNames				: CnStringArray;
	
	uniqueLocations				: CnStringArray;

	dbFileKind,
	dbFileStatus,
	errorCode					: Integer;

	dbFileName,
	dbFileLocation,
	location,
	resultStr,
	str,
	systemPath					: String;
	
	dbFileLength,
	dbFilePartitionCount		: Integer64;
	
	dbFileExclude,
	dbFileIsPartitioned			: Boolean;
begin
	create dbFileArray transient;
	self.getAllDbFiles(dbFileArray);
	
	systemPath := app.dbPath();
	on SystemException do self.ehHandleAnyException(exception, errorCode);
	create uniqueLocations transient;
	uniqueLocations.add(systemPath);						// the current system path required by default
	create ff transient;
	
	foreach dbFile in dbFileArray do
		str 						:= null;
		errorCode					:= null;
		dbFileName 					:= dbFile.getName();
		dbFileExclude 				:= false;
		dbFileIsPartitioned			:= false;
		dbFileLocation				:= null;
		dbFileKind					:= null;
		dbFileStatus				:= null;
		dbFileLength				:= null;
		dbFilePartitionCount		:= null;
		dbFileModifiedTimeStamp		:= null;
		dbFileBackupTimeStamp		:= null;
		dbFileFullBackupTimeStamp	:= null;

		dbFileExclude 		:= dbFile.excludeFromBackup;
		dbFileKind			:= dbFile.kind;
		if dbFileKind <> dbFile.Kind_Control then
			dbFileStatus		:= dbFile.getFileStatus();
			if errorCode <> null then
				str := str & " getFileStatus UE " & errorCode.String;
				errorCode := null;
			endif;
			
			dbFileLocation		:= dbFile.path;
			if errorCode = null then
				if dbFileLocation <> null and
				   not uniqueLocations.includes(location) then
					ff.fileName := location;
					if ff.isAvailable() then
						uniqueLocations.add(location);			// as we're going to access the File System for UDR files, don't want any duplicates
					
					else
						resultStr := resultStr & " path " & location & " not available";
					endif;
				endif;
			
				if dbFileLocation = systemPath then
					dbFileLocation := null;						// omly report back when file location not default system path
				endif;
				
			else
				str := str & " path UE " & errorCode.String;
				errorCode := null;
			endif;

			if dbFileStatus <> Status_Offline 	and					// should only apply to _syspkgs
			   pDbFileLengths <> null 			and
			   not dbFileExclude				then
				dbFileLength		:= dbFile.getFileLength().Integer64;
				if errorCode <> null then
					str := str & " getFileLength UE " & errorCode.String;
					errorCode := null;
				endif;
			endif;
	
			if pDbFileIsPartitioned <> null 	or
			   pDbFilePartitionCounts <> null 	then
				dbFileIsPartitioned := dbFile.isPartitioned();
				if errorCode <> null then
					str := str & " isPartitioned UE " & errorCode.String;
					errorCode := null;
				endif;
			endif;
			
			if pDbFilePartitionCounts <> null 	and
			   dbFileIsPartitioned				then
				dbFilePartitionCount := dbFile.getPartitionCount();
				if errorCode <> null then
					str := str & " partitionCount UE " & errorCode.String;
					errorCode := null;
				endif;
			endif;
			
			if pDbFileModifiedTimeStamps <> null then
				dbFileModifiedTimeStamp 	:= dbFile.getModifiedTimestamp();
				if errorCode <> null then
					str := str & " getModifiedTimestamp UE " & errorCode.String;
					errorCode := null;
				endif;
			endif;

			if pDbFileBackupTimeStamps <> null then
				dbFileBackupTimeStamp		:= dbFile.getBackupTimestamp();
				if errorCode <> null then
					str := str & " getBackupTimestamp UE " & errorCode.String;
					errorCode := null;
				endif;
			endif;
			
			if pDbFileFullBackupTimeStamps <> null then
				dbFileFullBackupTimeStamp	:= dbFile.getFullBackupTimestamp();
				if errorCode <> null then
					str := str & " getFullBackupTimestamp UE " & errorCode.String;
					errorCode := null;
				endif;
			endif;
		endif;

		if str <> null then		// we've had an exception
			resultStr := resultStr & dbFileName & " : " & str & CrLf;
		endif;
		
		pDbFiles.add(dbFile);
		pDbFileNames.add(dbFileName);
		pDbFileStatus.add(dbFileStatus);

		if pDbFileKind <> null then
			pDbFileKind.add(dbFileKind);
		endif;

		if pDbFileLocations <> null then
			pDbFileLocations.add(dbFileLocation);
		endif;
		
		if pDbFileExcludeFromBackup <> null then
			pDbFileExcludeFromBackup.add(dbFileExclude);
		endif;
		
		if pDbFileLengths <> null then
			pDbFileLengths.add(dbFileLength);
		endif;
		
		if pDbFileUDRFileLengths <> null then
			pDbFileUDRFileLengths.add(null);
		endif;
		
		if pDbFileIsPartitioned <> null then
			pDbFileIsPartitioned.add(dbFileIsPartitioned);
		endif;
		
		if pDbFilePartitionCounts <> null then
			pDbFilePartitionCounts.add(dbFilePartitionCount);
		endif;
		
		if pDbFileModifiedTimeStamps <> null then
			pDbFileModifiedTimeStamps.add(dbFileModifiedTimeStamp);
		endif;
		
		if pDbFileBackupTimeStamps <> null then
			pDbFileBackupTimeStamps.add(dbFileBackupTimeStamp);
		endif;
		
		if pDbFileFullBackupTimeStamps <> null then
			pDbFileFullBackupTimeStamps.add(dbFileFullBackupTimeStamp);
		endif;
	endforeach;

		// interim patch to obtain size of any udr files
	create structureNames transient;
	ff.cnGetMaskedFileLengths(uniqueLocations, "*_udr*.dat", "_udr", pDbFileNames, pDbFileLengths, pDbFileUDRFileLengths, null);

		// end of interim patch for size of UDR files
	if resultStr = null then
		return CN_OK;
	endif;
	
	return resultStr;
epilog
	delete dbFileArray;
	delete structureNames;
	delete uniqueLocations;
	delete ff;
end;
}
getAllPartitionInfoForDbFile
{
getAllPartitionInfoForDbFile(pDbFile					: DbFile;
							pGetUDRLengths				: Boolean;
							pGetUDRStructures			: Boolean;
							pPartitionNames	 			: CnStringArray input;
							pStatii						: IntegerArray input;				
							pPartitionIds				: Integer64Array input;					// optional
							pPartitionLocations			: CnStringArray input;					// optional
							pLengths					: Integer64Array input;					// optional
							pUDRFileLengths				: Integer64Array input;					// optional
							pUDRFileStructures			: Integer64Array input;					// optional
							pModifiedTimeStamps			: TimeStampArray input;					// optional
							pBackupTimeStamps			: TimeStampArray input;					// optional
							pFullBackupTimeStamps		: TimeStampArray input;					// optional
							pFrozenArray				: BooleanArray input;					// optional
							pOfflineArray				: BooleanArray input) : String;			// optional
/*
	Returns database file info.
	
	Note that the pDbFileLengths contains the sum of the DbFile as well as any UDR (JadeBytes) components associated with it.
*/
constants
	Status_Resident				: Integer	= DbFile.Status_Resident;

vars
	cc							: CnCntrl;
	
	kc							: CnKarmaCntrl;
	
	ff							: FileFolder;

	partitionArray				: JadeDbFilePartitionArray;
	
	partition					: JadeDbFilePartition;
	
	structureNames,
	uniqueLocations				: CnStringArray;

	modifiedTimeStamp,
	backupTimeStamp,
	fullBackupTimeStamp			: TimeStamp;
	
	frozen,
	offline						: Boolean;
	
	char						: Character;
	
	fileStatus,
	errorCode					: Integer;
	
	dbFileName,
	location,
	partitionName,
	resultStr,
	str,
	str2,
	structureName,
	systemPath					: String;
	
	fileLength,
	partitionId					: Integer64;
begin
	cc := app.myCnCntrl;
	kc := app.myCnKarmaCntrl;
	create partitionArray transient;
	pDbFile.getPartitions(partitionArray, null);
	
	systemPath := app.dbPath();
	on SystemException do self.ehHandleAnyException(exception, errorCode);
	create uniqueLocations transient;
	uniqueLocations.add(systemPath);

	foreach partition in partitionArray do
		str 					:= null;
		errorCode				:= null;
		partitionName 			:= partition.getName();
		partitionId				:= null;
		fileStatus				:= null;
		fileLength				:= null;
		location				:= null;
		modifiedTimeStamp		:= null;
		backupTimeStamp			:= null;
		fullBackupTimeStamp		:= null;
		frozen					:= partition.isFrozen();
		offline					:= partition.isOffline();

		fileStatus				:= partition.getFileStatus();
		if errorCode <> null then
			str := str & " getFileStatus UE " & errorCode.String;
			errorCode := null;
		endif;
		
		if fileStatus = Status_Resident then
			if pLengths <> null then
				fileLength			:= partition.getFileLength();
				if errorCode <> null then
					str := str & " getFileLength UE " & errorCode.String;
					errorCode := null;
				
				elseif fileLength = null then
					str2 := "Database structure " & partitionName & " (oid=" & partition.getOidString() & 
							") has status of Resident (" & fileStatus.String & ") yet has zero length";
					cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " " & str2, null);
					app.cnRaiseJossAlert(Cn_Karma_Alert,
										 "JADE metaschema issue",
										 str2,
										 "N",
										 app.actualTime,
										 app.name,
										 kc.managedEnvironmentName,
										 kc.localFQDN,
										 kc.localIpAddress,
										 kc.myParentTcp);
				endif;				
			endif;
			
			if pPartitionLocations <> null 	or
			   pGetUDRLengths				then
				location			:= partition.getLocation();
				if errorCode = null then
					location.replaceChar(CN_BACK_SLASH, CN_SLASH);
					char := location[location.length()];
					if char = CN_SLASH then
						location := location[1:(location.length() - 1)];
					endif;
					
					if not uniqueLocations.includes(location) then
						uniqueLocations.add(location);
					endif;

				else
					str := str & " path UE " & errorCode.String;
					errorCode := null;
				endif;
				
				if location = systemPath then
					location := null;							// only report where file location not default system path
				endif;
			endif;
		endif;

		if pModifiedTimeStamps <> null then
			modifiedTimeStamp 		:= partition.getModifiedTimestamp();
			if errorCode <> null then
				str := str & " getModifiedTimestamp UE " & errorCode.String;
				errorCode := null;
			endif;
		endif;

		if pBackupTimeStamps <> null then
			backupTimeStamp			:= partition.getBackupTimestamp();
			if errorCode <> null then
				str := str & " getBackupTimestamp UE " & errorCode.String;
				errorCode := null;
			endif;
		endif;
		
		if pFullBackupTimeStamps <> null then
			fullBackupTimeStamp		:= partition.getFullBackupTimestamp();
			if errorCode <> null then
				str := str & " getFullBackupTimestamp UE " & errorCode.String;
				errorCode := null;
			endif;
		endif;

		if str <> null then		// we've had an exception
			resultStr := resultStr & partitionName & " : " & str & CrLf;
		endif;
		
		pPartitionNames.add(partitionName);
		pStatii.add(fileStatus);
		if pPartitionIds <> null then
			pPartitionIds.add(partition.partitionID);
		endif;
		
		if pPartitionLocations <> null then
			pPartitionLocations.add(location);
		endif;
		
		if pLengths <> null then
			pLengths.add(fileLength);
		endif;
		
		if pUDRFileLengths <> null then
			pUDRFileLengths.add(null);
		endif;
		
		if pUDRFileStructures <> null then
			pUDRFileStructures.add(null);
		endif;
		
		if pModifiedTimeStamps <> null then
			pModifiedTimeStamps.add(modifiedTimeStamp);
		endif;
		
		if pBackupTimeStamps <> null then
			pBackupTimeStamps.add(backupTimeStamp);
		endif;
		
		if pFullBackupTimeStamps <> null then
			pFullBackupTimeStamps.add(fullBackupTimeStamp);
		endif;
		
		if pFrozenArray <> null then
			pFrozenArray.add(frozen);
		endif;
		
		if pOfflineArray <> null then
			pOfflineArray.add(offline);
		endif;
	endforeach;

		// interim patch to obtain size of any udr files
	if pGetUDRLengths or
	   pGetUDRStructures then
		if pLengths <> null or
		   pUDRFileLengths <> null or
		   pUDRFileStructures <> null then
			create structureNames transient;
			dbFileName := pDbFile.getName();
			foreach partitionName in pPartitionNames do
				structureName := dbFileName & "_" & partitionName;
				structureNames.add(structureName);
			endforeach;

			ff.cnGetMaskedFileLengths(uniqueLocations, "*_udr*.dat", "_udr", structureNames, pLengths, pUDRFileLengths, pUDRFileStructures);
		endif;
	endif;
		// end of interim patch for size of UDR files
	
	if resultStr = null then
		return CN_OK;
	endif;
	
	return resultStr;
epilog
	delete ff;
	delete uniqueLocations;
	delete structureNames;																										// PAR 746
	if partitionArray <> null then
		partitionArray.purge();
		delete partitionArray;
	endif;
end;
}
getDatabaseDetailsSendAdvice
{
getDatabaseDetailsSendAdvice();

vars
	cc						: CnCntrl;
	
	excludeFromBackup,
	frozenArray,
	offlineArray			: BooleanArray;
	
	dbFileNames,
	locationArray,
	partitionNames			: CnStringArray;

	dbFileArray				: DbFileArray;

	fileStatus,
	encryptionStatus		: IntegerArray;																						// JSM PAR 7050
	
	fileLengths,
	partitionIds,
	udrLengths,
	udrStructures			: Integer64Array;
	
	result					: String;
begin
	cc			:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " Getting database structure details....", null);
	create dbFileNames 				transient;
	create partitionNames			transient;
	create dbFileArray				transient;
	create fileStatus 				transient;
	create fileLengths 				transient;
	create locationArray			transient;
	create partitionIds				transient;
	create udrLengths				transient;
	create udrStructures			transient;
	create frozenArray				transient;
	create offlineArray				transient;
	create excludeFromBackup		transient;
	create encryptionStatus			transient;																					// JSM PAR 7050
	result := self.getAllDatabaseStructureInfo(dbFileNames,
												partitionNames,
												dbFileArray,
												fileStatus,
												partitionIds,					// partition ids
												null, 							// kind
												locationArray,					// location
												excludeFromBackup,
												fileLengths,
												udrLengths,						// UDR file lengths
												udrStructures,					// Number of UDR structures associated
												encryptionStatus,				// Encryption status							// PAR 1004, JSM PAR 7050
												null,							// DbFile is partitioned
												null,							// dbfile partition count
												null,							// dbfile modified timestamp
												null,							// dbfile backup timeStamp
												null,							// dbfile full backup timeStamp
												frozenArray,
												offlineArray);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " Got database structure details, number of structures " & dbFileNames.size64().userNumberFormat($CnWholeNumbers), null);
	
	self.sendDatabaseDetailsAdvice(dbFileNames,
									partitionNames,
									fileStatus,
									encryptionStatus,																			// JSM PAR 7050
									partitionIds,
									fileLengths,
									udrLengths,
									udrStructures,
									locationArray,
									frozenArray,
									offlineArray,
									excludeFromBackup);
									
epilog
	delete dbFileArray;
	delete dbFileNames;
	delete partitionNames;
	delete fileStatus;
	delete fileLengths;
	delete locationArray;
	delete frozenArray;
	delete offlineArray;
	delete excludeFromBackup;
	delete udrLengths;
	delete udrStructures;
	delete partitionIds;
end;
}
sendDatabaseDetailsAdvice
{
sendDatabaseDetailsAdvice(	pDbFileNames,
							pPartitionNames			: CnStringArray;
							pFileStatus,
							pEncryptionStatus		: IntegerArray;																// JSM PAR 7050
							pPartitionIds,
							pFileLengths,
							pUDRLengths,
							pUDRStructures			: Integer64Array;
							pLocationArray			: CnStringArray;
							pFrozenArray,
							pOfflineArray,
							pExcludeFromBackup		: BooleanArray);

constants
	Status_Resident		: Integer	= DbFile.Status_Resident;
	Status_Offline		: Integer	= DbFile.Status_Offline;
vars
	cc						: CnCntrl;

	kc						: CnKarmaCntrl;
	
	tmsg, 
	newmsg					: CnMessage;

	msg						: CnFileDetailsAdvice;
	
	excludeFromBackup,
	frozen,
	isPartitioned,
	offline					: Boolean;
	
	fileType				: Character;
	
	fileEncrptionStatus,																										// JSM PAR 7050
	fileStatus				: Integer;

	partitionId,
	structureLength,
	udrLength,
	udrStructures			: Integer64;
	
	iterExcludeFromBackup,
	iterFrozen,
	iterLength,
	iterLocation,
	iterOffline,
	iterPartitionId,
	iterPartitionName,
	iterStatus,
	iterUDRLength,
	iterUDRStructures,
	iterEncryptionStatus	: Iterator;																							// JSM PAR 7050
	
	dbFileName,
	location,
	partitionName,
	structureName			: String;
begin
	cc			:= app.myCnCntrl;
	kc			:= app.myCnKarmaCntrl;

	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " sending database file details advice", null);
	create tmsg transient;
	tmsg.createNewMsg(tmsg.Advice,
					  tmsg.File_Details_Advice,
					  kc.localFQDN,
					  kc.localIpAddress,
					  cc.KCCMgr_Process,
					  cc.JossCommsMgr_Process,
					  newmsg);
					  
	msg		:= newmsg.CnFileDetailsAdvice;
	msg.setAdviceType(msg.Advice_Type_FileDet_DbData);

	iterExcludeFromBackup	:= pExcludeFromBackup.createIterator();
	iterFrozen				:= pFrozenArray.createIterator();
	iterOffline				:= pOfflineArray.createIterator();
	iterStatus				:= pFileStatus.createIterator();
	iterLength				:= pFileLengths.createIterator();
	iterLocation			:= pLocationArray.createIterator();
	iterPartitionName		:= pPartitionNames.createIterator();
	iterPartitionId			:= pPartitionIds.createIterator();
	iterUDRLength			:= pUDRLengths.createIterator();
	iterUDRStructures		:= pUDRStructures.createIterator();
	iterEncryptionStatus	:= pEncryptionStatus.createIterator();																// JSM PAR 7050
	
	foreach dbFileName in pDbFileNames do
		iterExcludeFromBackup.next(excludeFromBackup);
		iterStatus.next(fileStatus);
		iterLength.next(structureLength);
		iterUDRLength.next(udrLength);
		iterUDRStructures.next(udrStructures);
		iterLocation.next(location);
		iterPartitionId.next(partitionId);
		iterPartitionName.next(partitionName);
		iterFrozen.next(frozen);
		iterOffline.next(offline);
		iterEncryptionStatus.next(fileEncrptionStatus);																			// JSM PAR 7050
		structureName := dbFileName;
		
		// we're not interested in items that are exclude from backup
		if excludeFromBackup then
			continue;
		endif;
		
		if fileStatus <> Status_Resident and
		   fileStatus <> Status_Offline  then
			continue;
		endif;
		
		if partitionName <> null then
			structureName := structureName & "_" & partitionName;
		endif;
		
		if partitionId = null then
			fileType := "D";
		
		else
			fileType := "P";
		endif;

		executeWhen Cn_Debug_FileDetails;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & structureName & " partitionID=" & partitionId.String & ", fileType=" & fileType, null);
		endExecuteWhen;
		
		msg.addItemDbData(location, 
							structureName,
							fileStatus,
							fileEncrptionStatus,																				// JSM PAR 7050
							fileType,
							partitionId,
							structureLength,
							udrLength,
							udrStructures,
							frozen,
							offline);
	endforeach;
	
	msg.sendMessage(kc.myParentTcp); 
epilog
	delete iterExcludeFromBackup;
	delete iterLocation;
	delete iterPartitionName;
	delete iterStatus;
	delete iterLength;
	delete iterPartitionId;
	delete iterUDRLength;
	delete iterUDRStructures;
	delete iterFrozen;
	delete iterOffline;
	delete iterEncryptionStatus;																								// JSM PAR 7050
	
	delete msg;
	delete tmsg;
end;
}
setAbortRequested
{
setAbortRequested(set : Boolean) updating;

vars

begin
	self.abortRequested := set;
end;
}
setBackupDir
{
setBackupDir(dir : String) updating;

vars

begin
	backupDir	:= dir;
end;
}
setCompress
{
setCompress(set : Boolean) updating;

vars

begin
	self.compress := set;
end;
}
setQuiesce
{
setQuiesce(set : Boolean) updating;

vars

begin
	quiesce := set;
end;
}
	)
	CnJadeDatabaseAdminExternal (
	jadeMethodSources
getConnectionState
{
getConnectionState();

vars
	dba			: JadeDatabaseAdmin;
	jdo			: JadeDynamicObject;
	exitCode	: Integer;
	state		: Integer;
begin
	create dba transient;
	create jdo transient;

	dba.sdsGetMyServerInfo(jdo);
	state			:= jdo.getPropertyValue("connectionState").Integer;
	if state = SDS_Connected then
		exitCode	:= 0;

	else
		exitCode	:= 10;
	endif;
	
	beginTransaction;
	node.userExitCode	:= exitCode;
	commitTransaction;
epilog
	delete dba;
	delete jdo;
end;
}
getTrackingStatus
{
getTrackingStatus(param : String) updating;
/*
	Param = 'R'
		request tracking stopped reason
		reason -1	- unknown
				0	- tracking again
				x	- tracking halt reason
				
	Param = 'H'
		request reason for RPS Admin Halt
		reason -1 	- unknown
				0	- tracking
				x	- tgracking halt reason
			  90x	- RPS Admin Halt reason

*/
vars
	dba			: JadeDatabaseAdmin;
	jdo			: JadeDynamicObject;
	tracking	: Boolean;
	reason		: Integer;
	exitCode	: Integer;
	errorCode	: Integer;
begin
	on SystemException do self.handleSystemExceptions(exception, errorCode);
	create dba transient;
	create jdo transient;
	dba.sdsGetMyServerInfo(jdo);
	tracking	:= jdo.getPropertyValue("tracking").Boolean;
	if errorCode <> null then
		return;
	endif;
	
	if tracking then
		reason		:= 0;							// tracking
	
	else
		reason		:= jdo.getPropertyValue("reasonTrackingStopped").Integer;
		if errorCode <> null then
			return;
		endif;
		
		if reason = 0 then
			reason	:= -1;							// tracking stopped, reason unknown
		endif;
	endif;
	
	if param = "R" then								// requested tracking stopped reason
		exitCode	:= reason;
		return;
	endif;
	
	if param = "H" then							// get RPS admin halt code
		if tracking then
			exitCode	:= 0;						// not applicable to tracking stopped status
			return;
		endif;
		
		if reason = SDS_ReasonRpsReorgHalt then // check reason is still RPS Admin Halt
			exitCode	:= jdo.getPropertyValue("rpsTransitionHaltCode").Integer + 900;
			return;
		endif;
			
											// tracking halt reason must have changed
		exitCode	:= reason;				// return the new tracking halt reason
		return;
	endif;
	
epilog
	if errorCode <> null then
		if errorCode < 9 then
			exitCode := -1;
		
		else
			exitCode := errorCode;
		endif;
	endif;

	beginTransaction;
	node.userExitCode	:= exitCode;
	commitTransaction;

	delete dba;
	delete jdo;
end;
}
getVersionedOrReorgState
{
getVersionedOrReorgState();
/*
	Purpose:
	
	Details provided by PARs 65686/65862.
	
	Identify whether or not the database is in a partially completed reorg state or versioned
	
	// exitcode values:
	//	0 - not versioned or pending transition
	//	1 - one or more schemas are versioned
	//	2 - in partial reorg state waiting for transition.

*/
constants
	ExitCode_NotVersioned				: Integer	= 0;
	ExitCode_Versioned					: Integer	= 1;
	ExitCode_ReorgPendingTransition		: Integer	= 2;
vars
	cem							: CnExternalMethods;
	
	fx							: CnFunctionAgent;
	
	obj							: Object;
	
	objSet						: ObjectSet;
	
	reorgIsWaitingForTransition	: Boolean;
	
	exitCode,
	schemasVersionedCount		: Integer;
	
	schemasVersioned,
	str							: String;
begin
	create cem transient;
	// "_reorgIsWaitingForTransition" is currently an unpublished method
	reorgIsWaitingForTransition	:= rootSchema.sendMsg("_reorgIsWaitingForTransition").Boolean;			// refer to PAR 65686
	if reorgIsWaitingForTransition then
		exitCode				:= ExitCode_ReorgPendingTransition;
		str 					:= "Reorg is Waiting For Transition" & CrLf;
		return;
	endif;
	
	// 
	create fx transient;
	create objSet transient;
	fx.getAllSchemas(objSet);
	foreach obj in objSet do
		// "_isVersioned" is currently an unpublished method
		if obj.sendMsg("_isVersioned").Boolean then
			schemasVersioned 	:= schemasVersioned & "- " & obj.Schema.name & CrLf;
			schemasVersionedCount := schemasVersionedCount + 1;
		endif;
	endforeach;
	
	if schemasVersionedCount = null then
		exitCode 				:= ExitCode_NotVersioned;
		str 					:= "No schemas versioned, database not waiting for transition" & CrLf;
	
	else
		exitCode				:= ExitCode_Versioned;
		str 					:= schemasVersionedCount.String & " schemas versioned:" & CrLf & schemasVersioned;
	endif;
	
epilog
	beginTransaction;
	node.userExitCode			:= exitCode;
	commitTransaction;
	cem.emSendStdOut(str);
	delete cem;
	delete fx;
	delete objSet;
end;
}
handleSystemExceptions
{
handleSystemExceptions(pExObj : Exception; pErrorCode : Integer output) : Integer;

vars

begin
	pErrorCode := pExObj.errorCode;
	return Ex_Resume_Next;
end;
}
restartRpsDataPump
{
restartRpsDataPump() updating;

vars

begin
	self.rpsStartDataPump(null, null);
end;
}
	)
	CnSDSDatabaseAdmin (
	jadeMethodSources
cnSDSStructureState_Check
{
cnSDSStructureState_Check();

vars
	cc						: CnCntrl;
	
	fx						: CnFunctionAgent;
	
	cndba					: CnJadeDatabaseAdmin;
	
	dbFileExcludeFromBackup,
	dbFrozenArray,
	dbOfflineArray			: BooleanArray;
	
	dbFileNames,
	partitionNames			: CnStringArray;
	
	dbFileArray				: DbFileArray;
	
	dbFileStatus 			: IntegerArray;
	
	partitionIds			: Integer64Array;
	
	result					: String;
begin
	cc := app.myCnCntrl;
	create cndba transient;
	create dbFileNames 				transient;
	create partitionNames			transient;
	create partitionIds				transient;
	create dbFileArray				transient;
	create dbFileExcludeFromBackup 	transient;
	create dbFileStatus 			transient;
	create dbFrozenArray			transient;
	create dbOfflineArray			transient;
	result := cndba.getAllDatabaseStructureInfo(dbFileNames,
												partitionNames,
												dbFileArray,
												dbFileStatus,
												partitionIds,
												null, 						// dbfile kind
												null,						// locations
												dbFileExcludeFromBackup, 
												null,						// dbFile Lengths, 
												null,						// dbFile UDR Lengths,
												null,						// dbFile UDR Structures,
												null,						// dbFile encryption status							// PAR 1004
												null,						// dbFile Is Partitioned,
												null,						// dbfile partition count
												null,						// dbfile modified timestamp
												null,						// dbfile backup timeStamp
												null,						// dbfile full backup timeStamp
												dbFrozenArray,
												dbOfflineArray);
	if result <> CN_OK then
		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : problem encountered trying to obtain database structure info, result=" & result, null);
		return;
	endif;
	
	create fx transient;
	fx.cnSDSStructureStatePrimUpdate(dbFileNames, dbFileStatus, partitionIds, dbFileExcludeFromBackup, dbFrozenArray, dbOfflineArray);
epilog
	delete fx;
	delete dbFileNames;
	delete partitionNames;
	delete partitionIds;
	delete dbFileArray;
	delete dbFileExcludeFromBackup;
	delete dbFileStatus;
	delete dbFrozenArray;
	delete dbOfflineArray;
	delete cndba;
end;
}
create
{
create() updating;

vars

begin
	create self.myJdo transient;
end;
}
delete
{
delete() updating;

vars

begin
	delete self.myJdo;
end;
}
doCommand
{
doCommand(pCommand : String) updating;

vars
	
begin
	if pCommand = Cn_Cmd_Disconnect then
		self.zSDSDisconnect();
		
	elseif pCommand = Cn_Cmd_StopTracking then
		self.zSDSStopTracking();
		
	elseif pCommand = Cn_Cmd_Reconnect then
		self.zSDSConnect();
		
	elseif pCommand = Cn_Cmd_ResumeTracking then			
		self.zSDSStartTracking();								
		
	elseif pCommand = Cn_Cmd_Stop_KCCMgr then
		self.zStopKCCMgr();											
		
	else
		app.cnRaiseNormalException(Cn_SDS_Exception, method.cnGetMethodName(), "Invalid command '" & pCommand & "'", null);
	endif;
end;
}
getConnectionState
{
getConnectionState() : Integer updating;

vars
	jdo			: JadeDynamicObject;
	
	hadError	: Boolean;
begin
	jdo		:= self.myJdo;
	if not self.sdsIsRunning then
		return SDS_Disconnected;		// SDS is not running so treat as disconnected.
	endif;
	
	on SystemException do app.cnGenericExceptionHandler(exception, JErr_SdsNotInitialized, null, hadError);
	self.sdsGetMyServerInfo(jdo);
	if hadError then
		return SDS_Disconnected;		// SDS has not initialized so treat as disconnected
	endif;
	
	return jdo.getPropertyValue("connectionState").Integer;
end;
}
getConnectionStateString
{
getConnectionStateString(pConnectionState : Integer) : String;

vars

begin
	if pConnectionState = SDS_Connected then
		return "connected";
	
	elseif pConnectionState = SDS_Connecting then
		return "connecting";
	
	elseif pConnectionState = SDS_ConnectionFailed then
		return "connection failed";
	
	elseif pConnectionState = SDS_Disconnected then
		return "disconnected";
	
	else
		return "<unknown : " & pConnectionState.String & ">";
	endif;
end;
}
getDatabaseRoleString
{
getDatabaseRoleString(pDatabaseRole : Integer) : String;

vars

begin
	if pDatabaseRole = SDS_RoleUndefined then
		return "Non-SDS";
	endif;
	
	if pDatabaseRole = SDS_RolePrimary then
		return "SDS Primary";
	endif;
	
	if pDatabaseRole = SDS_RoleSecondary then
		return "SDS Secondary";
	endif;
	
	return "Role unknown : " & pDatabaseRole.String;
end;
}
getDatabaseSubroleString
{
getDatabaseSubroleString(pDatabaseSubrole : Integer) : String;

vars

begin
	if pDatabaseSubrole = SDS_SubroleRelational then
		return "Relational";
	endif;
	
	if pDatabaseSubrole = SDS_SubroleNative then
		return "Native";
	endif;
	
	return "Subrole unknown : " & pDatabaseSubrole.String;
end;
}
getLastErrorCode
{
getLastErrorCode() : Integer updating;

vars
	jdo		: JadeDynamicObject;
	noSDS	: Boolean;
begin
	jdo		:= self.myJdo;
	
	on SystemException do app.cnGenericExceptionHandler(exception, JErr_SdsNotInitialized, null, noSDS);
	self.sdsGetMyServerInfo(jdo);
	if noSDS then
		return null;
	endif;
	
	return jdo.getPropertyValue("lastErrorCode").Integer;
end;
}
getMapFileInfo
{
getMapFileInfo(pMapFileNameArray : CnStringArray input; pMapFileSizeArray : Integer64Array input);

vars
	dbFile					: DbFile;

	cndba 					: CnJadeDatabaseAdmin;
	
	part,
	result,
	dbFileName				: String;
	
	dbFileNames,
	partitionFileNames		: CnStringArray;
	
	dbFileArray				: DbFileArray;
	
	dbFileExcludeFromBackup,
	dbFilePartitioned		: BooleanArray;
	
	dbFileStatus			: IntegerArray;
	
	dbFileLengths,
	partitionLengths		: Integer64Array;
	
	iterDbFile,
	iterExclude,
	iterStatus,
	iterLength,
	iterPartitioned,
	iterPartLength			: Iterator;
	
	fileExclude,
	partitioned				: Boolean;
	
	fileStatus				: Integer;
	
	fileSize,
	partLength				: Integer64;
begin
	create cndba transient;
	create dbFileNames 				transient;
	create dbFileArray				transient;
	create dbFileExcludeFromBackup 	transient;
	create dbFileStatus 			transient;
	create dbFileLengths 			transient;
	create dbFilePartitioned		transient;
	create partitionFileNames		transient;
	create partitionLengths			transient;
	result := cndba.getAllDbFileInfo(	dbFileNames, 						
										dbFileArray,
										dbFileStatus, 
										null,
										null,
										dbFileExcludeFromBackup, 
										dbFileLengths, 
										null,
										dbFilePartitioned,
										null,
										null,
										null,
										null);
	
	iterDbFile				:= dbFileArray.createIterator();
	iterStatus				:= dbFileStatus.createIterator();
	iterExclude				:= dbFileExcludeFromBackup.createIterator();
	iterLength				:= dbFileLengths.createIterator();
	iterPartitioned 		:= dbFilePartitioned.createIterator();
	iterPartLength			:= partitionLengths.createIterator();		
	foreach dbFileName in dbFileNames do
		iterDbFile.next(dbFile);
		iterStatus.next(fileStatus);
		iterExclude.next(fileExclude);		
		iterLength.next(fileSize);
		iterPartitioned.next(partitioned);
		
		if fileExclude then
			continue;
		endif;
		
		if fileStatus <> DbFile.Status_Resident then
			continue;
		endif;
		
		if fileStatus = DbFile.Status_Unmapped then	// database may be an RPS working-set or mapped extent
			continue;
		endif;
		
		if fileSize = null then
			continue;
		endif;
		
		if partitioned then
			partitionFileNames.purge();
			partitionLengths.purge();
			cndba.getAllPartitionInfoForDbFile(	dbFile,
												true,
												true,
												partitionFileNames,
												null,
												null,
												null,
												partitionLengths,
												null,
												null,
												null,
												null,
												null,
												null,
												null);
			iterPartLength.reset();						
			foreach part in partitionFileNames do
				iterPartLength.next(partLength);
				fileSize := fileSize + partLength;
			endforeach;	
			
		endif;
		
		pMapFileNameArray.add(dbFileName);
		pMapFileSizeArray.add(fileSize);
	endforeach;	
epilog
	delete cndba;
	delete dbFileArray;
	delete dbFileNames;
	delete dbFileExcludeFromBackup;
	delete dbFileStatus;
	delete dbFileLengths;
	delete dbFilePartitioned;
	delete partitionFileNames;
	delete partitionLengths;
	delete iterDbFile;
	delete iterExclude;
	delete iterStatus;
	delete iterLength;
	delete iterPartitioned;
	delete iterPartLength;	
end;
}
getRPSParameters
{
getRPSParameters(pSchemaName, pRPSMappingName : String output; pRPSStorageMode : Integer output);

vars
	databaseRole,
	databaseSubrole	: Integer;
	
	
begin
	//	Full 			= 0		RpsStorageMode_Full
	//	Mapped Extent	= 1		RpsStorageMode_MappedExtent
	//	Working Set		= 2		RpsStorageMode_WorkingSet
	//	Not RPS node	= -1	User defined value - not known
	pRPSStorageMode := -1;
	databaseRole := system.getDatabaseRole();
	if databaseRole <> SDS_RoleSecondary then
		return;
	endif;
	
	databaseSubrole := system.getDatabaseSubrole();
	if databaseSubrole <> SDS_SubroleRelational then
		return;
	endif;
	
	self.rpsGetDatabaseParameters(pSchemaName, pRPSMappingName, pRPSStorageMode);
end;
}
getRPSStorageModeString
{
getRPSStorageModeString(pSchemaName, pRPSMappingName : String output; pRPSStorageMode : Integer io) : String;
/*
	Method can be used in two modes:
	
	- the value can be passed in and evaluated and string value returned.
	- the value entered can be less than zero in which case the RPS storage mode for this system is returned along with the string value.
	
	Assumptions:
	- that user has already ensured that the database is an RPS node.
*/
vars
	rpsStorageMode	: Integer;
	
	str				: String;
begin
	rpsStorageMode := pRPSStorageMode;
	if rpsStorageMode < null then
		rpsStorageMode := -1;
		self.rpsGetDatabaseParameters(pSchemaName, pRPSMappingName, rpsStorageMode);
		pRPSStorageMode := rpsStorageMode;
	endif;
	
	if rpsStorageMode = self.RpsStorageMode_Full then
		str := "Full Extent";
	
	elseif rpsStorageMode = self.RpsStorageMode_MappedExtent then
		str := "Mapped Extent";
		
	elseif rpsStorageMode = self.RpsStorageMode_WorkingSet then
		str := "Working Set";
		
	else
		str := rpsStorageMode.String & " (Not Applicable)";
	endif;
	
	return str;
end;
}
getRpsTransitionHaltCodeStr
{
getRpsTransitionHaltCodeStr(reason : Integer) : String;

vars

begin
	if reason = RPS_HaltNoScript then			// 0
		return "Schema changes do not affect RDB so no script was generated.";
		
	elseif reason = RPS_HaltAutoScript then		// 1
		return "An auto initiate alter script was generated and will be auto loaded by data pump if configured for auto-restart.";
		
	elseif reason = RPS_HaltManualScript then	// 2
		return "A manual table alter script was generated.  Requires RDB admin to apply changes before tracking can be resumed.";
		
	elseif reason = RPS_HaltMappingDeleted then	// 3
		return "RPS mapping was deleted on primary database, rendering the RPS node and RDB defunct.";
		
	elseif reason = -1 then
		return "Not applicable";				// -1 = not applicable.  
		//										// Note that zero is a valid value when reasonTrackingStopped = RPS_SchemaTransition 
	else
		return "Unrecognized halt code";
	endif;		
end;
}
getRpsWorkers
{
getRpsWorkers() : Integer updating;

vars
	jdo				: JadeDynamicObject;
	
	notInitialized	: Boolean;
begin
	jdo		:= self.myJdo;
	on SystemException do app.cnGenericExceptionHandler(exception, JErr_SdsNotInitialized, self, notInitialized);
	self.sdsGetMyServerInfo(jdo);
	if notInitialized then
		return -1;
	endif;
	
	return jdo.getPropertyValue("rpsWorkers").Integer;
end;
}
getTracking
{
getTracking(pTrackingStoppedReason, pRpsTransitionHaltCode : Integer output) : Boolean updating;

vars	
	cc			: CnCntrl;

	jdo			: JadeDynamicObject;
	
	tracking	: Boolean;
	
	msg			: String;																										// PAR 1104
begin
	cc			:= app.myCnCntrl;
	jdo			:= self.myJdo;
	self.sdsGetMyServerInfo(jdo);
	if jdo.type <> SDS_SecondaryType then																						// PAR 1104
		pTrackingStoppedReason := SDS_ReasonTakeover;																			// PAR 1104
		pRpsTransitionHaltCode := -1;																							// PAR 1104
		tracking := false;																										// PAR 1104
		msg := "No longer SDS Secondary role;";																					// PAR 1104
		return tracking;																										// PAR 1104
	endif;																														// PAR 1104
	
	msg := "SDS Secondary role;";																								// PAR 1104
	tracking	:= jdo.getPropertyValue("tracking").Boolean;
	
	if not tracking then
		pTrackingStoppedReason		:= jdo.getPropertyValue("reasonTrackingStopped").Integer;
		if pTrackingStoppedReason = SDS_ReasonRpsReorgHalt then
			pRpsTransitionHaltCode	:= jdo.getPropertyValue("rpsTransitionHaltCode").Integer;
		else
			pRpsTransitionHaltCode	:= -1;		// -1 = not applicable.  
			//									// Note that zero is a valid value when reasonTrackingStopped = RPS_SchemaTransition 
		endif;
	else
		pTrackingStoppedReason		:= 0;
		pRpsTransitionHaltCode		:= -1;
	endif;
	
	return tracking;
epilog																															// PAR 1104
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : " & msg & " tracking=" & tracking.String & 						// PAR 1104
								", trackingStoppedReason=" & pTrackingStoppedReason.String &									// PAR 1104
								", rpsTransitionHaltCode=" & pRpsTransitionHaltCode.String, null);								// PAR 1104
end;
}
getTrackingDisabled
{
getTrackingDisabled() : Boolean updating;

vars
	jdo		: JadeDynamicObject;
	noSDS	: Boolean;
begin
	jdo		:= self.myJdo;
	
	on SystemException do app.cnGenericExceptionHandler(exception, JErr_SdsNotInitialized, null, noSDS);
	self.sdsGetMyServerInfo(jdo);
	if noSDS then
		return true;
	endif;
	
	return jdo.getPropertyValue("trackingDisabled").Boolean;
end;
}
getTrackingStoppedReasonStr
{
getTrackingStoppedReasonStr(reason : Integer) : String;

vars

begin
	if reason = SDS_ReasonAdminAudited then									// 1
		return "AdminAudited - Audited by JadeSDSAdmin";
			
	elseif reason = SDS_ReasonAdminDirect then								// 2
		return "AdminDirect - Programmatic call to sdsStopTracking";
		
	elseif reason = SDS_ReasonRpsSnapshot then								// 3
		return "Audited for RPS Snapshot";

	elseif reason = SDS_ReasonRpsAdminHalt then								// 4
		return "RPS Admin Halt - Data pump has been stopped";
		
	elseif reason = SDS_ReasonTransition then								// 5
		return "Schema Transition";
		
	elseif reason = SDS_ReasonAutoUpgradeMismatch then						// 6
		return "Auto upgrade version mismatch";
		
	elseif reason = SDS_ReasonTakeover then									// 7
		return "System takeover initiated";
		
	elseif reason = SDS_ReasonErrorHalt then								// 8
		return "Tracking halted on error";
		
	elseif reason = SDS_ReasonRpsReorgHalt then								// 9
		return "RPS reorg halt - may require admin intervention";
			
	elseif reason = SDS_ReasonRestart then 									// 10 - available in JADE 6.3.05 SDS_ReasonRestart
		return "Tracking restarted following connection loss";

	elseif reason = SDS_ReasonRpsRestart then 								// 11 - available in JADE 6.3.05 SDS_ReasonRpsRestart
		return "RPS halt - replication is stopped for a non structural transition";

	elseif reason = SDS_ReasonDeltaModeEntered then 						// 12 - available in JADE 6.3.07 SDS_ReasonDeltaModeEntered
		return "Tracking stopped - database in delta mode";		
		
	elseif reason = SDS_ReasonEnablingDbCrypt then							// 13 - available in JADE 7.0.06 SDS_ReasonEnablingDbCrypt
		return "Tracking stopped - enabling database encryption";		

		//  JADCare reasons
	
	elseif reason = SDS_ReasonDeploymentStart then							// 100
		return "Start of deployment indicator";
		
	elseif reason = SDS_ReasonEndJadeUpgrade then							// 101
		return "JADE upgrade phase completed";
		
	elseif reason = SDS_ReasonEndUserSchemaLoad then						// 102
		return "Load of one or more user schemas completed";
		
	elseif reason = SDS_ReasonDeploymentEnd then							// 109
		return "End of deployment indicator found";
		
	//

	elseif reason = null then
		return "0";
		
	else
		return "<Unknown> (" & reason.String & ")";
	endif;
end;
}
initializeKCCMgr
{
initializeKCCMgr() updating;

/*
	Purpose :
	Arm appropriate notifications for SDS environment. If we're not SDS'ed then
	these notifications will never be caused.
	
	This method only invoked if we are:
	- Application CardSchema,KCCMgr 				- in CardSchema::CnKarmaCntrl::create
	- Application JossControl,JossGeneralEventMgr	- in JossControl::GeneralEventMgr::initializeJSM
*/

vars
	cc					: CnCntrl;

	role,
	subRole				: Integer;	
begin
									
	app.setMyCnSDSDbAdmin(self);
	cc				:= app.myCnCntrl;
	role			:= system.getDatabaseRole();
	subRole			:= system.getDatabaseSubrole();

	if cc.appName = CN_KCCMGR then
		self.zGetIniFileSettings();
		self.zGetIniFileCheckInterval();
	endif;
	
	if cc.karmaControl then					// only turn on SDS structure state replication if KarmaControl=true
		self.zCnSDSStructureState_Setup();	// subscribe to CnSDSStructureState changes if TRUE in initialisation file
	endif;
	
	self.beginNotification(system, SDS_RoleChangeEvent,			Response_Continuous, null);
	self.beginNotification(system, SDS_RoleChangeProgress, 		Response_Continuous, null);
	if role = SDS_RoleSecondary then
		beginNotification(system, SDS_ConnectionStateChange, 	Response_Continuous, 0);										// PAR 958
		beginNotification(system, SDS_JournalTransferStopped, 	Response_Continuous, 0);
		beginNotification(system, SDS_TrackingStarted, 			Response_Continuous, 0);
		beginNotification(system, SDS_TrackingStopped, 			Response_Continuous, 0);			// stopped or disabled by command or audit entry
		beginNotification(system, SDS_TrackingHalted, 			Response_Continuous, 0);			// halted due to error  
		
		if subRole = SDS_SubroleRelational then
			beginNotification(system, RPS_SchemaTransition, 	Response_Continuous, 0);		// RPS Admin Halt : this event provides info about table alter script handling
		endif;
	endif;
	
	//////////////  If SDS is running we now complete the setup of this object  //////
	if self.sdsIsRunning() then
		self.updateSelf();
		cc.cnWriteLog(cc.CnLogComment, "SDS is running : CnSDSDatabaseAdmin object now correctly formed.", null);
		
	elseif role = SDS_RoleUndefined then
		cc.cnWriteLog(cc.CnLogComment, "SDS not running : this is not an SDS system.", null);
		
	else
		cc.cnWriteLog(cc.CnLogComment, "SDS not yet running : CnSDSDatabaseAdmin object not yet fully initialized.", null);
	endif;

	if role <> SDS_RoleUndefined 	and
	   cc.appName = CN_KCCMGR	then
		self.beginTimer(5 * 1000, Timer_OneShot, CN_CHECK_SDSCHECKSREQUIRED);					// start check in 5 secs so we're not initializing
	endif;
end;
}
initializeKCSDSChecks
{
initializeKCSDSChecks() updating;
/*
	Purpose :
	Refer to JADECare Start PAR #964.
	Move the handling of SDS Checks (lagging) into separate thread from KCCMgr so as to avoid
	potential 60 sec timeout when executing JadeDatabaseAdmin.sdsGetSecondaryInfo.
	
	While the latter only impacts the SDS primary, we've move the SDS Secondary lagging checks
	into the same application, KCSDSChecks
	
	This method only invoked if we are:
	- Application CardSchema,KCSDSChecks 			- in CardSchema::CnKarmaCntrl::create
	- Application JossControl,JossGeneralEventMgr	- in JossControl::GeneralEventMgr::initializeJSM

*/
vars
	cc					: CnCntrl;
	
	iniMaxLagTime		: Integer;	
	
	str					: String;
begin
									
	app.setMyCnSDSDbAdmin(self);
	cc				:= app.myCnCntrl;
	self.zGetIniFileSettings();
	self.zGetIniFileCheckInterval();
	self.zGetIniFileMaxLagTime(null, iniMaxLagTime);
	if self.checkInterval > null then
		beginTimer(self.checkInterval * 1000, Timer_OneShot, self.SDS_Check_Timer);
		beginNotification(system, SDS_TrackingStarted, 			Response_Continuous, 0);										// PAR 1059
		beginNotification(system, SDS_ConnectionStateChange, 	Response_Continuous, 0);										// PAR 1059
		str	:= "SDS check timer has been started : SDSCheckInterval=" & self.checkInterval.String & ", SDSMaxLagTime=" & iniMaxLagTime.String;

	elseif cc.appName = CN_KCSDSCHECKS then
		str	:= "SDS check timer not armed : SDSCheckInterval=0, terminating ...";
		app.cnTerminate();
	
	else
		str	:= "SDS check timer not armed : SDSCheckInterval=0";
	endif;
epilog
	cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " " & str, null);
end;
}
sdsExceptionHandler
{
sdsExceptionHandler(exObj : SystemException) : Integer subschemaHidden;

vars
	cc	: CnCntrl;
begin
	if exObj.errorCode = 3015 or				// database role change in progress
	   exObj.errorCode = 3079 then				// database locked for archive backup			
		cc	:= app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogErrors, ">>> Exception " & exObj.errorCode.String & " (" & exObj.text &
					  ") in CnSdsDatabaseAdmin - will discard this transaction / check cycle.  <<<<", null);
		abortTransaction;
		return Ex_Abort_Action;
	
	else
		return Ex_Pass_Back;
	endif;	 
end;
}
sendSDSAdviceMsg
{
sendSDSAdviceMsg(pAdviceType 				: String;
				 pTracking					: Boolean;
				 pTrackingStoppedReason		: Integer;
				 pRpsTransitionHaltCode		: Integer;
				 pText 						: String; 
				 pRaiseAlert 				: Boolean) updating;

vars
	cc						: CnCntrl;
	
	kc						: CnKarmaCntrl;

	tmsg, newmsg			: CnMessage;

	msg						: CnSDSAdvice;
	
	propertyError,
	trackingDisabled		: Boolean;																							// PAR 593
	
	databaseRole,																												// PAR 593
	databaseSubrole,																											// JSM PAR 5299
	connectionState			: Integer;
begin
	cc			:= app.myCnCntrl;
	kc			:= app.myCnKarmaCntrl;

	// when a takeover occurs, the tracking state change is handled but the database role
	// can be changing while trying to get the tracking status. If this occurs a 1011 (Cn_RequestedPropertyNotDefined)
	// will be invoked and we need to handle this correctly.
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_RequestedPropertyNotDefined, null, propertyError);
	while true do
		connectionState := self.getConnectionState();
		databaseRole := system.getDatabaseRole();																					// PAR 593
		if databaseRole = SDS_RolePrimary then																						// PAR 593
			trackingDisabled := false;																								// PAR 593
			
		else																														// PAR 593
			trackingDisabled := self.getTrackingDisabled();																			// PAR 593
			if databaseRole = SDS_RoleSecondary then																				// JSM PAR 5299
				databaseSubrole := system.getDatabaseSubrole();																		// JSM PAR 5299
			endif;																													// JSM PAR 5299
		endif;																														// PAR 593
		
		if not propertyError then
			break;
		endif;
		
		app.doWindowEvents(0);
		propertyError := false;
	endwhile;
	
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " sending SDS Advice type " 	& pAdviceType &
														" databaseRole=" 			& databaseRole.String &
														", databaseSubrole=" 		& databaseSubrole.String &
														", connectionState="		& connectionState.String &
														", tracking=" 				& pTracking.String &
														", trackingDisabled=" 		& trackingDisabled.String &
														", trackingStoppedReason=" 	& pTrackingStoppedReason.String & 
														", rpsTransitionHaltCod=" 	& pRpsTransitionHaltCode.String &
														", text='" 					& pText & "'", null);
	create tmsg transient;
	tmsg.createNewMsg(tmsg.Advice,
					  tmsg.SDS_Advice,
					  kc.localFQDN,
					  kc.localIpAddress,
					  cc.KCCMgr_Process,
					  cc.JossCommsMgr_Process,
					  newmsg);
					  
	msg		:= newmsg.CnSDSAdvice;
	msg.setAdviceType(pAdviceType);
	msg.setConnectionState(connectionState);
	msg.setDatabaseRole(databaseRole);
	msg.setDatabaseSubrole(databaseSubrole);
	msg.setText(pText);
	msg.setSdsTracking(pTracking);
	msg.setSdsLastErrorCode(getLastErrorCode);
	msg.setSdsTrackingDisabled(trackingDisabled);																				// PAR 593
	msg.setSdsTrackingStoppedReason(pTrackingStoppedReason);
	msg.setRpsTransitionHaltCode(pRpsTransitionHaltCode);
	msg.setRaiseAlert(pRaiseAlert);
	msg.sendMessage(kc.myParentTcp); 
	
epilog
	delete msg;
	delete tmsg;	
end;
}
sysNotification
{
sysNotification(eventType: Integer; theObject: Object; eventTag: Integer) updating;

vars
	cc : CnCntrl;
begin
	cc := app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : event=" & eventType.String & ", theObject=" & theObject.getOidString(), null);	
	if eventTag = Cn_SDSStructureState_Class then
		if eventType = Object_Create_Event then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : CnSDSStructureState class contains a new object (" & theObject.String & "), replicating change...", null);
			
		elseif eventType = Object_Update_Event then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : CnSDSStructureState class contains an updated object (" & theObject.String & "), replicating change...", null);
			
		endif;
		self.zCnSDSStructureState_Change(theObject);
	endif;
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;

vars
	cc				: CnCntrl;
	
	fx				: CnFunctionAgent;
	
	proc			: Process;																									// PAR 964
	
	oldInterval,																												// JSM PAR 6577
	option,																														// PAR 964
	timeRemaining	: Integer;																									// PAR 964
begin
	cc	:= app.myCnCntrl;
	if eventTag = self.SDS_Check_Timer then
		oldInterval	:= self.checkInterval;																						// JSM PAR 6577
		self.zGetIniFileCheckInterval();
		if oldInterval <> self.checkInterval then																				// JSM PAR 6577
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : SDSCheckInterval changed to " & self.checkInterval.String, null);	// JSM PAR 6577
		endif;																													// JSM PAR 6577
		
		on SystemException do sdsExceptionHandler(exception);
		if self.checkInterval > null then
			self.zDoChecks();
		endif;

		if self.checkInterval > null then
			self.beginTimer(self.checkInterval * 1000, Timer_OneShot, SDS_Check_Timer);
			
		elseif cc.appName = CN_KCSDSCHECKS then																					// PAR 964
			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : SDS check timer not required, terminating...", null);	// PAR 964
			app.cnTerminate();																									// PAR 964
		
		else
			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : SDS check timer has been STOPPED.", null);	
		endif;

		return;
	endif;	

	if eventTag = self.Stop_Tracking_Timer 		or
	   eventTag = self.Start_Tracking_Timer 	or
	   eventTag = self.Disconnecting_Timer		or
	   eventTag = self.Reconnecting_Timer 		then
		self.zCnSDSConnectionTrackingChecks(eventTag);
		return;
	endif;
	
	if eventTag = Cn_SDSStructureState_Class then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " executing timer for Cn_SDSStructureState_Class", null);
		self.cnSDSStructureState_Check();					// check current database structure state and update the CnSDSStructureState class as required
		self.beginTimer((self.replayStructFreq * 60 * 1000), Timer_OneShot, eventTag);
		return;
	endif;
	
	if eventTag = Cn_SDSStructure_Sync_Request then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " Cn_SDSStructure_Sync_Request (" & Cn_SDSStructure_Sync_Request.String & ") request executing ....", null);
		create fx transient;
		fx.cnSDSStructureState_Sync();
		return;
	endif;
	
	// timer below (CN_CHECK_SDSCHECKSREQUIRED) will only be running in application CardSchema,KCCMgr							// PAR 964
	// when database is SDS Primary or SDS Secondary.																			// PAR 964
	
	// timer to ensure that KCSDSChecks is running if the check interval is not zero											// PAR 964
	// if its not running then we start it up.																					// PAR 964
	if eventTag = CN_CHECK_SDSCHECKSREQUIRED then																				// PAR 964
		if app.isMultiUser() then																								// PAR 1006
			self.zGetIniFileCheckInterval();																					// PAR 964
			// if check interval is specified then start up KCSDSChecks 														// PAR 964
			// application if not already running																				// PAR 964
			if self.checkInterval <> null then																					// PAR 964
				if node.cnCheckApplicationAlreadyRunningInNode(CnKCSDSChecks) then												// PAR 964, 1065
					cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " check interval=" & self.checkInterval.String &		// PAR 964
																			" " & CN_KCSDSCHECKS & 								// PAR 964
																			" already running", null);							// PAR 964
				
				else
					app.startApplication(CN_CARDSCHEMA, CN_KCSDSCHECKS);														// PAR 964
					cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " check interval=" & self.checkInterval.String &		// PAR 964
																			" " & CN_KCSDSCHECKS & " not running" &				// PAR 964
																			", started up " & CN_KCSDSCHECKS, null);			// PAR 964

				endif;																											// PAR 964
				
			else																												// PAR 964
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " check interval=" & self.checkInterval.String &			// PAR 964
																			" " & CN_KCSDSCHECKS & " not required", null);		// PAR 964
			endif;																												// PAR 964
			
			if not self.getTimerStatus(CN_CHECK_SDSCHECKSREQUIRED, option, timeRemaining) then									// PAR 964
				self.beginTimer(self.Interval_To_Check_Check_Interval, Timer_Continuous, CN_CHECK_SDSCHECKSREQUIRED);			// PAR 964
			endif;																												// PAR 964
		endif;																													// PAR 1006										
		
		return;																													// PAR 964
	endif;
	
	cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " unexpected timer event " & eventTag.String, null);
epilog
	delete fx;
end;
}
updateSelf
{
updateSelf() updating;

vars
	jdo		: JadeDynamicObject;
begin
	if not self.sdsIsRunning() then
		return;
	endif;
	
	jdo									:= self.myJdo;
	self.sdsGetMyServerInfo(myJdo);
	self.myName							:= jdo.getPropertyValue("myName").String;
	
	if system.getDatabaseRole = SDS_RoleSecondary then
		self.syncMode					:= jdo.getPropertyValue("syncMode").Integer;
		self.connectionCheckInterval	:= jdo.getPropertyValue("connectionCheckInterval").Integer;
	endif;
end;
}
userNotification
{
userNotification(eventType: Integer; theObject: Object; eventTag: Integer; userInfo: Any) updating;

vars
	cc				: CnCntrl;
	
	functionAgent	: CnFunctionAgent;																							// PAR 1003
	
	tx				: CnTransactionAgent;
	
	cnSDSdba		: CnSDSDatabaseAdmin;
	
	jdo				: JadeDynamicObject;
	
	connName,
	str			: String;
begin
	cc	:= app.myCnCntrl;

	if eventType = SDS_RoleChangeEvent then						// 22
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : eventType=" & eventType.String & " (SDS_RoleChangeEvent), userInfo=" & userInfo.String, null);
		self.zHandleRoleChangeEvent(userInfo);
		return;
	endif;
	
	if eventType = SDS_RoleChangeProgress then					// 17387
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : eventType=" & eventType.String & " (SDS_RoleChangeProgress), userInfo=" & userInfo.String, null);
		create functionAgent transient;																							// PAR 1003
		functionAgent.cnHandleRoleChangeProgressEvent(userInfo.Integer, self.inTakeoverState, self.hostileTakeover);			// PAR 1003
		return;
	endif;
	
	if eventType = SDS_ConnectionStateChange then				// 17386
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : eventType=" & eventType.String & " (SDS_ConnectionStateChange), userInfo=" & userInfo.String, null);
		if app.name = CN_KCCMGR then																							// PAR 1059
			self.zHandleConnectionStateChange(userInfo);																		
			return;																												// PAR 1059
		endif;																													// PAR 1059
		
		if app.name = CN_KCSDSCHECKS then																						// PAR 1059
			self.zHandleConnectionStateChange_SDSChecks(userInfo);																// PAR 1059
			return;																												// PAR 1059
		endif;																													// PAR 1059
	endif;
	
	if eventType = SDS_JournalTransferStopped then				// 17385 : 6.1 should only happen if connection error
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : eventType=" & eventType.String & " (SDS_JournalTransferStopped), userInfo=" & userInfo.String, null);
		self.zRaiseAlert("Journal transfer to this secondary has halted due to error " & userInfo.Integer.String &
					" (" & app.cnGetErrorText(userInfo.Integer) & ").");
		return;
	endif;
	
	if eventType = SDS_TrackingStarted 	or						// 17389						
	   eventType = SDS_TrackingHalted 	or						// 17390 : always an error situation, refer to error code
	   eventType = SDS_TrackingStopped 	or						// 17388 : actually simply 'tracking stopped' : for reason see SDSStopTrackingCodes in RootSchema global constants
	   eventType = RPS_SchemaTransition then					// 220
	    if eventType = SDS_TrackingStarted 	then				// 17389						
			if app.name = CN_KCSDSCHECKS then																					// PAR 1059
				// if we're in KCSDSChecks then if tracking has started we don't want to wait till the check interval			// PAR 1059
				// expires before we clear outstanding alerts																	// PAR 1059
				self.zCheckTracking_SDSChecks();																				// PAR 1059
				return;																											// PAR 1059
			endif;																												// PAR 1059
			
			str := "(SDS_TrackingStarted)";
		
		elseif eventType = SDS_TrackingHalted 	then			// 17390 : always an error situation, refer to error code
			str := "(SDS_TrackingHalted)";
			
		elseif eventType = SDS_TrackingStopped 	then			// 17388 : actually simply 'tracking stopped' : for reason see SDSStopTrackingCodes in RootSchema global constants
			str := "(SDS_TrackingStopped)";
			
		else
			str := "(RPS_SchemaTransition)";
		endif;
		
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : eventType=" & eventType.String & " " & str & ", userInfo=" & userInfo.String, null);
		self.zHandleTrackingStateChange(eventType, userInfo);
		return;
	endif;
	
	if eventType = Cn_SDS_Structure_State_Delete then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : eventType=" & eventType.String & " (Cn_SDS_Structure_State_Delete),", null);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : CnSDSStructureState SDS Primary database deletion notification received, replicating change...", null);
		self.zCnSDSStructureState_Online(userInfo.String);
		return;
	endif;
	
	if eventType = Cn_SDS_PreTakeOver_Request then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : eventType=" & eventType.String & " (Cn_SDS_PreTakeOver_Request).", null);
		create cnSDSdba transient;
		create jdo transient;
		cnSDSdba.sdsGetMyServerInfo(jdo);
		connName := jdo.getPropertyValue("myName").String;
		create tx transient;
		tx.sdsCauseEventCommon(connName); // send acknowledgement
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : " & connName & " issued response to PreTakeOver Request.", null);
		return;
	endif;
	
	cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " : unexpected event, eventType=" & eventType.String & ", userInfo=" & userInfo.String, null);
epilog
	delete functionAgent;																										// PAR 1003
	delete cnSDSdba;
	delete jdo;
	delete tx;
end;
}
zCheckConnection
{
zCheckConnection(pTracking, pConnected : Boolean) subschemaHidden, updating, protected;
/*
	>>>>> BE AWARE <<<<<<<
	The short and long text of these alerts CANNOT be changed without also modifying the details in 
	JSM's AlertCtl::processKarmaTrap which ignores these alerts while a deployment is happening
*/
vars
	cc			: CnCntrl;

	kc			: CnKarmaCntrl;
	
	status		: Character;
	
	raiseAlert	: Boolean;
	
	nodeTypeStr,
	str,
	str2		: String;
	
	now,
	whenRaised	: TimeStamp;
begin
	//  Used by KCSDSChecks on secondary
	cc		:= app.myCnCntrl;
	kc		:= app.myCnKarmaCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : pConnected=" & pConnected.String & ", connectionAlertTimestamp=" & self.connectionAlertTimestamp.String, null);
	// >>>>> DO NOT CHANGE <<<< following 5 lines without also changing Joss::AlertCtl::processKarmaTrap
	str		:= Cn_SDSConnectionAlert & " for " & kc.environmentId.toUpper & " on " & app.cnComputerName;
	if app.cnDatabaseSubrole = SDS_SubroleRelational then
		nodeTypeStr	:= "RPS server ";
		
	else
		nodeTypeStr	:= "SDS secondary ";
	endif;	
	
	if self.connectionAlertTimestamp <> null then
		whenRaised	:= self.connectionAlertTimestamp;
		raiseAlert	:= true;
		if pConnected then
			status	:= "C";
			str2	:= nodeTypeStr & "now connected to primary,";
			if not pTracking then
				str2	:= str2 & " currently not tracking.";
				
			else
				str2	:= str2 & " tracking enabled.";
			endif;
			
			self.connectionAlertTimestamp	:= null;
			
		else	
			status	:= "R";
			// DO NOT CHANGE following without also changing Joss::AlertCtl::processKarmaTrap
			str2	:= "Repeat alert : " & nodeTypeStr & "not connected to primary";
/*
			// if not connected, then following message serves to confuse as
			// while tracking function is still working, as the connection is
			// down, no new journals are being made available for tracking to
			// function against.
			if not pTracking then
				str2	:= str2 & ", and not tracking";
			else
				str2	:= str2 & ", still tracking.";
			endif;
*/
		endif; 	

	elseif not pConnected and self.connectionAlertTimestamp = null then
		self.connectionAlertTimestamp	:= now;
		whenRaised	:= now;
		status		:= "N";
		raiseAlert	:= true;
		// DO NOT CHANGE following without also changing Joss::AlertCtl::processKarmaTrap
		str2		:= nodeTypeStr & "is not connected to primary";
/*		if not pTracking then
			str2	:= str2 & ", and not tracking";
		else
			str2	:= str2 & ", still tracking.";
		endif;
*/	endif;
	
	if raiseAlert then
		app.cnRaiseJossAlert(Cn_Karma_Alert
							 ,str
							 ,str2
							 ,status
							 ,whenRaised
							 ,cc.appName
							 ,kc.managedEnvironmentName																			// JSM PAR 8367M
							 ,app.cnComputerName
							 ,kc.localIpAddress
							 ,null);
	endif;		
end;
}
zCheckLagTime
{
zCheckLagTime(pLagSeconds : Integer; pStableTs : TimeStamp; pReplayTs : TimeStamp) subschemaHidden, updating, protected;

vars
	cc				: CnCntrl;

	kc				: CnKarmaCntrl;
	
	raiseAlert		: Boolean;

	status			: Character;
	
	iniMaxLagTime 	: Integer;
	
	computer,
	envId,
	str				: String;
	
	now,
	whenRaised		: TimeStamp;
begin
	cc	:= app.myCnCntrl;
	self.zGetIniFileMaxLagTime(null, iniMaxLagTime);
	if iniMaxLagTime = null then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : replay lag not checked : SDSMaxLagTime is zero.", null);
		return;
	endif;

	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : checking replay lag : " &
									" lag seconds " & pLagSeconds.String &
									", stable TS " & pStableTs.date().userFormat($CnDDMMYY) & " " & pStableTs.time().userFormat($CnHHMMSS) & "." & pStableTs.time().milliSecond().String &
									", replay TS " & pReplayTs.date().userFormat($CnDDMMYY) & " " & pReplayTs.time().userFormat($CnHHMMSS) & "." & pReplayTs.time().milliSecond().String, null);
	kc := app.myCnKarmaCntrl;
	
	if pLagSeconds > iniMaxLagTime then
		raiseAlert	:= true;
		if self.lagTimeAlertTimestamp = null then
			status	:= "N";
			self.lagTimeAlertTimestamp	:= now;
			
		else
			status	:= "R";
		endif;
		
		whenRaised	:= self.lagTimeAlertTimestamp;
		str		:= Cn_SDSSecondaryLagsPrimary & " by " & pLagSeconds.String & " seconds. " &
				   "(latestStableAuditTimestamp at secondary is " & pStableTs.String & 
				   ", database SyncMode=BlockWrite).";
				   
	elseif self.lagTimeAlertTimestamp <> null then
		raiseAlert				:= true;
		whenRaised				:= self.lagTimeAlertTimestamp;
		self.lagTimeAlertTimestamp	:= null;
		status					:= "C";
		str						:= "SDS secondary now replaying within parameters.";
	endif;
	
	if raiseAlert then
		envId := kc.managedEnvironmentName;																						// JSM PAR 8367
		computer := app.cnComputerName;
		app.cnRaiseJossAlert(Cn_Karma_Alert
							,Cn_SDSDelayedReplay & " for " & envId.toUpper() & " on " & computer
							,str
							,status
							,whenRaised
							,cc.appName
							,envId
							,computer
							,kc.localIpAddress
							,null);
	endif;
end;
}
zCheckReadyJournalNo
{
zCheckReadyJournalNo(jdo : JadeDynamicObject) subschemaHidden, updating, protected;

vars
	journalNo	: Integer;
	now			: TimeStamp;
	whenRaised	: TimeStamp;
	status		: Character;
	str, str2	: String;
	cc			: CnCntrl;
	kc			: CnKarmaCntrl;
	raiseAlert	: Boolean;
	
begin
	cc			:= app.myCnCntrl;
	kc			:= app.myCnKarmaCntrl;
	journalNo	:= zGetReadyJournalNo(jdo);
	
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : CnSdsAdmin::replayJournalAlertTimestamp=" & replayJournalAlertTimestamp.String, null);
	str			:= "SDS secondary ready journal alert for " & kc.environmentId.toUpper & " on " & app.cnComputerName;
	
	if replayJournalAlertTimestamp <> null then
		whenRaised	:= replayJournalAlertTimestamp;
		raiseAlert	:= true;
	
		if journalNo > 0 then
			status	:= "C";
			str2	:= "Journal transfer to secondary has resumed.";
			replayJournalAlertTimestamp	:= null;
		else	
			status	:= "R";
			str2	:= "Repeat alert : SDS secondary latest ready journal number is zero - waiting for first journal."; 
		endif; 	

	elseif journalNo = 0 and replayJournalAlertTimestamp = null then
		replayJournalAlertTimestamp	:= now;
		whenRaised	:= now;
		status		:= "N";
		raiseAlert	:= true;
		str2		:= "SDS secondary latest ready journal number is zero - waiting for first journal.";
	endif;
	
	if raiseAlert then
		app.cnRaiseJossAlert(Cn_Karma_Alert
							 ,str
							 ,str2
							 ,status
							 ,whenRaised
							 ,cc.appName
							 ,kc.managedEnvironmentName																			// JSM PAR 8367
							 ,app.cnComputerName
							 ,kc.localIpAddress
							 ,null);
	endif;		
end;
}
zCheckRetryCount
{
zCheckRetryCount(msg : String) : Boolean updating, protected;

vars
	kc		: CnKarmaCntrl;
begin
	if not retryNo > Max_Retries then
		retryNo	:= retryNo + 1;
		return true;
	else
		kc	:= app.myCnKarmaCntrl;
		zRaiseAlert(msg & " operation did not complete within defined retry window.  Investigate and fix.");
		connectionOperation	:= 0;
		trackingOperation	:= 0;
		return false;
	endif;
end;
}
zCheckSynchronicity
{
zCheckSynchronicity(state : Integer) subschemaHidden, updating, protected;

vars
	cc			: CnCntrl;
	kc			: CnKarmaCntrl;
	status		: Character;
	whenRaised	: TimeStamp;
	str, str2	: String;
	now			: TimeStamp;
	raiseAlert	: Boolean;
begin
	cc		:= app.myCnCntrl;
	kc		:= app.myCnKarmaCntrl;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : checking replay lag (SyncMode=JournalSwitch) ...", null);
	str2	:= kc.sdsGetStateString(state);
	
	if state <> SDS_StateSynchronized then
		raiseAlert	:= true;
		if lagTimeAlertTimestamp <> null then
			status		:= "R";
			whenRaised	:= lagTimeAlertTimestamp;
		else
			status	:= "N";
			lagTimeAlertTimestamp	:= now;
			whenRaised				:= now;
		endif;
		
		str		:= Cn_SDSSecondaryNotSynchronised & " : current state is " & str2 & 
				   ". (Database SyncMode=JournalSwitch).";
				   
	elseif lagTimeAlertTimestamp <> null then
		raiseAlert				:= true;
		whenRaised				:= lagTimeAlertTimestamp;
		lagTimeAlertTimestamp	:= null;
		status					:= "C";
		str						:= "SDS secondary now replaying within parameters.";
	endif;
	
	if raiseAlert then
		app.cnRaiseJossAlert(Cn_Karma_Alert
							,Cn_SDSDelayedReplay & " for " & kc.environmentId.toUpper & " on " & app.cnComputerName
							,str
							,status
							,whenRaised
							,cc.appName
							,kc.managedEnvironmentName																			// JSM PAR 8367
							,app.cnComputerName
							,kc.localIpAddress
							,null);
	endif;
end;
}
zCheckTracking
{
zCheckTracking(pTracking, pTrackingDisabled, pConnected : Boolean; pTrackingStoppedReason, pRpsTransitionHaltCode : Integer) subschemaHidden, updating, protected;

vars
	cc				: CnCntrl;
	
	kc				: CnKarmaCntrl;
	
	file			: File;

	deployRunning,
	raiseAlert		: Boolean;
	
	status			: Character;

	pos				: Integer;

	nodeTypeStr,
	path,
	str, 
	str2			: String;
	
	now,
	whenRaised		: TimeStamp;
begin
	//  If we get here then tracking is disabled.
	
	cc		:= app.myCnCntrl;
	kc		:= app.myCnKarmaCntrl;
	path := app.cnGetServerMiscPath();
	
	create file transient;																										// PAR 812
	file.mode := file.Mode_Input;																								// PAR 812
	file.fileName := path & "/deploy.htm";																						// PAR 812
	deployRunning := file.isAvailable() or																						// PAR 812
					 pTrackingStoppedReason = SDS_ReasonDeploymentStart;														// PAR 964
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : tracking=" & pTracking.String & 
															", trackingDisabled=" & pTrackingDisabled.String &
															", trackingAlertTimestamp=" & self.trackingAlertTimestamp.String &
															", deployRunning=" & deployRunning.String, null);					// PAR 812, 964
	str		:= "SDS tracking alert for " & kc.environmentId.toUpper & " on " & app.cnComputerName;
	if app.cnDatabaseSubrole = SDS_SubroleRelational then
		nodeTypeStr 	:= "RPS server ";
		
	else
		nodeTypeStr		:= "SDS secondary ";
	endif;
	
	if self.trackingAlertTimestamp <> null then
		whenRaised	:= trackingAlertTimestamp;
		raiseAlert	:= true;
		if pTracking then
			status	:= "C";
			str2	:= "Now tracking again ";
			if not pConnected then
				str2	:= str2 & "but not connected.";
			else
				str2	:= str2 & "and connected.";
			endif;
			
			self.trackingAlertTimestamp	:= null;
			
		else	
			status	:= "R";
			str2	:= "Repeat alert : " & nodeTypeStr & "is " & Cn_SDSTrackingAlert & " "; 									// PAR JSM 7552
			
			if not pConnected then
				str2	:= str2 & "and not connected.";
				
			elseif pTrackingDisabled then
				str2	:= str2 & ": connected, but tracking is disabled.";
				
			else
				str2	:= str2 & " : connected, but tracking has been stopped : reason=" & pTrackingStoppedReason.String & " (" &
						   getTrackingStoppedReasonStr(pTrackingStoppedReason) & ")";
				if pTrackingStoppedReason = SDS_ReasonRpsReorgHalt then
					str2	:= str2 & ", rpsTransitionHaltCode=" & pRpsTransitionHaltCode.String & " (" & 
							   getRpsTransitionHaltCodeStr(pRpsTransitionHaltCode) & ")";
				endif;
			endif;
		endif; 	

	elseif not pTracking 											and
	   self.trackingAlertTimestamp 	= null 							then
		self.trackingAlertTimestamp	:= now;																						// PAR 812
		whenRaised	:= now;
		status		:= "N";
		raiseAlert	:= true;
		str2		:= nodeTypeStr & "is " & Cn_SDSTrackingAlert & " ";															// PAR JSM 7552
		if not pConnected then
			str2	:= str2 & "and not connected.";
			
		elseif pTrackingDisabled then
			str2	:= ": connected, but tracking is disabled.";
			
		else
			str2	:= str2 & "connected, but tracking has been stopped : reason=" & pTrackingStoppedReason.String & 
					   " (" & getTrackingStoppedReasonStr(pTrackingStoppedReason) & ")";
			if system.getDatabaseSubrole = SDS_SubroleRelational and
			   pTrackingStoppedReason = RPS_SchemaTransition then
				str2	:= str2 & ", rpsTransitionHaltCode=" & pRpsTransitionHaltCode.String &
						   getRpsTransitionHaltCodeStr(pRpsTransitionHaltCode) & ").";
						   
			else
				str2	:= str2 & ".";
			endif;
		endif;
	endif;
	
	if raiseAlert then
		if status <> "C" and			// not clear, ie we're going to create or repeat an alert								// PAR 964
		   deployRunning then																									// PAR 964
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " suppressed alert as deploy in progress : short desc '" & str & "', long desc '" & str2 & "'", null);
			return;
		endif;
		
		app.cnRaiseJossAlert(Cn_Karma_Alert
							 ,str
							 ,str2
							 ,status
							 ,whenRaised
							 ,cc.appName
							 ,kc.managedEnvironmentName																			// JSM PAR 8367
							 ,app.cnComputerName
							 ,kc.localIpAddress
							 ,null);
	endif;
epilog
	delete file;
end;
}
zCheckTracking_SDSChecks
{
zCheckTracking_SDSChecks() subschemaHidden, updating, protected;
/*
	Purpose :
	
	When executing SDS Checks (at SDSCheckInterval ini setting), the connection and tracking status can change between SDS Check Interval.
	This will ensure that any 'SDS tracking alert' is cleared as soon as possible rather than waiting till timer fires.
*/
vars
	cc				: CnCntrl;
	
	kc				: CnKarmaCntrl;
	
	connected		: Boolean;
	
	longText, 
	shortText		: String;
begin
	//  If we get here then tracking is disabled.
	if self.trackingAlertTimestamp = null then
		return;
	endif;
	
	cc				:= app.myCnCntrl;
	kc				:= app.myCnKarmaCntrl;
	shortText		:= "SDS tracking alert for " & kc.environmentId.toUpper & " on " & app.cnComputerName;
	longText		:= "Now tracking again ";
	if self.getConnectionState() = SDS_Connected then
		longText	:= longText & "and connected.";
		
	else
		longText	:= longText & "but not connected.";
	endif;
	
	app.cnRaiseJossAlert(Cn_Karma_Alert,
						 shortText,
						 longText,
						 "C",					// Clear
						 self.trackingAlertTimestamp,
						 cc.appName,
						 kc.managedEnvironmentName,																				// JSM PAR 8367
						 app.cnComputerName,
						 kc.localIpAddress,
						 null);
	self.trackingAlertTimestamp	:= null;
end;
}
zCnSDSConnectionTrackingChecks
{
zCnSDSConnectionTrackingChecks(pEventTag : Integer) updating, protected;

vars
	cc						: CnCntrl;
	
	tracking				: Boolean;
	
	rpsTransitionHaltCode,
	trackingStoppedReason	: Integer;
	
	nodeTypeStr,
	str						: String;
begin
	cc	:= app.myCnCntrl;
	if self.sdsGetDatabaseRole() = SDS_RolePrimary then
		nodeTypeStr	:= "SDS primary";
	
	else
		if app.cnDatabaseSubrole = SDS_SubroleRelational then
			nodeTypeStr	:= "RPS server";
		else
			nodeTypeStr	:= "SDS secondary";
		endif;
	endif;
	
	if pEventTag = self.Stop_Tracking_Timer then
		tracking	:= self.getTracking(trackingStoppedReason, rpsTransitionHaltCode);
	
		if tracking then							// still tracking
			if not self.zCheckRetryCount("Stop Tracking") then
				return;				// retries exceeded
			endif;
			
			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : still waiting for tracking to stop...", null);
			
		else
			str		:= "Tracking has now stopped as commanded.";
			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : " & str, null);
			self.sendSDSAdviceMsg(CnMessage.Advice_Type_SDS_Status, tracking, trackingStoppedReason, rpsTransitionHaltCode, str, false);	
			self.trackingOperation	:= null;
			return;
		endif;
	endif;
	
		
	if pEventTag = self.Start_Tracking_Timer then
		tracking	:= self.getTracking(trackingStoppedReason, rpsTransitionHaltCode);
		if tracking then						// now tracking
			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : tracking has now resumed.", null);
			self.sendSDSAdviceMsg(CnMessage.Advice_Type_SDS_Status, tracking, trackingStoppedReason, rpsTransitionHaltCode, "Tracking has now resumed.", false);	
			self.trackingOperation	:= null;
			return;
		endif;
		
		if not self.zCheckRetryCount("Resume Tracking") then
			return;										// retries exceeded
		endif;

		cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : still waiting for tracking to resume...", null);
	endif;
	
	if pEventTag = self.Disconnecting_Timer then
		if self.getConnectionState() <> SDS_Disconnected then
			if not self.zCheckRetryCount("Disable Primary Connection") then
				return;										// retries exceeded
			endif;

			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : still waiting for this " & nodeTypeStr & " to disconnect...", null);
			
		else
			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : this " & nodeTypeStr & " has now disconnected from its primary.", null);
			connectionOperation	:= 0;
			return;
		endif;
	endif;
		
	if pEventTag = self.Reconnecting_Timer then
		if self.getConnectionState <> SDS_Connected then
			if not self.zCheckRetryCount("Reconnect " & nodeTypeStr & " to primary : ") then
				return;										// retries exceeded
			endif;

			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : still waiting for this " & nodeTypeStr & " to reconnect...", null);
			
		else
			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : this " & nodeTypeStr & " has now reconnected to its primary.", null);
			connectionOperation	:= 0;
			return;
		endif;
	endif;
	
	//  If we get to here, then we are still waiting for the operation to complete, so
	//  we restart the timer
	
	self.beginTimer(2000, Timer_OneShot, pEventTag);
end;
}
zCnSDSStructureState_Change
{
zCnSDSStructureState_Change(pObject : Object) protected;

vars
	fx 			: CnFunctionAgent;
	
	cndba		: CnJadeDatabaseAdmin;

	cnSDSss 	: CnSDSStructureState;
	
	dbFile		: DbFile;
	
	dbFileArray	: DbFileArray;
	
	found		: Boolean;
	
	partitionId : Integer64;
	
	partition	: JadeDbFilePartition;
	
	obj			: Object;
	
	errorCode	: Integer;
	
	errorText	: String;
begin
	create fx transient;
	create cndba transient;
	create dbFileArray transient;
	cndba.getAllDbFiles(dbFileArray);
	cnSDSss := pObject.CnSDSStructureState;
	foreach dbFile in dbFileArray do
		if dbFile.name = cnSDSss.name then
			found := true;
			break;
		endif;
	endforeach;
	
	if not found then
		fx.raiseJossAlert(cnSDSss, "Unable to find DbFile '" & cnSDSss.name & "' to replicate state change", Cn_General_Error);
		return;
	endif;
	
	on SystemException do fx.ehGeneralExceptionHandler(exception, errorCode, errorText);		
	partitionId := cnSDSss.partitionId;
	if partitionId <> null then
		partition := dbFile.getPartition(partitionId);
		obj := partition;
		fx.cnSDSStructureState_PHandler(dbFile, partition);
		return;
	endif;
	
	fx.cnSDSStructureState_DHandler(dbFile);
	obj := dbFile;
epilog
	if errorText <> null then
		fx.raiseJossAlert(obj, errorText, errorCode);
	endif;
	
	delete fx;
	delete cndba;
	delete dbFileArray;	
end;
}
zCnSDSStructureState_Online
{
zCnSDSStructureState_Online(pUserInfo : String) protected;
/*
	This method is only executed when the Primary sends through a sdsCauseEvent for a deleted
	object in the Primary CnSDSStructureState class. In this case we are are ALWAYS bringing
	a structure back online.
*/
vars
	fx 				: CnFunctionAgent;
	
	cndba			: CnJadeDatabaseAdmin;

	dbFile			: DbFile;
	
	dbFileArray		: DbFileArray;

	params			: CnStringArray;
	
	errorText,
	dbFileName		: String;
	
	partitionId 	: Integer64;
	
	found			: Boolean;
	
	partition		: JadeDbFilePartition;
	
	obj				: Object;
	
	errorCode		: Integer;			
begin
	create params transient;
	params 		:= pUserInfo.cnGetTokens("|");
	dbFileName 	:= params[1];
	partitionId	:= params[2].Integer64;
	
	create fx transient;
	create cndba transient;
	create dbFileArray transient;
	cndba.getAllDbFiles(dbFileArray);
	foreach dbFile in dbFileArray do
		if dbFile.name = dbFileName then
			found := true;
			break;
		endif;
	endforeach;
	
	if not found then
		return;
	endif;

	on SystemException do fx.ehGeneralExceptionHandler(exception, errorCode, errorText);	
	if partitionId <> null then
		partition := dbFile.getPartition(partitionId);
		if partition <> null then
			fx.cnSDSStructureState_PHandler(dbFile, partition);
			if errorText <> null then
				obj := partition;
				return;
			endif;
		endif;
	endif;	
	fx.cnSDSStructureState_DHandler(dbFile);
	obj := dbFile;
epilog
	if errorText <> null then
		fx.raiseJossAlert(obj, errorText, errorCode);
	endif;
	
	delete params;
	delete fx;
	delete cndba;
	delete dbFileArray;
end;
}
zCnSDSStructureState_Setup
{
zCnSDSStructureState_Setup() updating, protected;

vars
	cc				: CnCntrl;

	role,
	subRole,
	rpsStorageMode	: Integer;

	freq,
	iniFile,
	mapping,
	replay,
	schema,
	str				: String;
	
	fx				: CnFunctionAgent;
begin
	cc		:= app.myCnCntrl;
	iniFile	:= app.getIniFileName();
	/*
	This method only gets executed under two circumstances :
	 
		1) when CnSDSDatabaseAdmin is initialized
		2) when the SDS role changes
	
	If this environment was an SDS Secondary and replaying was enabled then self.replayStructState
	will be set to true. If we got to this method based on a role change event then we need to
	unsubscribe to all notifications and end the regular CnSDSStructureState timer.
	
	The rest of this method will setup the required changes for the role change event. Basically we
	are initialising everything and setting everything up again.
	
	Theres no issue coming in here on CnSDSDatabaseAdmin as self.replayStructState will be false.
	*/
	if self.replayStructState then
		endClassNotification(CnSDSStructureState, false, Object_Create_Event);
		endClassNotification(CnSDSStructureState, false, Object_Update_Event);
		endNotification(system, Cn_SDS_Structure_State_Delete);
//		endNotification(system, Cn_SDS_PreTakeOver_Request);
		endTimer(Cn_SDSStructureState_Class); // stop the timer that may have been running when this was a Primary
		self.replayStructState  := false;
		self.replayStructFreq	:= null;
	endif;	

	role := system.getDatabaseRole();
	if role = SDS_RoleUndefined then
		return;
	endif;	
	
	replay := app.getProfileString(iniFile, CN_APPEXCEPTIONS, CN_SDS_REPLAY_STRUCT_STATE, null);
	if replay = null then
		replay := true.String;
		app.setProfileString(iniFile, CN_APPEXCEPTIONS, CN_SDS_REPLAY_STRUCT_STATE, replay);
	endif;
	
	// only applicable if Primary
	if role = SDS_RolePrimary then
		freq := app.getProfileString(iniFile, CN_APPEXCEPTIONS, CN_SDS_UPDATE_STRUCT_STATE_FRQ, null);
		if freq = null then
			freq := "60"; // default 60 minutes
			app.setProfileString(iniFile, CN_APPEXCEPTIONS, CN_SDS_UPDATE_STRUCT_STATE_FRQ, freq);
		endif;
		self.replayStructFreq := freq.Integer;
		str := method.qualifiedName & " : scheduled updates for CnSDSStructureState are turned ";
		if self.replayStructFreq > null then
			cc.cnWriteLog(cc.CnLogComment, str & "ON, starting timer (" & self.replayStructFreq.String & " minute interval)...", null);
			self.beginTimer(0, Timer_OneShot, Cn_SDSStructureState_Class);	// start the schedule timer, refresh the CnSDSStructureState class immediately
																			// once the timer fires we will then restart it using the user defined value
		else
			cc.cnWriteLog(cc.CnLogComment, str & "OFF, timer won't be started.", null);
		endif;

	elseif role = SDS_RoleSecondary then
		self.replayStructState := replay.Boolean;
		if self.replayStructState then				// check if RPS and whether Full_Extent
			subRole := system.getDatabaseSubrole();		
			if subRole = SDS_SubroleRelational then
				rpsStorageMode := -1;
				self.getRPSStorageModeString(schema, mapping, rpsStorageMode);
				self.replayStructState := (rpsStorageMode = self.RpsStorageMode_Full);
			endif;
		endif;

		// always subscribe to PreTakeOver request so we issue a response
		beginNotification		(system, Cn_SDS_PreTakeOver_Request, Response_Continuous, 0);
		if self.replayStructState then
			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName & " : " & CN_SDS_REPLAY_STRUCT_STATE & "=true, database structure states will be replicated from Primary.", null);
			beginClassNotification	(CnSDSStructureState, false, Object_Create_Event, Response_Continuous, Cn_SDSStructureState_Class);
			beginClassNotification	(CnSDSStructureState, false, Object_Update_Event, Response_Continuous, Cn_SDSStructureState_Class);		
			beginNotification		(system, Cn_SDS_Structure_State_Delete, Response_Continuous, 0);
			// perform a full synchronisation now because objects can exist in CNSDSStructureState prior to notifications
			// being established, this is particulary true if the Secondary has just connected to the Primary
			create fx transient;
			fx.cnSDSStructureState_Sync();

		else
			cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName & " : " & CN_SDS_REPLAY_STRUCT_STATE & "=false, database structure states will NOT be replicated from Primary.", null);
		endif;
	endif;
epilog
	delete fx;
end;
}
zDoChecks
{
zDoChecks() subschemaHidden, updating, protected;

vars
	cc					: CnCntrl;
	
	sdsNotInitialized	: Boolean;																								// PAR 1003
	
	d1					: Decimal[23];
begin
	d1	:= app.relativeMachineTime();
	cc 	:= app.myCnCntrl;
//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " starting SDS Checks...", null);
	if self.inTakeoverState then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " bypassing SDS checks while in takeover state", null);
		return;
	endif;
	
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_SDSNotInitialized, null, sdsNotInitialized);				// PAR 1003
	if system.getDatabaseRole = SDS_RolePrimary then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " starting SDS Primary Checks...", null);
		self.zDoPrimaryChecks();
		return;
	endif;
	
	if system.getDatabaseRole = SDS_RoleSecondary then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " starting SDS Secondary Checks...", null);
		self.zDoSecondaryChecks();
		return;
	endif;
epilog
	if sdsNotInitialized then																									// PAR 1003
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " unable to perform SDS checks as SDS is not initialized.", null);	// PAR 1003
	
	else																														// PAR 1003
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " SDS Checks completed, " & d1.cnGetElapsedTimeString(), null);
	endif;																														// PAR 1003
end;
}
zDoPrimaryChecks
{
zDoPrimaryChecks() subschemaHidden, updating, protected;

constants
	Alert_New				: Character	= "N";
	Alert_Repeat			: Character = "R";
	Alert_Clear				: Character = "C";
vars
	cc						: CnCntrl;

	kc						: CnKarmaCntrl;
	
	jdo1,
	jdo2					: JadeDynamicObject;
	
	jdoArray				: JadeDynamicObjectArray;

	catchUpAlertIssued,
	connected,
	invalidRequest,
	notAttached,
	responseTimeout,
	tracking				: Boolean;
	
	alertState				: Character;

	connState,
	currentJournal,
	diffSecs,
	index,
	journalLagAllowed,
	journalsLagging,
	readyJournal,
	syncMode,
	iniMaxLagTime			: Integer;
	
	connName,
	connectStateString,																											// PAR 6577
	iniFile,
	longText,
	environmentName,																											// JSM PAR 8367
	shortText,
	shortText2,
	str						: String;

	alertTs,
	committedTs,
	prevReplayTs,
	replayTs,
	tsNow					: TimeStamp;
	
	replayDiff				: TimeStampInterval;
begin
	cc	:= app.myCnCntrl;
	kc 	:= app.myCnKarmaCntrl;
	if not self.sdsIsRunning() then
		cc	:= app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " SDS not running or not yet initialized .... will skip SDS checks.", null);
		return;
	endif;
	
	iniFile := app.getIniFileName();
	// set up short text here, common to all alerts.
	environmentName 	:= kc.managedEnvironmentName;																			// JSM PAR 8367
	shortText 	:= Cn_PossibleSDSConnectionIssue & " for " & environmentName.toUpper() & " on " & app.computerName;				// JSM PAR 8367
	shortText2 	:= "SDS journal transfer issue for " & environmentName.toUpper() & " on " & app.computerName;					// JSM PAR 8367
	
	create jdo2 transient;
	self.sdsGetMyServerInfo(jdo2);
	
	app.doWindowEvents(5);			// allow possible takeover notification to action
	if self.inTakeoverState then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " bypassing SDS checks while in takeover state", null);
		return;
	endif;

	currentJournal 	:= jdo2.getPropertyValue("currentJournalNumber").Integer;
	committedTs 	:= jdo2.getPropertyValue("latestCommittedTimeStamp").TimeStamp;
	
	create jdoArray transient;
	self.sdsGetSecondaryProxies(jdoArray);

	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " number of secondaries detected = " & jdoArray.size64().String &
							", current journal " & currentJournal.String &
							", last committedTimeStamp " & committedTs.cnFormat_DDMMYY_hhmmsscc(), null);
							
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_SDSSecondaryNotAttached, 		null, notAttached);
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_SDSResponseTimeout, 			null, responseTimeout);
	on SystemException do app.cnGenericExceptionHandler(exception, Cn_RequestedPropertyNotDefined, 	jdo2, invalidRequest);

	foreach jdo1 in jdoArray do
		app.doWindowEvents(5);			// allow possible takeover notification to action
		if self.inTakeoverState then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " bypassing SDS checks while in takeover state", null);
			return;
		endif;
		
		connName := jdo1.getPropertyValue("myName").String;
		index 	 := self.connectionNameArray.indexOf(connName);
		// always add to arrays. Note that once an entity has been defined in an array, they are not deleted as
		// the number of connections will be few.
		if index = null then
			self.connectionNameArray.add(connName);
			self.prevReplayedTimeStampArray.add(null);
			self.alertTimeStampArray.add(null);
			self.alertTimeStampCatchUpArray.add(null);
			index := self.connectionNameArray.size();
		endif;
		
		connState := jdo1.getPropertyValue("connectionState").Integer;
		connectStateString	:= "secondary connection " & connName & 															// PAR 6577
										" [" & index.String &
										"] connectionState=" & self.getConnectionStateString(connState);						// PAR 6577
		if connState <> SDS_Connected then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " secondary " & connName & " not connected, ignored", null);
			if index > null then
				alertTs := self.alertTimeStampArray[index];
				self.alertTimeStampArray[index] := null;
				if alertTs <> null then
					app.cnRaiseJossAlert(Cn_Karma_Alert,
										shortText,
										Cn_SDSSecondaryUsingConn & " '" & connName & "' is no longer connected",
										Alert_Clear,
										alertTs,
										cc.appName,
										environmentName,																		// JSM PAR 8367
										app.cnComputerName,
										kc.localIpAddress,
										kc.myParentTcp);
				endif;

				alertTs := self.alertTimeStampCatchUpArray[index];
				self.alertTimeStampCatchUpArray[index] := null;
				if alertTs <> null then
					app.cnRaiseJossAlert(Cn_Karma_Alert,
										shortText2,
										Cn_SDSSecondaryUsingConn & " '" & connName & "' is no longer connected",
										Alert_Clear,
										alertTs,
										cc.appName,
										environmentName,																		// JSM PAR 8367
										app.cnComputerName,
										kc.localIpAddress,
										kc.myParentTcp);
				endif;

			endif;
			
			continue;
		endif;
		
		app.doWindowEvents(5);			// allow possible takeover notification to action
		if self.inTakeoverState then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & connectStateString & ", bypassing SDS checks while in takeover state", null);	// PAR 6577
			return;
		endif;

		// go and get info for this connected secondary
		jdo2.clear();
		self.sdsGetSecondaryInfo(connName, jdo2);
		
		app.doWindowEvents(5);			// allow possible takeover notification to action
		if self.inTakeoverState then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & connectStateString & ", bypassing SDS checks while in takeover state", null);	// PAR 6577
			return;
		endif;
		
		// add check to ensure that secondary is receiving the journals being created by SDS Primary and that the 
		// network link is not causing an unacceptable lag.
		// NOTE : we are deliberately checking the latest READY journal (the last journal transferred and available for reply)
		readyJournal := jdo2.getPropertyValue("latestReadyJournalNumber").Integer;
		if invalidRequest then
			cc.cnWriteLog (CnCntrl.CnLogDiag, method.cnGetMethodName() & " " & connectStateString & ", unable to locate property 'latestReadyJournalNumber', continuing...", null);
			continue;
		endif;

		syncMode := jdo1.getPropertyValue("syncMode").Integer;
		if syncMode = SDS_BlockWrite then
			replayTs 	 := jdo2.getPropertyValue("latestReplayedAuditTimeStamp").TimeStamp;
			str			 := ", last replayed audit timestamp ";
		
		else
			replayTs 	 := jdo2.getPropertyValue("latestReplayJournalTimeStamp").TimeStamp;
			str			 := ", last replayed journal timestamp ";
		endif;
		
		journalsLagging := currentJournal.cnDifference(readyJournal);
		replayDiff := committedTs - replayTs;
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & connectStateString & 										// PAR 6577
															" ready journal #" & readyJournal.String &
															str & replayTs.String &
															", differences : journal transfers behind " & journalsLagging.String &
															", replay time lag " & replayDiff.String, null);
		alertTs := self.alertTimeStampCatchUpArray[index];
		catchUpAlertIssued := false;
		if currentJournal <> readyJournal then
			// journalLagAllowed of zero means to ignore any lag
			journalLagAllowed := app.getProfileString(iniFile, CN_APPEXCEPTIONS, connName & "_journalLagAllowed", "1").Integer;
			if journalLagAllowed = null then
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & connName & "_journalLagAllowed ini file setting is null, ignoring journal transfer lag...", null);
			
			elseif journalsLagging > journalLagAllowed then
				catchUpAlertIssued := true;
				if alertTs = null then
					alertTs := tsNow;
					alertState := Alert_New;
				
				else
					alertState := Alert_Repeat;
				endif;
			
				longText := "Connection " & connName & 
							" journal transfer from Primary is lagging" & CrLf &
							"    " & journalsLagging.String & " journals behind" & CrLf &
							"    " & replayDiff.cnFormatted() & " replay time lag " & CrLf &
							"    - Primary : current journal #" & currentJournal.String &
							", last committed timestamp " & committedTs.cnFormat_DDMMYY_hhmmsscc() & CrLf &
							"    - Secondary : last ready journal #" & readyJournal.String &
							str & replayTs.String & CrLf &
							"    Inifile setting [AppExceptions] " & connName & "_journalLagAllowed=" & journalLagAllowed.String;
				app.cnRaiseJossAlert(Cn_Karma_Alert,
									shortText2,
									longText,
									alertState,
									alertTs,
									cc.appName,
									environmentName,																			// JSM PAR 8367
									app.cnComputerName,
									kc.localIpAddress,
									kc.myParentTcp);

				self.alertTimeStampCatchUpArray[index] := alertTs;
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " raise journal transfer lag alert : " & longText, null);
			endif;
		endif;
		
		// if we haven't issued a new or repeat alert then clear any previous alert issued.
		if not catchUpAlertIssued and
		   alertTs <> null then
			self.alertTimeStampCatchUpArray[index] := null;
			app.cnRaiseJossAlert(Cn_Karma_Alert,
					shortText2,
					"Journal transfer lag (lag=" & journalsLagging.String & ") now within acceptable limits ([AppExceptions] " & connName & "_journalLagAllowed=" & journalLagAllowed.String & ")",
					Alert_Clear,
					alertTs,
					cc.appName,
					environmentName,																							// JSM PAR 8367
					app.cnComputerName,
					kc.localIpAddress,
					kc.myParentTcp);

			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " clear journal transfer lag alert for connection " & connName, null);
		endif;

		if notAttached or responseTimeout then
			longText := Cn_SDSSecondaryUsingConn & " '" & connName & "' marked as connected (connectionState=" & self.getConnectionStateString(connState) & ")";

			if notAttached then
				notAttached := false;
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " secondary " & connName & " not attached (exception 3204), ignored", null);
				longText := longText & " yet incurred exception 3204 (SDS Secondary not attached)";
			endif;
		
			if responseTimeout then
				responseTimeout := false;
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " secondary " & connName & " response timeout (exception 3212), ignored", null);
				longText := longText & " but timed-out getting secondary info, exception 3212 (SDS response was not received within a reasonable timeframe)";
			endif;

			alertTs := self.alertTimeStampArray[index];
			if alertTs = null then
				alertTs := tsNow;
				alertState := Alert_New;
			
			else
				alertState := Alert_Repeat;
			endif;
			
			app.cnRaiseJossAlert(Cn_Karma_Alert,
								shortText,
								longText,
								alertState,
								alertTs,
								cc.appName,
								environmentName,																				// JSM PAR 8367
								app.cnComputerName,
								kc.localIpAddress,
								kc.myParentTcp);

			self.prevReplayedTimeStampArray[index] := null;
			self.alertTimeStampArray[index] := alertTs;
			continue;
		endif;
		
		if syncMode <> SDS_BlockWrite then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " secondary " & connName & " syncMode is Journal Switch, ignored", null);
			if index > null then
				alertTs := self.alertTimeStampArray[index];
				if alertTs <> null then
					app.cnRaiseJossAlert(Cn_Karma_Alert,
										shortText,
										Cn_SDSSecondaryUsingConn & " '" & connName & "' changed syncMode to Journal Switch",
										Alert_Clear,
										alertTs,
										cc.appName,
										environmentName,																		// JSM PAR 8367
										app.cnComputerName,
										kc.localIpAddress,
										kc.myParentTcp);
					self.alertTimeStampArray[index] := null;
				endif;
			endif;

			continue;
		endif;

		tracking := jdo2.getPropertyValue("tracking").Boolean;
		if not tracking then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " secondary " & connName & " not tracking, ignored", null);
			if index > null then
				alertTs := self.alertTimeStampArray[index];
				if alertTs <> null then
					app.cnRaiseJossAlert(Cn_Karma_Alert,
										shortText,
										Cn_SDSSecondaryUsingConn & " '" & connName & "' is no longer tracking",
										Alert_Clear,
										alertTs,
										cc.appName,
										environmentName,																		// JSM PAR 8367
										app.cnComputerName,
										kc.localIpAddress,
										kc.myParentTcp);
					self.alertTimeStampArray[index] := null;
				endif;
			endif;

			continue;
		endif;
		
		alertTs := null;
		prevReplayTs := null;
		if index <> null then
			alertTs 	 := self.alertTimeStampArray[index];
			prevReplayTs := self.prevReplayedTimeStampArray[index];
		endif;
		
		self.zGetIniFileMaxLagTime(connName, iniMaxLagTime); 																	// PAR #743
		diffSecs := replayTs.cnSecondsDifference(committedTs);
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " connection " & connName & 
										" lastReplayedAuditTimeStamp=" & replayTs.cnFormat_DDMMYY_hhmmsscc() &
										", previous lastReplayedAuditTimeStamp=" & prevReplayTs.cnFormat_DDMMYY_hhmmsscc() &
										", difference=" & diffSecs.String & " secs" &
										", ini file maxLagTime=" & iniMaxLagTime.String, null);
		if replayTs = prevReplayTs and
		 diffSecs > iniMaxLagTime then														// PAR #743 - will also stop zero second time differences
			if committedTs = self.prevCommittedTimeStamp then
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " no change on primary or secondary (primary " &
																	committedTs.cnFormat_DDMMYY_hhmmsscc &
																	", secondary " & connName & " " & 
																	replayTs.cnFormat_DDMMYY_hhmmsscc &
																	")", null);
			
			else
				if alertTs = null then
					alertTs := tsNow;
					alertState := Alert_New;
				
				else
					alertState := Alert_Repeat;
				endif;
				
				app.cnRaiseJossAlert(Cn_Karma_Alert,
									shortText,
									Cn_SDSSecondaryUsingConn & " '" & connName & "' appears to be out of sync with Primary" & CrLf &
										"SDS Primary last committed timestamp        : " & committedTs.cnFormat_DDMMYY_hhmmsscc & CrLf &
										"SDS Secondary last replayed audit timestamp : " & replayTs.cnFormat_DDMMYY_hhmmsscc & CrLf &
										"Time difference = " & diffSecs.String & " seconds",
									alertState,
									alertTs,
									cc.appName,
									environmentName,																			// JSM PAR 8367
									app.cnComputerName,
									kc.localIpAddress,
									kc.myParentTcp);
			endif;
			
		// value has changed, clear corresponding alert
		else
			if alertTs <> null then
				app.cnRaiseJossAlert(Cn_Karma_Alert,
									shortText,
									Cn_SDSSecondaryUsingConn & " '" & connName & "' last replayed audit timestamp has changed.",
									Alert_Clear,
									alertTs,
									cc.appName,
									environmentName,																			// JSM PAR 8367
									app.cnComputerName,
									kc.localIpAddress,
									kc.myParentTcp);
									
				alertTs := null;
			endif;
		endif;
		
		self.prevReplayedTimeStampArray[index] := replayTs;
		self.alertTimeStampArray[index] := alertTs;
	endforeach;
	
	self.prevCommittedTimeStamp := committedTs;
epilog
	delete jdo2;
	if jdoArray <> null then		// PAR 515 - caused 1090 when offline backup
		jdoArray.purge();
	endif;							// PAR 515
	
	delete jdoArray;
end;
}
zDoSecondaryChecks
{
zDoSecondaryChecks() subschemaHidden, updating, protected;

vars
	cc						: CnCntrl;

	jdo						: JadeDynamicObject;
	
	connected,
	tracking,
	trackingDisabled		: Boolean;
	
	delta,
	lastErrorCode,
	rpsTransitionHaltCode,
	state,
	trackingStoppedReason	: Integer;

	replayTs,
	stableTs				: TimeStamp;
begin
	cc	:= app.myCnCntrl;
	if not self.sdsIsRunning() then
		cc	:= app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogErrors, method.cnGetMethodName() & " SDS not running or not yet initialized .... will skip SDS checks.", null);
		return;
	endif;
	
	self.updateSelf();				// PAR 438,483 always refresh details as syncmode could change.
	
	create jdo transient;
	self.sdsGetMyServerInfo(jdo);
	
	app.doWindowEvents(5);			// allow possible takeover notification to action
	if self.inTakeoverState then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " bypassing SDS checks while in takeover state", null);
		return;
	endif;
	
	if self.getConnectionState() = SDS_Connected then
		connected	:= true;
	endif;

	trackingDisabled	:= getTrackingDisabled();
	tracking			:= getTracking(trackingStoppedReason, rpsTransitionHaltCode);
	
	if tracking and connected then
		if syncMode = SDS_BlockWrite then
			replayTs	:= jdo.getPropertyValue("latestReplayedAuditTimeStamp").TimeStamp;
			stableTs	:= jdo.getPropertyValue("latestStableAuditTimeStamp").TimeStamp;
			delta		:= replayTs.cnSecondsDifference(stableTs);
			self.zCheckLagTime(delta, stableTs, replayTs);

		else
			state		:= jdo.getPropertyValue("state").Integer;
			self.zCheckSynchronicity(state);
		endif;
		
				
	else
		lastErrorCode	:= getLastErrorCode();
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : SDS secondary replay lag check not done : trackingDisabled=" & 
								    trackingDisabled.String & ", tracking=" & tracking.String & 
									", trackingStoppedReason=" & trackingStoppedReason.String & " (" &
									getTrackingStoppedReasonStr(trackingStoppedReason) & "), rpsTransitionHaltCode=" &
									rpsTransitionHaltCode.String & ", lastErrorCode=" &
									lastErrorCode.String & ", connected=" & connected.String, null);
	endif;
	
	self.zCheckTracking(tracking, trackingDisabled, connected, trackingStoppedReason, rpsTransitionHaltCode);		
	self.zCheckConnection(tracking, connected);
	
epilog
	delete jdo;		
end;
}
zGetIniFileCheckInterval
{
zGetIniFileCheckInterval() subschemaHidden, updating, protected;

vars
	iniFile	: String;
begin
	iniFile	:= app.getIniFileName();
	self.checkInterval := app.getProfileString(iniFile, CN_APPEXCEPTIONS, CN_SDS_CHECK_INTERVAL, null).Integer;
end;
}
zGetIniFileMaxLagTime
{
zGetIniFileMaxLagTime(	pConnName		: String;
						pSdsMaxLagTime 	: Integer output) subschemaHidden, updating, protected;

vars
	iniFile	: String;
begin
	iniFile	:= app.getIniFileName();
	if pConnName <> null then
		// if the ini file value is defined as zero, then we need to use this.
		pSdsMaxLagTime := app.getProfileString(iniFile, CN_APPEXCEPTIONS, pConnName & "_" & CN_SDS_MAX_LAG_TIME, "-1").Integer;
		// check if ini file contained the <connection_name>_SDSMaxLagTime entry and exit if it did
		if pSdsMaxLagTime <> -1 then
			return;
		endif;
	endif;
	
	pSdsMaxLagTime := app.getProfileString(iniFile, CN_APPEXCEPTIONS, CN_SDS_MAX_LAG_TIME, null).Integer;
end;
}
zGetIniFileSettings
{
zGetIniFileSettings() subschemaHidden, updating, protected;

vars
	iniFile		: String;
	kc			: CnKarmaCntrl;	
	primEnvId	: String;
	cc			: CnCntrl;
begin
	kc					:= app.myCnKarmaCntrl;
	primEnvId			:= kc.environmentId;
	cc					:= app.myCnCntrl;
	iniFile				:= app.getIniFileName;

	self.sdsEnvironmentId	:= app.getProfileString(iniFile, CN_APPENVIRONMENT, CN_SDS_ENVIRONMENT_ID, null);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " SDSEnvironmentId='" & self.sdsEnvironmentId & "'", null);
end;
}
zGetPrimaryHostFQDN
{
zGetPrimaryHostFQDN() : String protected;

vars

begin
	if system.getDatabaseRole = SDS_RolePrimary then
		return app.cnBuildFQDN(app.cnComputerName);
	else
		sdsGetPrimaryInfo(myJdo);
		return myJdo.getPropertyValue("hostName").String;	
	endif;
end;
}
zGetReadyJournalNo
{
zGetReadyJournalNo(jdo : JadeDynamicObject) : Integer subschemaHidden, protected;

vars

begin
	return jdo.getPropertyValue("latestReadyJournalNumber").Integer;
end;
}
zHandleConnectionStateChange
{
zHandleConnectionStateChange(userInfo : Any) updating, protected;

vars
	cc						: CnCntrl;
	
	raiseAlert,
	tracking				: Boolean;

	databaseRole,
	state,
	rpsTransitionHaltCode,
	trackingStoppedReason,
	workers					: Integer;

	nodeTypeStr,
	status,
	str						: String;
begin
	cc						:= app.myCnCntrl;
	databaseRole			:= system.getDatabaseRole();
	if databaseRole <> SDS_RoleSecondary then
		return;
	endif;
	
	if not self.sdsIsRunning() then																								// PAR 1102
		return;																													// PAR 1102
	endif;																														// PAR 1102
	
	state	:= userInfo.Integer;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " state=" & state.String & " (" & self.getConnectionStateString(state) & ")", null);
	if self.connectionOperation = 0 then	// self.connectionOperation indicates if CnSDSCmd caused connection state change				
		raiseAlert	:= true;				// not an expected event
	endif;
	
	if app.cnDatabaseSubrole = SDS_SubroleRelational then
		nodeTypeStr	:= "RPS server";
		workers		:= self.getRpsWorkers();
		if workers > null then
			status := "Data pump is active (workers=" & workers.String & ").";
			
		elseif workers = null then
			status := "Data pump is not active.";
		
		else
			status := "SDS is not initialized.";
		endif;
		
	else
		nodeTypeStr	:= "SDS secondary";
	endif;
	
	tracking	:= self.getTracking(trackingStoppedReason, rpsTransitionHaltCode);
	if state = SDS_Disconnected or
	   state = SDS_ConnectionFailed then
		str	:= nodeTypeStr & " has now disconnected from its primary. ";
		if app.cnDatabaseSubrole = SDS_SubroleRelational then
			str	:= str & status;
		endif;
		
		self.sendSDSAdviceMsg(CnMessage.Advice_Type_SDS_Connection_Chg, tracking, trackingStoppedReason, rpsTransitionHaltCode, str, raiseAlert);
		
	elseif state = SDS_Connected then
		str	:= nodeTypeStr & " now connected to primary. ";
		if app.cnDatabaseSubrole = SDS_SubroleRelational then
			str	:= str & status;
		endif;
		
		self.sendSDSAdviceMsg(CnMessage.Advice_Type_SDS_Connection_Chg, tracking, trackingStoppedReason, rpsTransitionHaltCode, str, raiseAlert);
	endif;
end;
}
zHandleConnectionStateChange_SDSChecks
{
zHandleConnectionStateChange_SDSChecks(userInfo : Any) updating, protected;

/*
	Purpose :
	PAR 1059.
	When executing SDS Checks (at SDSCheckInterval ini setting), the connection and tracking status can change between SDS Check Interval.
	This will ensure that any 'SDS connection alert' is cleared as soon as possible rather than waiting till timer fires.
*/

vars
	cc						: CnCntrl;
	
	tracking				: Boolean;

	databaseRole,
	state,
	rpsTransitionHaltCode,
	trackingStoppedReason					: Integer;

begin
	cc						:= app.myCnCntrl;
	databaseRole			:= system.getDatabaseRole();
	if databaseRole <> SDS_RoleSecondary then
		return;
	endif;
	
	if self.connectionAlertTimestamp = null then
		return;
	endif;
	
	state	:= userInfo.Integer;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " state=" & state.String & " (" & self.getConnectionStateString(state) & ")", null);
	if state <> SDS_Connected then
		return;
	endif;
	
	tracking	:= self.getTracking(trackingStoppedReason, rpsTransitionHaltCode);
	self.zCheckConnection(tracking, true);
end;
}
zHandleRoleChangeEvent
{
zHandleRoleChangeEvent(userInfo : Any) updating, protected;

vars
	cc				: CnCntrl;

	clusterinfo		: CnClusterInfo;

	cem				: CnExternalMethods;

	kc				: CnKarmaCntrl;

	root			: CnRoot;

	tmsg, 
	newmsg			: CnMessage;
	
	msg				: CnSDSAdvice;

	databaseRole,
	databaseSubrole	: Integer;
	
	str,
	str2			: String;
begin
	kc					:= app.myCnKarmaCntrl;
	cc					:= app.myCnCntrl;
	databaseRole		:= userInfo.Integer;
	
	if databaseRole = SDS_RolePrimary then
		str				:= "Primary";
		
	elseif databaseRole = SDS_RoleSecondary then
		str				:= "Secondary";
		databaseSubrole := system.getDatabaseSubrole();
		str2			:= ", subrole=" & databaseSubrole.String;
		
	else
		str				:= "Undefined (" & databaseRole.String & ")";
	endif;
	
	create tmsg transient;
	tmsg.createNewMsg(msg.Advice, msg.SDS_Advice, kc.localFQDN, kc.localIpAddress, cc.KCCMgr_Process, cc.JossCommsMgr_Process, newmsg);
	msg		:= newmsg.CnSDSAdvice;
	msg.setManagedEnvironmentName(kc.managedEnvironmentName);
	msg.setAdviceType(msg.Advice_Type_SDS_RoleChange);
	msg.setDatabaseRole(databaseRole);
	msg.setDatabaseSubrole(databaseSubrole);
	msg.setHostileTakeover(self.hostileTakeover);			// 3.5 hostile takeover is set by zHandleRoleChangeProgress method
	if self.hostileTakeover then
		str := str & " (hostile takeover)";
	
	else
		str := str & " (negotiated takeover)";
	endif;
	
	msg.setText("Database role has changed to " & str & str2);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " " & msg.text, null);
	if self.inTakeoverState then																								// PAR 1045
		if self.hostileTakeover then																							// PAR 1045
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " hostile takeover has completed", null);					// PAR 1045
		
		else																													// PAR 1045
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " negotiated takeover has completed", null);					// PAR 1045
		endif;																													// PAR 1045
		
		self.inTakeoverState := false;																							// PAR 1045
		self.hostileTakeover := false;																							// PAR 1045
	endif;																														// PAR 1045

	msg.sendMessage(kc.myParentTcp);
	
	kc.sendPingReplyAdvice(cc.appSchemaName, cc.appName, null, true, app.actualTime);
	// PAR 374 When changing role to Primary, we need to refresh the clusterinfo as this may have 
	//         been changed should the previous primary have been cycled.
	create cem transient;
	if databaseRole = SDS_RolePrimary 	and 
	   cem.emIsService() 				and 
	   app.isMultiUser() 				then
		root := CnRoot.firstInstance;
		create clusterinfo transient;
		str := null;
		if clusterinfo.virtualMachineName = null then
			if root.virtualMachineName <> null then
				foreach str2 in root.possibleHosts do
					str	:= str & str2 & " ";
				endforeach;
				
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " Cluster info indicates no longer clustered and was previously been clustered as " & root.virtualMachineName & 
				  		   					  " with possible hosts : " & str & ", clearing cluster information", null);
				beginTransaction;
				root.clearClusterInfo();
				commitTransaction;
			endif;  
		
		else
			foreach str2 in clusterinfo.possibleHosts do
					str	:= str & str2 & " ";
			endforeach;
			
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " Database role changed to Primary, updating cluster info : " &
						"clusterName=" 		& clusterinfo.clusterName & 
						", clusterGroup=" 	& clusterinfo.clusterGroup & 
						", virtualMachine=" & clusterinfo.virtualMachineName &
						", preferredHost=" 	& clusterinfo.preferredHost & 
						", hosts=" & str &
						", windowStation=" 	& clusterinfo.windowStation & 
						", service=" 		& clusterinfo.serviceName &
  						", JAWS version=" 	& clusterinfo.jawsVersion, null);
			beginTransaction;
			root.loadClusterInfo(clusterinfo);
			commitTransaction;
		endif;	
	endif;

	// role has changed so execute the CnSDSStructureState setup procedure
	self.zCnSDSStructureState_Setup();
epilog
	delete tmsg;
	delete msg;
	delete clusterinfo;
	delete cem;
end;
}
zHandleTrackingStateChange
{
zHandleTrackingStateChange(eventType : Integer; userInfo : Any) updating, protected;

vars
	cc						: CnCntrl;
	
	raiseAlert,
	tracking				: Boolean;
	
	connectionState,																											// PAR 964
	reason,
	rpsTransitionHaltCode,
	rpsWorkers				: Integer;
	
	str						: String;
begin
	cc		:= app.myCnCntrl;
	reason	:= userInfo.Integer;					// Tracking stopped or halted reason
	if eventType = SDS_TrackingStarted then
		// JADE 2016 returns a SDS_TrackingStarted notification AFTER															// PAR 964
		// a SDS_ConnectionStateChange where the connection state is															// PAR 964
		// SDS_Disconnected. This is erroneous so we check the connection state													// PAR 964
		// here before we do anything else.																						// PAR 964
		connectionState				:= self.getConnectionState();																// PAR 964
		if connectionState <> SDS_Connected then																				// PAR 964
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : eventType=" & eventType.String &							// PAR 964 
													" (SDS_TrackingStarted) but connection is disconnected, ignoring notification", null);	// PAR 964
			return;																												// PAR 964
		endif;																													// PAR 964
		
		endTimer(Start_Tracking_Timer);
		tracking					:= true;
		reason						:= 0;			// we don't use tracking started reason
		rpsTransitionHaltCode		:= -1;
		str							:= "Tracking now started.";
		
	elseif eventType = SDS_TrackingStopped then
		// JADE 2016 returns a SDS_TrackingStopped notification AFTER															// PAR 964
		// a SDS_ConnectionStateChange where the connection state is															// PAR 964
		// SDS_Disconnected. This is erroneous so we check the connection state													// PAR 964
		// here before we do anything else.																						// PAR 964
		connectionState				:= self.getConnectionState();																// PAR 964
		if connectionState <> SDS_Connected then																				// PAR 964
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : eventType=" & eventType.String &							// PAR 964 
													" (SDS_TrackingStopped) but connection is disconnected, ignoring notification", null);	// PAR 964
			return;																												// PAR 964
		endif;																													// PAR 964
		
		str							:= "Tracking has been stopped : reason=" & reason.String & " (" & self.getTrackingStoppedReasonStr(reason) & ")";
		if reason = SDS_ReasonRpsReorgHalt then
			//  We no longer advise this event to JSA : discard and wait for RPS schema transition event
			str 					:= str & "; RPS reorg halt : now waiting for RPS_SchemaTransition event.";
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : eventType=" & eventType.String & ", reason=" & reason.String & ", message=" & str, null);
			return;
		endif;
		
		raiseAlert := (reason 	 <> SDS_ReasonAdminAudited 			and			// 1
					   reason 	 <> SDS_ReasonAutoUpgradeMismatch 	and			// 6
					   reason 	 <> SDS_ReasonDeploymentStart		and 		// 100	User-defined
					   reason	 <> SDS_ReasonDeploymentEnd			and			// 109	User-defined
					   reason	 <> SDS_ReasonEndJadeUpgrade 		and			// 101	User-defined
					   reason	 <> SDS_ReasonEndUserSchemaLoad); 				// 102	User-defined
		
	elseif eventType = SDS_TrackingHalted then
		str							:= "Tracking has been halted due to error (" & getLastErrorCode.String & ").";
		raiseAlert					:= true;
	endif;
	
	if app.cnDatabaseSubrole = SDS_SubroleRelational then
		rpsWorkers		:= self.getRpsWorkers();
		if rpsWorkers > null then
			str 		:= str & " data pump is active (workers=" & rpsWorkers.String & ").";
			
		elseif rpsWorkers = null then
			str 		:= str & " data pump is not active.";
		
		else
			str 		:= str & " SDS is not initialized.";
		endif;
	endif;
	
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " : eventType=" & eventType.String & 
															", reason=" & reason.String & 
															", raiseAlert=" & raiseAlert.String & 								// PAR 964
															", message=" & str, null);
	if eventType = RPS_SchemaTransition then
		str						:= "RPS schema transition halt : rpsTransitionHaltCode=" & reason.String & " (" & self.getRpsTransitionHaltCodeStr(reason) & ")";
		rpsTransitionHaltCode	:= reason;
		reason					:= SDS_ReasonRpsReorgHalt;
		if rpsTransitionHaltCode = RPS_HaltNoScript or
		   rpsTransitionHaltCode = RPS_HaltAutoScript then
			cc.cnWriteLog(cc.CnLogDiag, str & " : JADE will auto-restart data pump so do not report to JSA/JSM.", null);
			return;
		endif;
			
		str					:= str & " : advise JSA/JSM and raise alert.";
		raiseAlert			:= true;
		cc.cnWriteLog(cc.CnLogDiag, str, null);
		
	else
		rpsTransitionHaltCode	:= -1;
	endif;

	self.sendSDSAdviceMsg(CnMessage.Advice_Type_SDS_Status, tracking, reason, rpsTransitionHaltCode, str, raiseAlert);
end;
}
zRaiseAlert
{
zRaiseAlert(msg : String) updating, protected;

vars
	kc		: CnKarmaCntrl;
	str		: String;
	cc		: CnCntrl;
begin
	kc		:= app.myCnKarmaCntrl;
	cc		:= app.myCnCntrl;
	if app.cnDatabaseSubrole = SDS_SubroleRelational then
		str	:= "Error on RPS server ";
	else
		str	:= "Error on SDS secondary ";
	endif;
	
	app.cnRaiseAlert(str & kc.environmentId.toUpper & " on " & app.cnComputerName,
					 msg,
					 "N",
					 app.actualTime,
					 cc.appName,
					 app.cnComputerName,
					 null);
end;
}
zSDSConnect
{
zSDSConnect() updating, protected;

vars
	cc						: CnCntrl;
	str						: String;
	tracking				: Boolean;
	trackingStoppedReason	: Integer;
	rpsTransitionHaltCode	: Integer;
begin
	//  Only valid for SDS secondary
	
	cc					:= app.myCnCntrl;
	retryNo				:= 0;
	connectionOperation	:= Connecting;
	
	if getConnectionState() = SDS_Disconnected then
		cc.cnWriteLog(cc.CnLogComment, "SDS reconnect command received : attempting reconnect now...", null);
		sdsReconnectNow();
		beginTimer(1000, Timer_OneShot, Reconnecting_Timer);
	else
		str			:= "SDS reconnect command received : already connected.";
		cc.cnWriteLog(cc.CnLogComment, str, null);
		tracking	:= getTracking(trackingStoppedReason, rpsTransitionHaltCode);
		sendSDSAdviceMsg(CnMessage.Advice_Type_SDS_Status, tracking, trackingStoppedReason, rpsTransitionHaltCode, str, false);
	endif;	
end;
}
zSDSDisconnect
{
zSDSDisconnect() updating, protected;

vars
	cc		: CnCntrl;
begin
	//  Only valid for SDS secondary
	
	cc					:= app.myCnCntrl;
	retryNo				:= 0;
	connectionOperation	:= Disconnecting;	
	
	if getConnectionState() = SDS_Disconnected then
		cc.cnWriteLog(cc.CnLogComment, "SDS disconnect command received : secondary already already disconnected.", null);
	else
		cc.cnWriteLog(cc.CnLogComment, "SDS disconnect command received : issuing sdsDisablePrimaryConnection call...", null);
		sdsDisablePrimaryConnection();
		beginTimer(1000, Timer_OneShot, Disconnecting_Timer);			
	endif;	
end;
}
zSDSStartTracking
{
zSDSStartTracking() updating, protected;

vars
	cc						: CnCntrl;
	str						: String;
	trackingStoppedReason	: Integer; 
	rpsTransitionHaltCode	: Integer;
	tracking				: Boolean;
begin
	//  Only valid for SDS secondary
	
	cc					:= app.myCnCntrl;
	retryNo				:= 0;
	trackingOperation	:= Stop_Tracking;			
	tracking			:= getTracking(trackingStoppedReason, rpsTransitionHaltCode);
	if tracking then											
		str		:= "Start tracking command received : already tracking : ignored.";
		cc.cnWriteLog(cc.CnLogErrors, str, null);
		sendSDSAdviceMsg(CnMessage.Advice_Type_SDS_Status, tracking, trackingStoppedReason, rpsTransitionHaltCode, str, false); 
		
	elseif system.getDatabaseSubrole = SDS_SubroleRelational then
		if myJdo.getPropertyValue("rpsWorkers").Integer = 0 then			// check datapump isn't going
			cc.cnWriteLog(cc.CnLogComment, "Start tracking command received : RPS node : starting data pump...", null);
			self.rpsStartDataPump(null, null);
			
		else
			cc.cnWriteLog(cc.CnLogErrors, ">>> Start tracking command received : RPS node : can't start data pump because rpsWorkers <> 0.", null);
		endif;
			
	else																	// native secondary
		cc.cnWriteLog(cc.CnLogComment, "Start tracking command received : executing sdsStartTracking method...", null);
		endTimer(Start_Tracking_Timer);
		self.sdsStartTracking();
		beginTimer(1000, Timer_OneShot, Start_Tracking_Timer);			
	endif;		
end;
}
zSDSStopTracking
{
zSDSStopTracking() updating, protected;

vars
	cc						: CnCntrl;
	str						: String;
	trackingStoppedReason	: Integer;
	rpsTransitionHaltCode	: Integer;
	tracking				: Boolean;
begin
	//  Only valid for SDS secondary. 
	
	cc					:= app.myCnCntrl;
	retryNo				:= 0;
	trackingOperation	:= Stop_Tracking;	
	tracking			:= getTracking(trackingStoppedReason, rpsTransitionHaltCode);
	
	if not tracking then											// not tracking
		str		:= "Stop tracking command received : tracking already stopped : reason=" & trackingStoppedReason.String & " (" & 
				   self.getTrackingStoppedReasonStr(trackingStoppedReason) & ")";
		if system.getDatabaseSubrole = SDS_SubroleRelational then
			str	:= str & ", rpsTransitionHaltCode (if applicable)=" & rpsTransitionHaltCode.String;
		endif;
		cc.cnWriteLog(cc.CnLogComment, str, null);
		sendSDSAdviceMsg(CnMessage.Advice_Type_SDS_Status, tracking, trackingStoppedReason, rpsTransitionHaltCode, str, false); 
		
	else
		cc.cnWriteLog(cc.CnLogComment, "Stop tracking command received : issuing sdsStopTracking call...", null);
		sdsStopTracking();
		beginTimer(1000, Timer_OneShot, Stop_Tracking_Timer);			
	endif;		
end;
}
zStopKCCMgr
{
zStopKCCMgr() protected;

vars
	cc	: CnCntrl;
begin
	cc	:= app.myCnCntrl;
	cc.cnWriteLog(cc.CnLogComment, method.cnGetMethodName() & " : SDS command requested KCCMgr to stop : terminating now....", null);
	app.cnTerminate();
end;
}
	)
	JadeDynamicObject (
	jadeMethodSources
cnGetDeltaInteger64
{
cnGetDeltaInteger64(pPropertyName : String; pPreviousJDO : JadeDynamicObject input) : Integer64;

constants
	DEBUG		: Boolean = false;
vars
	cc			: CnCntrl;
	
	deltaValue,
	newValue,
	oldValue	: Integer64;
	
	msg,
	str			: String;
begin
	cc := app.myCnCntrl;
	newValue := self.getPropertyValue(pPropertyName).Integer64;
	if pPreviousJDO = null then
		return null;
	endif;
	
	oldValue := pPreviousJDO.getPropertyValue(pPropertyName).Integer64;
	if newValue >= oldValue then
		deltaValue := newValue - oldValue;
		msg := "normal";
		return deltaValue;
	endif;
	
	// 	value has wrapped round to a negative value.
	//	Need to add 1 because of the way 2s complement works.
	
	deltaValue := -((Max_Integer64 - oldValue) + 1 + (newValue - Min_Integer64));
	msg := "wrapped-around";
	return deltaValue;
epilog
	// PAR 807. If the deltaValue is negative we have a problem.
	//			So take a stackdump and cause an alert to be generated.
	str := " values " & msg & " :" &
			" property=" & pPropertyName &			
			", old=" & oldValue.userNumberFormat($CnWholeNumbers) &
			", new=" & newValue.userNumberFormat($CnWholeNumbers) &
			", delta=" & deltaValue.userNumberFormat($CnWholeNumbers);
	if DEBUG or 
	   newValue < oldValue then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & str, null);
	endif;
	
	if deltaValue < null then
		app.cnRaiseNormalException(Cn_General_Error,
									method.qualifiedName(),
									"Statistics delta value is negative" & CrLf & str,
									true);
	endif;
end;
}
	)
	CnJadeDynamicObject (
	jadeMethodSources
create
{
create() updating;

vars
	cc	: CnCntrl;
begin
	cc	:= app.myCnCntrl;
	if not cc.isInTestMode() then
		return;
	endif;
	
	if cc.testMode > 1 then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " created " &  self.String, null);
	endif;
end;
}
delete
{
delete() updating;

vars
	cc	: CnCntrl;
begin
	cc	:= app.myCnCntrl;
	if not cc.isInTestMode() then
		return;
	endif;
	
	if cc.testMode > 1 then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName & " deleted " &  self.String & ", was created " & self.creationTime().cnFormat_DDMMYY_hhmmsscc(), null);
	endif;
end;
}
	)
	JadeScript (
	jadeMethodSources
cnA__MergeGlobalConstants
{
cnA__MergeGlobalConstants();

vars
	s	: String;
	i	: Integer;
	b	: Boolean;
begin
	//b := Joss_SessionOpen_DumpInfo;
	//i := i;
	//s := OK;
	
	// 4.1.02
	i := Cn_IndexUsedInStringOperationIsOutOfBounds;
end;
}
cnAnalyzeQueuedLocks
{
cnAnalyzeQueuedLocks();

constants
	DEBUG	: Boolean	= false;
vars
	lock				: Lock;
	
	lockArray,
	lockArray2			: LockArray;
	
	lastProcess,
	lockedBy,
	requestedBy			: Process;
	
	lockedByArray,
	requestedByArray,
	requestedByArray2	: ObjectArray;
	
	requestedByDepthArray	: IntegerArray;
	
	processNode			: Node;
	
	ki					: CnQueuedLockDepth;
	
	proc				: Process;
	
	obj					: Object;
	
	iter				: Iterator;
	
	badObject,
	stopLoop			: Boolean;
	
	count,
	depth,
	index				: Integer;
	
	appl,
	msg,
	schema,
	userCode,
	userInfo			: String;
	
	dyna				: DynaDictionary;
	
	cc					: CnCntrl;
begin
	create app.myCnCntrl transient;
	cc := app.myCnCntrl;
	
	create lockArray transient;
	system.getQueuedLocks(lockArray, 10000);

//	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " size=" & lockArray.size().String, null);
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, proc, badObject);
	
	create lockedByArray transient;
	create requestedByArray transient;
	create lockArray2 transient;
	
	foreach lock in lockArray do
		if lock.duration.Integer <> Transaction_Duration then
			continue;
		endif;
		
		if lock.kind <> lock.Kind_Normal then
			continue;
		endif;
		
		if lock.target().isSharedTransient() then
			continue;
		endif;
		
		proc := lock.requestedBy;
		badObject := false;
		processNode := proc.node;
		if badObject then
			continue;
		endif;
		
		if DEBUG then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " lock=" & lock.getObjectStringForObject(lock) & " process " & proc.getObjectStringForObject(proc) & " lockTarget=" & lock.target().String, null);
		endif;
		
		requestedByArray.add(proc);
		lockArray2.add(lock);
	endforeach;
	
	create requestedByArray2 transient;
	create requestedByDepthArray transient;

	foreach lock in lockArray2 do
		depth := 1;
		if DEBUG then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " check lock " & lock.getObjectStringForObject(lock), null);
		endif;
		
		requestedBy := self.cnGetTopOfLockStack(lock, lockArray2, requestedByArray, depth, stopLoop, DEBUG);
		if requestedBy = null then
			if DEBUG then
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " result=null", null);
			endif;
			
			continue;
		endif;
		
		if DEBUG then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " result=" & requestedBy.String, null);
		endif;
		
		index := requestedByArray2.indexOf(requestedBy);
		if index > null then
			count := requestedByDepthArray[index];
			if DEBUG then
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " requestedBy=" & requestedBy.getObjectStringForObject(requestedBy) & " index=" & index.String & " oldDepth=" & count.String & " depth=" & depth.String, null);
			endif;
			
			if depth > count then
				requestedByDepthArray[index] := depth;
			endif;
			
		else
			requestedByArray2.add(requestedBy);
			requestedByDepthArray.add(depth);
		endif;
	endforeach;
	
	create dyna transient;
	dyna.setMembership(CnQueuedLockDepth);
	dyna.addMemberKey("count", true, false);
	dyna.endKeys(true);								// allow dup

	iter := requestedByArray2.createIterator();
	foreach depth in requestedByDepthArray do
		iter.next(requestedBy);
		
		create ki transient;
		ki.count := depth;
		ki.myProcess := requestedBy;
		dyna.add(ki);
		
		if DEBUG then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " dyna count=" & depth.String & " proc=" & requestedBy.getObjectStringForObject(requestedBy), null);
		endif;
	endforeach;
	
	if DEBUG then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " dyna.size=" & dyna.size().String, null);
	endif;
	
	count := null;
	foreach obj in dyna do
		count := count + 1;
		ki := obj.CnQueuedLockDepth;
		proc := ki.myProcess;
		badObject := false;
		processNode := proc.node;
		if badObject then
//			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " badObject #" & count.String, null);
			msg := msg & app.cnGetClassAndOid(proc) & CrLf;
		
		else
			userCode := proc.userCode;
			userInfo := proc.userInfo;
			schema 	 := proc.schema.name;
			appl	 := proc.persistentApp.name;
			msg	:= msg & " depth=" & ki.count.String & " n=" & processNode.osID.String & " p=" & proc.getObjectStringForObject(proc) & " u=" & userCode & " (" & userInfo & ") scm=" & schema & " app=" & appl & CrLf;
		endif;
		
		if count > 9 then
			break;
		endif;
	endforeach;
	
	msg := "Total Queued Persistent Locks = " & lockArray.size().String & CrLf & msg;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & CrLf & msg, null);
	app.msgBox(msg, null, null);
epilog
	delete lockArray;
	delete lockArray2;
	delete lockedByArray;
	delete requestedByArray;
	delete requestedByArray2;
	delete requestedByDepthArray;
	delete iter;
	if dyna <> null then
		dyna.purge();
	endif;
	delete dyna;
	if DEBUG then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " exit", null);
	endif;
	delete cc;
end;
}
cnBenchMarkPSArray
{
cnBenchMarkPSArray();

vars
 	ps	: ProcessStackArray;
 	i	: Integer;
 	t1	: Decimal[19];
begin
	t1	:= app.relativeMachineTime;

	foreach i in 1 to 2 do
	 	create ps transient;
	 	process.currentStack(ps);
	 	write ps.size;
	 	delete ps;
	endforeach;

 	write "Elapsed=" & (app.relativeMachineTime - t1).String;
end;
}
cnCheckDbFiles
{
cnCheckDbFiles();

vars
	file		: File;
	dbFile		: DbFile;
	dbFileArray	: DbFileArray;
	jdba		: JadeDatabaseAdmin;
	str			: String;
begin
	create file transient;
	file.fileName	:= "c:\temp\DbFileSummary.txt";
	file.writeLine("DbFile Summary for " & app.dbPath & " @ " & app.actualTimeServer.String);
	file.writeLine(" ");
	
	create dbFileArray transient; 
	create jdba transient;
	jdba.getAllDbFiles(dbFileArray);
	
	foreach dbFile in dbFileArray do
		str	:= dbFile.getName;
		if dbFile.excludeFromBackup then
			str	:= str & " (excluded from backup)";
		elseif dbFile.getFileStatus = dbFile.Status_Unmapped then
			str	:= str & " (file not in current mapping)"; 
		elseif dbFile.getFileLength = 0 then
			str := str & " (dropped file : length = 0)";
		endif;
		
		file.writeLine(str);
	endforeach;
	
	file.close;
epilog
	delete file;
	delete dbFileArray;
	delete jdba;
end;
}
cnConsolidateHotFixes
{
cnConsolidateHotFixes();

vars
	//  This script builds a consolidation of hot fixes for a selected JADE release (type i686_msoft_win32, ANSI), and 
	//  a script file that loads the associated schema files.  The script requires access to a 
	//  Jade Systems Manager master product repository as the source.  See method text for
	//  full details.
	//
	ff			: FileFolder;
	file,
	batFile		: File;
	fHotFixNode,
	fNode,
	fNode2		: FileNode;
	ddbAttr,
	destFileName,
	dirSchema,
	dirWinAnsi,
	errTxt,
	envName,
	drive,
	hotFixDestDir,
	hotFixInputDir,
	result,
	simpleFileName,
	suffix		: String;	
	schemaDir	: Boolean;
	kc			: CnKarmaCntrl;
	strArray	: StringArray;
	countSchema,
	countWinAnsi,
	countWinAnsiOverwrite	: Integer;
begin
	create ff transient;
	while true do
		hotFixDestDir := "Enter destination directory of consolidated hot fixes";
		read hotFixDestDir;
		if hotFixDestDir = null then
			return;
		endif;
		
		hotFixDestDir := app.cnStandardizePathName(hotFixDestDir);
		if hotFixDestDir[hotFixDestDir.length():1] = "/" then
			hotFixDestDir := hotFixDestDir[1:hotFixDestDir.length()-1];
		endif;
		
		ff.fileName := hotFixDestDir;
		if ff.isValidPathName(hotFixDestDir) then
			break;
		endif;
		
		app.msgBox("Invalid path name " & CrLf & hotFixDestDir, "Error", 48);
	endwhile;
	
	if ff.isAvailable then
		app.msgBox("Specified output directory already exists : remove it or specify a different name, then restart.", "Error", 48);
		return;
	endif;
	
	while true do
		hotFixInputDir := "Enter source directory for hot fixes to consolidate";
		read hotFixInputDir;
		if hotFixInputDir = null then
			return;
		endif;
		
		hotFixInputDir := app.cnStandardizePathName(hotFixInputDir);
		ff.fileName := hotFixInputDir;
		if not ff.isValidPathName(hotFixInputDir) then
			app.msgBox("Invalid path name " & CrLf & hotFixInputDir, "Error", 48);
			continue;
		endif;
		
		if not ff.isAvailable() then
			app.msgBox("Path is not available " & CrLf & hotFixInputDir, "Error", 48);
			continue;
		endif;
		
		break;
	endwhile;

	while true do
		drive := "Enter drive letter of JADE environment to be upgraded";
		read drive;
		if drive.trimBlanks() = null then
			return;
		endif;
		
		if drive.length() <> 1 then
			app.msgBox("Invalid drive " & CrLf & "'" & drive & "'", "Error", 48);
			continue;
		endif;
		
		break;
	endwhile;

	while true do
		envName := "Enter name of JADE environment to be upgraded";
		read envName;
		if envName = null then
			return;
		endif;
		
		if envName.length() > 9 then
			app.msgBox("Environment name length too long " & CrLf & "'" & envName & "'", "Error", 48);
			continue;
		endif;
		
		break;
	endwhile;

	create kc transient;
	
	ff.make();				// output dir

	dirSchema := hotFixDestDir & "\schemafiles";
	ff.fileName := dirSchema;
	ff.make();
	
	dirWinAnsi := hotFixDestDir & "\i686_msoft_win32_ansi";
	ff.fileName := dirWinAnsi;
	ff.make();
	
	
	create file transient;
	file.mode := file.Mode_Input;

	create batFile transient;
	batFile.fileName := dirSchema & "\_schemaLoad.bat";
	batFile.mode := batFile.Mode_Output;
	batFile.open();
	
	batFile.writeLine("echo on");
	batFile.writeLine("set env_systempath=" & drive & ":\" & envName & "\server\c_system");
	batFile.writeLine("set env_binpath=" & drive & ":\" & envName & "\server\c_bin");
	batFile.writeLine("set env_inifile=" & drive & ":\" & envName & "\server\c_bin\" & envName & ".ini");
	hotFixDestDir.replaceChar("/", "\");
	batFile.writeLine('set hotFixDir="' & dirSchema & '\"');

	create strArray transient;
	ff.fileName := hotFixInputDir;
	foreach fHotFixNode in ff.files do								// gets the /012 dir
		if fHotFixNode.isKindOf(File) then
			write "Unexpected file " & fHotFixNode.fileName;
			continue;
		endif;
		
		write "scanning hot fix directory : " & fHotFixNode.cnGetSimpleFileName();
		foreach fNode in fHotFixNode.FileFolder.files do			// gets /schemafiles or /winansi
			if fHotFixNode.isKindOf(File) then
				write "Unexpected file " & fHotFixNode.fileName;
				continue;
			endif;

			simpleFileName := fNode.cnGetSimpleFileName().toLower();
			if  simpleFileName <> "schemafiles" and
				simpleFileName <> "a_bin"		then
				continue;
			endif;
			
			schemaDir := (simpleFileName = "schemafiles");
			foreach fNode2 in fNode.FileFolder.files do
				if fNode2.isKindOf(FileFolder) then
					write "Unexpected file folder " & fNode2.fileName;
					continue;
				endif;
				
				simpleFileName := fNode2.cnGetSimpleFileName();
				if schemaDir then
					suffix := fNode2.File.cnGetSuffix().toLower();
					if 	suffix <> "scm" and
						suffix <> "cls" and
						suffix <> "mth" and
						suffix <> "jcf" and
						suffix <> "ddb" and
						suffix <> "ddx" and																					// PAR 7308 - new format added by JADE 2018
						suffix <> "bat" then
						write "Ignoring file " & fNode2.fileName;
						continue;
					endif;

					if strArray.includes(simpleFileName) then				// file already seen
						continue;
					endif;
					
					ddbAttr := null;
					if 	suffix = "scm" or
						suffix = "cls" then
						file.fileName := fNode2.fileName[1:(fNode2.fileName.length()-3)] & "ddb";
						if file.isAvailable() then
							file.close();
							ddbAttr := " ddbFile=%hotFixDir%" & simpleFileName[1:(simpleFileName.length()-3)] & ".ddb";
							destFileName := dirSchema & "\" & simpleFileName;
							if not fNode2.File.cnCopyFile(destFileName, false, errTxt) then
								app.msgBox(fNode2.fileName & " copy failed" & CrLf & errTxt, "Error", 48);
							endif;
							
							countSchema := countSchema + 1;
						
						else				// ddb file is not present, check for ddx (added by JADE 2018)						// PAR 7308
							file.fileName := fNode2.fileName[1:(fNode2.fileName.length()-3)] & "ddx";							// PAR 7308
							if file.isAvailable() then																			// PAR 7308
								file.close();																					// PAR 7308
								ddbAttr := " ddbFile=%hotFixDir%" & simpleFileName[1:(simpleFileName.length()-3)] & ".ddx";		// PAR 7308
								destFileName := dirSchema & "\" & simpleFileName;												// PAR 7308
								if not fNode2.File.cnCopyFile(destFileName, false, errTxt) then									// PAR 7308
									app.msgBox(fNode2.fileName & " copy failed" & CrLf & errTxt, "Error", 48);					// PAR 7308
								endif;																							// PAR 7308
								
								countSchema := countSchema + 1;																	// PAR 7308
							endif;																								// PAR 7308
						endif;
					endif;
					
					batFile.writeLine(null);
					if suffix = "jcf" then																	
						batFile.writeLine("%env_binpath%\" & Cn_Jadloadb & 
											" path=%env_systempath% ini=%env_inifile% commandFile=%hotFixDir%" &
											simpleFileName & " deletePropertiesIfAbsent=true deleteMethodsIfAbsent=true");

					else
						batFile.writeLine("%env_binpath%\" & Cn_Jadloadb & 
											" path=%env_systempath% ini=%env_inifile% schemaFile=%hotFixDir%" &
										  simpleFileName & ddbAttr & " deletePropertiesIfAbsent=true deleteMethodsIfAbsent=true");
					endif;
				endif;
				
				if schemaDir then 
					destFileName := dirSchema & "\" & simpleFileName;
					
				else
					destFileName := dirWinAnsi & "\" & simpleFileName;
				endif;
				
				file.fileName := destFileName;
				if file.isAvailable() then
					file.close();
					countWinAnsiOverwrite := countWinAnsiOverwrite + 1;
				endif;
				
				if fNode2.File.cnCopyFile(destFileName, false, errTxt) then
					if schemaDir then 
						countSchema := countSchema + 1;
						
					else
						countWinAnsi := countWinAnsi + 1;
					endif;
					
				else
					app.msgBox(fNode2.fileName & " copy failed" & CrLf & errTxt, "Error", 48);
				endif;
			endforeach;
		endforeach;
	endforeach;
	
	batFile.close();
	
	app.msgBox("Completed hot fix consolidation from " & CrLf &
				hotFixInputDir &
				" into" & CrLf & hotFixDestDir & CrLf & CrLf &
				"Schema  files : " & countSchema.String & CrLf &
				"WinAnsi files : " & (countWinAnsi - countWinAnsiOverwrite).String & " (input " & countWinAnsi.String & ")"
				, "Confirmation", null);
epilog
	delete ff;
	delete batFile;
	delete kc;
	delete file;
	delete strArray;
end;
}
cnConvertRGB
{
cnConvertRGB();

vars
	str : String;
	sa	: CnStringArray;
	i	: Integer;
begin
	read(str);
	sa := str.cnGetTokens(",");		//  R, G, B
	i := sa[1].Integer + sa[2].Integer * 256 + sa[3].Integer * 65536;
    write i.String;
    delete sa;
end;
}
cnDbFileDetails
{
cnDbFileDetails();
vars
	dbFile		: DbFile;
	dbFileArray	: DbFileArray;
	jdba		: JadeDatabaseAdmin;
begin	
	create jdba transient;
	create dbFileArray transient;
	jdba.getAllDbFiles(dbFileArray);
	
	foreach dbFile in dbFileArray do
		if dbFile.getName.toLower = "exceptionform" then
			app.msgBox(dbFile.getName & " " & dbFile.getCryptStatus.String, null, null);
			break;
		endif;
	endforeach;
epilog
	delete jdba;
	delete dbFileArray;
end;
}
cnExceptionHandler
{
cnExceptionHandler(pExObj : Exception; pHadError : Boolean output) : Integer;

vars
	obj	: Object;
	objArray : ObjectArray;
	i	: Integer;
begin
	if pExObj.errorCode = 1090 then
		pHadError := true;
		
		create objArray transient;
		process.getExceptionHandlerStack(objArray);
		foreach obj in objArray do
			i := i + obj.ExceptionHandlerDesc.invocationCount;
		endforeach;
		
		write "exception handlers invoked = " & i.String;
		return Ex_Resume_Next;
	endif;
	
	return Ex_Pass_Back;
epilog
	objArray.purge();
	delete objArray;
end;
}
cnExtractDatabaseStructureInfo
{
cnExtractDatabaseStructureInfo();

vars
	cnu	: CnUtility;
begin
	create cnu transient;
	cnu.extractDatabaseStructureInfo();
epilog
	delete cnu;
end;
}
cnExtractDbFileInfExtra
{
cnExtractDbFileInfExtra();

vars
	cnu	: CnUtility;
begin
	create cnu transient;
	cnu.extractDbFileInfo();
epilog
	delete cnu;
end;
}
cnExtractDbFileInfoSimple
{
cnExtractDbFileInfoSimple();

vars
	sdsAdmin			: CnSDSDatabaseAdmin;

	mapFileNameArray	: CnStringArray;
	
	mapFileSizeArray	: Integer64Array;
	
	iter				: Iterator;
	
	mapFileName			: String;
	
	mapFileSize			: Real;
	
	file				: File;
begin
	create sdsAdmin transient;
	create mapFileNameArray transient;
	create mapFileSizeArray transient;
	sdsAdmin.getMapFileInfo(mapFileNameArray, mapFileSizeArray);

	create file transient;
	file.fileName := "c:\temp\CnExtractDbFileInfo.csv";
	file.mode := file.Mode_Output;
	file.open();
	file.writeLine("Name,Size");
	iter := mapFileSizeArray.createIterator();
	foreach mapFileName in mapFileNameArray do
		iter.next(mapFileSize);
		file.writeLine(mapFileName & CN_COMMA &	mapFileSize.String);
	endforeach;
	
	file.close();
epilog
	delete file;
	delete sdsAdmin;
	delete mapFileNameArray;
	delete mapFileSizeArray;
	delete iter;
end;
}
cnExtractGlobalConstants
{
cnExtractGlobalConstants();

vars
	i : Integer;
begin
	//  Dummy method to enforce extraction of global constants
	
	i	:= SDS_ReasonDeploymentEnd;
end;
}
cnExtractSchemasAndAllClasses
{
cnExtractSchemasAndAllClasses();

vars
	class,
	objectClass		: Class;
	
	file			: File;
	
	obj				: Object;
	
	schema			: Schema;
	
	classColl		: ClassColl;
	
	objArray		: ObjectArray;
	
	schemaColl,
	schemaCollTemp	: SchemaColl;
	
	pos				: Integer;
	
	cmiscPath,
	schemaName		: String;
begin
	create schemaCollTemp transient;
	rootSchema.allSubschemas(schemaCollTemp);
	create schemaColl transient;
	foreach schema in schemaCollTemp do
		schemaName := schema.name;
//		write schemaName;
		if schemaName = "JadeMonitorSchema" or
		   schemaName = "JadeSchema" 		or
		   schemaName = "JadeToolsSchema" 	then
			continue;
		endif;
		
		schemaColl.add(schema);
	endforeach;

	cmiscPath := app.dbPath();
	pos := cmiscPath.reversePos(CN_BACK_SLASH);
	cmiscPath := cmiscPath[1:pos] & "c_misc";
	create file transient;
	file.fileName := cmiscPath & CN_BACK_SLASH & "schemaAndClassExtract.txt";
	file.mode := file.Mode_Output;
	file.open();
	create objArray transient;
	foreach schema in schemaColl do
		file.writeLine("Schema " & schema.name);
		objectClass := schema.getClass("Object");
		objArray.clear();
		if objectClass <> null then
			objArray.add(objectClass);
			self.zExtractSchemaAndClasses_getSubClasses(objectClass, objArray);
			foreach obj in objArray do
				file.writeLine("Class " & obj.Class.name);
			endforeach;
		endif;
	endforeach;
	
	file.close();
epilog
	delete objArray;
	delete schemaColl;
	delete schemaCollTemp;
end;
}
cnGetTopOfLockStack
{
cnGetTopOfLockStack(pLock : Lock; pLockArray : LockArray; pRequestorArray : ObjectArray; pDepth : Integer io; pTerminate : Boolean output; pDebug : Boolean) : Process;

vars
	lock			: Lock;

	lockedBy,
	requestedBy		: Process;
	
	index			: Integer;
	
	proc			: Process;
	
	xNode			: Node;
	
	badObject		: Boolean;
	
	cc				: CnCntrl;
	
	str				: String;
	
	stopLoop		: Boolean;
begin
	cc := app.myCnCntrl;
	if pDebug then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " checking " & pLock.String & ", depth=" & pDepth.String & " target=" & pLock.target().String, null);
	endif;
	
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, proc, badObject);

	proc := pLock.lockedBy;
	xNode := proc.node;
	if badObject then
		if pDebug then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " bad locked by object, early return", null);
		endif;
		
		pTerminate := true;
		return null;
	endif;
	
	lockedBy := proc;								// process that has obtained lock
	
	while true do
		if pDebug then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " search for requestor " & lockedBy.getObjectStringForObject(lockedBy), null);
		endif;
		
		index := pRequestorArray.indexOf(lockedBy);		// see if process that has lock, is itself locked
		if pDebug then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " index=" & index.String & ", lockedBy=" & lockedBy.getObjectStringForObject(lockedBy), null);
		endif;
		
		if index = null then
			if pDebug then
				cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " lockedBy=" & lockedBy.String & " not found as requestor", null);
			endif;
			
			pTerminate := true;
			return lockedBy;
		endif;
		
		lock := pLockArray[index];
		pDepth := pDepth + 1;
		if pDebug then
			cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " check lock " & lock.getObjectStringForObject(lock) & " at index " & index.String, null);
		endif;
		
		proc := self.cnGetTopOfLockStack(lock, pLockArray, pRequestorArray, pDepth, stopLoop, pDebug);
		if stopLoop then
			pTerminate := true;
			return lock.lockedBy;
		endif;
		
		if pDepth > 10 then
			pTerminate := true;
			return null;
		endif;
	endwhile;
end;
}
cnIssueShutdownCommandEvent
{
cnIssueShutdownCommandEvent();

vars

begin
	//  This script is designed to invoke a graceful shut down of applications that 
	//  subscribe to the event below.  By using this along with code to close all connections
	//  in your app's finalize method, you can avoid tying up TCP sockets in Linux.  See
	//  CardSchema::cnInitializeKCCMgr, ::cnFinalizeKCCMgr and ::userNotification.
	//
	//  RWM 19 Jan 2005 (3.1)

	system.causeEvent(Cn_Process_Shutdown_Command, true, 0);
end;
}
cnJC24CheckCommandLine
{
cnJC24CheckCommandLine();

vars
	util	: CnUtility;
begin
	create util transient;
	util.jc24CheckCommandLine();
epilog
	delete util;
end;
}
cnJadeSkinsReload
{
cnJadeSkinsReload() updating;

vars
	loader	: CnJadeSkinsLoader;
begin
	create loader transient;
	loader.reload(null, false, false);
epilog
	delete loader;
end;
}
cnJadeSkinsUnload
{
cnJadeSkinsUnload() updating;

vars
	loader	: CnJadeSkinsLoader;
begin
	create loader transient;
	loader.unload(null, true);

epilog
	delete loader;
end;
}
cnListApplications
{
cnListApplications();

vars
	ap	: Application;
	str	: String;
	ver : String;
begin
	write "Application" & Tab & "Type";
	write "-----------" & Tab & Tab & "----";

	foreach ap in currentSchema.cnGetApplications do
		if ap.applicationType = ap.ApplicationType_GUI then
			str	:= "GUI";
		elseif ap.applicationType = ap.ApplicationType_GUI_No_Forms then
			str	:= "GUI No Forms";
		elseif ap.applicationType = ap.ApplicationType_Non_GUI then
			str	:= "Non GUI";
		elseif ap.applicationType = ap.ApplicationType_Non_GUI_Web then
			str	:= "Non GUI Web";
		elseif ap.applicationType = ap.ApplicationType_Web_Enabled then
			str	:= "Web Enabled";
		else
			str := "<Unknown application type>";
		endif;
		
		if app.appVersion = null then
			ver := "no version";
		
		else
			ver := app.appVersion;
		endif;
		
		write ap.name & Tab & str & " " & ver;
	endforeach;	
end;
}
cnListDbFiles
{
cnListDbFiles();
vars
	dbArray	: DbFileArray;
	
	jdba	: JadeDatabaseAdmin;
	
	dbFile	: DbFile;
	
	kind,
	status : Integer;
	
	param	: String;
begin
	create jdba transient;
	create dbArray transient;
	kind := DbFile.Kind_User_Schema;
	jdba.getDbFiles(kind, dbArray);
	foreach dbFile in dbArray do
		if dbFile.getFileStatus() = DbFile.Status_Offline then
			write dbFile.name & ", kind=" & dbFile.cnGetKind() & ", status=" & dbFile.cnGetStatus();
		
		else
			write dbFile.name & ", kind=" & dbFile.cnGetKind() & ", status=" & dbFile.cnGetStatus() & ", frozen=" & dbFile.isFrozen().String;
		endif;
	endforeach;
epilog
	delete dbArray;
	delete jdba;
end;
}
cnMakeCommandFile
{
cnMakeCommandFile();

vars
	//  Creates JADE command file for period / patch versions selected
	//
	j			: JadePatchControlInterface;
 	startTs		: TimeStamp;
 	endTs		: TimeStamp;
 	startTime	: String;
 	endTime		: String;
 	schemaName	: String;
 	outFileName	: String;
 	userName	: String;
 	startPatch	: String;
 	endPatch	: String;
 	
begin
	schemaName	:= "Enter schema name";
	read(schemaName);
	outFileName	:= "Enter output file name (full path)";
	read(outFileName);

	while true do
		startTime	:= "Enter period start date and time, or space";
		read(startTime);
		startTime	:= startTime.trimBlanks;
		if startTime <> null then
			startTs	:= startTime.TimeStamp;
			if startTs.date.isValid and
			   startTs.time.isValid then
			   	break;
			else
				app.msgBox("Invalid start timestamp", "Error", 48);
			endif;
		else
			startTs	:= null;
			break;
		endif;
	endwhile;
			
	while true do
		endTime	:= "Enter period end date and time, or space";
		read(endTime);
		endTime	:= endTime.trimBlanks;
		if endTime <> null then
			endTs	:= endTime.TimeStamp;
			if endTs.date.isValid and
			   endTs.time.isValid then
			   	break;
			else
				app.msgBox("Invalid end timestamp", "Error", 48);
			endif;
		else	
			endTs	:= null;
			break;
		endif;
	endwhile;
	
	userName 	:= "Enter user name or space to include all users' patches.";
	read(userName);
	userName	:= userName.trimBlanks();
	
	startPatch	:= "Enter start patch number or zero";
	read(startPatch);
	endPatch	:= "Enter end patch number or zero";
	read(endPatch);
	
	if app.msgBox("Will now generate JCF file : OK to proceed ?", "Confirmation", MsgBox_OK_Cancel + 48) <> MsgBox_Return_OK then
		return;
	endif;
		
 	create j transient;
// 	j.makeCommandFile(schemaName, outFileName, startTs, endTs, userName, startPatch.Integer, endPatch.Integer);  // requires 6.0.19
 	
 	app.msgBox("Command file generation complete", "DEone", 48);
epilog
 	delete j;
 end;
}
cnMethodInError
{
cnMethodInError();

vars
	i : Integer;
begin
	//  Method which can be used for deployment method-in-error tests
	
//	i := "abc";	
end;
}
cnSDSListMyServerInfo
{
cnSDSListMyServerInfo();

vars
	dba	: JadeDatabaseAdmin;
	jdo	: JadeDynamicObject;
	cc	: CnCntrl;
begin
	create dba transient;
	create jdo transient;
	dba.sdsGetMyServerInfo(jdo);
	create cc transient;
	cc.cnWriteLog(cc.CnLogComment, jdo.display, null);
epilog
	delete cc;
	delete jdo;
	delete dba;
end;
}
cnSchemaAnalyserDemo
{
cnSchemaAnalyserDemo() updating;

vars
	sa		: CnSchemaAnalyser;
	kc		: CnKarmaCntrl;
begin
	create kc;
	create sa transient;
	sa.analyse(null, false);
	
epilog
	delete sa;
	delete kc;
end;
}
cnSchemaComparator
{
cnSchemaComparator() updating;

vars
	sa	: CnSchemaAnalyser;
	fd	: TimeStamp;
begin
	create sa transient;
	fd.setDate("27/01/02".Date);
	sa.reportChangesSinceForkDate(fd, "d:\share40\martinjagers\jossmerge\joss loaded 28Feb02.scm", "c:\temp3\report.log", true);
	delete sa;
end;
}
cnServerStatsDisplay
{
cnServerStatsDisplay(pBin : Binary; pLength : Integer) protected;

vars
	bin			: Binary;
	
	int,
	max,
	offset,
	offset31	: Integer;
	
	head,
	str1		: String;
	
	ts			: TimeStamp;
begin
	bin 	:= pBin;
	if pLength = 8 then
		max := 1019;
		
	else
		max := 1016;
	endif;
	
	foreach int in 1000 to max do
		offset := int mod 1000 * pLength + 6;
		if int = 1000 then
			head := "committedTransactions";
			
		elseif int = 1001 then
			head := "abortedTransactions";
			
		elseif int = 1002 then
			head := "getObjects";
			
		elseif int = 1003 then
			head := "createObjects";
			
		elseif int = 1004 then
			head := "deleteObjects";
			
		elseif int = 1005 then
			head := "updateObjects";
			
		elseif int = 1006 then
			head := "lockObjects";
			
		elseif int = 1007 then
			head := "unlockObjects";
			
		elseif int = 1008 then
			head := "beginNotifications";
			
		elseif int = 1009 then
			head := "endNotifications";
			
		elseif int = 1010 then
			head := "deliveredNotifications";
			
		elseif int = 1011 then
			head := "serverMethodExecutions";
			
		elseif int = 1012 then
			head := "HtmlThinSessions";
			
		elseif int = 1013 then
			head := "JadeDevProcesses";
			
		elseif int = 1014 then
			head := "ThinNonJadeDevProcesses";
			
		elseif int = 1015 then
			head := "NonJadeDevProcesses";
			
		elseif int = 1016 then
			head := "ProcessesLeft";
			
		elseif int = 1017 then
			head := "queuedLocks";
			
		elseif int = 1018 then
			head := "totalLockQueueWaitTime";
			
		elseif int = 1019 then
			head := "causeEvents";
		endif;
		
		head := head & " (" & int.String & ") [" & offset.String & ":" & pLength.String & "]  ";
		if pLength = 8 then
			str1 := bin[offset:pLength].Integer64.String;
		
		else
			str1 := bin[offset:pLength].Integer.String;
		endif;
		
		write head.padBlanks(60) & str1;
	endforeach;
end;
}
cnServerStatsTest
{
cnServerStatsTest();

vars
	cs		: CnServerStatistics;//31;
	
	bin		: Binary;
	
	int,
	len,
	offset,
	offset31	: Integer;
	
	head,
	str1		: String;
begin
	create app.myCnCntrl transient;
	create cs transient;
	if cs.isKindOf(CnServerStatistics) then
		len := 8;
	
	else
		len := 4;
	endif;
	cs.captureSystemStatistics();
//	bin 	:= cnAnsiBinary("D") & cs.getStatsSummary();
//	self.cnServerStatsDisplay(bin, len);
	
//	app.doWindowEvents(1000);
	app.msgBox("OK when ready to show stats", null, null);
	cs.captureSystemStatistics();
	
	bin 	:= cnAnsiBinary("D") & cs.getStatsSummary();
	
	self.cnServerStatsDisplay(bin, len);
epilog
	delete app.myCnCntrl;
	delete cs;
end;
}
cnSetScaleForm
{
cnSetScaleForm();

vars
	frm : Form;
begin
	beginTransaction;
	foreach frm in Form.instances do
		frm.cnSetScaleForm(true);
	endforeach;
	commitTransaction;
end;
}
cnSetupApplicationVersions
{
cnSetupApplicationVersions();

vars
	ap		: Application;
	
	obj		: Object;
	
	scm		: Schema;
	
	objSet	: ObjectSet;
	
	cardVersion,
	jossVersion,
	version	: String;
begin
	create objSet transient;
	objSet.add(currentSchema);
	cardVersion := app.cnGetCardSchemaVersion();
	
	beginTransaction;
	foreach obj in objSet reversed do
		scm := obj.Schema;
		if scm.name[1:4] = "Card" then
			version := cardVersion;
		
		else
			version := jossVersion;
		endif;
		
		foreach ap in scm.cnGetApplications do
			ap.appVersion := version;
			write "Updated " & scm.name & " " & ap.name & " : " & version;
		endforeach;
	endforeach;	
	commitTransaction;
epilog
	delete objSet;
end;
}
cnStartKCCMgr
{
cnStartKCCMgr() serverExecution;

vars
	// Use to restart KCCMgr if required, via JADLOADB.  If you can get on to the 
	// development environment, then you don't need this script because you can
	// run KCCMgr serverExecution from the File | Run ... menu.
begin
    app.startApplication(CN_CARDSCHEMA, CN_KCCMGR);
end;
}
cnTest2
{
cnTest2(val : Integer);

vars
 	
begin
	if val = 0 then
		return;
	endif;
end;
}
cnTestAlert
{
cnTestAlert();

vars
	t1: Time;
	ts: TimeStamp;
	kc: CnKarmaCntrl;
begin
	t1.setTime(17, 33, 08, 00);
	ts.setTime(t1);
	create kc;

	app.cnRaiseAlert("Generic Error Message", "Something is broken.", "N", ts, "TheAlertinator", null, null);
epilog
	delete kc;
end;
}
cnTestBinary
{
cnTestBinary();

vars
	bin	: Binary;
begin
	bin := "A".Binary;
	write bin.length;
	write bin.display;
	cnTestBinary2(bin);
end;
}
cnTestBinary2
{
cnTestBinary2(bin : Binary);

vars

begin
	write bin.length;
	write bin.display;
end;
}
cnTestBinaryTooLong
{
cnTestBinaryTooLong() updating;

vars
	cnproc	: CnProcess;
	bin		: Binary;
	i		: Integer;
begin
	create cnproc transient;
	i	:= 1;
	
	bin[137:4]	:= 0.Binary;
	bin[1:4]	:= 9.Binary;

	write bin.length.String & CrLf & bin.display;
	cnproc.tranStats.add(bin);
epilog
	delete cnproc;	
end;
}
cnTestCheckForTransients
{
cnTestCheckForTransients() updating;

vars
 	kc 		: CnKarmaCntrl;
 	cc		: CnCntrl;
begin
 	create kc;
 	cc := app.myCnCntrl;
 	app.cnCheckForTransients;	
epilog
	delete kc;
end;
}
cnTestCnGetToken
{
cnTestCnGetToken();

vars
	str		: String;
	str2	: String;
	posn	: Integer;
begin
 	posn := 1;
 	str := "test/12345";
 	str2 := str.cnGetToken(posn, "12345");
 	write str2;
end;
}
cnTestDeployControl
{
cnTestDeployControl() updating;

vars
	bm		: CnBatchMgr;
	dbPath	: String;
	pos		: Integer;
	logPath	: String;
	date	: Date;
	param	: HugeStringArray;
begin
	create param transient;
	param.add("action=resumeTracking");

	create bm transient;
	app.myCnManagerClass	:= bm;
	dbPath					:= app.dbPath;
	
	dbPath.replaceChar("\", "/");
	pos				:= 2;					// skip /opt if Linux
	
	dbPath.scanUntil("/", pos);
	pos				:= pos + 1;
											// now pointing to start of environment id
	bm.initParams	:= param;
	bm.environmentName	:= dbPath.scanUntil("/", pos);
	logPath			:= app.getProfileString(app.getIniFileName, "CardLog", "LogPath", app.dbPath[1 : pos -1] & "/logs");
	
	create bm.myLog transient;
	bm.myLog.mode		:= File.Mode_Append;
	bm.myLog.fileName	:= logPath & "/cn_sdsdeploycontrol_" & date.userFormat($CnCCYYMMDD_ns) & ".log";
	bm.timerEvent(1);
epilog
	delete param;
	delete bm;
end;
}
cnTestException1
{
cnTestException1() updating;

vars
 	cc : CnCntrl;
 	kc : CnKarmaCntrl;
 	indx : Integer;
 	str	: String;
 	mach : CnMachine;
 	m2	: CnMachine;
 	i 	: Integer;
 	ia	: IntegerArray;
 	oid	: String;
 	osId, platformId, majorVersion, minorVersion, buildNumber : Integer;
 	extraInfo : String;
 	file	: File;
begin
	create kc;
    app.myCnKarmaCntrl := kc;
	cc := app.myCnCntrl;
	
	create file;
	file.fileName	:= "c:\temp2\test.txt";
	file.purge;
	
epilog
	delete file;
	delete kc;
end;
}
cnTestException2
{
cnTestException2(str1, str2 : String; mach : CnMachine input; ia : IntegerArray) updating;

vars
 	str 	: String;
 	indx	: Integer;
 	now		: TimeStamp;
 	msg		: CnMessage;
 	junk	: String[3];
 	tcp		: CnTcpConnection;
	mach2  	: CnMachine;
	cc		: CnCntrl;
begin
//	mach2 := mach;

	beginTransaction;
	create mach2 transient;
	mach2.setMyKarmaCntrl(app.myCnKarmaCntrl);
	create mach2 transient;
	mach2.setMyKarmaCntrl(app.myCnKarmaCntrl);							// dictionary duplicate
//	mach.setIpAddress("aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa");			// overlength
	commitTransaction;

    junk := "Overlength string";
epilog

end;
}
cnTestExceptionStackDump
{
cnTestExceptionStackDump();

vars
	obj			: Object;
	
	i,
	x			: Integer;
	
	objArray	: ObjectArray;
	
	hadError	: Boolean;
begin
	on SystemException do self.cnExceptionHandler(exception, hadError);
	
	x := obj.edition;	// force a 1090 exception, handled by cnExceptionHandler
	
	write "had exception = " & hadError.String;
	
	create objArray transient;
	process.getExceptionHandlerStack(objArray);
	foreach obj in objArray do
		i := i + obj.ExceptionHandlerDesc.invocationCount;
	endforeach;
	
	write "exception handlers invoked = " & i.String;
epilog
	objArray.purge();
	delete objArray;
end;
}
cnTestFTP_create2GBFile
{
cnTestFTP_create2GBFile();

constants
	MAX_SIZE	: Integer	= (CN_BYTES_PER_KILOBYTE * 100);
vars
	kc			: CnKarmaCntrl;
	
	file		: File;
	
	bin			: Binary[MAX_SIZE];
	
	fileSize	: Integer64;
begin
	create kc transient;
	create file transient;
	file.fileName := "c:\temp\_ftp_over_2GB_file.txt";
	file.mode	  := file.Mode_Input;
	file.kind	  := file.Kind_Binary;
	if file.isAvailable() then
		fileSize := file.fileLength64();
		if fileSize > Max_Integer then
			write file.fileName & " already exists, file size=" & fileSize.userNumberFormat($CnWholeNumbers) & "bytes";
			return;
		endif;
		
		file.cnRemoveFile(2, 5000);
	endif;
	
	bin := "A".Binary;
	bin[MAX_SIZE:1] := "Z".Binary;
	file.mode := file.Mode_Output;
	fileSize := null;
	while fileSize <= Max_Integer do
		file.writeBinary(bin);
		fileSize := fileSize + MAX_SIZE;
	endwhile;
	
	file.close();
epilog
	delete file;
	delete kc;
end;
}
cnTestFtp32Delete
{
cnTestFtp32Delete() updating;

vars
	fto 		: CnFtp;

	iResult 	: Integer;
	
	findFile,
	pw,
	result,
	serverName,
	userId		: String;
begin
	create app.myCnCntrl transient;
    if not self.zCnGetFTPRequiredInfo(userId, pw, serverName) then
		return;
	endif;
	
 	create fto;
 	fto.setUserId(userId, pw);
 	fto.setServerName(serverName);
 	result := fto.cnConnect();
 	if result <> CN_OK then
       	write("File transfer from server failed : your workstation could not" & CrLf &
        		   "connect to server " & serverName & " : advise your administrator");
       return;
	endif;
	
	findFile	:= "renamed.dat";

	iResult := fto.emFtpDeleteFile(fto.connectionHandle, findFile);

    if iResult = null then
		app.msgBox("Zero result from emFtPDeleteFile", null, null);
	
	else
    	app.msgBox("CnFtp::emFtpDeleteFile failed for file " & findFile & " : " & iResult.String & 
    		  "(" & fto.cnGetInternetError(iResult) & ")", null, null);
    endif;

epilog
	delete fto;
	delete app.myCnCntrl;
end;
}
cnTestFtp32FindFile
{
cnTestFtp32FindFile() updating;

vars
	cc			: CnCntrl;

	fto 		: CnFtp;

	kc			: CnKarmaCntrl;

	fileinfo 	: Binary;

	isDirectory : Boolean;
	
	fileHandle 	: MemoryAddress;

	iResult 	: Integer;
	
	findFile, 
	foundfile,
	pw,
	result,
	serverName,
	userId		: String;
begin
 	create kc;
 	cc := app.myCnCntrl;
	if not self.zCnGetFTPRequiredInfo(userId, pw, serverName) then
		return;
	endif;
	
 	create fto;
 	fto.setUserId(userId, pw);
 	fto.setServerName(serverName);
 	result := fto.cnConnect();
 	if result <> CN_OK then
       	write("File transfer from server failed : your workstation could not" & CrLf &
        		   "connect to server " & serverName & " : advise your administrator");
       return;
	endif;
	
	findFile	:= "renamed.dat";

	iResult := fto.emFtpFindFirstFile(fileHandle, fto.connectionHandle, findFile, fileinfo, foundfile, isDirectory);

    if iResult <> null then
    	write "CnFtp::cnGetFileInfo::emFtpFindFirstFile failed for file " & findFile & " : " & iResult.String & 
    		  "(" & fto.cnGetInternetError(iResult) & ")";
	
	else
		write "foundFile=" & foundfile & ", isDirectory=" & isDirectory.String;
    endif;
	
//	iResult	:= fto.emFtpDeleteFile(fto.connectionHandle, findFile);
//	write "result from emFtpDeleteFile=" & iResult.String & " (" & fto.cnGetInternetError(iResult) & ")";
	
	iResult := fto.emFtpFindNextFile(fileHandle, fileinfo, foundfile, isDirectory);
	write "result from emFtpFindNextFile=" & iResult.String & " (" & fto.cnGetInternetError(iResult) & ") : file=" & foundfile;
	

epilog
	delete fto;
	delete kc;
end;
}
cnTestFtp32GetInfo
{
cnTestFtp32GetInfo() updating;

vars
	cc			: CnCntrl;

	fto 		: CnFtp;

	filesize	: Integer;
	
	attr,
	pw,
	result,
	serverName,
	userId		: String;
	
	lastMod		: TimeStamp;
begin
 	create app.myCnCntrl transient;
 	cc := app.myCnCntrl;
	if not self.zCnGetFTPRequiredInfo(userId, pw, serverName) then
		return;
	endif;
	
 	create fto;
 	fto.setUserId(userId, pw);
 	fto.setServerName(serverName);
 	result := fto.cnConnect();
 	if result <> CN_OK then
       	write("File transfer from server failed : your workstation could not" & CrLf &
        		   "connect to server " & serverName & " : advise your administrator");
       return;
	endif;

	// if getting file from directory, you need to change into the directory first.
	result := fto.cnGetFileInfo('renamed.dat', attr, filesize, lastMod);
	write "Result=" & result;
	if result = CN_OK then
		write "Filesize=" & filesize.String & ", LastModified=" & lastMod.String;
	endif;

epilog
	delete fto;
	delete app.myCnCntrl;
end;
}
cnTestFtp32GetInfo_2GB
{
cnTestFtp32GetInfo_2GB() updating;

vars
	cc				: CnCntrl;

	fto 			: CnFtp;

	filesize		: Integer;
	
	attr,
	pw,
	result,
	serverName,
	userId			: String;
	
	lastMod			: TimeStamp;
begin
 	create app.myCnCntrl transient;
 	cc := app.myCnCntrl;
	if not self.zCnGetFTPRequiredInfo(userId, pw, serverName) then
		return;
	endif;
	
 	create fto;
 	fto.setUserId(userId, pw);
 	fto.setServerName(serverName);
 	result := fto.cnConnect();
 	if result <> CN_OK then
       	write("File transfer from server failed : your workstation could not" & CrLf &
        		   "connect to server " & serverName & " : advise your administrator");
       return;
	endif;

	// if getting file from directory, you need to change into the directory first.
	result := fto.cnGetFileInfo('Renamed_Over2GBFile.dat', attr, filesize, lastMod);
	write "Result=" & result;
	if result = CN_OK then
		write "Filesize=" & filesize.userNumberFormat($CnWholeNumbers) & "bytes, LastModified=" & lastMod.String;
	endif;

epilog
	delete fto;
	delete app.myCnCntrl;
end;
}
cnTestFtp32Limits2
{
cnTestFtp32Limits2() updating;

vars
	cc		: CnCntrl;

	fto0,
	fto1,
	fto2,
	fto3,
	fto4,
	fto5,
	fto6,
	fto7,
	fto8,
	fto9 	: CnFtp;	
	
	kc		: CnKarmaCntrl;

	count,
	filesize: Integer;
	
	attr,
	result	: String;
	
	lastMod	: TimeStamp;
begin
 	create kc;
 	cc := app.myCnCntrl;
	
	
	count := 1;
	while count <= 3000 do 
		write "Count = " & count.String;
		
		create fto0;
		fto0.setUserId("asbftpuser1", "1asbftpuser11");
		fto0.setServerName("cnwjwc1a");
		result := fto0.cnConnect();
		if result <> CN_OK then
			write("File transfer from server failed : your workstation could not" & CrLf &
					   "connect to server " & fto0.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		// if getting file from directory, you need to change into the directory first.
		result := fto0.cnGetFileInfo('testfileforftp', attr, filesize, lastMod);
		if result <> CN_OK then
			write("cnGetFileInfo failed : your workstation could not" & CrLf &
					   "connect to server " & fto0.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		delete fto0;
		
		create fto1;
		fto1.setUserId("asbftpuser1", "1asbftpuser11");
		fto1.setServerName("cnwjwc1a");
		result := fto1.cnConnect();
		if result <> CN_OK then
			write("File transfer from server failed : your workstation could not" & CrLf &
					   "connect to server " & fto1.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		// if getting file from directory, you need to change into the directory first.
		result := fto1.cnGetFileInfo('testfileforftp', attr, filesize, lastMod);
		if result <> CN_OK then
			write("cnGetFileInfo failed : your workstation could not" & CrLf &
					   "connect to server " & fto1.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;			
		delete fto1;
		
		create fto2;
		fto2.setUserId("asbftpuser1", "1asbftpuser11");
		fto2.setServerName("cnwjwc1a");
		result := fto2.cnConnect();
		if result <> CN_OK then
			write("File transfer from server failed : your workstation could not" & CrLf &
					   "connect to server " & fto2.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		// if getting file from directory, you need to change into the directory first.
		result := fto2.cnGetFileInfo('testfileforftp', attr, filesize, lastMod);
		if result <> CN_OK then
			write("cnGetFileInfo failed : your workstation could not" & CrLf &
					   "connect to server " & fto2.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		delete fto2;
		
		create fto3;
		fto3.setUserId("asbftpuser1", "1asbftpuser11");
		fto3.setServerName("cnwjwc1a");
		result := fto3.cnConnect();
		if result <> CN_OK then
			write("File transfer from server failed : your workstation could not" & CrLf &
					   "connect to server " & fto3.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		// if getting file from directory, you need to change into the directory first.
		result := fto3.cnGetFileInfo('testfileforftp', attr, filesize, lastMod);
		if result <> CN_OK then
			write("cnGetFileInfo failed : your workstation could not" & CrLf &
					   "connect to server " & fto3.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		delete fto3;
		
		create fto4;
		fto4.setUserId("asbftpuser1", "1asbftpuser11");
		fto4.setServerName("cnwjwc1a");
		result := fto4.cnConnect();
		if result <> CN_OK then
			write("File transfer from server failed : your workstation could not" & CrLf &
					   "connect to server " & fto4.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		// if getting file from directory, you need to change into the directory first.
		result := fto4.cnGetFileInfo('testfileforftp', attr, filesize, lastMod);
		if result <> CN_OK then
			write("cnGetFileInfo failed : your workstation could not" & CrLf &
					   "connect to server " & fto4.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		delete fto4;
		
		create fto5;
		fto5.setUserId("asbftpuser1", "1asbftpuser11");
		fto5.setServerName("cnwjwc1a");
		result := fto5.cnConnect();
		if result <> CN_OK then
			write("File transfer from server failed : your workstation could not" & CrLf &
					   "connect to server " & fto5.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		// if getting file from directory, you need to change into the directory first.
		result := fto5.cnGetFileInfo('testfileforftp', attr, filesize, lastMod);
		if result <> CN_OK then
			write("cnGetFileInfo failed : your workstation could not" & CrLf &
					   "connect to server " & fto5.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		delete fto5;
		
		create fto6;
		fto6.setUserId("asbftpuser1", "1asbftpuser11");
		fto6.setServerName("cnwjwc1a");
		result := fto6.cnConnect();
		if result <> CN_OK then
			write("File transfer from server failed : your workstation could not" & CrLf &
					   "connect to server " & fto6.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		// if getting file from directory, you need to change into the directory first.
		result := fto6.cnGetFileInfo('testfileforftp', attr, filesize, lastMod);
		if result <> CN_OK then
			write("cnGetFileInfo failed : your workstation could not" & CrLf &
					   "connect to server " & fto6.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		delete fto6;
		
		create fto7;
		fto7.setUserId("asbftpuser1", "1asbftpuser11");
		fto7.setServerName("cnwjwc1a");
		result := fto7.cnConnect();
		if result <> CN_OK then
			write("File transfer from server failed : your workstation could not" & CrLf &
					   "connect to server " & fto7.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		// if getting file from directory, you need to change into the directory first.
		result := fto7.cnGetFileInfo('testfileforftp', attr, filesize, lastMod);
		if result <> CN_OK then
			write("cnGetFileInfo failed : your workstation could not" & CrLf &
					   "connect to server " & fto7.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		delete fto7;
		
		create fto8;
		fto8.setUserId("asbftpuser1", "1asbftpuser11");
		fto8.setServerName("cnwjwc1a");
		result := fto8.cnConnect();
		if result <> CN_OK then
			write("File transfer from server failed : your workstation could not" & CrLf &
					   "connect to server " & fto8.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		// if getting file from directory, you need to change into the directory first.
		result := fto8.cnGetFileInfo('testfileforftp', attr, filesize, lastMod);
		if result <> CN_OK then
			write("cnGetFileInfo failed : your workstation could not" & CrLf &
					   "connect to server " & fto8.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		delete fto8;
		
		create fto9;
		fto9.setUserId("asbftpuser1", "1asbftpuser11");
		fto9.setServerName("cnwjwc1a");
		result := fto9.cnConnect();
		if result <> CN_OK then
			write("File transfer from server failed : your workstation could not" & CrLf &
					   "connect to server " & fto9.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;
		// if getting file from directory, you need to change into the directory first.
		result := fto9.cnGetFileInfo('testfileforftp', attr, filesize, lastMod);
		if result <> CN_OK then
			write("cnGetFileInfo failed : your workstation could not" & CrLf &
					   "connect to server " & fto9.serverName & " : advise your administrator" & CrLf &
					   "result " & result);
		   return;
		endif;			
		delete fto9;

		process.sleep(2000);
		count := count + 1;
	endwhile;		
	
epilog

	delete kc;
end;
}
cnTestFtp32PutFile
{
cnTestFtp32PutFile() updating;

constants
	SOURCE_FILE			: String	= "c:\temp\_cnHugeBinary_1.txt";
	DEST_FILE			: String	= "testftp.txt.tmp";
	RENAMED_FILE		: String	= "testftp.txt";
	ASCII_MODE			: Boolean	= false;
	CLOSEWHENFINISHED	: Boolean	= false;
vars
	cc 			: CnCntrl;

	fto			: CnFtp;

	kc			: CnKarmaCntrl;

	file		: File;
	
	pw,
    result,
	serverName,
	userId		: String;
begin
	create kc;	// required as we use the File Exception handler
	cc := app.myCnCntrl;
	if not self.zCnGetFTPRequiredInfo(userId, pw, serverName) then
		return;
	endif;
	
	create fto;
	create file;
	
	file.fileName := SOURCE_FILE;
	if not file.tryOpen() then
		cc.cnWriteLog(cc.CnLogDiag, "Can't find source file " & file.fileName, null);
		return;
	endif;
	
	fto.totalBytesToBeTransferred := file.fileLength();
	file.close();
	fto.setServerName(app.cnBuildFQDN(serverName));
	fto.setUserId(userId, pw);
	fto.setModeAscii(ASCII_MODE);
	result := fto.cnConnect();
	cc.cnWriteLog(cc.CnLogDiag, "Attempted to connect to " & fto.serverName & ", user=" & fto.userId & 
									", modeAscii=" & fto.modeAscii.String & ", closeWhenFinished=" & CLOSEWHENFINISHED.String & 
									", result=" & result, null);
	if result <> CN_OK then
		app.msgBox(result, null, null);
		return;
	endif;
	
	result := fto.cnPutFile(file.fileName, DEST_FILE, false, CLOSEWHENFINISHED);
	cc.cnWriteLog(cc.CnLogDiag, "cnPutFile result=" & result, null);
	if result <> CN_OK then
		app.msgBox(result, null, null);
		return;
	endif;
	
	process.sleep(2000);			// give IIS time to sort itself out
	
	if fto.connectionHandle = null then
		fto.setServerName(app.cnBuildFQDN(serverName));
		fto.setUserId(userId, pw);
		fto.setModeAscii(ASCII_MODE);
		result := fto.cnConnect();
		cc.cnWriteLog(cc.CnLogDiag, "Attempted re-connect to " & fto.serverName & ", user=" & fto.userId & 
										", modeAscii=" & fto.modeAscii.String & ", result=" & result, null);
	endif;
	
	result := fto.cnRenameFile(DEST_FILE, "Ascii" & ASCII_MODE.String & "_Close" & CLOSEWHENFINISHED.String & "_" & RENAMED_FILE);
	cc.cnWriteLog(cc.CnLogDiag, "Rename file result=" & result, null);
	fto.cnCloseConnection();
epilog
	delete file;
	delete fto;
	delete kc;
end;
}
cnTestFtp32PutFile_2GB
{
cnTestFtp32PutFile_2GB() updating;

vars
	cc 			: CnCntrl;

	fto			: CnFtp;

	kc			: CnKarmaCntrl;

	file		: File;
	
	pw,
    result,
	serverName,
	userId		: String;
begin
	create kc;	// required as we use the File Exception handler
	cc := app.myCnCntrl;
	create file;
	
	file.fileName := "c:\temp\_ftp_over_2GB_file.txt";
	if not file.tryOpen() then
		write "Can't find source file " & file.fileName;
		return;
	endif;
	
	if file.fileLength64() <= Max_Integer then
		write "File to FTP is not greater than 2GB, terminating...";
		return;
	endif;

	// OK, all OK now to transfer, get password for this user
	if not self.zCnGetFTPRequiredInfo(userId, pw, serverName) then
		return;
	endif;
	
	create fto;
//	fto.totalBytesToBeTransferred := file.cnGetFileLength();
	fto.totalBytesToBeTransferred := Max_Integer-1;
	fto.setServerName(serverName);

	fto.setUserId(userId, pw);
	write "Attempted to connect to " & fto.serverName & ", user=" & fto.userId & ", result = " & fto.cnConnect();

	result := fto.cnPutFile(file.fileName, "testftp.dat", false, false);
	if result <> CN_OK then
		write result;
		return;
	endif;
	
	process.sleep(2000);			// give IIS time to sort itself out
	
	write "Rename file = " & fto.cnRenameFile("testftp.dat", "renamed.dat");
	fto.cnCloseConnection();
epilog
	delete file;
	delete fto;
	delete kc;
end;
}
cnTestFtp64Delete
{
cnTestFtp64Delete() updating;

vars
	fto 				: CnFtp64;
	
	iResult				: Integer;
	
	findFile, 
	pw,
	result,
	serverName,
	userId				: String;
begin
	create app.myCnCntrl transient;
	if not self.zCnGetFTPRequiredInfo(userId, pw, serverName) then
		return;
	endif;
	
 	create fto;
 	fto.setUserId(userId, pw);
 	fto.setServerName(serverName);
 	result := fto.cnConnect();
 	if result <> CN_OK then
       	write("File transfer from server failed : your workstation could not" & CrLf &
        		   "connect to server " & serverName & " : advise your administrator");
       return;
	endif;
	
	findFile	:= "renamed.dat";

	iResult := fto.emFtpDeleteFile(fto.connectionHandle, findFile);

    if iResult = null then
		app.msgBox("Zero result from emFtPDeleteFile", null, null);
	
	else
    	app.msgBox("CnFtp64::emFtpDeleteFile failed for file " & findFile & " : " & iResult.String & 
    		  "(" & fto.cnGetInternetError(iResult) & ")", null, null);
    endif;

epilog
	delete fto;
	delete app.myCnCntrl;
end;
}
cnTestFtp64FindFile
{
cnTestFtp64FindFile() updating;

vars
	cc					: CnCntrl;

	fto 				: CnFtp64;
	
	kc					: CnKarmaCntrl;

	fileinfo 			: Binary;
	
	isDirectory 		: Boolean;
	
	iResult 			: Integer;
	
	fileHandle		 	: MemoryAddress;

	findFile,
	foundfile,
	pw,
	result,
	serverName,
	userId				: String;
begin
 	create kc;
 	cc := app.myCnCntrl;
	if not self.zCnGetFTPRequiredInfo(userId, pw, serverName) then
		return;
	endif;
	
 	create fto;
 	fto.setUserId(userId, pw);
 	fto.setServerName(serverName);
 	result := fto.cnConnect();
 	if result <> CN_OK then
       	write("File transfer from server failed : your workstation could not" & CrLf &
        		   "connect to server " & serverName & " : advise your administrator");
       return;
	endif;
	
	findFile	:= "renamed.dat";

	iResult := fto.emFtpFindFirstFile(fileHandle, fto.connectionHandle, findFile, fileinfo, foundfile, isDirectory);

    if iResult <> null then
    	write "CnFtp::cnGetFileInfo::emFtpFindFirstFile failed for file " & findFile & " : " & iResult.String & 
    		  "(" & fto.cnGetInternetError(iResult) & ")";
	
	else
		write "foundFile=" & foundfile & ", isDirectory=" & isDirectory.String;
    endif;
	
//	iResult	:= fto.emFtpDeleteFile(fto.connectionHandle, findFile);
//	write "result from emFtpDeleteFile=" & iResult.String & " (" & fto.cnGetInternetError(iResult) & ")";
	
	iResult := fto.emFtpFindNextFile(fileHandle, fileinfo, foundfile, isDirectory);
	write "result from emFtpFindNextFile=" & iResult.String & " (" & fto.cnGetInternetError(iResult) & ") : file=" & foundfile;
	

epilog
	delete fto;
	delete kc;
end;
}
cnTestFtp64GetInfo
{
cnTestFtp64GetInfo() updating;

vars
	cc			: CnCntrl;

	fto 		: CnFtp64;

	filesize	: Integer64;

	attr,
	pw,
	result,
	serverName,
	userId		: String;

	lastMod		: TimeStamp;
begin
 	create app.myCnCntrl transient;
 	cc := app.myCnCntrl;
	if not self.zCnGetFTPRequiredInfo(userId, pw, serverName) then
		return;
	endif;
	
 	create fto;
 	fto.setUserId(userId, pw);
 	fto.setServerName(serverName);
 	result := fto.cnConnect();
 	if result <> CN_OK then
       	write("File transfer from server failed : your workstation could not" & CrLf &
        		   "connect to server " & serverName & " : advise your administrator");
       return;
	endif;

	// if getting file from directory, you need to change into the directory first.
	result := fto.cnGetFileInfo('renamed.dat', attr, filesize, lastMod);
	write "Result=" & result;
	if result = CN_OK then
		write "Filesize=" & filesize.String & ", LastModified=" & lastMod.String;
	endif;

epilog
	delete fto;
	delete app.myCnCntrl;
end;
}
cnTestFtp64GetInfo_2GB
{
cnTestFtp64GetInfo_2GB() updating;

vars
	cc			: CnCntrl;

	fto 		: CnFtp64;

	filesize	: Integer64;
	
	attr,
	pw,
	result,
	serverName,
	userId		: String;
	
	lastMod		: TimeStamp;
begin
 	create app.myCnCntrl transient;
 	cc := app.myCnCntrl;
	if not self.zCnGetFTPRequiredInfo(userId, pw, serverName) then
		return;
	endif;
	
 	create fto;
 	fto.setUserId(userId, pw);
 	fto.setServerName(serverName);
 	result := fto.cnConnect();
 	if result <> CN_OK then
       	write("File transfer from server failed : your workstation could not" & CrLf &
        		   "connect to server " & serverName & " : advise your administrator");
       return;
	endif;

	// if getting file from directory, you need to change into the directory first.
	result := fto.cnGetFileInfo('Renamed_Over2GBFile.dat', attr, filesize, lastMod);
	write "Result=" & result;
	if result = CN_OK then
		write "Filesize=" & filesize.userNumberFormat($CnWholeNumbers) & "bytes, LastModified=" & lastMod.String;
		if filesize > Max_Integer then
			write "Exceeded Max_Integer by " & (filesize - Max_Integer).userNumberFormat($CnWholeNumbers) & "bytes";
		endif;
	endif;

epilog
	delete fto;
	delete app.myCnCntrl;
end;
}
cnTestFtp64PutFile
{
cnTestFtp64PutFile() updating;

vars
	cc 			: CnCntrl;

	kc			: CnKarmaCntrl;
	
	fto			: CnFtp64;
	
	file		: File;
	
	pw,
    result,
	serverName,
	userId		: String;
begin
	create kc;	// required as we use the File Exception handler
	cc := app.myCnCntrl;
	if not self.zCnGetFTPRequiredInfo(userId, pw, serverName) then
		return;
	endif;
	
 	create fto;
	create file;
	
//	file.fileName := "c:\temp\test.bat";
	file.fileName := "c:\temp\tcluvtx_stackdump.log";
	if not file.tryOpen() then
		write "Can't find source file " & file.fileName;
		return;
	endif;
	
	fto.totalBytesToBeTransferred := file.fileLength64();
	fto.setServerName(serverName);

	fto.setUserId(userId, pw);
	write "Attempted to connect to " & serverName & ", user=" & fto.userId & ", result = " & fto.cnConnect();

	result := fto.cnPutFile(file.fileName, "testftp.dat", false, false);
	if result <> CN_OK then
		write result;
		return;
	endif;
	
	process.sleep(2000);			// give IIS time to sort itself out
	
	write "Rename file = " & fto.cnRenameFile("testftp.dat", "renamed.dat");
	fto.cnCloseConnection();
epilog
	delete file;
	delete fto;
	delete kc;
end;
}
cnTestFtp64PutFile_2GB
{
cnTestFtp64PutFile_2GB() updating;

vars
	cc 			: CnCntrl;

	fto			: CnFtp64;

	kc			: CnKarmaCntrl;

	file		: File;
	
	pw,
    result,
	serverName,
	userId		: String;
begin
	create kc;	// required as we use the File Exception handler
	cc := app.myCnCntrl;
	create file;
	
	file.fileName := "c:\temp\_ftp_over_2GB_file.txt";
	if not file.tryOpen() then
		write "Can't find source file " & file.fileName;
		return;
	endif;
	
	if file.fileLength64() <= Max_Integer then
		write "File to FTP is not greater than 2GB, terminating...";
		return;
	endif;

	// OK, all OK now to transfer, get password for this user
	if not self.zCnGetFTPRequiredInfo(userId, pw, serverName) then
		return;
	endif;
	
	create fto;
	fto.totalBytesToBeTransferred := file.fileLength64();
	fto.setServerName(serverName);

	fto.setUserId(userId, pw);
	write "Attempted to connect to " & serverName & ", user=" & userId & ", result = " & fto.cnConnect();

	result := fto.cnPutFile(file.fileName, "Over2GBFile.dat", false, false);
	if result <> CN_OK then
		write result;
		return;
	endif;
	
	process.sleep(2000);			// give IIS time to sort itself out
	
	write "Rename file = " & fto.cnRenameFile("Over2GBFile.dat", "Renamed_Over2GBFile.dat");
	fto.cnCloseConnection();
epilog
	delete file;
	delete fto;
	delete kc;
end;
}
cnTestGetCacheSizes
{
cnTestGetCacheSizes() serverExecution;

vars
 	tc, rc, pc : Integer64;
begin
 	node.getCacheSizes64(tc, pc, rc);
 	write tc;
 	write pc;
 	write rc;
end;
}
cnTestGetHostByAddress
{
cnTestGetHostByAddress();

vars
	cem			: CnExternalMethods;
	result 		: Integer;
	fqdn		: String;
begin
	create cem transient;
	result := cem.emGetHostByAddress("143.96.129.155", fqdn);
	if result = null then
		app.msgBox("FQDN=" & fqdn, "karma.emGetHostByAddress test", null);
	
	else
		app.msgBox("Result=" & result.String, "karma.emGetHostByAddress test", null);
	endif;
epilog
	delete cem;
end;
}
cnTestGetHostByName
{
cnTestGetHostByName();

vars
	cem : CnExternalMethods;
	
	maxNum,
	result	: Integer;
	
	sFQDN,
	sIpAddress	: String;
begin
	create cem transient;
	maxNum := 1;
	sFQDN := "cnwbw2a.cnw.co.nz";
	result := cem.emGetHostByName ( sFQDN , maxNum , sIpAddress ) ;
	if result = 1 then
		app.msgBox( "Cannot determine the TCP/IP address, because there are multiple" & CrLf &
				 "addresses associated with the FQDN you entered","karma.emGetHostByName", null);
		return;
	endif;
	
	if result <> 0 then
		app.msgBox( "The FQDN you entered does not resolve to a TCP/IP address", "karma.emGetHostByName", null);
		return ;
	endif;
	
	app.msgBox("IP Address " & sIpAddress, "karma.emGetHostByName", null);
epilog
	delete cem;
end;
}
cnTestGetTimeZoneStuff
{
cnTestGetTimeZoneStuff();

vars
 	i	: Integer;
 	bin	: Binary[256];
 	bias:Integer;
 	db	: Integer;
 	ts	: TimeStamp;
 	ts2	: TimeStamp;
begin
	i := ts.cnGetGMTBias(bias);
	write bias;
	write ts.cnGMT.String;
	ts2 := ts.cnGMT;
	write ts2.cnLocalTime.String;
end;
}
cnTestGetTokens
{
cnTestGetTokens() updating;

vars
	array  : CnStringArray;
	str		: String;
begin
	str := "AdminEmail~S~ ~~~^ARC_EMail~S~ ~~~^BackupEMail~S~ ~~~^MotherHost~S~ ~~~^MotherHostIPAddress~S~ ~~~^MotherSystemConfigPath~S~ ~~~^Repository~S~ ~~~^";
	create array transient;
	array.cnGetTokens(str, "^", false);

	foreach str in array do
		write str;
	endforeach;

	write "Size=" & array.size.String;
	delete array;
end;
}
cnTestHttp
{
cnTestHttp() updating;

vars
	cc			: CnCntrl;

	fto 		: CnHttp;
	
	kc			: CnKarmaCntrl;
	
	bool		: Boolean;

	filesize	: Integer;

	attr,
	pw,
	result,
	serverName,
	userId		: String;
	
	lastMod		: TimeStamp;
begin
 	create kc;
 	cc := app.myCnCntrl;
	if not self.zCnGetFTPRequiredInfo(userId, pw, serverName) then
		return;
	endif;
	
 	create fto;
// 	fto.setUserId("mike", "mike02");
 	fto.setServerName(serverName);
 	result := fto.cnConnect();
 	if result <> CN_OK then
       	write("File transfer from server failed : your workstation could not" & CrLf &
        		   "connect to server " & fto.serverName & " : advise your administrator");
       return;
	endif;

	result := fto.cnGetFileInfo('renamed.dat', attr, filesize, lastMod);
	write "Result=" & result;
	if result = CN_OK then
		write "Filesize=" & filesize.String & ", LastModified=" & lastMod.String;
	endif;

epilog
	delete fto;
	delete kc;
end;
}
cnTestHttpGetFile
{
cnTestHttpGetFile() updating;

vars
	cc			: CnCntrl;

	fto 		: CnHttp;
	
	kc			: CnKarmaCntrl;
	
	bool		: Boolean;

	filesize	: Integer;

	attr,
	pw,
	result,
	serverName,
	userId		: String;
	
	lastMod		: TimeStamp;
begin
 	create kc;
 	cc := app.myCnCntrl;
	if not self.zCnGetFTPRequiredInfo(userId, pw, serverName) then
		return;
	endif;
	
 	create fto;
	fto.setUserId(userId, pw);
 	fto.setServerName(serverName);
 	result := fto.cnConnect();
 	if result <> CN_OK then
       	write("File transfer from server failed : your workstation could not" & CrLf &
        		   "connect to server " & serverName & " : advise your administrator");
       return;
	endif;

	result := fto.cnGetFile('renamed.dat', "c:\temp\renamed.dat", false);
	write "Result=" & result;
epilog
	delete fto;
	delete kc;
end;
}
cnTestHttpWithGoogle
{
cnTestHttpWithGoogle();
constants
	Server : String = "www.google.com";
	FileName : String = "/intl/en/mail/help/about.html";
//    Server : String = "www.jadeworld.com";
//    FileName : String = "/developer-center/jade-support/jade-care/#releases/download.htm";
vars
    http : CnHttp;
    
begin
    app.cnSetExceptionHandlerType(CnCntrl.Exception_Handler_Jade);
    app.cnActivateKarmaControl(Cn_JADE_Thin_Client, null, null);
    
    create http transient;
    http.setSecure(false);
    http.setServerName(Server);
    http.setUserId(null, null);
	http.setUseProxy(true);
    
    if http.cnConnect = OK then
        write http.cnGetFile(FileName, "c:\temp\temp.html", true);
    else
        write "not connected";
    endif;

epilog
    delete http;
end;
}
cnTestInstrumentation
{
cnTestInstrumentation() serverExecution;

vars
	kc	: CnKarmaCntrl;
begin
	create kc;
	cnStartTransaction(method.cnGetMethodName());
	
	process.sleep(100);
epilog
	cnEndTransaction();
	delete kc;
end;
}
cnTestJadeRecompleAllMethodsApplication
{
cnTestJadeRecompleAllMethodsApplication();

vars
	parameters	: HugeStringArray;
	
	proc		: Process;
begin
	beginTransientTransaction;
	create parameters sharedTransient;
	commitTransientTransaction;
	
	proc := app.startApplicationWithParameter(CN_ROOTSCHEMA, "JadeRecompileAllMethods", parameters);
	while app.isValidObject(proc) do
		app.doWindowEvents(2000);
	endwhile;
	
	if parameters.isEmpty then
		app.msgBox("No parameters", null, null);
	
	else
		app.msgBox("Last entry " & parameters.last, null, null);
	endif;
	
	beginTransientTransaction;
	delete parameters;
	commitTransientTransaction;
end;
}
cnTestManagedBackup
{
cnTestManagedBackup() updating;

vars
	dba	: CnDatabaseAdmin;
begin
	beginTransientTransaction;
	create dba sharedTransient;
	dba.setBackupRootDir("c:\cnwstdbackup");
	dba.setQuiesce(false);
	dba.setBackupWorkers(2);
	commitTransientTransaction;
	
	app.startApplicationWithParameter(CN_CARDSCHEMA, CN_KCONLINEBACKUP, dba);
end;
}
cnTestOSPlatform
{
cnTestOSPlatform();

vars
	osPlatform		: Integer;
	osArchitecture	: Integer;
	osVersion		: String;
begin
	osPlatform	:= node.getOSPlatform(osVersion, osArchitecture);
	app.msgBox("Platform=" & osPlatform.String & CrLf &
			   "osVersion=" & osVersion & CrLf &
			   "osArchitecture=" & osArchitecture.String, null, null);
end;
}
cnTestPerf
{
cnTestPerf() updating;

vars
 	array 	: StringArray;
 	i		: Integer;
 	str		: String;
 	s		: String;
begin
	write "Building array...";
	create array transient;
	while i < 10000 do
		array.add(#"00");
		i := i + 1;
	endwhile;

	write "Starting concatenation at " & app.actualTime.time.String;
	write "Array size=" & array.size.String;

	foreach s in array do
		str := s & "~";
	endforeach;

	write "Ended concatenation at " & app.actualTime.time.String;
epilog
	delete array;	
end;
}
cnTestSamplingProblem
{
cnTestSamplingProblem();

vars
	tag			: Integer;
	jdo			: JadeDynamicObject;
	i			: Integer;
	cnt			: Integer;
begin
	foreach i in 1 to 100000 do
		cnt := 37 * 54;
	endforeach;	

	create jdo transient;
	tag		:= node.beginSample("filesmpl", "<null>");
	write "After begin sample, returned sampling tag=" & tag.String;
	node.getObjectCaches(jdo, 1);
	write "NodeCPU at start=" & jdo.getPropertyValue("nodeCPUTime").Integer64.String;
	write Cn_Hits & " at start=" & jdo.getPropertyValue(Cn_Hits).Integer64.String;

	foreach i in 1 to 100000 do
		cnt := 37 * 54;							// burn some CPU
	endforeach;	
	
	node.getObjectCaches(jdo, 1);
	write "NodeCPU at end=" & jdo.getPropertyValue("nodeCPUTime").Integer64.String;
	write Cn_Hits & " at end=" & jdo.getPropertyValue(Cn_Hits).Integer64.String;

	node.endSample(tag);							// JADE doesn't seem to care about the tag
epilog
	delete jdo;
end;
}
cnTestSchemaAnalyser
{
cnTestSchemaAnalyser() updating;

vars
	sa		: CnSchemaAnalyser;
	kc		: CnKarmaCntrl;
	cc		: CnCntrl;
begin
//	create kc;
	create app.myCnCntrl;
	create sa transient;
	sa.analyse(null, false);
	
epilog
	delete sa;
end;
}
cnTestSecondsDifference
{
cnTestSecondsDifference();

vars
	t1, t2 : TimeStamp;
begin
	t1.setDate("23/9/99".Date);
	t1.setTime("23:00:00".Time);
	t2.setDate("24/9/99".Date);
	t2.setTime("00:30:05".Time);
	write t1.cnSecondsDifference(t2).String;
end;
}
cnTestServerApp
{
cnTestServerApp() serverExecution;

vars

begin
 	app.startApplication(CN_CARDSCHEMA, CN_KCCMGR);
	app.startApplication(CN_CARDSCHEMA, CN_KCCMGR);
	app.startApplication(CN_CARDSCHEMA, CN_KCCMGR);
	app.startApplication(CN_CARDSCHEMA, CN_KCCMGR);
	app.startApplication(CN_CARDSCHEMA, CN_KCCMGR);
	app.startApplication(CN_CARDSCHEMA, CN_KCCMGR);
	app.startApplication(CN_CARDSCHEMA, CN_KCCMGR);
end;
}
cnTestStartTransaction
{
cnTestStartTransaction();

vars
 	kc	: CnKarmaCntrl;
 	t1	: Decimal[19];
 	h	: Integer;
 	h2	: Integer;
 	h3	: Integer;
 	i	: Integer;
 	s	: String[2];
begin
 	create kc;

	t1	:= app.relativeMachineTime;
	cnStartTransaction("Test1");
	write "cnStartTran Elapsed=" & (app.relativeMachineTime - t1).String;
	foreach i in 1 to 10 do
		cnTest2(0);
	endforeach;

epilog
	cnEndTransaction();
    write "Elapsed=" & (app.relativeMachineTime - t1).String;
	delete kc;
end;
}
cnTestTimeStuff
{
cnTestTimeStuff() updating;

vars
	t : Time;
begin
	t := "600".cnHHMMTime;

	if not t.isValid then
		app.msgBox("Invalid time", "Error", 48);
	else
		write t.String;
	endif;
end;
}
cnTestUnicode
{
cnTestUnicode();

vars
	msg : CnSessionOpenAdvice;
	bin : Binary;
	c	: Character;
	b	: Boolean;
	str : String;
begin
	str := "abc";
	bin := str.cnUnicodeToAnsi();
	write bin.display;
end;
}
cnTestValidateMethodApplication
{
cnTestValidateMethodApplication();

vars
	parameters	: HugeStringArray;
	
	proc		: Process;
begin
	beginTransientTransaction;
	create parameters sharedTransient;
	commitTransientTransaction;
	
	proc := app.startApplicationWithParameter(CN_CARDSCHEMA, CN_KCVALIDATEMETHODS, parameters);
	while app.isValidObject(proc) do
		app.doWindowEvents(2000);
	endwhile;
	
	app.msgBox(parameters.last, null, null);
	beginTransientTransaction;
	delete parameters;
	commitTransientTransaction;
end;
}
cnTestVerifyJournal
{
cnTestVerifyJournal();

vars
	jdba 	: JadeDatabaseAdmin;
	file	: File;
	logNo	: Integer;
	path	: String;
begin
	create jdba transient;
	logNo	:= jdba.getCurrentJournalNumber();
	write "Verifying database journal #" & logNo.String;   
	path	:= "f:\joss30_m\logs\current";
	
	// from Hugh McColl 2Feb2011
	// A call to closeCurrentJournal is performed as inline synchronous code, 
	// thus guaranteeing that a journal switch record is written to the current
	// journal before the line of code returns. It is an atomic operation that 
	// preps the new journal and increments the currentJournal number as accessed
	// by getCurrentJournalNumber.
	jdba.closeCurrentJournal();
	jdba.verifyJournal(logNo, path);

	write "Verification of database journal #" & logNo.String & " completed OK.";  
	process.sleep(1000);
	delete jdba;
	create file transient;
	file.mode		:= file.Mode_IO;
	file.shareMode	:= file.Share_Exclusive;
	file.fileName	:= path & "/db" & logNo.String.padLeadingZeros(10) & ".scan";
	if file.isAvailable then
		file.purge();
		write "Journal scan log '" & file.fileName & "' removed.";
	else
		write "Journal scan log '" & file.fileName & "' not removed : not found.";
	endif;	
epilog
	delete file;
end;
}
cnTestWriteLog
{
cnTestWriteLog();

vars
bin : Binary;
 	kc	: CnKarmaCntrl;
 	cc	: CnCntrl;
 	i, j, k, l : Integer;
begin
	create kc;
	cc := app.myCnCntrl;
	i := 43;
	j := 0;
	k := 33;

	bin	:= "Received header or part header from cnwrwm1c.cnw.co.nz on connection #3, buf=CNW000255::::Testing - i:".Binary & i.Binary & ", j:".Binary & j.Binary & ", k".Binary & k.Binary & "ends".Binary;
	cc.cnWriteLog(cc.CnLogDiag, bin.String, null); 
epilog
	delete kc;
end;
}
cnUnloadSkins
{
cnUnloadSkins();

vars
	loader	: CnJadeSkinsLoader;
begin
	create loader transient;
	loader.unload(null, true);

epilog
	delete loader;
end;
}
cnUpdatePersistentAppVersion
{
cnUpdatePersistentAppVersion() updating;
/*
	Updates all version numbers for all applications in CardSchema, Joss and ScmSchema
*/
vars
	ap			: Application;
	dict		: AppNameDict;
	schema		: Schema;
	schemaDict	: SchemaNDict;
begin
	schema := currentSchema;
	create schemaDict transient;
	schemaDict.add(schema);
	schema := schema.getSubschema("Joss");
	if schema <> null then
		schemaDict.add(schema);
		schema := schema.getSubschema("ScmSchema");
		if schema <> null then
			schemaDict.add(schema);
		endif;
	endif;
	
	beginTransaction;
	foreach schema in schemaDict do
		dict	:= schema.cnGetApplications();
		foreach ap in dict do
			ap.appVersion	:= "3.2";
		endforeach;
	endforeach;
	commitTransaction;
epilog
	delete schemaDict;
end;
}
cnVerifyKarmaExternalFunctions
{
cnVerifyKarmaExternalFunctions();

vars
	str,
	strError,
	strOK		: String;
begin
	create app.myCnCntrl transient;
	str := "- cnFileVersionInfo";
	if self.cnZGetFileVersionInfo() then
		strOK := strOK & str & CrLf;
	
	else
		strError := strError & str & CrLf;
	endif;

	str := "- cnGetDriveInfo";
	if self.cnZGetDriveInfo() then
		strOK := strOK & str & CrLf;
	
	else
		strError := strError & str & CrLf;
	endif;

	str := "- cnGetDriveMapping";
	if self.cnZGetDriveMapping() then
		strOK := strOK & str & CrLf;
	
	else
		strError := strError & str & CrLf;
	endif;

	str := "- cnGetEnvironmentVariable";
	if self.cnZGetEnvironmentVariable() then
		strOK := strOK & str & CrLf;
	
	else
		strError := strError & str & CrLf;
	endif;

	str := "- cnGetLogicalDrives";
	if self.cnZGetLogicalDrives() then
		strOK := strOK & str & CrLf;
	
	else
		strError := strError & str & CrLf;
	endif;

	str := "- cnGetSubDirectories";
	if self.cnZGetSubDirectories() then
		strOK := strOK & str & CrLf;
	
	else
		strError := strError & str & CrLf;
	endif;

	str := "- cnHasSubDirectories";
	if self.cnZHasSubdirectories() then
		strOK := strOK & str & CrLf;
	
	else
		strError := strError & str & CrLf;
	endif;
epilog
	delete app.myCnCntrl;
	if strOK = null then
		strOK := "No valid entrypoints." & CrLf;
	
	else
		strOK := "Valid entrypoints:" & CrLf & strOK;
	endif;
	
	if process.isInExceptionState() then
		app.msgBox("Had exception while executing entrypoint " & str & CrLf & CrLf & strOK, null, null);
		return;
	endif;
	
	if strError = null then
		strError := "No missing entrypoints." & CrLf;
	
	else
		strError := "Missing entrypoints:" & CrLf & strError;
	endif;
	
	app.msgBox("External functions tested :" & CrLf &
				strError & CrLf &
				strOK, null, null);
				
end;
}
cnZGetDriveInfo
{
cnZGetDriveInfo() : Boolean protected;

vars
	result,
	sz			: Integer;
	
	volumeName,
	pcName		: String;
	
	returnArg	: Boolean;
	
	cc			: CnCntrl;
begin
	cc := app.myCnCntrl;
	sz := 1024;
	result := call cnGetDriveInfo("c:", volumeName, pcName);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " result=" & result.String & ", volumename=" & volumeName.String & ", pcName=" & pcName, null);
	returnArg := true;
/*	app.msgBox("Result=" & result.String & CrLf & 
				"Info=" & info & CrLf &
				"ErrText=" & errText, null, null);
*/
epilog
	return returnArg;
end;
}
cnZGetDriveMapping
{
cnZGetDriveMapping() : Boolean protected;

vars
	result,
	sz			: Integer;
	
	mapName,
	pcName		: String;
	
	returnArg	: Boolean;
	
	cc			: CnCntrl;
begin
	cc := app.myCnCntrl;
	sz := 1024;
	result := call cnGetDriveMapping("g:", mapName, 260);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " result=" & result.String & ", mapname=" & mapName, null);
	returnArg := true;

epilog
	return returnArg;
end;
}
cnZGetEnvironmentVariable
{
cnZGetEnvironmentVariable() : Boolean protected;

vars
	result,
	sz			: Integer;
	
	info,
	errText		: String;
	
	returnArg	: Boolean;
	
	cc			: CnCntrl;
begin
	cc := app.myCnCntrl;
	sz := 1024;
	result := call cnGetEnvironmentVariable("TEMP", info, sz);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " result=" & result.String & ", size=" & sz.String & ", value=" & info, null);
	returnArg := true;
/*	app.msgBox("Result=" & result.String & CrLf & 
				"Info=" & info & CrLf &
				"ErrText=" & errText, null, null);
*/
epilog
	return returnArg;
end;
}
cnZGetFileVersionInfo
{
cnZGetFileVersionInfo() : Boolean protected;

vars
	result		: Integer;
	
	info,
	errText		: String;
	
	returnArg	: Boolean;
	
	cc			: CnCntrl;
begin
	cc := app.myCnCntrl;
	result := call cnFileVersionInfo("d:\joss331\server\c_bin\jade.exe", "FileVersion", info, 200, errText);
	returnArg := true;
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " result=" & result.String & ", info=" & info & ", errText=" & errText, null);
/*	app.msgBox("Result=" & result.String & CrLf & 
				"Info=" & info & CrLf &
				"ErrText=" & errText, null, null);
*/
epilog
	return returnArg;
end;
}
cnZGetLogicalDrives
{
cnZGetLogicalDrives() : Boolean protected;

vars
	result,
	sz			: Integer;
	
	info,
	errText		: String;
	
	returnArg	: Boolean;
	
	cc			: CnCntrl;
begin
	cc := app.myCnCntrl;
	sz := 1024;
	result := call cnGetLogicalDrives(info);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " result=" & result.String & ", drives=" & info, null);
	returnArg := true;
epilog
	return returnArg;
end;
}
cnZGetSubDirectories
{
cnZGetSubDirectories() : Boolean protected;

vars
	result,
	sz			: Integer;
	
	info,
	errText		: String;
	
	returnArg	: Boolean;
	
	cc			: CnCntrl;
begin
	cc := app.myCnCntrl;
	sz := 8192;
	result := call cnGetSubDirectories("g:\", info, sz);
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " result=" & result.String & ", sz" & sz.String & " subDirList=" & info, null);
	returnArg := true;
epilog
	return returnArg;
end;
}
cnZHasSubdirectories
{
cnZHasSubdirectories() : Boolean protected;

vars
	result		: Boolean;
	sz			: Integer;
	
	info,
	errText		: String;
	
	returnArg	: Boolean;
	
	cc			: CnCntrl;
begin
	cc := app.myCnCntrl;
	result := call cnHasSubDirectories("g:\");
	cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " result=" & result.String, null);
	returnArg := true;
epilog
	return returnArg;
end;
}
zCnGetFTPRequiredInfo
{
zCnGetFTPRequiredInfo(pUserId, pPassWord, pServerName : String output) : Boolean protected;

vars

begin
    pUserId		:= app.userName();
	pPassWord 	:= "<Enter domain password for user " & pUserId & ">";
	read pPassWord;
	if pPassWord = null then
		return false;
	endif;
	
	pServerName:= "<Enter FTP server name>";
	read pServerName;
	if pServerName = null then
		return false;
	endif;
	
	return true;
end;
}
zExtractSchemaAndClasses_getSubClasses
{
zExtractSchemaAndClasses_getSubClasses(pClass : Class; pObjArray : ObjectArray input) protected;

/*
	Required by 2 other JadeScript methods retained in JossMethod schema:
	- emptyDatabaseActual
	- showPersistentClassInstances
*/
vars
	class,
	subclass : Class;
begin
	foreach class in pClass.cnGetSubClasses() do
		if not class.abstract then
			pObjArray.add(class);
		endif;
	
		subclass := class.cnGetSubClasses().first;
		if subclass <> null then
			self.zExtractSchemaAndClasses_getSubClasses(class, pObjArray);
		endif;
	endforeach;
end;
}
	)
	Lock (
	jadeMethodSources
getLockType
{
getLockType() : String;

vars
	typeNumeric	: Integer;
begin
	typeNumeric	:= self.type.Integer;
	if typeNumeric = Share_Lock then
		return "ShareLock";
	
	elseif typeNumeric = Exclusive_Lock then
		return "ExclusiveLock";
		
	elseif typeNumeric = Reserve_Lock then
		return "ReserveLock";
		
	elseif typeNumeric = Update_Lock then
		return "UpdateLock";
	
	else
		return "unknownLockType (" & typeNumeric.String & ")";
	endif;
end;
}
	)
	Node (
	jadeMethodSources
cnCheckApplicationAlreadyRunningInNode
{
cnCheckApplicationAlreadyRunningInNode(pClass : Class) : Boolean;

/*
	Refer to PAR #1065.
	
	Description:
		This method checks if this application is already running or not in this node. and returns true or false.
	Methodology:
		Create a unique transient class (eg CnKCNodeControl) as a sub-class under Cn_Locks that is to be solely 
		associated with a specific application.
		
		Execute this method passing in the unique class name.
		
		If the application associated with this class is already running, this method will identify that.
		
		The shared transient is only created once per node and does not need to be explicitly removed as this 
		will be deleted when the node terminates.
		
*/
constants
	Max_Attempts	: Integer	= 1;
vars
	cc				: CnCntrl;
	
	obj				: Object;
begin
	cc := app.myCnCntrl;
	obj := app.cnGetSharedTransient(pClass, Max_Attempts);
	if obj = null then
		return true;
	endif;
	
	// unlock the shared transient that we've just obtained
	unlock(obj);
	return false;
end;
}
cnCheckDuplNodeApplication
{
cnCheckDuplNodeApplication(pClass : Class);

/*
	Description:
		This method checks if this application is already running or not in this node.
	
	Methodology:
		Create a unique transient class (eg CnKCNodeControl) as a sub-class under Cn_Locks that is to be solely 
		associated with a specific application.
		
		Execute this method passing in the unique class name.
		
		If the application associated with this class is already running, this method will cause it to terminate.
		
		The shared transient is only created once per node and does not need to be explicitly removed as this 
		will be deleted when the node terminates. If KCNodeControl terminates and restarts within the node, it will
		find and lock the shared transient, which will cause other copies of KCNodeControl starting in this node to 
		fail.
*/
constants
	Max_Attempts	: Integer	= 30;
vars
	cc				: CnCntrl;
	
	obj				: Object;
begin
	cc := app.myCnCntrl;
	obj := app.cnGetSharedTransient(pClass, Max_Attempts);
	if obj = null then
		cc.cnWriteLog(cc.CnLogDiag, method.cnGetMethodName() & " duplicate application running in node, terminating...", null);
		app.cnTerminate();
	endif;
end;
}
cnGetComputerName
{
cnGetComputerName() : String;

vars
	id	: String;
begin
	id := cnGetInstanceId(self).String;
	return self.name[1 : self.name.length - id.length];
end;
}
cnGetNameFromCommandLine
{
cnGetNameFromCommandLine() : String;

vars
	line	: String;
	ix		: Integer;
	array	: CnStringArray;
begin
	line	:= self.getCommandLine.toLower;
	array	:= line.cnGetTokensUsingTruthSet(" =");
	ix		:= array.indexOf("name");
	if ix > 0 then
		ix	:= ix + 1;
		if ix <= array.size then 
			return array[ix];
		endif;
	endif;
epilog
	delete array;
end;
}
cnGetServerCacheSizes
{
cnGetServerCacheSizes(pc, tc, rc, pdb : Integer64 output) serverExecution;

vars
 	str		: String;
 	s2		: String;
 	pos		: Integer;
 	
begin
	node.getCacheSizes64(pc, tc, rc);
	//
	str 	:= app.getProfileString(app.getIniFileName, "PersistentDb", "ObjectCacheSizeLimit", "4M").toUpper;
	pos		:= 1;
	s2		:= str.scanWhile(" 1234567890", pos).trimBlanks();
	
	if pos = 0 then 											// convert ini file value to megabytes : JSM PAR 1855
		pdb	:= (s2.Real / CN_BYTES_PER_MEGABYTE).rounded;
	
	elseif str[pos]	= "K" then
		pdb	:= (s2.Real / CN_BYTES_PER_KILOBYTE).rounded;
		
	elseif str[pos] = "M" then
		pdb	:= s2.Integer;
		
	elseif str[pos] = "G" then
		pdb	:= s2.Integer * CN_BYTES_PER_GIGABYTE;
	endif;
end;
}
cnIsApplicationRunningInNode
{
cnIsApplicationRunningInNode(pApplicationName : String; pExcludeSelf : Boolean) : Boolean;
/*
	Identifies if the named application is running within this node.
	
*/
vars
	obj			: Object;
 	proc		: Process;
	procSet		: ObjectSet;
	badObject	: Boolean;
begin
	create procSet transient;
	self.processes.copy(procSet);		// use set to avoid locking each object as we're not worried about order
	/////  Gets first process for specified node based on app name
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, proc, badObject);
	foreach obj in procSet do
		proc := obj.Process;
		if pExcludeSelf and proc = process then
			continue;
		endif;
		
		if proc.persistentApp.name = pApplicationName then
			return true;
		endif;
	endforeach;
	
	return false;
epilog
	delete procSet;
end;
}
	)
	Process (
	jadeMethodSources
cnGetTransactionStartTime
{
cnGetTransactionStartTime(pMilliseconds : Integer output) : TimeStamp;

vars
	msTs	: Integer;
	
	ts,
	tsNow	: TimeStamp;
	
	tsi		: TimeStampInterval;
begin
	if not process.isInTransactionState() then
		return null;
	endif;
	
	msTs := system.getTimeInTransactionState(self);
	tsi.set(null, msTs);
	ts := tsNow - tsi;
	pMilliseconds := msTs;
	return ts;
end;
}
cnSetThreadPriority
{
cnSetThreadPriority(priority : String) : String;

vars
	result	: Integer;
	str		: String;
	cc		: CnCntrl;
begin
	cc	:= app.myCnCntrl;
	if self <> process then
		str	:= "Prority change attempted on " & self.String & " not allowed: can only change own priority.";
		cc.cnWriteLog(cc.CnLogErrors, str , null);
		return str;
	endif;

	result	:= emSetThreadPriority(priority);
	if result <> 0 then
		str	:= "Attempted to set priority to " & priority & " but failed : result = " & result.String & ".";
		cc.cnWriteLog(cc.CnLogErrors, str , null);
		return str;
	else	
		cc.cnWriteLog(cc.CnLogDiag, "Thread priority for " & self.String & " successfully changed to " & priority, null);  
		return CN_OK;
	endif;
end;
}
	externalMethodSources
emSetThreadPriority
{
emSetThreadPriority(priority: String): Integer is "emSetThreadPriority" in "karma" protected, number = 1002;
}
	)
	Schema (
	jadeMethodSources
cnGetApplications
{
cnGetApplications()  : AppNameDict;

vars

begin
 	return self._applications;
end;
}
cnGetGlobalConstants
{
cnGetGlobalConstants() : ConstantNDict;

vars

begin
	return consts;
end;
}
	)
	SchemaEntity (
	jadeMethodSources
cnGetModifiedTimeStamp
{
cnGetModifiedTimeStamp() : TimeStamp;

vars

begin
	return modifiedTimeStamp;
end;
}
cnGetModifierName
{
cnGetModifierName() : String;

vars

begin
	if self.isKindOf(Property) then
		return self.getPropertyValue("_modifiedBy").String;		// this works for properties only and is undocumented so runs same risk as using attr userProfile.
	endif;

	return self.sendMsgWithParams("_get_modifiedBy").String;		// the method _get_modifiedBy is also a systemOnly call and is undocumented so runs same risk as using attr userProfile.
end;
}
cnGetPatchNumber
{
cnGetPatchNumber() : Integer;

vars

begin
	return self.getPatchNumber();
end;
}
	)
	DbFile (
	jadeMethodSources
cnGetKind
{
cnGetKind() : String;

vars
	xKind	: Integer;
begin
	xKind := self.kind;
	if xKind = self.Kind_Control then
		return "Control";
	endif;
	
	if xKind = 	self.Kind_Environmental then
		return "Environment";
	endif;
	
	if xKind = 	self.Kind_User_Data then
		return "User Data";
	endif;

	if xKind = 	self.Kind_User_Schema then
		return "User Schema";
	endif;

	if xKind = 	self.Kind_Utility then
		return "Utility";
	endif;

	if xKind = 	self.Kind_System then
		return "System";
	endif;

	if xKind = 	self.Kind_Unknown then
		return "Unknown";
	endif;

	return "<unknown " & xKind.String & ">";
end;
}
cnGetStatus
{
cnGetStatus() : String;

vars
	xFileStatus	: Integer;
begin
	xFileStatus := self.getFileStatus();
	if xFileStatus = self.Status_Resident then
		return "Resident";
	endif;
	
	if xFileStatus = self.Status_Missing then
		return "Missing";
	endif;

	if xFileStatus = self.Status_NotCreated then
		return "Not Created";
	endif;
	
	if xFileStatus = self.Status_NotAssigned then
		return "Not Assigned";
	endif;
	
	if xFileStatus = self.Status_Offline then
		return "Offline";
	endif;
	
	if xFileStatus = self.Status_Deleted then
		return "Deleted";
	endif;
	
	if xFileStatus = self.Status_InvalidPath then
		return "Invalid Path";
	endif;

	if xFileStatus = self.Status_Unmapped then
		return "Unmapped";
	endif;

	return "<unknown " & xFileStatus.String & ">";
end;
}
cnGetStatusFromInput
{
cnGetStatusFromInput(pFileStatus : Integer) : String;

vars
	
begin
	if pFileStatus = self.Status_Resident then
		return "Resident";
	endif;
	
	if pFileStatus = self.Status_Missing then
		return "Missing";
	endif;

	if pFileStatus = self.Status_NotCreated then
		return "Not Created";
	endif;
	
	if pFileStatus = self.Status_NotAssigned then
		return "Not Assigned";
	endif;
	
	if pFileStatus = self.Status_Offline then
		return "Offline";
	endif;
	
	if pFileStatus = self.Status_Deleted then
		return "Deleted";
	endif;
	
	if pFileStatus = self.Status_InvalidPath then
		return "Invalid Path";
	endif;

	if pFileStatus = self.Status_Unmapped then
		return "Unmapped";
	endif;

	return "<unknown " & pFileStatus.String & ">";
end;
}
	)
	Method (
	jadeMethodSources
cnGetExecutionLocation
{
cnGetExecutionLocation() : Character;

vars

begin
 	return executionLocation;
end;
}
cnGetMethodName
{
cnGetMethodName() : String;

vars

begin
	return self.getSchema().name & "::" &
		   self.qualifiedName(); 
end;
}
cnGetParameters
{
cnGetParameters() : ParameterColl;

vars

begin
 	return parameters;
end;
}
cnGetPriorMethod
{
cnGetPriorMethod(offset : Integer; codePosition : Integer output) : Method;

vars
	ps		: ProcessStackArray;
	md		: MethodCallDesc;
	meth	: Method;
	i		: Integer;
begin
	create ps transient;
	process.currentStack(ps);
//	ps.inspectModal;

	if offset < 2 then
		i	:= 4;
	else
		i	:= offset + 3;
	endif;
	
	if i > ps.size then
		md	:= ps[ps.size];
	else
		md	:= ps[i];
	endif;
	
	meth			:= md.method;
	codePosition	:= md.position;
	return meth;
	
epilog
	ps.purge();
	delete ps;
end;
}
cnGetSourceLine
{
cnGetSourceLine(position: Integer): String abstract, number = 1005;
}
resetSubAccess
{
resetSubAccess() updating;

vars

begin
 	subAccess := 0.Character;
end;
}
	)
	ExternalMethod (
	jadeMethodSources
cnGetSourceLine
{
cnGetSourceLine(position : Integer) : String;

vars
	lib		: Library;
	libname	: String;
	str		: String;	
	cc		: CnCntrl;
	ed		: Integer;
	badObj	: Boolean;
begin
	cc		:= app.myCnCntrl;
	lib		:= self.library;
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, lib, badObj);
	ed := lib.edition;
	if badObj then
		libname := "<invalid object>";
	
	else
		libname := lib.name;
	endif;

	return self.entrypoint & " in " & libname & " @ line # " & position.String; 
end;
}
	)
	JadeMethod (
	jadeMethodSources
cnGetLocalVars
{
cnGetLocalVars() : JadeLocalVarColl ;

vars

begin
	return localVars;
end;
}
cnGetSourceLine
{
cnGetSourceLine(pPosition : Integer) : String;

vars
	e,
 	i,
	len		: Integer;
	
	str		: String;
begin
	str := self.getSource();					// was 'str := self.source;' until Nick Scott highlighted the issue here with encrypted source
	if str = null then
		return "<Source not available>";
	endif;

	i := pPosition;
	if i < 1 then 
		return "<Position not specified>";
	endif;

	len := str.length();
	if i > len then
		return "<Position > source length>";
	endif;

	while str[i] <> ";" 	and 
		  str[i] <> #"0D" 	and 
		  i > 2 			do
		i := i - 1;
	endwhile;

	while str[i] = ";" 		or 
		  str[i] < #"21" 	do
		i := i + 1;
		if i > len then
			return "<Forward scan couldn't find start of line>";
		endif;
	endwhile;

	e := str.pos(";", i);
	if e = null then
		return "<Forward scan couldn't find end of code line>";
	endif;
	
	return str[i : e - i + 1];
end;
}
	)
	Type (
	jadeMethodSources
cnGetMethods
{
cnGetMethods() : MethodNDict;

vars

begin
	return methods;
end;
}
	)
	Class (
	jadeMethodSources
cnDeleteTransientInstances
{
cnDeleteTransientInstances() updating;

vars
 	coll 	: ObjectArray;
 	obj		: Object;
begin
	create coll transient;
 	self.allProcessTransientInstances(coll, 0, false);
 	foreach obj in coll do
 		delete obj;
 	endforeach;

 	coll.clear();
epilog
 	delete coll;
end;
}
cnGetProperties
{
cnGetProperties() : PropertyNDict;

vars

begin
	return properties;
end;
}
cnGetSubClasses
{
cnGetSubClasses() : ClassNDict;

vars

begin
	return subclasses;
end;
}
	)
	System (
	jadeMethodSources
cnGetDeltaDatabaseStatusString
{
cnGetDeltaDatabaseStatusString(pDeltaDatabaseStatus : Integer) : String;

vars
	str	: String;
begin
	if pDeltaDatabaseStatus = null then
		str := "Not delta database capable";
	
	elseif pDeltaDatabaseStatus = 1 then
		str := "Inactive";
	
	elseif pDeltaDatabaseStatus = 2 then
		str := "Active";
	
	elseif pDeltaDatabaseStatus = 3 then
		str := "Pending active";
	
	elseif pDeltaDatabaseStatus = 4 then
		str := "Pending inactive";
	
	else
		str := "<unknown : " & pDeltaDatabaseStatus.String;
	endif;
	
	return str;
end;
}
cnIsApplicationRunning
{
cnIsApplicationRunning(pApplicationName : String; pExcludeSelf : Boolean) : Boolean;
/*
	Identifies if the named application is running anywhere in the system.

*/
vars
 	proc		: Process;
	badObject	: Boolean;
begin
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, proc, badObject);
	
	// use of Process.instances creates a virtual collection
	// thereby avoiding excessive lock contention on system.nodes
	// and node.processes collections
	foreach proc in Process.instances do
		if pExcludeSelf and proc = process then
			continue;
		endif;
		
		if proc.persistentApp.name = pApplicationName then
			return true;
		endif;
	endforeach;
	
	return false;
end;
}
cnIsApplicationRunningInNode
{
cnIsApplicationRunningInNode(pNode : Node; pApplicationName : String; pExcludeSelf : Boolean) : Boolean;
/*
	Identifies if the named application is running within specified node.
	
*/
vars
	obj			: Object;
 	proc		: Process;
	procSet		: ObjectSet;
	badObject	: Boolean;
begin
	create procSet transient;
	pNode.processes.copy(procSet);		// use set to avoid locking each object as we're not worried about order
	/////  Gets first process for specified node based on app name
	on SystemException do app.cnHandleNullOrInvObjectRef(exception, proc, badObject);
	foreach obj in procSet do
		proc := obj.Process;
		if pExcludeSelf and proc = process then
			continue;
		endif;
		
		if proc.persistentApp.name = pApplicationName then
			return true;
		endif;
	endforeach;
	
	return false;
epilog
	delete procSet;
end;
}
	)
	CnToolBarPicture (
	jadeMethodSources
click
{
click(pict : Picture input) updating;

vars

begin
	if app.activeForm <> pict.form then
		pict.form.show;
	endif;

 	inheritMethod(pict);
end;
}
create
{
create() updating;

vars

begin
	borderStyle := 0;
 	width := 24;
 	height := 22;
 	backColor := getSystemColor(Color_3DFace);
 	transparent := true;
 	transparentColor := 192 + 192*256 + 192*256*256;
end;
}
mouseLeave
{
mouseLeave(pict : Picture input) updating;

vars

begin
	if mouseOver then
		mouseOver := false;
		refresh;
	endif;
end;
}
mouseMove
{
mouseMove(pict : Picture input; button : Integer; shift : Integer; x : Real; y : Real) updating;

vars

begin
	if x < 0
	or y < 0
	or x > pict.width
	or y > pict.height then
		if mouseOver then
			mouseOver := false;
			pict.refresh;
		endif;
	else
		if not mouseOver then
			mouseOver := true;
			pict.refresh;
		endif;
	endif;
end;
}
paint
{
paint(pict : Picture input) updating;

vars
 	colour : Integer;
begin
 	if mouseOver
	and not upAndDownSwapped then
		colour := getSystemColor(Color_3DHighlight);
		pict.drawLine(0, 0, pict.width, 0, colour);	// top
		pict.drawLine(0, 0, 0, pict.height, colour);	// left 
		colour := getSystemColor(Color_3DShadow);
		pict.drawLine(pict.width-1, pict.height-1, pict.width-1, 0, colour);	// right
		pict.drawLine(pict.width, pict.height-1, 0, pict.height-1, colour);	// bottom
	endif;
end;
}
	)
	Table (
	jadeMethodSources
cnAdjustColumnWidth
{
cnAdjustColumnWidth(pColumn:Integer) updating;

// Adjusts the width of a column to the width of the longest text in any row of that column.

vars
	extent, biggest, tRow:Integer;
begin

    tRow := 1;
    self.column := pColumn;
    while tRow <= self.rows do
    	self.row := tRow;
    	extent := getTextExtent(self.text);
    	if extent > biggest then
    		 biggest := extent;
    	endif;
    	tRow := tRow + 1;
    endwhile;

    self.columnWidth[pColumn] := biggest + 20;
end;
}
cnAdjustColumnWidths
{
cnAdjustColumnWidths() updating;

vars
	col	:	Integer;
begin

	if self.columns > 0 then
		foreach col in 1 to self.columns - 1 do
			cnAdjustColumnWidth(col);
		endforeach;
		cnAdjustLastColumn;
	endif;		
end;
}
cnAdjustLastColumn
{
cnAdjustLastColumn() updating;

// Adjusts the right-most column so that it occupies the whole space between its left edge and the right-most edge of the table area.

vars

begin
	if self.columns > 0 then
		self.columnWidth[self.columns] := self.clientWidth - self.leftColumn;
	endif;
end;
}
cnSetHeading
{
cnSetHeading(pColumn:Integer; pHeading:String; pAlignment:Integer) updating;

vars

begin

	if self.rows = 0 then
		self.rows					:= 1;
		self.fixedRows				:= 1;
	endif;	
	self.row 						:= 1;
	self.column 					:= pColumn;
	self.accessMode 				:= AccessMode_Column;
	self.alignment 					:= pAlignment;
	self.fontBold 					:= false;
	self.columnWidth[self.column] 	:= getTextExtent(pHeading) + 5;
	self.setCellText(self.row, self.column, pHeading);
end;
}
	)
	Form (
	jadeMethodSources
cnSetScaleForm
{
cnSetScaleForm(set : Boolean) updating;

vars

begin
	self.scaleForm := set;
end;
}
	)
	CnConnectionForm (
	jadeMethodSources
btnClose_click
{
btnClose_click(btn: Button input) updating;

vars

begin
	self.unloadForm();
end;
}
btnClose_windowCreated
{
btnClose_windowCreated(cntrl: Control input; persistCntrl: Control) updating;

vars

begin
	cntrl.top := -1;
	cntrl.left := -1;
	cntrl.width := null;
	cntrl.height := null;
end;
}
load
{
load() updating;

constants
	Indent_Spaces	: String = "                                                  ";
vars
	kc 			: CnKarmaCntrl;
	
	stringArray	: CnStringArray;
	
	dbRole,
	maxLength,
	pos,
	row			: Integer;
	
	appServer,
	appServerPort,
	commandLine,
	dbRoleName,
	displayText,
	str			: String;
begin
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);	
	kc := app.myCnKarmaCntrl;
	
	dbRole := system.getDatabaseRole();
	dbRoleName := "Non-SDS";
	if dbRole = SDS_RolePrimary then
		dbRoleName := "SDS Primary";
	
	elseif dbRole = SDS_RoleSecondary then
		dbRoleName := "SDS Secondary";
	endif;
	
	commandLine := process.getCommandLine().toLower();
	pos := 1;
	pos := commandLine.pos("appserver=", pos);
	if pos <> null then
		pos := pos + "appserver=".length();
		appServer := commandLine.scanUntil(CN_SPACE, pos);
	endif;

	pos := 1;
	pos := commandLine.pos("appserverport=", pos);
	if pos <> null then
		pos := pos + "appserverport=".length();
		appServerPort := commandLine.scanUntil(CN_SPACE, pos);
	endif;
	
	create stringArray transient;
	stringArray.add("Your Computer Name  " 		& process.getComputerName());
	stringArray.add("IP Address  " 				& kc.networkAddressProcess);
	stringArray.add("JADE Environment Name  " 	& kc.environmentId.toUpper());
	stringArray.add("Database Role  " 			& dbRoleName);
	stringArray.add("Server Name  "				& node.getComputerName());
	stringArray.add("Server IP Address " 		& kc.networkAddressNode);
	stringArray.add(null);
	stringArray.add("Commandline AppServer  " 	& appServer);
	stringArray.add("Commandline AppServerPort  " & appServerPort);
	foreach str in stringArray do
		maxLength := str.length().max(maxLength);
	endforeach;
	
	foreach str in stringArray do
		displayText := displayText & CrLf & Indent_Spaces[1:maxLength - str.length()] & str;
	endforeach;
	
	tbxDetails.text := displayText;
	
	frmShutdown.caption := "Shutting down in 60 seconds....";
	self.beginTimer(60000, Timer_OneShot, self.Close_Down);
	self.beginTimer(2000, Timer_Continuous, self.Reminder);

	self.centreWindow;
end;
}
timerEvent
{
timerEvent(eventTag : Integer) updating;

vars
	option,
	timeRemain : Integer;
begin
	if eventTag = self.Reminder then
		self.getTimerStatus(self.Close_Down, option, timeRemain);
		frmShutdown.caption := "Shutting down in " & (timeRemain div 1000).String & " seconds....";
		self.refreshNow();
		return;
	endif;
	
	if eventTag = self.Close_Down then
		app.cnTerminate();
	endif;
end;
}
unload
{
unload() updating;

vars
 	cc : CnCntrl;
begin
	if denyStartup or delay = 0 then
		cc := app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogComment, "------- Application Shut Down : Server is Shutting Down  -------------", null);
		app.cnTerminate();
	endif;
end;
}
	)
	CnDumpForm (
	jadeMethodSources
load
{
load() updating;

vars
	cc	: CnCntrl;
begin
	cc := app.myCnCntrl;
	laText.caption 	:= "Error " & exObj.errorCode.String & CrLf & exObj.text;
	laHelp.caption	:= "Your application is saving a program stack dump for diagnostic" & CrLf &
					   "purposes.  This may take a minute or two .... please wait.";
	self.caption 	:= "Application error in " & cc.appName & "/" & cnGetInstanceId(process).String;  
	self.width		:= 613;
	self.height		:= 211;
	
	setupPicture();
end;
}
positionPicture
{
positionPicture(pic : Picture input) updating;

vars

begin
	pic.left	:= 16;
	pic.top		:= 29;
	pic.visible	:= true;
	pic.zOrder(1);
end;
}
setupPicture
{
setupPicture() updating;

vars
	pictureType	: Integer;
begin
	pictureType	:= app.myCnCntrl.exceptionFormPicture;

	if userPicture <> null then
		picRoadSign.picture	:= userPicture;
		picRoadSign.visible	:= true;
	elseif pictureType = Cn_Green_Frog then
		positionPicture(picGreenFrog);
	elseif pictureType = Cn_Original_Green_Frog then
		positionPicture(picOriginalFrog);
	elseif pictureType = Cn_Rainbow_Frog then
		positionPicture(picRainbowFrog);
	elseif pictureType = Cn_Green_Frog_Photo then
		positionPicture(picFrogPhoto);
	else
		picRoadSign.visible := true;
	endif;
end;
}
	)
	CnExceptionForm (
	jadeMethodSources
bAbort_click
{
bAbort_click(btn: Button input) updating;

vars

begin
	unloadForm;
end;
}
bClose_click
{
bClose_click(btn: Button input) updating;

vars

begin
	unloadForm;
end;
}
bClose_windowCreated
{
bClose_windowCreated(cntrl: Control input; persistCntrl: Control) updating;

vars

begin
	cntrl.top	:= bAbort.top;
end;
}
bTerminate_click
{
bTerminate_click(btn: Button input) updating;

vars

begin
	app.cnTerminate();
end;
}
load
{
load() updating;

vars
 	cc 			: CnCntrl;
	
	helpStr,
	versionStr	: String;
begin
	cc 			:= app.myCnCntrl;
	self.centreWindow();
	versionStr	:= app.appVersion;																								// PAR 1034
	if versionStr = null then																									// PAR 1034
		versionStr := "<not defined>";																							// PAR 1034
	endif;																														// PAR 1034
	
	self.caption := "Application Error   App=" & cc.appName & "   Version=" & versionStr;										// PAR 1034
	if myException.isKindOf(FatalError) then
		laType.caption := "Fatal Error";

	elseif myException.isKindOf(SystemException) then
		if myException.isKindOf(ConnectionException) then
			laType.caption := "Connection Error";
			
		elseif myException.isKindOf(FileException) then
			laType.caption := "File Error";
			
		elseif myException.isKindOf(IntegrityViolation) then
			laType.caption := "Integrity Violation";
			
		elseif myException.isKindOf(LockException) then
			laType.caption := "Locking Error";
			
		else
			laType.caption := "System Error";
		endif;

    elseif myException.isKindOf(UserInterfaceException) then
    	laType.caption	:= "User Interface Error";
		
    elseif myException.isKindOf(NormalException) then
    	laType.caption := "Application Program Error";
		
    else
    	laType.caption := "General Exception";					// probably 'Exception'
    endif;

    laText.caption := "Error Code " & myException.errorCode.String & CrLf & myException.text;
    helpStr := "Refer to application logs for more information.";
	if app.cnStackDumpFileName <> null then
		helpStr := helpStr & CrLf & "Stack dump : " & app.cnStackDumpFileName;
	endif;

	laHelp.caption := helpStr;
	if cc.exceptionDisplayModal then
		bTerminate.visible 	:= true;
		bAbort.visible		:= true;
        laAction.caption 	:= "Application is now waiting on your action - Abort or Terminate";
	
	else
    	bClose.visible  	:= true;
    	if cc.exceptionDisplayTimeout > 0 then
    		remainingTime	:= cc.exceptionDisplayTimeout;
            laAction.caption := "This notification will disappear in " & remainingTime.String & " seconds, or" & CrLf &
                                "you may press 'Close' now."; 
    		beginTimer(1000, Timer_OneShot, 1);
    		beginTimer(cc.exceptionDisplayTimeout * 1000, Timer_OneShot, 2);
			
    	else
    		laAction.caption := "Your transaction has been automatically aborted, however this notification will " &
    						    "remain here until you press 'Close'";
    	endif;
    endif;
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;

vars

begin
	if eventTag = 1 then
		remainingTime := remainingTime -1;
		laAction.caption := "This notification will disappear in " & remainingTime.String & " seconds, or" & CrLf &
                                "you may press 'Close' now."; 
        beginTimer(1000, Timer_OneShot, 1);
    endif;

    if eventTag = 2 then
    	unloadForm;
    endif;
end;
}
unload
{
unload() updating;

vars

begin
 	endTimer(1);
end;
}
	)
	CnKCGui (
	jadeMethodSources
btnTerminate_click
{
btnTerminate_click(btn: Button input) updating;

vars
	result	: Integer;
begin
	result := app.msgBox("Clicking this button will terminate this application." & CrLf & CrLf &
							"Are you sure?", "Warning", MsgBox_OK_Cancel);
	if result = MsgBox_Return_OK then
		app.cnTerminate();
	endif;
end;
}
load
{
load() updating;

vars

begin
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	cnStartTransaction(method.qualifiedName);
epilog
	cnEndTransaction();
end;
}
	)
	CnKCGuiTimer (
	jadeMethodSources
btnTerminate_click
{
btnTerminate_click(btn: Button input) updating;

vars

begin
	self.zTerminate();
end;
}
load
{
load() updating;

vars

begin
	app.cnActivateKarmaControl(Cn_Fat_Client, null, null);
	cnStartTransaction(method.qualifiedName);
	self.beginTimer(5000, Timer_OneShot, 101);
epilog
	cnEndTransaction();
end;
}
timerEvent
{
timerEvent(eventTag: Integer) updating;

vars

begin
	self.zTerminate();
end;
}
zTerminate
{
zTerminate() protected;

vars

begin
	beginTransaction;
	node.userExitCode := 1;
	commitTransaction;
	app.cnTerminate();
end;
}
	)
	CnTransferProgress (
	jadeMethodSources
bCancel_click
{
bCancel_click(btn: Button input) updating;

vars
	cc : CnCntrl;
begin
	cc := app.myCnCntrl;
	if app.msgBox("All files have not yet been transferred.  Do you really wish to cancel ?",
	              "File Transfer Cancellation", MsgBox_Yes_No) = MsgBox_Return_Yes then
		cc.cnWriteLog(cc.CnLogComment, "File transfer cancelled at user request : current file = " & myFTO.currentFileName, null);
		app.cnTerminate();
	endif;
end;
}
getDivisionFactor
{
getDivisionFactor(filesize : Integer) : Integer;

vars

begin
 	if 	   filesize < 32000000 then					// 32 MB
 		return 1000;
 	elseif filesize < 320000000 then           		// 320 MB
 		return 10000;
 	elseif filesize < 3200000000 then				// 3.2 GB
 		return 100000;
 	elseif filesize < 32000000000 then				// 320 GB
 		return 1000000;
 	else											// 3200 GB Max
 		return 10000000;
 	endif;
end;
}
getTimeDifference
{
getTimeDifference(timeSt1, timeSt2 : TimeStamp) : Real updating;

vars
	secs1, secs2	: Real;
	diff			: Real;
	ts, ts1, ts2	: TimeStamp;
begin
	ts1	:= timeSt1;
	ts2 := timeSt2;

	if ts2 < ts1 then				
		ts := ts1;
		ts1 := ts2;
		ts2 := ts;
	endif;

	if ts1 = ts2 then
	 	return 0;
	else
		if ts1.date = (ts2.date - 1) then
		 	secs2 := 60 * 60 * 24;	

		elseif ts1.date <> ts2.date then
			return -1;
		endif;


		secs1 := ts1.time.hour * 3600 + ts1.time.minute * 60 + ts1.time.second + ts1.time.milliSecond/1000;
		secs2 := ts2.time.hour * 3600 + ts2.time.minute * 60 + ts2.time.second + ts2.time.milliSecond/1000;
		diff  := secs2 - secs1;
		return diff;
	endif; 
end;
}
load
{
load() updating;

vars
 	ts : TimeStamp;
begin
	laFile.caption := "Copying file : " & myFTO.currentFileName;
	beginNotification(myFTO, Cn_Transfer_Progress, 0, 0);	
	beginNotification(myFTO, Cn_Transfer_Complete, 0, 0);
	self.startTime := ts;						
end;
}
unload
{
unload() updating;

vars

begin
 	endNotificationForSubscriber(self);
end;
}
userNotify
{
userNotify(eventType: Integer; theObject: Object; eventTag: Integer; userInfo: Any) updating;

vars
	fto 	: CnInternet;
	bytes	: Integer;
	elapsed	: Real;
	remain	: Real;
	ts		: TimeStamp;
	time	: Time;
	pc		: Real;
	cfactor	: Integer;
	tfactor	: Integer;
begin
	if eventType = Cn_Transfer_Progress then
		fto := theObject.CnInternet;
		laFile.caption := "Copying file : " & fto.currentFileName;
		cfactor := getDivisionFactor(fto.currentFileSize);
		tfactor := getDivisionFactor(fto.totalBytesToBeTransferred);
        pbCurrentFile.partsInJob := fto.currentFileSize div cfactor;
        pbCurrentFile.partsDone	 := fto.fileBytesTransferred div cfactor;
        pbAllFiles.partsInJob	 := fto.totalBytesToBeTransferred div tfactor;
        pbAllFiles.partsDone	 := fto.totalBytesTransferred div tfactor;

        //  Now compute estimate of remaining time

        elapsed := getTimeDifference(startTime, ts);				// this is in seconds
        pc		:= fto.totalBytesToBeTransferred / fto.totalBytesTransferred;
        remain  := ((elapsed * pc) - elapsed).rounded;
        time.setTime(0,0,remain.Integer, 0);
        laRemaining.caption := "Estimated time remaining : " & time.String;
	endif;
end;
}
	)
	CnLogOptions (
	jadeMethodSources
bCancel_click
{
bCancel_click(btn: Button input) updating;

vars

begin
  	unloadForm;
end;
}
bOK_click
{
bOK_click(btn: Button input) updating;

vars
 	cc 		: CnCntrl;
 	iniFile	: String;
 	str		: String;
begin
	if tbLogFilePath.text = "" or tbLogFilePath.text = "" then
		app.msgBox("Log file path and file name must always be provided", "Error", 0);
		return;
	endif;

	cc := app.myCnCntrl;

	cc.setLogPath(tbLogFilePath.text);
	cc.setLogFileName(tbLogFileName.text);
	cc.setLogging(cbxLogging.value);	
	cc.setLogCommsBuffers(cbxLogCommsBuffers.value);
	cc.setLogCommsConnections(cbxLogConnect.value);
	cc.setLogDiagnostics(cbxLogDiagnostics.value);
	cc.setLogToScreen(cbxLogToScreen.value);
	cc.setLogCommsComputer(tbHostFQDN.text);
	cc.setLogImmediateCommit(cbxImmediateCommit.value);

	iniFile := app.getIniFileNameAppServer;
	app.setProfileStringAppServer(iniFile, "CardLog", "LogPath", tbLogFilePath.text);
	app.setProfileStringAppServer(iniFile, "CardLog", "LogFileName", tbLogFileName.text);
	app.setProfileStringAppServer(iniFile, "CardLog", "Logging", cc.logging.String);
	app.setProfileStringAppServer(iniFile, "CardLog", "LogCommsBuffers", cc.logCommsBuffers.String);
	app.setProfileStringAppServer(iniFile, "CardLog", "LogCommsConnections", cc.logCommsConnections.String);
	app.setProfileStringAppServer(iniFile, "CardLog", "LogDiagnostics", cc.logDiagnostics.String);
	app.setProfileStringAppServer(iniFile, "CardLog", "LogToScreen", cc.logToScreen.String);
	app.setProfileStringAppServer(iniFile, "CardLog", "LogImmediateCommit", cc.logImmediateCommit.String);
	
	str := tbHostFQDN.text;
	if str = "" then
		str := "All";
	endif;
	app.setProfileStringAppServer(iniFile, "CardLog", "LogCommsComputer", str);

	unloadForm;
end;
}
cbxLogging_click
{
cbxLogging_click(checkbox: CheckBox input) updating;

vars

begin
	enableOptions(cbxLogging.value);
end;
}
enableOptions
{
enableOptions(set : Boolean) updating;

vars

begin
	cbxLogConnect.enabled		:= set;
 	cbxImmediateCommit.enabled	:= set;
 	cbxLogCommsBuffers.enabled	:= set;
 	cbxLogDiagnostics.enabled	:= set;
 	cbxLogToScreen.enabled		:= set;
 	optAllHosts.enabled			:= set;
 	optSelHost.enabled 			:= set;
end;
}
load
{
load() updating;

vars
 	cc : CnCntrl;
begin
	cc := app.myCnCntrl;

	cbxLogging.value			:= cc.logging;
 	cbxLogConnect.value			:= cc.logCommsConnections;
 	cbxLogCommsBuffers.value	:= cc.logCommsBuffers;
 	cbxLogDiagnostics.value		:= cc.logDiagnostics;
 	cbxImmediateCommit.value	:= cc.logImmediateCommit;
 	cbxLogToScreen.value		:= cc.logToScreen;
 	tbLogFilePath.text			:= cc.logPath;
 	tbLogFileName.text			:= cc.logFileName;

 	if cc.logCommsComputer <> "" then
 		tbHostFQDN.text			:= cc.logCommsComputer;
 		optSelHost.value		:= true;
 	else
 		optAllHosts.value		:= true;
 	endif;

 	if not cc.logging then
 		enableOptions(false);
 	endif;	
end;
}
	)
	CnMsgForm (
	jadeMethodSources
bClose_click
{
bClose_click(btn: Button input) updating;

vars

begin
	unloadForm();
end;
}
load
{
load() updating;

vars
	cc : CnCntrl;
begin
	cc := app.myCnCntrl;
	frame1.caption := message;
	if delay > 0 then
		frame2.caption := "Shut down will occur in " & delay.String & " seconds";
		beginTimer(1000, Timer_Continuous, 1);
	endif;

	self.centreWindow;
	self.caption := "Warning for " & cc.appName;
	
	bFocusGrabber.setFocus;					// so that space bar doesn't inadvertently press the Close button
	bFocusGrabber.height	:= 0;
	bFocusGrabber.width		:= 0;
end;
}
timerEvent
{
timerEvent(eventTag : Integer) updating;

vars

begin
	delay := delay - 1;

	if delay = 0 then
		if not dontTerminate then
			unloadForm;
		endif;

	else
		frame2.caption := "Shut down will occur in " & delay.String & " seconds";
	endif;
end;
}
unload
{
unload() updating;

vars
 	cc : CnCntrl;
begin
	if denyStartup or delay = 0 then
		cc := app.myCnCntrl;
		cc.cnWriteLog(cc.CnLogComment, "------- Application Shut Down : Server is Shutting Down  -------------", null);
		app.cnTerminate();
	endif;
end;
}
	)
	CnProgressDialog (
	jadeMethodSources
bCancel_click
{
bCancel_click(btn: Button input) updating;

vars
	
begin
	//  This is used in cnGlobalLockExceptionHandler.
	//  Note that we don't show a message box here, since we are still in tran state.

	cancelled := 1;	
end;
}
showProgress
{
showProgress(msg1, msg2, msg3 : String) : Integer;

vars

begin
	frMsg1.caption	:= msg1;
	frMsg2.caption	:= msg2;
	frMsg3.caption	:= msg3;
	self.refreshNow();
	bCancel.doWindowEvents(0);
	return cancelled;					// 1= Cancelled
end;
}
	)
	CnWebAppError (
	jadeMethodSources
bOK_click
{
bOK_click(btn: Button input) updating;

vars

begin
  	unloadForm;
end;
}
load
{
load() updating;

vars
	dumpFileCaption	: String;
begin
 	laError.caption := "An unexpected error has occurred in the server application.  Please retry the transaction." & CrLf &
				   	   "If the problem persists, contact the server administrator." & CrLf & CrLf & CrLf &
				   	   "Diagnostics : Error=" & errorCode.String & " : " & errorText.String;
	if self.lockTargetClassAndOid <> null then
		laError.caption := laError.caption & ", lockTarget=" & self.lockTargetClassAndOid & ", locked by " & lockedBy;			// PAR 979
		
	else
		laError.caption := laError.caption & ", errorItem=" & errorItem;
	endif;
	
	if app.cnStackDumpFileName <> null then
		dumpFileCaption := "Stack Dump" & CrLf &
							app.cnStackDumpFileName;
	endif;
	
	laDumpFile.caption := dumpFileCaption;
end;
}
	)
	CnNameSizeInfoByNameDict (
	jadeMethodSources
loadInstance
{
loadInstance(pName : String; pDec : Decimal) updating;

vars
	nameSizeInfo	: CnNameSizeInfo;
begin
	create nameSizeInfo transient;
	nameSizeInfo.loadSelf(pName, pDec);
	
	self.add(nameSizeInfo);
end;
}
	)
	CnNameSizeInfoBySizeDict (
	jadeMethodSources
loadInstance
{
loadInstance(pName : String; pDec : Decimal) updating;

vars
	nameSizeInfo	: CnNameSizeInfo;
begin
	create nameSizeInfo transient;
	nameSizeInfo.loadSelf(pName, pDec);
	
	self.add(nameSizeInfo);
end;
}
	)
	HugeStringArray (
	jadeMethodSources
cnGetAsParameterString
{
cnGetAsParameterString() : String;

vars
	parameter,
	parameterString	: String;
begin
	foreach parameter in self do
		parameterString := parameterString & parameter & " ";
	endforeach;
	
	return parameterString.trimRight();
end;
}
cnGetNextTokenPos
{
cnGetNextTokenPos(str : String; delimiter : String; dlen : Integer; spos : Integer io; addNullTokens : Boolean) updating, protected;

vars

begin
	while true do
		spos := spos + dlen;

		if (spos + dlen - 1) > str.length then
			if addNullTokens then
				self.add(null);
			endif;

			spos := 0;
			return;

		elseif str[spos : dlen] <> delimiter then
			return;

		elseif addNullTokens then
			self.add(null);
		endif;
	endwhile;
end;
}
cnGetTokens
{
cnGetTokens(inputStr : String; delimiter : String; addNullTokens : Boolean) updating;

vars
	pos		: Integer;
	spos	: Integer;
	dlen	: Integer;
begin
	//  If addNullTokens is true, this method will add a null entry into the array if 
	//  adjacent delimiters are found.  Otherwise it skips over delimiters without
	//  reporting them.

	dlen := delimiter.length;
	pos		:= 1;
	spos	:= 1;

	self.clear;

	if dlen = 0 then
		return;
	endif;

	if inputStr[spos : dlen] = delimiter then
		if addNullTokens then
			self.add(null);
		endif;
		cnGetNextTokenPos(inputStr, delimiter, dlen, spos, addNullTokens);
	endif;	

	if spos = 0 then
		return;
	endif;									

	while true do
		pos := inputStr.pos(delimiter, spos);
		if pos > 0 then
			self.add(inputStr[spos : pos - spos]);
			spos := pos;
			cnGetNextTokenPos(inputStr, delimiter, dlen, spos, addNullTokens);
			if spos = 0 then
				break;
			endif;
		else
			break;
		endif;
	endwhile;

	if spos > 0 and spos <= inputStr.length then			// get the last token
		self.add(inputStr[spos : end]);
	endif;
end;
}
	)
	CnNameSizeInfoArray (
	jadeMethodSources
loadInstance
{
loadInstance(pName : String; pDec : Decimal) updating;

vars
	nameSizeInfo	: CnNameSizeInfo;
begin
	create nameSizeInfo transient;
	nameSizeInfo.loadSelf(pName, pDec);
	
	self.add(nameSizeInfo);
end;
}
	)
	StringArray (
	jadeMethodSources
cnFind
{
cnFind(str : String) : Integer;

vars
	i 		: Integer;
	str2 	: String;
	str3	: String;
begin
	//  Case-insensitive find, returns array position of input string ///

	str2	:= str.toLower;

	foreach str3 in self do
		if str3.toLower = str2 then
			return self.indexOf(str3);
		endif;
	endforeach;

 	return 0;	
end;
}
cnGetNextTokenPos
{
cnGetNextTokenPos(str : String; delimiter : String; dlen : Integer; spos : Integer io; addNullTokens : Boolean) updating, protected;

vars

begin
	while true do
		spos := spos + dlen;

		if (spos + dlen - 1) > str.length then
			if addNullTokens then
				self.add(null);
			endif;

			spos := 0;
			return;

		elseif str[spos : dlen] <> delimiter then
			return;

		elseif addNullTokens then
			self.add(null);
		endif;
	endwhile;
end;
}
cnGetTokens
{
cnGetTokens(inputStr : String; delimiter : String; addNullTokens : Boolean) updating;

vars
	pos		: Integer;
	spos	: Integer;
	dlen	: Integer;
begin
	//  If addNullTokens is true, this method will add a null entry into the array if 
	//  adjacent delimiters are found.  Otherwise it skips over delimiters without
	//  reporting them.

	dlen := delimiter.length;
	pos		:= 1;
	spos	:= 1;

	self.clear;

	if dlen = 0 then
		return;
	endif;

	if inputStr[spos : dlen] = delimiter then
		if addNullTokens then
			self.add(null);
		endif;
		cnGetNextTokenPos(inputStr, delimiter, dlen, spos, addNullTokens);
	endif;	

	if spos = 0 then
		return;
	endif;									

	while true do
		pos := inputStr.pos(delimiter, spos);
		if pos > 0 then
			self.add(inputStr[spos : pos - spos]);
			spos := pos;
			cnGetNextTokenPos(inputStr, delimiter, dlen, spos, addNullTokens);
			if spos = 0 then
				break;
			endif;
		else
			break;
		endif;
	endwhile;

	if spos > 0 and spos <= inputStr.length then			// get the last token
		self.add(inputStr[spos : end]);
	endif;
end;
}
cnGetTokensUsingTruthSet
{
cnGetTokensUsingTruthSet(pInputStr : String; pTruthSet: String; pAddNullTokens : Boolean) updating;

vars
	// This method returns an array of tokens.  The delimiter for each token
	// is any character in the truthset. 

	delim	: Character;

	spos	: Integer;
	ix		: Integer;				// input index
	dx		: Integer;				// destination string index
	len		: Integer;

	str		: String;
begin
	ix 	:= 1;
	dx	:= 1;
	len := pInputStr.length();
	if pTruthSet.length() = null then
		return;
	endif;

	while true do
		if ix > len then
			if str <> null or
			   pAddNullTokens then
				self.add(str);
			endif;
			
			return;
		endif;

		if pTruthSet.pos(pInputStr[ix], 1) > null then
			if str <> null 		or
			   pAddNullTokens 	then
				self.add(str);
				str := null;
				dx := 1;
			endif;

		else
			str[dx] := pInputStr[ix];
			dx := dx + 1;
		endif;

		ix := ix + 1; 
	endwhile;	
end;
}
	)
	Any (
	jadeMethodSources
cnGetType
{
cnGetType() : Type;

vars
	myType : Type;
begin
	if self.isKindOf(Object) then
		myType := Object;
	elseif self.isKindOf(Binary) then
		myType := Binary;
	elseif self.isKindOf(Byte) then																								// PAR 1030
		myType := Byte;																											// PAR 1030
	elseif self.isKindOf(Boolean) then
		myType := Boolean;
	elseif self.isKindOf(Character) then
		myType := Character;
	elseif self.isKindOf(Date) then
		myType := Date;
	elseif self.isKindOf(Decimal) then
		myType := Decimal;
	elseif self.isKindOf(Integer) then
		myType := Integer;
	elseif self.isKindOf(Integer64) then																						// PAR 1030
		myType := Integer64;																									// PAR 1030
	elseif self.isKindOf(MemoryAddress) then																					// PAR 1030
		myType := MemoryAddress;																								// PAR 1030
	elseif self.isKindOf(Point) then
		myType := Point;
	elseif self.isKindOf(Real) then
		myType := Real;
	elseif self.isKindOf(String) then
		myType := String;
	elseif self.isKindOf(StringUtf8) then																						// PAR 1030
		myType := StringUtf8;																									// PAR 1030
	elseif self.isKindOf(Time) then
		myType := Time;
	elseif self.isKindOf(TimeStamp) then
		myType := TimeStamp;
	elseif self.isKindOf(TimeStampInterval) then																				// PAR 1030
		myType := TimeStampInterval;																							// PAR 1030
	elseif self.isKindOf(TimeStampOffset) then																					// PAR 1030
		myType := TimeStampOffset;																								// PAR 1030
	endif;

	return myType;
end;
}
	)
	Binary (
	jadeMethodSources
cnAnsiToString
{
cnAnsiToString(length : Integer) : String;

vars

begin
	//  This method is similar to the RootSchema method Binary::ansiToString except that it doesn't 
	//  delimit on the first null.  Note that the length of a binary is the attribute's length if
	//  it is a property of a class - so use Binary::length method with care.			RWM 7/00
	
	if app.isUnicode then
		return pmAnsiToUnicode(self, length).String;
	else
		return self[1 : length].String;
	endif;  
end;
}
cnAsType
{
cnAsType(type : Type) : Any;

begin
	if type = Boolean then
		return self.Boolean;
	elseif type = Character then
		return self.Character;
	elseif type = Date then
		return  self.Date;
	elseif type = Decimal then
		return self.Decimal;
	elseif type = Integer then
		return self.Integer;
	elseif type = Point then
		return self.Point;
	elseif type = Real then
		return self.Real;
	elseif type = String then
		return self.String;
	elseif type = Time then
		return self.Time;
	elseif type = TimeStamp then
		return self.TimeStamp;
	endif;

	// return self as a binary
	return self;
end;
}
cnConvertNullsToQueries
{
cnConvertNullsToQueries() : Binary updating;

vars
	nul	: Binary;
	len	: Integer;
	pos	: Integer;
begin
	nul[1]	:= #"00".Binary[1];
	len		:= self.length;
	pos		:= 1;
	
	while pos <= len do
		if self[pos] = nul[1] then
			self[pos]	:= #"3F".Binary[1];
		endif;
		
		pos := pos + 1;
	endwhile;
	
	return self;
end;
}
	externalMethodSources
pmAnsiToUnicode
{
pmAnsiToUnicode(
			bin: Binary; 
			length: Integer): Binary is "pmAnsiToUnicode" in "karma" protected, number = 1001;
}
	)
	Boolean (
	jadeMethodSources
cnReturnTickDisplayValue
{
cnReturnTickDisplayValue() : String;

vars

begin
	if self then
		return "1";
	endif;
	
	return null;
end;
}
	)
	Date (
	jadeMethodSources
cnFormat_MMMYY
{
cnFormat_MMMYY() : String;

vars
	
begin
	return self.monthName()[1:3] & " " & self.year().String;
end;
}
cnFormat_MonthName_Year
{
cnFormat_MonthName_Year() : String;

vars
	
begin
	return self.monthName() & " " & self.year().String;
end;
}
cnUserFormat
{
cnUserFormat(fmt : DateFormat) : String;

vars
	defaultCountryCode	: Integer;
begin
	defaultCountryCode := app.cnCurrentLocaleDefaultCountryCode;
	if defaultCountryCode = null then
		defaultCountryCode := app.currentLocaleInfo.defaultCountryCode;
	endif;
	
	if defaultCountryCode <> 1 then	// 1 = USA
		return self.userFormat(fmt);
	endif;
	
	if fmt.name = "CnDDMMYY" or
	   fmt.name = "DDMMYY"	 then
		return self.userFormat($CnMMDDYY);
		
	elseif fmt.name = "DD_MMM_YY" 	or
		   fmt.name = "CnDD_MMM_YY"	then
		return self.userFormat($CnMMM_DD_YY);
		
	elseif fmt.name = "CnDW_DD_MMM_CCYY" then
		return self.userFormat($CnDW_MMM_DD_CCYY);
		
	elseif fmt.name = "CnDD_MMMMM_CCYY" then
		return self.userFormat($CnMMMMM_DD_CCYY);
		
	else
		return self.userFormat(fmt);					// e.g. CnCCYYMMDD_ns
	endif;
end;
}
	)
	Decimal (
	jadeMethodSources
cnConvertToByteString
{
cnConvertToByteString() : String;

vars
	real	: Real;
begin
	real := self.Real;
	return real.cnConvertToByteString();
end;
}
cnElapsedTimeInMilliSeconds
{
cnElapsedTimeInMilliSeconds() : Integer;
/*
	Returns elapsed time in seconds from decimal value which is expected
	to contain app.relativeMachineTime stored earlier.
*/
vars
	d	: Decimal[23];
begin
	d := app.relativeMachineTime();
	return (d - self).Integer;
end;
}
cnElapsedTimeInSeconds
{
cnElapsedTimeInSeconds() : Integer;
/*
	Returns elapsed time in seconds from decimal value which is expected
	to contain app.relativeMachineTime stored earlier.
*/
vars
	d	: Decimal[23];
begin
	d := app.relativeMachineTime();
	return (d - self) div 1000;
end;
}
cnGetElapsedTime
{
cnGetElapsedTime() : String;

/*
	This method assumes that the receiver is a decimal of size 23 whole numbers
	
*/

vars
	d : Decimal [23];
begin
	d := app.relativeMachineTime();
	
	return (d-self).userNumberFormat($CnWholeNumbers) & "ms";
end;
}
cnGetElapsedTimeMicrosString
{
cnGetElapsedTimeMicrosString() : String;

constants
	ELAPSED_TIME	: String	= "Elapsed time ";
	MICROS			: String	= "microsecs";
vars
	d : Decimal [23];
begin
	d := app.relativeMachineMicros();
	return ELAPSED_TIME & (d-self).userNumberFormat($CnWholeNumbers) & MICROS;
end;
}
cnGetElapsedTimeString
{
cnGetElapsedTimeString() : String;

constants
	ELAPSED_TIME	: String	= "Elapsed time ";
	MILLISECS		: String	= "ms";
vars
	d : Decimal [23];
begin
	d := app.relativeMachineTime();
	return ELAPSED_TIME & (d-self).userNumberFormat($CnWholeNumbers) & MILLISECS;
end;
}
cnGetElapsedTime_ns
{
cnGetElapsedTime_ns() : String;

/*
	This method assumes that the receiver is a decimal of size 23 whole numbers
	
*/

vars
	d : Decimal [23];
begin
	d := app.relativeMachineTime();
	
	return (d-self).userNumberFormat($CnWholeNumbers_ns) & "ms";
end;
}
cnNullStringWhenZero
{
cnNullStringWhenZero() : String;

vars

begin
	if self = null then
		return null;
	endif;
	
	return self.String;
end;
}
	)
	Integer (
	jadeMethodSources
cnAsDayName
{
cnAsDayName() : String;

vars
	//  Returns day name for day number
begin
	if self = 1 then
		return "Monday";
	elseif self = 2 then
		return "Tuesday";
	elseif self = 3 then
		return "Wednesday";
	elseif self = 4 then
		return "Thursday";
	elseif self = 5 then
		return "Friday";
	elseif self = 6 then
		return "Saturday";
	elseif self = 7 then
		return "Sunday";
	else
		return "Invalid day number (" & self.String & ")";
	endif;		
end;
}
cnAsDayNameShort
{
cnAsDayNameShort() : String;

vars
	//  Returns short day name for day number
begin
	return self.cnAsDayName()[1:3];
end;
}
cnAsMonthName
{
cnAsMonthName() : String;

vars
	//  Returns Month name for day number
begin
	if self = 1 then
		return "January";
		
	elseif self = 2 then
		return "February";
		
	elseif self = 3 then
		return "March";
		
	elseif self = 4 then
		return "April";
		
	elseif self = 5 then
		return "May";
		
	elseif self = 6 then
		return "June";
		
	elseif self = 7 then
		return "July";
		
	elseif self = 8 then
		return "August";
		
	elseif self = 9 then
		return "September";
		
	elseif self = 10 then
		return "October";
		
	elseif self = 11 then
		return "November";
		
	elseif self = 12 then
		return "December";
		
	else
		return "Invalid month number (" & self.String & ")";
	endif;		
end;
}
cnAsMonthNameShort
{
cnAsMonthNameShort() : String;

vars
	//  Returns short month name for day number
begin
	return self.cnAsMonthName[1:3];
end;
}
cnAsOrdinalName
{
cnAsOrdinalName() : String;

vars
	last,
	str,
	suffix : String;
begin
	if self = 0 then
		str := "Zeroth";
		
	elseif self = 1 then
		str := "First";
		
	elseif self = 2 then
		str := "Second";
		
	elseif self = 3 then
		str := "Third";
	
	elseif self = 4 then
		str := "Fourth";
		
	elseif self = 5 then
		str := "Fifth";
		
	elseif self = 6 then
		str := "Sixth";
	
	elseif self = 7 then
		str := "Seventh";
	
	elseif self = 8 then
		str := "Eighth";
		
	elseif self = 9 then
		str := "ninith";
		
	elseif self = 10 then
		str := "Tenth";
	
	elseif self = 11 then
		str := "Eleventh";
		
	elseif self = 12 then
		str := "Twelth";
		
	elseif self = 13 then
		str := "Thirteenth";
	
	elseif self = 14 then
		str := "Fourteenth";
		
	elseif self = 15 then
		str := "Fifteenth";
		
	elseif self = 16 then
		str := "Sixteenth";
	
	elseif self = 17 then
		str := "Seventeenth";
	
	elseif self = 18 then
		str := "Eighteenth";
		
	elseif self = 19 then
		str := "niniteenth";
	else
		str := self.String;
		last := str[str.length:1];
		if last = "1" then
			suffix := "st";
			
		elseif last = "2" then
			suffix := "nd";
		
		elseif last = "3" then
			suffix := "rd";
		
		else
			suffix := "th";
		endif;
		
		str := str & suffix;
	endif;
	
	return str;
end;
}
cnConvertToByteString
{
cnConvertToByteString() : String;

vars
	
begin
	return self.Integer64.cnConvertToByteString();
end;
}
cnDifference
{
cnDifference(pInteger : Integer) : Integer;

/*
	The value in self is the ending value and the integer argument provided
	is the starting value.
	
	Work out the difference given that when the value exceeds Max_Integer, the value
	is initialized back to 1. For example, in the assignment of journal log numbers
	
	Examples:
	
	Starting journal = 10, End Journal = 13 		- endJournal.cnDifference(startJournal) = 3
	Starting journal = 2147483646, End Journal = 2 	- endJournal.cnDifference(startJournal) = 3
	

*/
vars
	i	: Integer;
begin
	if self > pInteger then
		return self - pInteger;
	endif;

	i := Max_Integer - pInteger + self;
	return i;
end;
}
cnMarkReleaseCutPatchString
{
cnMarkReleaseCutPatchString() : String;
/*
	Returns a string value in form mm.r.cc.ppp format
	
	Caters for when the mark id exceeds 1 digit.
	
	Version must be any at least 4 digits long.
	Input				Output
	6108003				6.1.08.003
	10201010			10.2.01.010
	
	Null result returned if an invalid number entered.
*/
vars
	len,
	mark,
	release,
	cut,
	patch		: Integer;
begin
	if self <= null then
		return null;
	endif;
	
	len := self.String.length();
	if len < 7 then
		return null;
	endif;

	if len < 8 then
		mark	:= self div 1000000;
		release := self div 100000 mod 10;
		cut		:= self div 1000 mod 100;
		patch	:= self mod 1000; 
	
	elseif len > 7 and
	    len < 9 then
		mark	:= self div 1000000;
		release := self div 100000 mod 10;
		cut		:= self div 1000 mod 100;
		patch	:= self mod 1000;
		
	else
		return null;
	endif;
	
	return mark.String & "." & release.String & "." & cut.String.padLeadingZeros(2) & "." & patch.String.padLeadingZeros(3);
end;
}
cnMarkReleaseCutString
{
cnMarkReleaseCutString() : String;
/*
	Returns a string value in form mm.r.cc format
	
	Caters for when the mark id exceeds 1 digit.
	
	Version must be any at least 4 digits long.
	Input				Output
	6108				6.1.08
	10201				10.2.01
	
	Null result returned if an invalid number entered.
*/
vars
	len,
	mark,
	release,
	cut			: Integer;
begin
	if self <= null then
		return null;
	endif;
	
	len := self.String.length();
	if len < 4 then
		return null;
	endif;

	if len < 6 then
		mark	:= self div 1000;
		release := self div 100 mod 10;
		cut		:= self mod 100;
	
	elseif len > 6 and
	    len < 9 then
		mark	:= self div 1000000;
		release := self mod 1000000 div 100000;
		cut		:= self mod 100000 div 1000;
		
	else
		return null;
	endif;
	
	return mark.String & "." & release.String & "." & cut.String.padLeadingZeros(2);
end;
}
cnMarkReleaseString
{
cnMarkReleaseString() : String;
/*
	Returns a string value in form mm.r format
	
	Caters for when the mark id exceeds 1 digit.
	
	Version must be at least 2 digits long.
	Input				Output
	61					6.1
	6108				6.1
	10201				10.2
	
	Null result returned if an invalid number entered.
*/
vars
	len,
	mark,
	release,
	cut		: Integer;
begin
	if self <= null then
		return null;
	endif;
	
	len := self.String.length();
	if len < 2 then
		return null;
	endif;

	if len = 2 then
		// format mr  eg 61 -> 6.1
		mark 	:= self div 10;
		release := self mod 10;
	
	elseif len = 3 then
		// format mmr  eg 102 -> 10.2
		mark := self div 10;
		release := self mod 10;
	
	elseif len = 4 then
		// format mrcc  eg 6108 -> 6.1
		mark := self div 1000;
		release := self mod 1000 div 100;
		
	elseif len = 5 then
		// format mmrcc  eg 10108 -> 10.1
		mark := self div 1000;
		release := self mod 1000 div 100;
		
	elseif len = 7 then
		// format mrccppp  eg 6108003 -> 6.1
		mark := self div 1000000;
		release := self mod 1000000 div 100000;
		
	elseif len = 8 then
		// format mmrccppp  eg 10108003 -> 10.1
		mark := self div 1000000;
		release := self mod 1000000 div 100000;
		
	else
		return null;
	endif;
	
	return mark.String & "." & release.String;
end;
}
cnNullStringWhenZero
{
cnNullStringWhenZero() : String;

vars

begin
	if self = null then
		return null;
	endif;
	
	return self.String;
end;
}
cnToHex
{
cnToHex() : String;

vars
	val			: Integer;
	remainder	: Integer;
	hadError	: Boolean;
	strHex	: String;
begin
	val := self;
	while val > 0 do
		remainder := val mod 16;
		val := val div 16;
		strHex := CN_HEXVALS[remainder + 1] & strHex;
	endwhile;

	return strHex;
end;
}
	)
	Integer64 (
	jadeMethodSources
cnConvertToByteString
{
cnConvertToByteString() : String;

vars
	size		: Decimal [23,1];
	
	int,
	intSelf		: Integer64;
	
	byteSz,
	sign		: String;
begin
//	write "Integer64::cnConvertToByteString";
	if self < 0 then
		sign	:= "-";
	endif;
	
	intSelf := self.abs();
//	write "self=" & self.display();
//	write "intSelf=" & intSelf.display();
	
	// unable to cater for values larger than exa bytes as Max_Integer64 only caters for exa-byte value

//	write "EB";
	int := CN_BYTES_PER_KILOBYTE.Integer64 ^ 6.Integer64;
	if intSelf >= int then
		size := (intSelf / int);
		return sign & size.userNumberFormat($CnOneDecimalPlace) & " EB";	// ExaBytes
	endif;

//	write "PB";
	int := CN_BYTES_PER_KILOBYTE.Integer64 ^ 5.Integer64;
	if intSelf >= int then
		size := (intSelf / int);
		return sign & size.userNumberFormat($CnOneDecimalPlace) & " PB";	// PetaBytes
	endif;

//	write "TB";
	int := CN_BYTES_PER_KILOBYTE.Integer64 ^ 4.Integer64;
	if intSelf >= int then
		size := (intSelf / int);
		return sign & size.userNumberFormat($CnOneDecimalPlace) & " TB";	// TeraBytes
	endif;

//	write "GB";
	int := CN_BYTES_PER_KILOBYTE.Integer64 ^ 3.Integer64;
	if intSelf >= int then
		size := (intSelf / int);
		return sign & size.userNumberFormat($CnOneDecimalPlace) & " GB";	// GigaBytes
	endif;

//	write "MB";
	int := CN_BYTES_PER_KILOBYTE.Integer64 ^ 2.Integer64;
	if intSelf >= int then
		size := (intSelf / int);
		return sign & size.userNumberFormat($CnOneDecimalPlace) & " MB";	// MegaBytes
	endif;

//	write "KB";
	if intSelf >= CN_BYTES_PER_KILOBYTE then
		size := (intSelf / CN_BYTES_PER_KILOBYTE);
		return sign & size.userNumberFormat($CnOneDecimalPlace) & " KB";	// KiloBytes
	endif;

//	write "bytes";
	return sign & intSelf.String & " bytes";
end;
}
cnNullStringWhenZero
{
cnNullStringWhenZero() : String;

vars

begin
	if self = null then
		return null;
	endif;
	
	return self.String;
end;
}
cnToHex
{
cnToHex() : String;

vars
	val			: Integer64;
	remainder	: Integer;
	hadError	: Boolean;
	strHex	: String;
begin
	val := self;
	while val > 0 do
		remainder := (val mod 16).Integer;
		val := val div 16;
		strHex := CN_HEXVALS[remainder + 1] & strHex;
	endwhile;

	return strHex;
end;
}
	)
	MemoryAddress (
	jadeMethodSources
cnToHex
{
cnToHex() : String;

vars
	val			: Integer64;
	remainder	: Integer;
	hadError	: Boolean;
	strHex	: String;
begin
	val := self.Binary.Integer64;
	while val > 0 do
		remainder := (val mod 16).Integer;
		val := val div 16;
		strHex := CN_HEXVALS[remainder + 1] & strHex;
	endwhile;

	return strHex;
end;
}
	)
	Real (
	jadeMethodSources
cnConvertToByteString
{
cnConvertToByteString() : String;

vars
	size		: Decimal [23,1];
	real,
	realSelf	: Real;
begin
//	write "Real::cnConvertToByteString";
	realSelf := self.abs();
	if realSelf = 0 then
//		write "zero";
		return "0 bytes";
	endif;

	if self > Max_Integer64 then
//		write "BB";
		real := CN_BYTES_PER_KILOBYTE.Real ^ 9.Real;
		if realSelf >= real then
			size := (realSelf / real);
			return size.userNumberFormat($CnOneDecimalPlace) & " BB";	// BrontoBytes
		endif;
	
//		write "YB";
		real := CN_BYTES_PER_KILOBYTE.Real ^ 8.Real;
		if realSelf >= real then
			size := (realSelf / real);
			return size.userNumberFormat($CnOneDecimalPlace) & " YB";	// YottaBytes
		endif;
	
//		write "ZB";
		real := CN_BYTES_PER_KILOBYTE.Real ^ 7.Real;
		if realSelf >= real then
			size := (realSelf / real);
			return size.userNumberFormat($CnOneDecimalPlace) & " ZB";	// ZettaBytes
		endif;
	endif;

	return realSelf.rounded64().cnConvertToByteString();
end;
}
cnNullStringWhenZero
{
cnNullStringWhenZero() : String;

vars

begin
	if self = null then
		return null;
	endif;
	
	return self.String;
end;
}
	)
	String (
	jadeMethodSources
cnAsDate
{
cnAsDate() : Date;

vars
	d	: Date;
	str	: String;
begin
	//
	//  This method assumes that the caller will check that the returned date
	//  is valid.
	//
	d		:= "-1".Date;
	
	if self = null then
		d	:= "99/99/99".Date;										// force invalid date
	else
		if self.length = 6 then			
			str	:= self[1:2] & "/" & self[3:2] & "/" & self[5:2];	// handle numeric 6 date
		else
			str	:= self;
		endif;
	
		d.parseForCurrentLocale(str);
	endif;
	
	return d;	
end;
}
cnAsDayNumber
{
cnAsDayNumber() : Integer;

vars
	dayName : String;
begin
	dayName := self.toLower();
	
	if dayName = "monday" then
		return 1;
		
	elseif dayName = "tuesday" then
		return 2;
		
	elseif dayName = "wednesday" then
		return 3;
		
	elseif dayName = "thursday" then
		return 4;
		
	elseif dayName = "friday" then
		return 5;
		
	elseif dayName = "saturday" then
		return 6;
		
	elseif dayName = "sunday" then
		return 7;
	
	else
		return 0;
	endif;
end;
}
cnContains
{
cnContains(str : String) : Boolean;		// returns true if self contains the string in str (case-sensitive)

vars

begin
	return (self.pos(str, 1) > null);
end;
}
cnConvertStringToTimeStamp
{
cnConvertStringToTimeStamp() : TimeStamp;
/*
	Converts a string of form DD/MM/YY hh:mm:ss to a timestamp
	
	If the hh:mm:ss portion is not present, then will just convert the date.
*/
vars
 	pos 	: Integer;
 	date	: Date;
 	time	: Time;
 	str		: String;
 	ts		: TimeStamp;
begin
	ts 	:= null;
	pos := 1;
	str := self.scanUntil(CN_SPACE, pos);
	if str <> null then
		date := str.cnAsDate();
		ts.setDate(date);
	endif;

	if pos = null then
		return ts;
	endif;
	
	str := null;
	self.scanWhile(CN_SPACE, pos);
	if pos = null then
		return ts;
	endif;
	
	str := self.scanUntil(CN_SPACE, pos);
	if str <> null then
		time := str.Time;
		ts.setTime(time);
	endif;

   	return ts; 
end;
}
cnConvertZuluStringToTimeStamp
{
cnConvertZuluStringToTimeStamp():TimeStamp;

vars
	ts  	: TimeStamp;
	
	datePos,
	timePos	: Integer;
	
	date,
	time	: String;
begin
	if self[self.length():1] = "Z" then
		datePos := self.pos('T',1);
		if datePos > 0 then
			date := self[1:datePos-1];
			ts.setDate(date.Date);
			timePos := self.reversePos('.');
			if timePos > 0 then
				time := self[datePos+1:(self.length()-1)-(datePos+1)];
				ts.setTime(time.Time);
			else
			
				return null;
			endif;
			
		else
			return null;
		endif;
	
	else
		return null;
	endif;	
	return ts;
end;
}
cnCountCharOccurences
{
cnCountCharOccurences(pSearchCharacter : Character) : Integer;

vars
	count,
	len,
	pos		: Integer;
	
	str		: String;
begin
	str := pSearchCharacter;
	len := self.length();
	if len = null then
		return null;
	endif;
	
	pos := 1;
	while pos > null do
		self.scanUntil(str, pos);
		if pos > null then
			count := count + 1;
			pos := pos + 1;
			if pos > len then
				break;
			endif;
		endif;
	endwhile;
	
	return count;
end;
}
cnCountLiteralOccurences
{
cnCountLiteralOccurences(pSearchLiteral : String) : Integer;

vars
	count,
	len,
	pos		: Integer;
	
	str		: String;
begin
	str := pSearchLiteral;
	len := self.length();
	if len = null then
		return null;
	endif;
	
	pos := 1;
	while pos > null do
		pos := self.pos(str, pos);
		if pos > null then
			count := count + 1;
			pos := pos + 1;
			if pos > len then
				break;
			endif;
		endif;
	endwhile;
	
	return count;
end;
}
cnDecimalToHex
{
cnDecimalToHex(length : Integer):String ;

vars
    num , r , i , len : Integer ;
    s : String ;
    negative : Boolean ;
begin
	num := self.Integer ;
	if num < 0 then
		negative := true ;
		num := - num ;
	endif ;
	if length <= 0 and num = 0 then
		return "0" ;
	else
		while num > 0 do
			r := num mod 16 ;
			if r > 9 then
				s := (r + ('A').Integer - 10).Character & s ;
			else
				s := (r + ('0').Integer).Character & s ;
			endif ;
			num := num div 16 ;
		endwhile ;
		if length <= 0 then
			if negative then
				s := "-" & s ;
			endif ;
			return s ;
		else
			if negative then
				len := length - 1 ;
			else
				len := length ;
			endif ;		
			if s.length() > len then
				app.cnRaiseNormalException ( Cn_Field_Overflow , "decimalToHex" , 
				                             "Value does not fit within the specified length", false) ;
				return null ;
			elseif negative then
				if s.length() < len then
					s := s.padLeadingZeros(len) ;
				endif ;
				return "-" & s ;
			else
				return s.padLeadingZeros(length) ;
			endif ;
		endif ;	
	endif ;
end;
}
cnEncrypt
{
cnEncrypt(key : Integer) : String;

vars
 	dest 	: String;
 	len, indx : Integer;
 	char : Character;
begin
	//	!!  This method is obsolete, only retained for compatability with old schemas.
	//  !!  Use cnEncryptV2 instead.
	//
	//  To ensure portability (i.e. that we get the same result) across architectures
	//  that may have different byte ordering we use a mod 256 to get the logical
	//  LSB and build the result into a character string.  This algorithm will work with
	//  ANSI or UNICODE strings.  One-way encryption.

	if self = null then				//  handle special case of empty string
		dest[1] := (key mod 256).Character;
	else
		len := self.length;
		indx := 1;
		char := self[len];
		while indx <= len do
			dest[indx] := ((self[indx].Integer*key + char.Integer) mod 256).Character;
			char := self[indx];
			indx := indx + 1;
		endwhile;
	endif;

	return dest;
end;
}
cnEncryptV2
{
cnEncryptV2(key : Integer) : String;

vars
 	dest 	: String;
 	len, indx : Integer;
 	char : Character;
begin
	//  To ensure portability (i.e. that we get the same result) across architectures
	//  that may have different byte ordering we use a mod 256 to get the logical
	//  LSB and build the result into a character string.  This algorithm will work with
	//  ANSI or UNICODE strings.  One-way encryption.

	if self = null then				//  handle special case of empty string
		dest[1] := (key mod 256).Character;
	else
		len := self.length;
		indx := 1;
		char := self[len];
		while indx <= len do
			dest[indx] := ((self[indx].Integer*key + char.Integer) mod 256).Character;
			if dest[indx] = #"00" then
           		dest[indx] := #"41";
			endif;
			char := self[indx];
			indx := indx + 1;
		endwhile;
	endif;

	return dest;
end;
}
cnFormatForCSVFile
{
cnFormatForCSVFile( _appendComma : Boolean ) : String ;

vars
	returnString : String ;
	pos : Integer ;
begin
	// Pre-pend the opening double quote
	returnString := '"' ;

	// Replace any double quotes in the string with 2 double quotes
	pos := 1 ;
	while pos > 0 and pos <= self.length do
		returnString := returnString & self.scanUntil('"',pos);
		if pos > 0 then
			returnString := returnString & '""';
			pos := pos + 1 ;
		endif;
	endwhile ;

	// Append the closing double quote
	returnString := returnString & '"';

	if _appendComma then
		returnString := returnString & ',';
	endif;

	// Replace any embedded CrLf characters with spaces to make file more
	// compatible with MS Excel
	returnString.cnReplaceString( CrLf, ' ');

	return returnString ;
end;
}
cnFormatVersion
{
cnFormatVersion(pMark, pRelease, pCut, pPatch : Integer output) : String;
/*
	Caters for when the mark id exceeds 1 digit.
	
	If the version string contains any non-numeric other than period (.) we return
	the whole string as its not a known JADECare format.
	
	Version can be any of the following formats
	Input				Output
	6.1					6.1
	6.1.08				6.1.08
	6.1.8.4				6.1.08.004
	
	Null result returned if minimum of x.y is not entered.
*/
vars
	len,
	pos		: Integer;
	
	ver		: String;
begin
	if self = null then
		return null;
	endif;
	
	pos		:= 1;
	self.scanWhile("1234567890.", pos);
	if pos > null then
		return self;
	endif;
	
	len		:= self.length;
	pos		:= 1;
	pMark	:= self.scanUntil(".", pos).Integer;
	ver		:= pMark.String;
	pos := pos + 1;
	if pos = 1 or pos > len then
		return self;
	endif;
	
	pRelease	:= self.scanUntil(".", pos).Integer;
	ver := ver & "." & pRelease.String;
	pos := pos + 1;
	if pos = 1 or pos > len then
		return ver;
	endif;

	pCut	:= self.scanUntil(".", pos).Integer;
	ver := ver & "." & pCut.String.padLeadingZeros(2);
	pos := pos + 1;
	if pos = 1 or pos > len then
		return ver;
	endif;

	pPatch	:= self.scanUntil(".", pos).Integer;
	ver := ver & "." & pPatch.String.padLeadingZeros(3);
	if pos <> null then
		ver := ver & self[pos:end];
	endif;

	return ver;
end;
}
cnGetDbFileName
{
cnGetDbFileName() : String;

vars
	pos		: Integer;

	partId	: Integer64;
begin
	pos := 1;
	// look for literal '_part'
	pos := self.pos("_part", pos);
	if pos = null then
		return self;
	endif;

	// verify that there is some data after the '_part' just in-case someone
	// has defined a mapfile with '_part' in it.
	if self.length() < (pos + 5) then
		return self;
	endif;
	
	// verify that the last bit is numeric
	partId := self[pos+5 :end].Integer64;
	if partId = null then
		return self;
	endif;
	
	return self[1:pos-1];
end;
}
cnGetDbFilePartitionID
{
cnGetDbFilePartitionID() : Integer64;

vars
	pos	: Integer;
begin
	pos := 1;
	pos := self.pos("_part", pos);
	if pos = null then
		return null;
	endif;
	
	pos := pos + 5;
	if pos >= self.length() then
		return null;
	endif;
	
	return self[pos:end].Integer64;
end;
}
cnGetNextTokenPos
{
cnGetNextTokenPos(delimiter : String; dlen : Integer; spos : Integer io) protected;

vars

begin
	while true do
		spos := spos + dlen;
		if spos > self.length then
			spos := 0;
			return;

		elseif self[spos : dlen] <> delimiter then
			return;
		endif;
	endwhile;
end;
}
cnGetPatchId
{
cnGetPatchId(pPatchId : Integer output) : String;
/*
	returns the patch number from a string.
	
	Expected format input:
	m.r.cc.ppp
	
	If not the above form then pPatchId will be zero and string returned will
	identify that patch wasn't found.
*/
vars
	tokenArray	: CnSmallStringArray;

	len,
	sz			: Integer;
	
	token		: String;
begin
	create tokenArray transient;
	tokenArray.cnGetTokens(self, CN_PERIOD, false);
	sz := tokenArray.size();
	if sz <> 4 then
		return "Input string invalid format, had " & sz.String & " nodes";
	endif;
	
	token := tokenArray.last();
	if not token.cnIsNumericAndNotNegative() then
		return "Patch Id is not numeric";
	endif;
	
	len := token.length();
	if len <> 3 then
		return "Patch Id incorrect length, actual length " & len.String;
	endif;
	
	pPatchId := token.Integer;
	return CN_OK;
epilog
	delete tokenArray;
end;
}
cnGetServerMiscPathFromAppDbpath
{
cnGetServerMiscPathFromAppDbpath() : String;

vars
	pos			: Integer;
	
	dbPath,
	miscPath	: String;
begin
	dbPath		:= app.dbPath;
	pos			:= dbPath.reversePos(CN_BACK_SLASH);
	miscPath	:= dbPath[1:pos] & CN_C_MISC;
	return miscPath;
end;
}
cnGetToken
{
cnGetToken(pStartPos : Integer io; pDelimiter : String) : String;

vars
	epos,
	lenDelimiter,
	lenString,
	startpos		: Integer;	
	
	str 			: String;	
begin
	lenString 		:= self.length();
	lenDelimiter 	:= pDelimiter.length();
	startpos := pStartPos;
	if startpos > lenString then
		pStartPos := null;
		return null;
	endif;
	
	epos := self.pos(pDelimiter, pStartPos);
	if epos = null then
		pStartPos := null;
		return self[startpos:lenString - startpos + 1];
	endif;
	
	pStartPos := epos + lenDelimiter; 					// point at start of next token
	if pStartPos > lenString then
		pStartPos := null;
	endif;

	return self[startpos:epos - startpos];
end;
}
cnGetTokens
{
cnGetTokens(delimiter : String) : CnStringArray;

vars
	array 	: CnStringArray;
	pos		: Integer;
	spos	: Integer;
	dlen	: Integer;
begin
	dlen := delimiter.length;
	create array transient;
	pos		:= 1;
	spos	:= 1;

	if dlen = 0 then
		return array;
	endif;

	if self[spos : dlen] = delimiter then
		cnGetNextTokenPos(delimiter, dlen, spos);
	endif;

	if spos = 0 then
		return array;
	endif;									

	while true do
		pos := self.pos(delimiter, spos);
		if pos > 0 then
			array.add(self[spos : pos - spos]);
			spos := pos;
			cnGetNextTokenPos(delimiter, dlen, spos);
			if spos = 0 then
				break;
			endif;
		else
			break;
		endif;
	endwhile;

	if spos > 0 and spos <= self.length then			// get the last token
		array.add(self[spos : end]);
	endif;

	return array;
end;
}
cnGetTokensUsingTruthSet
{
cnGetTokensUsingTruthSet(truthSet : String) : CnStringArray;

vars
	// This method returns an array of tokens.  The delimiter for each token
	// is any character in the truthset. 

	delim	: Character;
	array	: CnStringArray;
	str		: String;
	spos	: Integer;
	ix		: Integer;				// input index
	dx		: Integer;				// destination string index
	len		: Integer;
begin
	create array transient;

	ix 	:= 1;
	dx	:= 1;
	len := self.length;
	if truthSet.length() = null then
		return array;
	endif;

	while true do
		if ix > self.length then
			if str <> null then
				array.add(str);
			endif;
			
			return array;
		endif;

		if truthSet.pos(self[ix], 1) > null then
			if str <> null then
				array.add(str);
				str := null;
				dx := 1;
			endif;

		else
			str[dx] := self[ix];
			dx := dx + 1;
		endif;

		ix := ix + 1; 
	endwhile;	
end;
}
cnHHMMTime
{
cnHHMMTime() : Time;

vars								// takes 24 hr format string e.g. 300 = 03:00, 1500 = 15:00
	t 			: Time;				// and returns time variable
	pos			: Integer;
	hhmm		: Integer;
	invalidTime	: Time;
begin
	invalidTime := "9999".Time;

	if self.length < 3 or self.length > 5 then
		return invalidTime;
	endif;

	pos := self.pos(":", 1);
	if pos > 0 then					//  if there's a colon, we'll assume it's OK (it may
		return self.Time;			//  not be - up to calling method to check)

	elseif self.length = 3 then
		return ("0" & self[1] & ":" & self[2:end]).Time;

	elseif self.length = 4 then
		return (self[1:2] & ":" & self[3:end]).Time;

	else
		return invalidTime;
	endif;
end;
}
cnHasSuffix
{
cnHasSuffix(pSuffix 		: String;
			pCaseSensitive	: Boolean) : Boolean;

/*
	Purpose :
	
	Evaluate the receiver and return true if the last characters of the 
	receiver match the suffix provided in the input argument.
	
	The pCaseSensitive argument allows for the test to be case-sensitive
	or not, as required.
*/
vars
	receiverLen,
	suffixLen			: Integer;
	
	receiver,
	suffix				: String;
begin
	receiverLen			:= self.length();
	suffixLen			:= pSuffix.length();
	if suffixLen > self.length() then
		return false;
	endif;
	
	if pCaseSensitive then
		receiver		:= self;
		suffix			:= pSuffix;
	
	else
		receiver		:= self.toLower();
		suffix			:= pSuffix.toLower();
	endif;
	
//	app.msgBox(receiver[receiverLen - suffixLen + 1:end], null, null);
	return (receiver[receiverLen - suffixLen + 1:end] = suffix);
end;
}
cnHexToDecimal
{
cnHexToDecimal(length : Integer): String;

vars
    negative 	: Boolean;
	
    c 			: Character;
    i,
	len,
	num			: Integer;
	
    s 			: String;
begin
	s := self.toLower();																										// PAR 999
	if s.length() = null then
		return null;
	endif;
	
	if s[1:1].Character	= '-' then
		if s.length() = 1 then
			return null;
		endif;
		
		negative := true;
		s := s[2:end].cnTrimLeadingZeros();
	endif;

	if not s.cnIsHex() then
		return null;
	endif;
	
	i := 1;
	num := null;
	len := s.length();
	if len > 8 then
		app.cnRaiseNormalException(1406, method.cnGetMethodName(), null, true);
	endif;
	
	while i <= len 	and 
		  i <= 8 			do
		c := s[i:1].Character;
		if c >= '0' and c <=  '9' then
			num := num*16 + c.Integer - ('0').Integer;

		elseif c >= 'a' and c <= 'f' then
			num := num*16 + c.Integer - ('a').Integer + 10;
			
		else
			break;
		endif;
		
		i := i + 1;
	endwhile;
		
	s := num.String;
	if length <= 0 then
		if negative and num > 0 then
			s := "-" & s;
		endif;
		
		return s;
	endif;
	
	if negative 	and 
	   num > null 	then
		len := length - 1;
		
	else
		len := length;
	endif;
	
	if s.length() > len then
		app.cnRaiseNormalException(Cn_Field_Overflow, method.cnGetMethodName(), "Value does not fit within the specified length", true);
		return null;
	endif;
	
	if negative 	and 
	   num > null 	then
		if s.length() < len then
			s := s.padLeadingZeros(len);
		endif;
		
		return "-" & s;
	endif;
	
	return s.padLeadingZeros(length);
end;
}
cnHexToInteger
{
cnHexToInteger() : Integer;

vars
    negative 	: Boolean;

    c 			: Character;
    
	i,
	len,
	num 		: Integer;
	
    s 			: String;
begin
	s := self.cnTrimLeadingZeros().toLower();
	if s.length() = null then
		return null;
	endif;

	if s[1:1].Character	= CN_HYPHEN then
		if s.length() = 1 then
			return null;
		endif;

		negative := true;
		s := s[2:end].cnTrimLeadingZeros();
	endif;
	
	if not s.cnIsHex() then
		return null;
	endif;
	
	num := null;
	len := s.length();
	if len > 8 then
		app.cnRaiseNormalException(1406, method.cnGetMethodName(), null, true);
	endif;
	
	
	i := 1;
	while i <= len 	and 
	      i <= 8 			do
		c := s[i:1].Character;
		if c >= '0' and c <=  '9' then
			num := num*16 + c.Integer - ('0').Integer;
			
		elseif c >= 'a' and c <= 'f' then
			num := num*16 + c.Integer - ('a').Integer + 10;
			
		else
			break;
		endif;
		
		i := i + 1;
	endwhile;
	
	if negative then
		return -num;
	endif;
	
	return num;
end;
}
cnIsAlpha
{
cnIsAlpha() : Boolean;

constants
	Alpha_Values	: String	= "abcdefghijklmnopqrstuvwxyz";
vars
	pos	: Integer;
	
	str	: String;
begin
	pos := 1;
	str := self.toLower();
	str.scanWhile(Alpha_Values, pos);
	return (pos = null);
end;
}
cnIsBoolean
{
cnIsBoolean() : Boolean;

vars
	str	: String;
begin
	str := self.toLower();
	return str = false.String or
		   str = true.String;
end;
}
cnIsDecimal
{
cnIsDecimal(pMustHaveDecimalPoint : Boolean) : Boolean;

vars
	count,
	includeHyphen,
	maxLength,
	pos				: Integer;
	
	str				: String;
begin
	str := self;
	if str = null then
		return false;
	endif;
	
	// need to allow for negative value
	if str[1] = CN_HYPHEN then
		includeHyphen := 1;
		str := str[2:end];
		if str = null then
			return false;
		endif;
	endif;
	
	pos := 1;
	str.scanWhile("0123456789.", pos);
	if pos <> null then
//		write "invalid chars";
		return false;
	endif;

	count := str.cnCountCharOccurences(CN_PERIOD);
	if count > 1 then
//		write "period count";
		return false;
	endif;
	
	write count.String & " " & pMustHaveDecimalPoint.String;
	if count = null and 
	   pMustHaveDecimalPoint then
//		write "must have decimal point";
		return false;
	endif;
	
	// decimal can only be 23 places
	if count = null then
		maxLength := 23;
	
	else
		maxLength := 24;
	endif;
	
	maxLength := maxLength + includeHyphen;
//	write "maxlength=" & maxLength.String & ", actual length=" & self.length().String;
	return (self.length() <= maxLength);
end;
}
cnIsDecimalAndNotNegative
{
cnIsDecimalAndNotNegative(pMustHaveDecimalPoint : Boolean) : Boolean;

vars
	count,
	maxLength,
	pos				: Integer;
	
	str				: String;
begin
	str := self;
	if str = null then
		return false;
	endif;
	
	pos := 1;
	str.scanWhile("0123456789.", pos);
	if pos <> null then
//		write "invalid chars";
		return false;
	endif;

	count := str.cnCountCharOccurences(CN_PERIOD);
	if count > 1 then
//		write "period count";
		return false;
	endif;
	
//	write count.String & " " & pMustHaveDecimalPoint.String;
	if count = null and 
	   pMustHaveDecimalPoint then
//		write "must have decimal point";
		return false;
	endif;
	
	// decimal can only be 23 places
	if count = null then
		maxLength := 23;
	
	else
		maxLength := 24;
	endif;
	
//	write "maxlength=" & maxLength.String & ", actual length=" & self.length().String;
	return (self.length() <= maxLength);
end;
}
cnIsHex
{
cnIsHex() : Boolean;

constants
	Valid_Hex_Characters = "0123456789abcdef";
vars
	pos	: Integer;
	
	str	: String;
begin
	if self = null then
		return null;
	endif;
	
	pos := 1;
	str := self.toLower();
	str.scanWhile(Valid_Hex_Characters, pos);
	return (pos = null);
end;
}
cnIsNumeric
{
cnIsNumeric() : Boolean;

vars
	pos	: Integer;
	
	str	: String;
begin
	str := self;
	if str = null then
		return false;
	endif;
	
	// need to allow for negative value
	if str[1] = CN_HYPHEN then
		str := str[2:end];
		if str = null then
			return false;
		endif;
	endif;
	
	pos := 1;
	str.scanWhile("0123456789", pos);
	return (pos = null);
end;
}
cnIsNumericAndNotNegative
{
cnIsNumericAndNotNegative() : Boolean;

vars
	pos	: Integer;
	
	str	: String;
begin
	str := self;
	if str = null then
		return false;
	endif;
	
	pos := 1;
	str.scanWhile("0123456789", pos);
	return (pos = null);
end;
}
cnIsTrueOrFalse
{
cnIsTrueOrFalse(pBoolean : Boolean output) : String;

vars
	lCase	: String;
begin
	lCase := self.trimBlanks().toLower();
	if lCase = true.String 	or
	   lCase = false.String then
		pBoolean := lCase.Boolean;
		return CN_OK;
	endif;
	
	return "Invalid boolean value (" & self.toLower() & ")";
end;
}
cnMark
{
cnMark() : Integer;
/*
	Returns the mark and release as an integer value where the mark is the leading digit(s) and the release
	is the last digits 
	
	Caters for when the mark id exceeds 1 digit.
	
	Version can be any of the following formats
	Input				Output
	6.1					6
	6.1.08				6
	10.2.8.4			10
	
	Null result returned if minimum of x.y is not entered.
*/
vars
	mark,
	pos		: Integer;
begin
	if self = null then
		return null;
	endif;
	
	pos	:= 1;
	
	mark	:= self.scanUntil(".", pos).Integer;
	return mark;
end;
}
cnMarkRelease
{
cnMarkRelease() : Integer;
/*
	Returns the mark and release as an integer value where the mark is the leading digit(s) and the release
	is the last digits 
	
	Caters for when the mark id exceeds 1 digit.
	
	Version can be any of the following formats
	Input				Output
	6.1					61
	6.1.08				61
	10.2.8.4			102
	
	Null result returned if minimum of x.y is not entered.
*/
vars
	mark,
	release,
	patch,
	cut,
	len,
	pos,
	ver		: Integer;
begin
	if self = null then
		return null;
	endif;
	
	len	:= self.length;
	pos	:= 1;
	
	mark	:= self.scanUntil(".", pos).Integer;
	pos := pos + 1;
	if pos = 1 or pos > len then
		return null;
	endif;
	
	release	:= self.scanUntil(".", pos).Integer;
	if release > 9 then
		return null;
	endif;
	
	ver := mark * 10 + release;
	return ver;
end;
}
cnMarkReleaseCut
{
cnMarkReleaseCut() : Integer;
/*
	Returns an integer value.
	
	Caters for when the mark id exceeds 1 digit.
	
	Version can be any of the following formats
	Input				Output
	6.1.08				6108
	10.2.01				10201
	
	Null result returned if minimum of x.y.z is not entered.
*/
vars
	mark,
	release,
	cut,
	len,
	pos,
	ver		: Integer;
begin
	if self = null then
		return null;
	endif;
	
	len	:= self.length;
	pos	:= 1;
	
	mark	:= self.scanUntil(".", pos).Integer;
	pos := pos + 1;
	if pos = 1 or pos > len then
		return null;
	endif;
	
	release	:= self.scanUntil(".", pos).Integer;
	if release > 9 then
		return null;
	endif;
	
	pos := pos + 1;
	if pos = 1 or pos > len then
		return null;
	endif;

	cut	:= self.scanUntil(".", pos).Integer;
	if cut > 99 then
		return null;
	endif;
	
	ver := (mark * 1000) + (release * 100) + cut;
	return ver;
end;
}
cnMarkReleaseCutPatch
{
cnMarkReleaseCutPatch() : Integer;
/*
	Returns an integer value.
	
	Caters for when the mark id exceeds 1 digit.
	
	Version can be any of the following formats
	Input				Output
	6.1.08.024			6108024
	10.2.01.01			10201001
	
	Null result returned if minimum of m.r.p.c is not entered.
*/
vars
	mark,
	release,
	patch,
	cut,
	len,
	pos,
	ver		: Integer;
begin
	if self = null then
		return null;
	endif;
	
	len	:= self.length;
	pos	:= 1;
	
	mark	:= self.scanUntil(".", pos).Integer;
	pos := pos + 1;
	if pos = 1 or pos > len then
		return null;
	endif;
	
	release	:= self.scanUntil(".", pos).Integer;
	if release > 9 then
		return null;
	endif;
	
	pos := pos + 1;
	if pos = 1 or pos > len then
		return null;
	endif;

	cut	:= self.scanUntil(".", pos).Integer;
	if cut > 99 then
		return null;
	endif;
	
	pos := pos + 1;
	if pos = 1 or pos > len then
		return null;
	endif;

	patch := self.scanUntil(".", pos).Integer;
	if patch > 999 then
		return null;
	endif;
	
	ver := (mark * 1000000) + (release * 100000) + (cut * 1000) + patch;
	return ver;
end;
}
cnMarkReleaseCutPatchString
{
cnMarkReleaseCutPatchString() : String;
/*
	Returns a string value in forms:
		mm.r.cc.ppp 	or
		mm.r.cc			or
		mm.r
		
		depending on whether the input string has sufficient input.
	
	Caters for when the mark id exceeds 1 digit.
	
	Version can be any of the following formats
	Input				Output
	6.1.8.1				6.1.08.001
	10.2.1				10.2.01
	2.0.0.42			2.0.00.042
	
	Null result returned if minimum of x.y.z is not entered.
*/
vars
	mark,
	release,
	cut,
	patch,
	len,
	pos			: Integer;
	
	str			: String;
begin
	if self = null then
		return null;
	endif;

	pos := 1;
	str := self.scanWhile("0123456789.", pos);
	// if not numeric then just return value
	if pos > null then
		return self;
	endif;
	
	len	:= self.length;
	pos	:= 1;
	
	mark	:= self.scanUntil(".", pos).Integer;
	pos := pos + 1;
	if pos = 1 or pos > len then
		return null;
	endif;
	
	release	:= self.scanUntil(".", pos).Integer;
	if release > 9 then
		return null;
	endif;

	pos := pos + 1;
	if pos = 1 or pos > len then
		return mark.String & "." & release.String;
	endif;

	cut	:= self.scanUntil(".", pos).Integer;
	if cut > 99 then
		return null;
	endif;
	
	pos := pos + 1;
	if pos = 1 or pos > len then
		return mark.String & "." & release.String & "." & cut.String.padLeadingZeros(2);
	endif;
	
	patch := self.scanUntil(".", pos).Integer;
	if patch > 999 then
		return null;
	endif;
	
	return mark.String & "." & release.String & "." & cut.String.padLeadingZeros(2) & "." & patch.String.padLeadingZeros(3);
end;
}
cnMarkReleaseCutPatchString_AppVersion
{
cnMarkReleaseCutPatchString_AppVersion() : String;
/*
	Returns a string value in forms:
		mm.r.cc.ppp	or
		<string>
		
		depending on whether the input string has appropriate input.
	
	Caters for when the mark id exceeds 1 digit.
	
	Version can be any of the following formats
	Input				Output
	6.1.8.1				6.1.08.001
	10.2.1				10.2.01.000
	2.0.0.42			2.0.00.042
	
	If expected format is not delivered then the input string is returned.
*/
vars
	mark,
	release,
	cut,
	patch,
	len,
	pos			: Integer;
	
	str			: String;
begin
	if self = null then
		return null;
	endif;

	pos := 1;
	str := self.scanWhile("0123456789.", pos);
	// if not numeric then just return value
	if pos > null then
		return self;
	endif;
	
	len	:= self.length;
	pos	:= 1;
	
	mark	:= self.scanUntil(".", pos).Integer;
	pos := pos + 1;
	if pos = 1 or pos > len then
		return self;
	endif;
	
	release	:= self.scanUntil(".", pos).Integer;
	if release > 9 then
		return self;
	endif;

	pos := pos + 1;
	if pos = 1 or pos > len then
		return mark.String & "." & release.String & ".00.000";
	endif;

	cut	:= self.scanUntil(".", pos).Integer;
	if cut > 99 then
		return self;
	endif;
	
	pos := pos + 1;
	if pos = 1 or pos > len then
		return mark.String & "." & release.String & "." & cut.String.padLeadingZeros(2) & ".000";
	endif;
	
	patch := self.scanUntil(".", pos).Integer;
	if patch > 999 then
		return self;
	endif;
	
	return mark.String & "." & release.String & "." & cut.String.padLeadingZeros(2) & "." & patch.String.padLeadingZeros(3);
end;
}
cnMarkReleaseCutString
{
cnMarkReleaseCutString() : String;
/*
	Returns a string value in form mm.r.cc format
	
	Caters for when the mark id exceeds 1 digit.
	
	Version can be any of the following formats
	Input				Output
	6.1.8				6.1.08
	10.2.1				10.2.01
	3.2					3.2
	
	Null result returned if minimum of x.y.z is not entered.
*/
vars
	mark,
	release,
	cut,
	len,
	pos			: Integer;
	
	str			: String;
begin
	if self = null then
		return null;
	endif;
	
	pos := 1;
	str := self.scanWhile("0123456789.", pos);
	// if not numeric then just return value
	if pos > null then
		return self;
	endif;
	
	len	:= self.length;
	pos	:= 1;
	
	mark	:= self.scanUntil(".", pos).Integer;
	pos := pos + 1;
	if pos = 1 or pos > len then
		return null;
	endif;
	
	release	:= self.scanUntil(".", pos).Integer;
	if release > 9 then
		return null;
	endif;
	
	pos := pos + 1;
	if pos = 1 or pos > len then
		return mark.String & "." & release.String;
	endif;

	cut	:= self.scanUntil(".", pos).Integer;
	if cut > 99 then
		return null;
	endif;
	
	return mark.String & "." & release.String & "." & cut.String.padLeadingZeros(2);
end;
}
cnMarkReleaseString
{
cnMarkReleaseString() : String;
/*
	Returns a string value.
	
	Caters for when the mark id exceeds 1 digit.
	
	Version can be any of the following formats
	Input				Output
	6.1.08				6.1
	10.2.01				10.2
	8.3					8.3
	
	Null result returned if minimum of x.y is not entered.
	Also returns nul result if the 2nd node (release) is greater than 9
*/
vars
	mark,
	release,
	len,
	pos			: Integer;
	
	str			: String;
begin
	if self = null then
		return null;
	endif;
	
	pos := 1;
	str := self.scanWhile("0123456789.", pos);
	// if not numeric then just return value
	if pos > null then
		return self;
	endif;
	
	len	:= self.length;
	pos	:= 1;
	
	mark	:= self.scanUntil(".", pos).Integer;
	pos := pos + 1;
	if pos = 1 or pos > len then
		return null;
	endif;
	
	release	:= self.scanUntil(".", pos).Integer;
	if release > 9 then
		return null;
	endif;

	return mark.String & "." & release.String;
end;
}
cnMultipleLines
{
cnMultipleLines(pLineArray 	: HugeStringArray input; 
				pLineSize 	: Integer);

constants
	Line_Break 	: Character = #"FF";
	Line_New	: Character = #"FE";
vars
	strArray	: HugeStringArray;
	
	i,
	len,
	pos			: Integer;
	
	str,
	str2		: String;
begin
	str := self;
	str.replaceChar(Cr, Line_Break);
	str.replaceChar(Lf, Line_Break);
	pos := 1;
	len := str.length();
	while pos < len do
/*			i := i + 1;
		if i > 50 then
			write ">>>>> Exceeded iteration limit <<<<<";
			break;
		endif;
*/			
		str2 := str2 & str.scanUntil(Line_Break & CN_SPACE, pos);
		if pos = null then
			break;
		endif;
		
		if pos + 1 <= len then
			if pos + 2 <= len and str[pos:2] = (Line_Break & Line_Break) then
				str2 := str2 & Line_New;
				pos := pos + 2;
				continue;
			endif;
			
			if str[pos:1] = Line_Break then
				str2 := str2 & Line_New;
				pos := pos + 1;
				continue;
			endif;
		
			if str[pos] = CN_SPACE then
				str2 := str2 & CN_SPACE;
				str.scanWhile(CN_SPACE, pos);
				if pos = null then
					break;
				endif;
			endif;
		endif;
	endwhile;
	
	create strArray transient;
	strArray.cnGetTokens(str2, Line_New, false);
	foreach str in strArray do
		i := i + 1;
		if i > 30 then
			pLineArray.add(">>>>>" & method.cnGetMethodName() & " exceeded iteration limit");
			return;
		endif;
		
		str := str.trimBlanks();
		len := str.length();
//		write len.String.padBlanks(4) & str;
		while true do
			str2 := null;
			pos := pLineSize;
			if pos <= len then
				str2 := str[1:pos];
//				write "str2 #1 : " & str2;
				pos := pos + 1;
				if pos >= len then
					pLineArray.add(str2);
					break;
				endif;
				
				// break line at next space
				str2 := str2 & str.scanUntil(CN_SPACE, pos);
//				write "str2 #2 : " & str2;
				pLineArray.add(str2);
				if pos = null then
					break;
				endif;
				
				str := str[pos:end];
				len := str.length();
//				write "new str : " & len.String.padBlanks(4) & str;
				continue;
			endif;
			
			pLineArray.add(str.trimBlanks());
			break;
		endwhile;
	endforeach;
epilog
	delete strArray;
end;
}
cnObfuscator
{
cnObfuscator(pCypherText : String):String;

/*
	self 		= passphrase
	pCypherText = text to encrypt/decrypt
*/
constants	
	Salt : String = "gI:$ro3j4%;pEXdu&SdZd=4iXJhdpCOF9jtdhL\5?dnEdNf0Km$a^:1T9B`@1!wX#i5aR!n~Za3O%-6^t~+:PJVgzrNb=yX;gbW5l/Ay%jPm.zw:JxWWwfY^j56xlj%1";
vars
	strPepper,
	strEncrypted	: String;
	
	bin				: Binary;
	
	limit,
	indx			: Integer;
	
	char			: Character;	
begin
	if pCypherText.length() = 0 then
		return "";
	endif;

	strPepper 	:= self & Salt;	
	bin 		:= pCypherText.Binary;
	indx 		:= 1;
	while indx <= bin.length() do
		char := (bin[indx:1].Integer.bitXor(strPepper[indx:1].Character.Integer)).Character;
		strEncrypted[indx:1] := char;
		indx := indx + 1;
	endwhile;
	
	return strEncrypted;
end;
}
cnPadLeadingBlanks
{
cnPadLeadingBlanks(pNum : Integer) : String;

vars
	len,
	reqd	: Integer;
	
	blanks,
	str		: String;
begin
	str := self;
	len := str.length();
	reqd := pNum - len;
	if reqd <= null then
		return str;
	endif;
	
	blanks := CN_SPACE.String.padBlanks(pNum);
	str := blanks[1:reqd] & str;
	return str;
end;
}
cnRemoveChars
{
cnRemoveChars(pCharsToRemove	: String ) : String ;

vars
	str	: String ;
	
	len,
	pos	: Integer ;
begin
	if pCharsToRemove = null then
		return self;
	endif;
	
	len		:= self.length();
	pos		:= 1 ;

	while pos > null and 
	      pos <= len do
		str	:= str & self.scanUntil(pCharsToRemove, pos);
		if pos > null then
			self.scanWhile(pCharsToRemove, pos);
		endif;
	endwhile ;
	
	return str ;
end;
}
cnRemoveInvalidFileNameChars
{
cnRemoveInvalidFileNameChars() : String ;

constants
	InvalidFileNameChars : String = '\/:*?"<>|';
	
begin
	return self.cnRemoveChars(InvalidFileNameChars);
end;
}
cnReplaceChar
{
cnReplaceChar(pChar,
			  pWithChar:Character) updating;

/* 
	This version of replaceChar allows withChar to be a null character (which causes all occurrences
	of char to be stripped from the string). 
*/

vars
	len,
	pos	: Integer;
	
	str	: String;
begin
	pos := 1;
	len := self.length();
	while pos > null and
	      pos <= len do
		str := str & self.scanUntil(pChar.String, pos);
		if pos = null then
			break;
		endif;
		
		pos := pos + 1;
		if pWithChar = CN_NULL then
			continue;
		endif;
		
		str := str & pWithChar;
	endwhile;
	
	self := str;
end;
}
cnReplaceString
{
cnReplaceString(os,
				ns:String) : Integer updating;

vars
	ct,
	ix,
	iy,
	len,
	osLength	:	Integer;
	
	st			:	String;
begin
	len := self.length();
	osLength := os.length();
	if len < osLength then
		return null;
	endif;
	
	iy := 1;
	ix := 1;
	while ix <= len-osLength + 1 do
		ix := self.pos(os,ix);
		if ix = 0 then
			break;
		endif;
		
		st := st & self[iy:ix-iy] & ns;
		ct := ct + 1;
		iy := ix + osLength;
		ix := iy;
	endwhile;
	
	if iy <= len then
		st := st & self[iy:end];
	endif;
	
	self := st;
	return ct;
end;
}
cnStartsWithJoss
{
cnStartsWithJoss() : Boolean;

vars

begin
	return (self[1:4] = CN_JOSS);
end;
}
cnStartsWithKarma
{
cnStartsWithKarma() : Boolean;

vars

begin
	return (self[1:5] = CN_KARMA);
end;
}
cnStripLeadingAndTrailingCharacters
{
cnStripLeadingAndTrailingCharacters(pCharacter : Character) : String;
/*
	Purpose	:
	
	Remove characters from the start and/or end of the string where they are the same as the character specififed.
*/
vars
 	len 	: Integer;
	
	str		: String;
begin
	if self = null then
		return null;
	endif;
	
	str		:= self;
	// strip the characters from leading part of string
	while true do
		if str = null then
			break;
		endif;
		
		if str[1] <> pCharacter then
			break;
		endif;
		
		if str.length() = 1 then
			break;
		endif;
		
		str	:= str[2:end];
	endwhile;

	while true do
		if str = null then
			break;
		endif;

		len := str.length();
		if str[len] <> pCharacter then
			break;
		endif;
		
		str	:= str[1:len - 1];
	endwhile;
	
	return str;
end;
}
cnStripTrailingCharacters
{
cnStripTrailingCharacters(pCharacter : Character) : String;
/*
	Purpose	:
	
	Remove characters from the end of the string where they are the same as the character specififed.
*/
vars
 	len 	: Integer;
	
	str		: String;
begin
	if self = null then
		return null;
	endif;
	
	str		:= self;
	while true do
		len := str.length();
		if str[len] <> pCharacter then
			break;
		endif;
		
		str	:= str[1:len - 1];
	endwhile;
	
	return str;
end;
}
cnStripTrailingSlash
{
cnStripTrailingSlash() : String;

vars
 	len 	: Integer;
begin
	if self = null then
		return null;
	endif;
	
	len := self.length();
	if self[len] = CN_BACK_SLASH or
	   self[len] = CN_SLASH then
	   	return self[1:len - 1];
	endif;
	
	return self;
end;
}
cnToLowerFirst
{
cnToLowerFirst() : String;

vars
	str	: String;
begin
	str := self;
	str.firstCharToLower();
	return str;
end;
}
cnToUpperFirst
{
cnToUpperFirst() : String;

vars
	str	: String;
begin
	str := self;
	str.firstCharToUpper();
	return str;
end;
}
cnTrimLeadingZeros
{
cnTrimLeadingZeros() : String ;

vars
	i 	: Integer;
	
	s	: String;
begin
	s := self;
	if s.length() = null then
		return null;
	endif;
	
	i := 1;
	s.scanWhile("0".String, i);
	if i = null then
		return null;
	endif;
	
	return s[i:end];
end;
}
cnTrimToMaxLength
{
cnTrimToMaxLength(str : String) updating;

vars

begin
	if str.length > self.maxLength then
		self := str[1:self.maxLength];
	else
		self := str;
	endif;
end;
}
cnUnbust
{
cnUnbust(pDelimiters 	: String; 
		 pStringArray	: CnStringArray io;
		 pStripSpaces	: Boolean) : Integer updating;

/* 
	This method breaks a string into tokens and places the tokens in pStringArray.
	
	Any number of delimiters can be specified in pDelimiters.
	
	If pStripSpaces is true, all spaces are removed from the string before the unbust starts.
	
	If a delimiter occurs as the last character of the string, a null value is considered to lie between it
	and the closing quote. For example, "Joe,Fred," will unbust to three string array elements: Joe, Fred, null.

	If no errors occur, return 0. 
	If pDelimiters or pStringArray is null, return 1 or 2 respectively. 

*/
constants

vars
	delimiter,
	nullCharacter	: Character;
	
	delimiterArray	: CharacterArray;
	
	copyStringLength,
	delimLength,
	delimPos,
	i,
	shortest,
	startPos		: Integer;
	
	copyString		: String;
begin
	if pDelimiters = null then
		return 1;
	endif;

	if pStringArray = null then
		return 2;
	endif;
	
	create delimiterArray transient;
	delimLength := pDelimiters.length();
	foreach i in 1 to delimLength do
		delimiterArray.add(pDelimiters[i]);
	endforeach;

	pStringArray.clear;
	copyString := self;

    if pStripSpaces = true then
   		copyString.cnReplaceChar(CN_SPACE, nullCharacter);			// Replace spaces by null (i.e. remove spaces)
    endif;

	copyStringLength 	:= copyString.length();
    startPos 			:= 1;
    while startPos <= copyStringLength do
		shortest := null;											//Will hold the next delimiter character
		foreach delimiter in delimiterArray do
			delimPos := copyString.pos(delimiter, startPos);
			if delimPos <> null 						and 
			   (delimPos < shortest or shortest = null) then
				shortest := delimPos;                       		//This delimiter is the nearest to the start of the string
			endif;
		endforeach;

		if shortest = null then										//If no more delimiters found, insert rest of string in array
			pStringArray.add(copyString[startPos:copyStringLength-startPos+1]);
			break;
		endif;							

		pStringArray.add(copyString[startPos:shortest-startPos]);	//Insert this token in array
		if shortest = copyStringLength then
			pStringArray.add(null);									//Add null token if delimiter was last character
		endif;	
		
		startPos := shortest + 1;
	endwhile;

	// return all OK - value zero
 	return null; 
epilog
	delete delimiterArray;
end;
}
cnUnicodeToAnsi
{
cnUnicodeToAnsi() : Binary;

vars

begin
	return pmUnicodeToAnsi(self);
end;
}
	externalMethodSources
pmUnicodeToAnsi
{
pmUnicodeToAnsi(str: String): Binary is "pmUnicodeToAnsi" in "karma" protected, number = 1013;
}
	)
	Time (
	jadeMethodSources
cnMinutesDifference
{
cnMinutesDifference(time : Time) : Integer;

vars
 	mins1	: Integer;
 	mins2	: Integer;
begin
	//  Returns the difference in minutes between two times. 	
	//  The later time should be passed as the argument.


	mins1 := (self.hour) * 60 + self.minute; 
	mins2 := (time.hour) * 60 + time.minute;
	return mins2 - mins1;
end;
}
cnToMinutes
{
cnToMinutes() : Integer;

vars
 	// returns time in minutes since midnight
begin
	return (self.hour * 60) + self.minute;
end;
}
cnUserFormat
{
cnUserFormat(fmt : TimeFormat) : String;

vars

begin
	return self.userFormat(fmt);
end;
}
	)
	TimeStamp (
	jadeMethodSources
cnConvertToGMT
{
cnConvertToGMT(bias : Integer): TimeStamp;			// allows input of different bias to executing host

vars
	myTime	: Time;
begin
	if self = null then
		return self;
	endif;
	
	if bias = null then
		return self;
	endif;
	
	if bias < null then
		myTime.setTime(0, -bias, 0, 0);
		return self - myTime;
	endif;
	
	myTime.setTime(0, bias, 0, 0);
	return self + myTime;
end;
}
cnFormat_CCYYMMDD_hhmmss
{
cnFormat_CCYYMMDD_hhmmss() : String;
// if timestamp is 31/03/2010 23:10:03 this method returns format  20100331_231003
vars

begin
	return self.date().userFormat($CnCCYYMMDD_ns) & CN_UNDERSCORE & self.time().userFormat($CnHHMMSS_ns);
end;
}
cnFormat_CCYYMMDD_hhmmsscc
{
cnFormat_CCYYMMDD_hhmmsscc() : String;
// if timestamp is 31/03/2010 23:10:03.071 this method returns format  20100331_231003071
vars

begin
	return self.date().userFormat($CnCCYYMMDD_ns) & CN_UNDERSCORE &
			self.time().userFormat($CnHHMMSS_ns) &
			self.time().milliSecond().String.padLeadingZeros(3);
end;
}
cnFormat_DDMMYY_hhmm
{
cnFormat_DDMMYY_hhmm() : String;
// returns format 
//		31/03/2010  23:10 if locale other than USA
//		03/31/2010  23:10 if locale is USA
vars

begin
	return self.date().cnUserFormat($CnDDMMYY) & "  " & 
		   self.time().cnUserFormat($CnHHMM);
end;
}
cnFormat_DDMMYY_hhmmss
{
cnFormat_DDMMYY_hhmmss() : String;
// returns format
//	  31/03/2010  23:10:03 if country code is other than USA
//	  03/31/2010  23:10:03 if country code is USA
vars

begin
	return self.date().cnUserFormat($CnDDMMYY) & "  " & 
			self.time().cnUserFormat($CnHHMMSS);
end;
}
cnFormat_DDMMYY_hhmmsscc
{
cnFormat_DDMMYY_hhmmsscc() : String;
// returns format
//	  31/03/2010  23:10:03.070 if country code is other than USA
//	  03/31/2010  23:10:03.070 if country code is USA
vars

begin
	return self.date().cnUserFormat($CnDDMMYY) & "  " & 
			self.time().cnUserFormat($CnHHMMSS) & "." & 
			self.time().milliSecond().String.padLeadingZeros(3);
end;
}
cnGMT
{
cnGMT() : TimeStamp;				// assumes bias is same as executing host

vars
	bias,
	result  : Integer;
	
	myTime	: Time;
begin
	if self = null then
		return self;
	endif;
	
	result := self.cnGetGMTBias(bias);
	if result <> null then
        return self;
    endif;

	if bias = null then
		return self;
	endif;
	
	if bias < null then
		myTime.setTime(0, -bias, 0, 0);
		return self - myTime;
	endif;
	
	myTime.setTime(0, bias, 0, 0);
	return self + myTime;
end;
}
cnGMTAppServer
{
cnGMTAppServer() : TimeStamp;				// assumes bias is same as executing host

vars
	bias,
	result  : Integer;
	
	myTime	: Time;
begin
	if self = null then
		return self;
	endif;
	
	result := self.cnGetGMTBiasAppServer(bias);
	if result <> null then
        return self;
    endif;

	if bias = null then
		return self;
	endif;
	
	if bias < null then
		myTime.setTime(0, -bias, 0, 0);
		return self - myTime;
	endif;
	
	myTime.setTime(0, bias, 0, 0);
	return self + myTime;
end;
}
cnGetElapsedTimeString
{
cnGetElapsedTimeString() : String;

vars
	ts		: TimeStamp;
	
	tsi		: TimeStampInterval;
begin
	tsi		:= ts - self;
	return tsi.cnFormatted();
end;
}
cnGetGMTBias
{
cnGetGMTBias(bias : Integer output) : Integer;		// signature is like this for compatibility
													// with prior implementation
vars

begin
	if process.isUsingThinClient then
		bias	:= app.currentUTCBias(PresentationClient);
	else
		bias	:= app.currentUTCBias(CurrentLocation);
	endif;
	
	return 0;	
end;
}
cnGetGMTBiasAppServer
{
cnGetGMTBiasAppServer(bias : Integer output) : Integer;

vars
	//  Changed internal implementation for CardSchema 3.0.  Signature format is historical.
begin
	bias	:= app.currentUTCBias(CurrentLocation);
	return null;
end;
}
cnLocalTime
{
cnLocalTime()  : TimeStamp;

vars
	bias,
	iResult	: Integer;

	myTime	: Time;
begin
	if self = null then
		return null;
	endif;
	
	iResult := self.cnGetGMTBias(bias);
	if iResult <> null then
	    return self; 
    endif;

	if bias = null then
		return self;
	endif;
	
	if bias < null then
		myTime.setTime(0, -bias, 0, 0);
		return self + myTime;
	endif;
	
	myTime.setTime(0, bias, 0, 0);
	return self - myTime;
end;
}
cnLocalTimeAppServer
{
cnLocalTimeAppServer()  : TimeStamp;

vars
	bias,
	iResult	: Integer;

	myTime	: Time;
begin
	if self = null then
		return self;
	endif;
	
	iResult := self.cnGetGMTBiasAppServer(bias);
	if iResult <> null then
	    return self; 
    endif;

	if bias = null then
		return self;
	endif;
	
	if bias < null then
		myTime.setTime(0, -bias, 0, 0);
		return self + myTime;
	endif;
	
	myTime.setTime(0, bias, 0, 0);
	return self - myTime;
end;
}
cnMinutesDifference
{
cnMinutesDifference(ts : TimeStamp) : Integer;

vars
	ts1, ts2	: TimeStamp;
	t1, t2		: Time;
	i1, i2		: Integer;
	days		: Integer;
	minus		: Boolean;
	rval		: Integer;
	mins		: Real;
begin
	//  The later time should be passed as ts, to obtain a positive return value.

	if self <= ts then
		ts1 	:= self;
		ts2		:= ts;
	else
		ts1 	:= ts;
		ts2		:= self;
		minus	:= true;
	endif;

	if ts1.date = ts2.date then
		rval :=  ((ts2.time - ts1.time) / 60000).rounded;

	else
    	i1		:= Milliseconds_In_Day - ts1.time.Integer;		// diff between time and midnight
    	i2		:= ts2.time.Integer;
    	days	:= ts2.date - ts1.date;

    	if days > 1 then
  			mins := (i2 + i1) / 60000; 
  			rval := (mins + ((days - 1) * Minutes_In_Day)).rounded; 		
    	else
    		rval := ((i2 + i1) / 60000).rounded;
    	endif;
	endif;

	if minus then 
		return -rval;
	else
		return rval;
	endif;
end;
}
cnSecondsDifference
{
cnSecondsDifference(ts : TimeStamp) : Integer;

vars
	ts1, ts2	: TimeStamp;
	t1, t2		: Time;
	i1, i2		: Integer;
	days		: Integer;
	minus		: Boolean;
	rval		: Integer;
	secs		: Real;
begin
	//  The later time should be passed as ts, to obtain a positive return value.

	if self <= ts then
		ts1 	:= self;
		ts2		:= ts;
	else
		ts1 	:= ts;
		ts2		:= self;
		minus	:= true;
	endif;

	if ts1.date = ts2.date then
		rval :=  ((ts2.time - ts1.time) / 1000).rounded;

	else
    	i1		:= Milliseconds_In_Day - ts1.time.Integer;		// diff between time and midnight
    	i2		:= ts2.time.Integer;
    	days	:= ts2.date - ts1.date;

    	if days > 1 then
  			secs := (i2 + i1) / 1000; 
  			rval := (secs + ((days - 1) * Seconds_In_Day)).rounded; 		
    	else
    		rval := ((i2 + i1) / 1000).rounded;
    	endif;
	endif;

	if minus then 
		return -rval;
	else
		return rval;
	endif;
end;
}
cnZeroMilliseconds
{
cnZeroMilliseconds() : TimeStamp;

vars
 	time	: Time;
	newTS	: TimeStamp;
begin
	time 	:= self.time;
	newTS 	:= self;
	time.setTime(time.hour, time.minute, time.second, 0);
	newTS.setTime(time);
	return newTS;
end;
}
cnZeroSeconds
{
cnZeroSeconds() : TimeStamp updating;

vars
	time 	: Time;
	newTs	: TimeStamp;
begin
	newTs	:= self;
 	time.setTime(self.time.hour, self.time.minute, 0, 0);
	self.setTime(time);
	newTs.setTime(time);
	return newTs;
end;
}
	)
	TimeStampInterval (
	jadeMethodSources
cnDays
{
cnDays() : Integer;

vars
	val	: Integer64;
begin
	val := self.getMilliseconds();
	return (val div (3600 * 24 * 1000)).Integer;
end;
}
cnFormatShort
{
cnFormatShort() : String;

	/*
		Purpose
		Return the interval in hrs and minutes if more than 24hrs, else
		return interval in hh:mm::ss
	*/

vars
	days,
 	hours,
	mins		: Integer;
	
	intervalSec : Integer;
	
	strSign,
	strInterval : String;
	
	time		: Time;
	
	tsiValue	: TimeStampInterval;
begin
	strInterval := self.display;
	if strInterval[1] = CN_HYPHEN then
		strSign	:= "-";
		tsiValue := strInterval[2:end].TimeStampInterval;
		
	else
		tsiValue := self;
	endif;
	
	days := tsiValue.cnDays();
	if days > null then
		hours := tsiValue.cnHours();
		hours := hours + 24*days;
		strInterval := hours.String & "hr";
		strInterval := strInterval & " ";
		mins := tsiValue.cnMinutes();
		strInterval := strInterval & mins.String & "min";
		
	else
		intervalSec := (tsiValue.getMilliseconds() div 1000).Integer;
		time.setTime(intervalSec div 3600, (intervalSec mod 3600) div 60, (intervalSec mod 3600) mod 60, 0);
		strInterval := time.String;
	endif;
	
	strInterval := strSign & strInterval;
	return strInterval;
end;
}
cnFormatted
{
cnFormatted() : String;
/*
	Provides the time stamp interval regardless of 
	whether plus or minus values.
*/
vars
	str,
	str2,
	value			: String;
	
	days,
	hours,
	minutes,
	seconds,
	milliseconds	: Integer;
begin
	days 			:= self.cnDays();
	hours			:= self.cnHours();
	minutes			:= self.cnMinutes();
	seconds			:= self.cnSeconds();
	milliseconds	:= self.cnMilliseconds();
	
	if days <> null then
		if days.abs() = 1 then
			value := " day";
		
		else
			value := " days";
		endif;
		
		str := days.abs().userNumberFormat($CnWholeNumbers) & value;
	endif;
	
	if hours <> null then
		if hours.abs() = 1 then
			value := " hour";
		
		else
			value := " hours";
		endif;
		
		if str <> null then
			str := str & " " & hours.abs().String;
		
		else
			str := hours.abs().String;
		endif;
		
		str := str & value;
	endif;
	
	if minutes <> null then
		if minutes.abs() = 1 then
			value := " min";
		
		else
			value := " mins";
		endif;
		
		if str <> null then
			str := str & " " & minutes.abs().String;
		
		else
			str := minutes.abs().String;
		endif;
		
		str := str & value;
	endif;

	if seconds <> null then
		str2 := seconds.abs().String;
		if milliseconds = null then
			if seconds.abs() = 1 then
				value := " sec";
			
			else
				value := " secs";
			endif;
			
		else
			str2 := str2 & "." & milliseconds.abs().String.padLeadingZeros(3);
			value := " secs";
		endif;
			
		if str <> null then
			str := str & " " & str2;
		
		else
			str := str2;
		endif;
		
		str := str & value;
		
	elseif milliseconds <> null then
		str2 := "0." & milliseconds.abs().String.padLeadingZeros(3);
		if str <> null then
			str := str & " " & str2 & " secs";
		
		else
			str := str2 & " secs";
		endif;
	endif;
	
	if self < null then
		return "- " & str;
	endif;
	
	return str;
end;
}
cnFormattedAbsolute
{
cnFormattedAbsolute() : String;
/*
	Provides the time stamp interval regardless of 
	whether plus or minus values.
*/
vars
	str,
	str2,
	value			: String;
	
	days,
	hours,
	minutes,
	seconds,
	milliseconds	: Integer;
begin
	days 			:= self.cnDays().abs();
	hours			:= self.cnHours().abs();
	minutes			:= self.cnMinutes().abs();
	seconds			:= self.cnSeconds().abs();
	milliseconds	:= self.cnMilliseconds().abs();
	
	if days > null then
		if days = 1 then
			value := " day";
		
		else
			value := " days";
		endif;
		
		str := days.userNumberFormat($CnWholeNumbers) & value;
	endif;
	
	if hours > null then
		if hours = 1 then
			value := " hour";
		
		else
			value := " hours";
		endif;
		
		if str <> null then
			str := str & " " & hours.String;
		
		else
			str := hours.String;
		endif;
		
		str := str & value;
	endif;
	
	if minutes > null then
		if minutes = 1 then
			value := " min";
		
		else
			value := " mins";
		endif;
		
		if str <> null then
			str := str & " " & minutes.String;
		
		else
			str := minutes.String;
		endif;
		
		str := str & value;
	endif;

	if seconds > null then
		str2 := seconds.String;
		if milliseconds = null then
			if seconds = 1 then
				value := " sec";
			
			else
				value := " secs";
			endif;
			
		else
			str2 := str2 & "." & milliseconds.String.padLeadingZeros(3);
			value := " secs";
		endif;
			
		if str <> null then
			str := str & " " & str2;
		
		else
			str := str2;
		endif;
		
		str := str & value;
		
	elseif milliseconds <> null then
		str2 := "0." & milliseconds.String.padLeadingZeros(3);
		if str <> null then
			str := str & " " & str2 & " secs";
		
		else
			str := str2 & " secs";
		endif;
	endif;
	
	return str;
end;
}
cnFormatted_DaysHoursMins
{
cnFormatted_DaysHoursMins() : String;
/*
	Provides the time stamp interval regardless of 
	whether plus or minus values.
*/
vars
	str,
	str2,
	value			: String;
	
	days,
	hours,
	minutes			: Integer;
begin
	days 			:= self.cnDays();
	hours			:= self.cnHours();
	minutes			:= self.cnMinutes();
	
	if days <> null then
		if days.abs() = 1 then
			value := " day";
		
		else
			value := " days";
		endif;
		
		str := days.abs().userNumberFormat($CnWholeNumbers) & value;
	endif;
	
	if hours <> null then
		if hours.abs() = 1 then
			value := " hour";
		
		else
			value := " hours";
		endif;
		
		if str <> null then
			str := str & " " & hours.abs().String;
		
		else
			str := hours.abs().String;
		endif;
		
		str := str & value;
	endif;
	
	if minutes <> null then
		if minutes.abs() = 1 then
			value := " min";
		
		else
			value := " mins";
		endif;
		
		if str <> null then
			str := str & " " & minutes.abs().String;
		
		else
			str := minutes.abs().String;
		endif;
		
		str := str & value;
	endif;

	if self < null then
		return "- " & str;
	endif;
	
	return str;
end;
}
cnFormatted_DaysHoursMinsSecs
{
cnFormatted_DaysHoursMinsSecs() : String;
/*
	Provides the time stamp interval regardless of 
	whether plus or minus values.
*/
vars
	str,
	str2,
	value			: String;
	
	days,
	hours,
	minutes,
	seconds			: Integer;
begin
	days 			:= self.cnDays();
	hours			:= self.cnHours();
	minutes			:= self.cnMinutes();
	seconds			:= self.cnSeconds();
	
	if days <> null then
		if days.abs() = 1 then
			value := " day";
		
		else
			value := " days";
		endif;
		
		str := days.abs().userNumberFormat($CnWholeNumbers) & value;
	endif;
	
	if hours <> null then
		if hours.abs() = 1 then
			value := " hour";
		
		else
			value := " hours";
		endif;
		
		if str <> null then
			str := str & " " & hours.abs().String;
		
		else
			str := hours.abs().String;
		endif;
		
		str := str & value;
	endif;
	
	if minutes <> null then
		if minutes.abs() = 1 then
			value := " min";
		
		else
			value := " mins";
		endif;
		
		if str <> null then
			str := str & " " & minutes.abs().String;
		
		else
			str := minutes.abs().String;
		endif;
		
		str := str & value;
	endif;

	if seconds <> null then
		str2 := seconds.abs().String;
		if seconds.abs() = 1 then
			value := " sec";
		
		else
			value := " secs";
		endif;
			
		if str <> null then
			str := str & " " & str2;
		
		else
			str := str2;
		endif;
		
		str := str & value;
	endif;
	
	if self < null then
		return "- " & str;
	endif;
	
	return str;
end;
}
cnHours
{
cnHours() : Integer;

vars
	val	: Integer64;
begin
	val := self.getMilliseconds();
	return (val div 3600000 mod 24).Integer;																					// PAR 702
end;
}
cnMilliseconds
{
cnMilliseconds() : Integer;

vars
	val	: Integer64;
begin
	val := self.getMilliseconds();
	return (val mod 1000).Integer;
end;
}
cnMinutes
{
cnMinutes() : Integer;

vars
	val	: Integer64;
begin
//	val := self.getMilliseconds() mod (3600 * 24 * 1000) mod (3600 * 1000);
//	return (val div (60 * 1000)).Integer;
	val := self.getMilliseconds();
	return (val div 60000 mod 60).Integer;
end;
}
cnSeconds
{
cnSeconds() : Integer;

vars
	val	: Integer64;
begin
	val := self.getMilliseconds();
	return (val div 1000 mod 60).Integer;
end;
}
	)
